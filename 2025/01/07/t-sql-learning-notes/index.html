<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>T-SQL Learning Notes | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="T-SQL Learning Notes" />
<meta property="og:locale" content="en" />
<meta name="description" content="SQL (pronounced /ˌɛsˌkjuˈɛl/ S-Q-L; or alternatively as /ˈsiːkwəl/ &quot;sequel&quot;) stands for Structured Query Language, which is both an ANSI and ISO standard language that was designed to query and manage data in relational database management systems (RDBMSs). An RDBMS is a database management system based on the relational model (a semantic model for representing data), which in turn is based on two mathematical branches: set theory and predicate logic. &quot;NULL marker&quot; or just &quot;NULL&quot; (/nʌl/) is not a NULL value but rather a marker for a missing value. SQL comprises several sub-languages for managing different aspects of a database: Data Definition Language (DDL) defines and manages the structure of database objects with statements such as CREATE, ALTER, and DROP. Data Manipulation Language (DML) retrieves and modifies data using statements like SELECT, INSERT, UPDATE, DELETE, and MERGE. Data Control Language (DCL) manages data access and user permissions through statements such as GRANT and REVOKE. Transaction Control Language (TCL) controls the lifecycle of transactions with statements like COMMIT and ROLLBACK. Microsoft provides T-SQL as a dialect of, or an extension to, SQL in SQL Server—its on-premises RDBMS flavor, and in Azure SQL and Azure Synapse Analytics—its cloud-based RDBMS flavors. T-SQL is based on standard SQL, but it also provides some nonstandard or proprietary extensions. Moreover, T-SQL does not implement all of standard SQL. To run T-SQL code against a database, a client application needs to connect to a SQL Server instance and be in the context of, or use, the relevant database. In both SQL Server and Azure SQL Managed Instance, the application can still access objects from other databases by adding the database name as a prefix. Azure SQL Database does not support cross-database/three-part name queries. SQL Server supports a feature called contained databases that breaks the connection between a database user and an instance-level login. The user (Windows or SQL authenticated) is fully contained within the specific database and is not tied to a login at the instance level. When connecting to SQL Server, the user needs to specify the database to connect, and the user cannot subsequently switch to other user databases. Unless specified otherwise, all T-SQL references to the name of a database object can be a four-part name in the following form: -- Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views server_name.[database_name].[schema_name].object_name | database_name.[schema_name].object_name | schema_name.object_name | object_name 1. Data Integrity 1.1. PRIMARY KEY 1.2. UNIQUE 1.3. FOREIGN KEY 1.4. CHECK 1.5. DEFAULT 2. Logical Query Processing 2.1. FROM 2.2. WHERE 2.3. GROUP BY 2.4. HAVING 2.5. SELECT 2.6. ORDER BY 2.7. TOP 2.8. OFFSET-FETCH 2.9. CASE 3. Predicates and Operators 3.1. Predicates: IN, BETWEEN, LIKE, EXISTS, and IS NULL 3.2. Three-Valued Logic (3VL) 3.3. Equality and Distinctness 3.4. Comparison Operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, and ALL, SOME, ANY 3.5. Logical Operators: OR, AND, and NOT 3.6. Arithmetic Operators: +, -, *, /, and % 4. Query Tuning 4.1. SQL Server Internals 4.1.1. Indexes 4.1.2. Execution Plans 4.1.3. Cardinality Estimates 4.1.4. Parallel Query Execution 4.2. Data Retrieval Strategies 4.2.1. Unordered Clustered Index Scan or Table Scan 4.2.2. Unordered Covering Nonclustered Index Scan 4.2.3. Ordered Clustered Index Scan 4.2.4. Ordered Covering Nonclustered Index Scan 4.2.5. Nonclustered Index Seek + Range Scan + Lookups 4.2.6. Unordered Nonclustered Index Scan + Lookups 4.2.7. Clustered Index Seek + Range Scan 4.2.8. Covering Nonclustered Index Seek + Range Scan 4.3. Tied Rows and Sorting 5. Joins 5.1. CROSS 5.2. INNER 5.3. OUTER 5.4. APPLY 6. Subqueries 6.1. Subqueries with IN or NOT IN 6.2. Subqueries with comparison operators 6.3. Subqueries with EXISTS or NOT EXISTS 7. Table Expressions 7.1. Derived Tables 7.2. CTEs 7.3. Views and TVFs 8. UNION, UNION ALL, INTERSECT, and EXCEPT 9. Data Analysis 9.1. Window Functions 9.1.1. Ranking 9.1.2. Offset 9.1.3. Aggregate 9.1.4. WINDOW 9.2. Pivoting 9.2.1. Grouped Query 9.2.2. PIVOT Operator 9.3. Unpivoting 9.3.1. APPLY Operator 9.3.2. UNPIVOT Operator 9.4. Grouping Sets 9.5. Time Series 10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE 10.1. INSERT 10.1.1. INSERT VALUES 10.1.2. INSERT SELECT 10.1.3. INSERT EXEC 10.1.4. SELECT INTO 10.1.5. BULK INSERT 10.2. DELETE and TRUNCATE 10.3. UPDATE 10.4. MERGE 11. System-Versioned Temporal Tables 12. Transactions and Concurrency 12.1. Locks and Blocking 12.1.1. Locks 12.1.1.1. Lock Modes and Compatibility 12.1.1.2. Lockable Resource Types 12.1.2. Blocking 12.2. Isolation Levels 12.2.1. READ UNCOMMITTED 12.2.2. READ COMMITTED 12.2.3. REPEATABLE READ 12.2.4. SERIALIZABLE 12.2.5. Multi-Version Concurrency Control 12.2.5.1. SNAPSHOT 12.2.5.2. Conflict Detection 12.2.5.3. READ COMMITTED SNAPSHOT 12.3. Deadlocks 13. Programmable Objects 13.1. Variables 13.2. Batchs 13.3. Flow Elements: IF and WHILE 13.4. Cursors 13.5. Temporary Tables 13.5.1. Local Temporary Tables 13.5.2. Global Temporary Tables 13.5.3. Table Variables 13.6. Dynamic SQL 13.7. Routines 13.7.1. User-defined Functions 13.7.2. Stored Procedures 13.7.3. Triggers 13.7.3.1. DML Triggers 13.7.3.2. DDL Triggers 13.8. Error Handling: TRY-CATCH 14. JSON 14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY 14.2. OPENJSON 14.3. FOR JSON 15. Vectors and embeddings 15.1. Embeddings 15.2. Vector search 15.2.1. Exact nearest neighbor (k-NN) search and vector distance 15.2.2. Approximate nearest neighbors (ANN) and vector index Appendix A: Data Types A.1. Character A.2. Date and Time References 1. Data Integrity SQL provides several mechanisms for enforcing data integrity: PRIMARY KEY constraint FOREIGN KEY constraint with actions like CASCADE, SET NULL, RESTRICT NOT NULL constraint CHECK constraint UNIQUE constraint DEFAULT constraint Triggers Stored procedures USE TSQLV6; DROP TABLE IF EXISTS dbo.Employees; CREATE TABLE dbo.Employees ( empid INT NOT NULL, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, hiredate DATE NOT NULL, mgrid INT NULL, ssn VARCHAR(20) NOT NULL, salary MONEY NOT NULL ); 1.1. PRIMARY KEY A primary key constraint enforces the uniqueness of rows and also disallows NULLs in the constraint attributes. Each unique combination of values in the constraint attributes can appear only once in the table—in other words, only in one row. An attempt to define a primary key constraint on a column that allows NULLs will be rejected by the RDBMS. Each table can have only one primary key. ALTER TABLE dbo.Employees ADD CONSTRAINT PK_Employees PRIMARY KEY (empid); To enforce the uniqueness of the logical primary key constraint, SQL Server will create a unique index behind the scenes. A unique index is a physical object used by SQL Server to enforce uniqueness. Indexes (not necessarily unique ones) are also used to speed up queries by avoiding sorting and unnecessary full table scans (similar to indexes in books). 1.2. UNIQUE A unique constraint enforces the uniqueness of rows, allowing to implement the concept of alternate keys from the relational model in a database. Unlike with primary keys, multiple unique constraints can be defined within the same table. Also, a unique constraint is not restricted to columns defined as NOT NULL. ALTER TABLE dbo.Employees ADD CONSTRAINT UNQ_Employees_ssn UNIQUE(ssn); For the purpose of enforcing a unique constraint, SQL Server handles NULLs just like non-NULL values. Consequently, for example, a single-column unique constraint allows only one NULL in the constrained column. However, the SQL standard defines NULL-handling by a unique constraint differently, like so: “A unique constraint on T is satisfied if and only if there do not exist two rows R1 and R2 of T such that R1 and R2 have the same non-NULL values in the unique columns.” In other words, only the non-NULL values are compared to determine whether duplicates exist. Consequently, a standard single-column unique constraint would allow multiple NULLs in the constrained column. 1.3. FOREIGN KEY A foreign key enforces referential integrity. It is defined on one or more attributes in what’s called the referencing table and points to candidate key (primary key or unique constraint) attributes in what’s called the referenced table. Note that the referencing and referenced tables can be one and the same. The foreign key’s purpose is to restrict the values allowed in the foreign key columns to those that exist in the referenced columns. DROP TABLE IF EXISTS dbo.Orders; CREATE TABLE dbo.Orders ( orderid INT NOT NULL, empid INT NOT NULL, custid VARCHAR(10) NOT NULL, orderts DATETIME2 NOT NULL, qty INT NOT NULL, CONSTRAINT PK_Orders PRIMARY KEY (orderid) ); -- enforce an integrity rule that restricts the values supported by the empid column in the Orders table to the values that exist in the empid column in the Employees table. ALTER TABLE dbo.Orders ADD CONSTRAINT FK_Orders_Employees FOREIGN KEY(empid) REFERENCES dbo.Employees(empid); -- restrict the values supported by the mgrid column in the Employees table to the values that exist in the empid column of the same table. ALTER TABLE dbo.Employees ADD CONSTRAINT FK_Employees_Employees FOREIGN KEY(mgrid) REFERENCES dbo.Employees(empid); Note that NULLs are allowed in the foreign key columns (mgrid in the last example) even if there are no NULLs in the referenced candidate key columns. 1.4. CHECK A check constraint is used to define a predicate that a row must meet to be entered into the table or to be modified. ALTER TABLE dbo.Employees ADD CONSTRAINT CHK_Employees_salary CHECK(salary &gt; 0.00); Note that a check constraint rejects an attempt to insert or update a row when the predicate evaluates to FALSE. The modification will be accepted when the predicate evaluates to either TRUE or UNKNOWN. 1.5. DEFAULT A default constraint is associated with a particular attribute. It’s an expression that is used as the default value when an explicit value is not specified for the attribute when inserting a row. ALTER TABLE dbo.Orders ADD CONSTRAINT DFT_Orders_orderts DEFAULT(SYSDATETIME()) FOR orderts; When done, run the following code for cleanup: DROP TABLE IF EXISTS dbo.Orders, dbo.Employees; 2. Logical Query Processing The logical query processing in standard SQL defines how a query should be processed and the final result achieved. Logical query-processing step numbers (5) SELECT (5-2) DISTINCT (7) TOP(&lt;top_specification&gt;) (5-1) &lt;select_list&gt; (1) FROM (1-J) &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; ON &lt;on_predicate&gt; | (1-A) &lt;left_table&gt; &lt;apply_type&gt; APPLY &lt;right_input_table&gt; AS &lt;alias&gt; | (1-P) &lt;left_table&gt; PIVOT(&lt;pivot_specification&gt;) AS &lt;alias&gt; | (1-U) &lt;left_table&gt; UNPIVOT(&lt;unpivot_specification&gt;) AS &lt;alias&gt; (2) WHERE &lt;where_predicate&gt; (3) GROUP BY &lt;group_by_specification&gt; (4) HAVING &lt;having_predicate&gt; (6) ORDER BY &lt;order_by_list&gt; (7) OFFSET &lt;offset_specification&gt; ROWS FETCH NEXT &lt;fetch_specification&gt; ROWS ONLY; The database engine is free to physically process a query differently by rearranging processing phases, as long as the final result would be the same as that dictated by logical query processing. The database engine’s query optimizer can—and in fact, often does—apply many transformation rules and shortcuts in the physical processing of a query as part of query optimization. USE TSQLV6; SELECT empid, YEAR (orderdate) AS orderyear, COUNT(*) AS numorder FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR (orderdate) HAVING COUNT(*) &gt; 1 ORDER BY empid, orderyear; If an identifier is irregular—for example, if it has embedded spaces or special characters, starts with a digit, or is a reserved keyword—it must be delimited. There are a couple of ways to delimit identifiers in T-SQL. One is the standard SQL form using double quotes—for example, &quot;Order Details&quot;. Another is the T-SQL- specific form using square brackets—for example, [Order Details]. In most programming languages, the lines of code are processed in the order that they are written. In SQL, things are different. Even though the SELECT clause appears first in the query, it is logically processed almost last. The clauses are logically processed in the following order: FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) HAVING COUNT(*) &gt; 1 SELECT empid, YEAR(orderdate) AS orderyear, COUNT(*) AS numorders ORDER BY empid, orderyear FROM &#8594; WHERE &#8594; GROUP BY &#8594; HAVING &#8594; SELECT &#8594; Expressions &#8594; DISTINCT &#8594; ORDER BY &#8594; TOP/OFFSET-FETCH 2.1. FROM The FROM clause is the very first query clause that is logically processed, which is used to specify the names of the tables to query and table operators that operate on those tables. FROM Sales.Orders 2.2. WHERE In the WHERE clause, a predicate, or logical expression is specified to filter the rows returned by the FROM phase. FROM Sales.Orders WHERE custid = 71 T-SQL uses three-valued predicate logic, where logical expressions can evaluate to TRUE, FALSE, or UNKNOWN. With three-valued logic, saying “returns TRUE” is not the same as saying “does not return FALSE.” The WHERE phase returns rows for which the logical expression evaluates to TRUE, and it doesn’t return rows for which the logical expression evaluates to FALSE or UNKNOWN. 2.3. GROUP BY The GROUP BY phase is used to arrange the rows returned by the previous logical query processing phase in groups determined by the elements, or expressions. FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) If the query is a grouped query, all phases subsequent to the GROUP BY phase— including HAVING, SELECT, and ORDER BY—operate on groups as opposed to operating on individual rows. Each group is ultimately represented by a single row in the final result of the query. All expressions specified in clauses that are processed in phases subsequent to the GROUP BY phase are required to guarantee returning a scalar (single value) per group. SELECT empid, YEAR(orderdate) AS orderyear, freight -- sum(freight) AS totalfreight FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate); Msg 8120, Level 16, State 1, Line 1 Column &#39;Sales.Orders.freight&#39; is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause. Total execution time: 00:00:00.016 Expressions based on elements that participate in the GROUP BY clause meet the requirement because, by definition, each such element represents a distinct value per group. Elements that do not participate in the GROUP BY clause are allowed only as inputs to an aggregate function such as COUNT, SUM, AVG, MIN, or MAX. Note that all aggregate functions that are applied to an input expression ignore NULLs. The COUNT(*) function isn’t applied to any input expression; it just counts rows irrespective of what those rows contain. For example, consider a group of five rows with the values 30, 10, NULL, 10, 10 in a column called qty. The expression COUNT(*) returns 5 because there are five rows in the group, whereas COUNT(qty) returns 4 because there are four known (non-NULL) values. To handle only distinct (unique) occurrences of known values, specify the DISTINCT keyword before the input expression to the aggregate function, like COUNT(DISTINCT qty), AVG(DISTINCT qty) and so on. 2.4. HAVING Whereas the WHERE clause is a row filter, the HAVING clause is a group filter. Only groups for which the HAVING predicate evaluates to TRUE are returned by the HAVING phase to the next logical query processing phase. Groups for which the predicate evaluates to FALSE or UNKNOWN are discarded. The HAVING clause is processed after the rows have been grouped, so aggregate functions can be referred to in the HAVING filter predicate. SELECT empid, YEAR(orderdate) AS orderyear, SUM(freight) AS totalfreight FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) -- filters only groups (employee and order year) with more than one row, and total freight with more than 500.0 HAVING COUNT(*) &gt; 1 AND SUM(freight) &gt; 500.0 ORDER BY empid, YEAR(orderdate) 1 2021 711.13 2 2022 672.16 4 2022 651.83 6 2021 628.31 7 2022 1231.56 2.5. SELECT The SELECT clause is where to specify the attributes (columns) to return in the result table of the query. SELECT empid, YEAR(orderdate) AS orderyear, COUNT(*) AS numorders FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) HAVING COUNT(*) &gt; 1 The SELECT clause is processed after the FROM, WHERE, GROUP BY, and HAVING clauses, which means that aliases assigned to expressions in the SELECT clause do not exist as far as clauses that are processed before the SELECT clause are concerned. It’s a typical mistake to try and refer to expression aliases in clauses that are processed before the SELECT clause, such as in the following example in which the attempt is made in the WHERE clause: SELECT orderid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE orderyear &gt; 2021; Msg 207, Level 16, State 1, Line 3 Invalid column name &#39;orderyear&#39;. One way around this problem is to repeat the expression YEAR(orderdate) in both the WHERE and SELECT clauses: SELECT orderid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE YEAR(orderdate) &gt; 2021; In addition to supporting the AS clause, T-SQL supports the form &lt;expression&gt; AS &lt;alias&gt;, and also supports the forms &lt;alias&gt; = &lt;expression&gt; (“alias equals expression”) and &lt;expression&gt; &lt;alias&gt; (“expression space alias”). In relational theory, a relational expression is applied to one or more input relations using operators from relational algebra, and returns a relation as output, that is, a relation in SQL is a table, and a relational expression in SQL is a table expression. Recall that a relation’s body is a set of tuples, and a set has no duplicates. Unlike relational theory, which is based on mathematical set theory, SQL is based on multiset theory. The mathematical term multiset, or bag, is similar in some aspects to a set, but it does allow duplicates. A table in SQL isn’t required to have a key. Without a key, the table can have duplicate rows and therefore isn’t relational. Even if the table does have a key, a SELECT query against the table can still return duplicate rows. SQL query results do not have keys. SQL provides the means to remove duplicates using the DISTINCT clause to return a relational result. SELECT DISTINCT empid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE custid = 71; 2.6. ORDER BY In terms of logical query processing, ORDER BY comes after SELECT. With T-SQL, elements can also be specified in the ORDER BY clause that do not appear in the SELECT clause, meaning to sort by something that don’t necessarily want to be returned. SELECT empid, firstname, lastname, country FROM HR.Employees ORDER BY hiredate; SELECT empid, firstname, lastname, country FROM HR.Employees ORDER BY CASE country WHEN &#39;USA&#39; THEN 1 WHEN &#39;CHN&#39; THEN 2 WHEN &#39;JPN&#39; THEN 3 WHEN &#39;DEU&#39; THEN 4 WHEN &#39;CAN&#39; THEN 5 WHEN &#39;KOR&#39; THEN 6 ELSE 7 END, empid; -- tie-breaker However, when the DISTINCT clause is specified, the ORDER BY are restricted to list only elements that appear in the SELECT list. SELECT DISTINCT empid, firstname, lastname, country FROM HR.Employees ORDER BY hiredate; Msg 145, Level 15, State 1, Line 1 ORDER BY items must appear in the select list if SELECT DISTINCT is specified. ASC is the default sort order. NULL values are treated as the lowest possible values. One of the most important points to understand about SQL is that a table—be it an existing table in the database or a table result returned by a query—has no guaranteed order. That’s because a table is supposed to represent a set of rows (or multiset, if it has duplicates), and a set has no order. It means that when querying a table without specifying an ORDER BY clause, SQL Server is free to return the rows in the output in any order. The only way to guarantee the presentation order in the result is with an ORDER BY clause. However, realizing that if specifying an ORDER BY clause, the result can’t qualify as a table, because it is ordered. Standard SQL calls such a result a cursor. 2.7. TOP The TOP filter is a proprietary T-SQL feature that can be used to limit the number or percentage of rows queried returns. It relies on two elements as part of its specification: one is the number or percent of rows to return, and the other is the ordering. SELECT TOP (5) orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; Note that the TOP filter is handled after DISTINCT. The TOP can use option with the PERCENT keyword, in which case SQL Server calculates the number of rows to return based on a percentage of the number of qualifying rows, rounded up. SELECT TOP (1) PERCENT orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; The query returns nine rows because the Orders table has 830 rows, and 1 percent of 830, rounded up, is 9. 11074 2022-05-06 73 7 11075 2022-05-06 68 8 11076 2022-05-06 9 4 11077 2022-05-06 65 1 11070 2022-05-05 44 2 11071 2022-05-05 46 1 11072 2022-05-05 20 4 11073 2022-05-05 58 2 11067 2022-05-04 17 1 In the above query, notice that the ORDER BY list is not unique (because no primary key or unique constraint is defined on the orderdate column). In other words, the ordering is not strict total ordering. Multiple rows can have the same order date. In such a case, the ordering among rows with the same order date is undefined, which makes the query nondeterministic—more than one result can be considered correct. In case of ties, SQL Server filters rows based on optimization choices and physical access order. Note that when using the TOP filter in a query without an ORDER BY clause, the ordering is completely undefined—SQL Server returns whichever n rows it happens to physically access first, where n is the requested number of rows. To make the query be deterministic, a strict total ordering is needed; in other words, add a tie-breaker. SELECT TOP (5) orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC, orderid DESC; -- the row with the greater order ID value will be preferred. 11077 2022-05-06 65 1 11076 2022-05-06 9 4 11075 2022-05-06 68 8 11074 2022-05-06 73 7 11073 2022-05-05 58 2 Instead of adding a tie-breaker to the ORDER BY list, a request can be made to return all ties by adding the WITH TIES option. SELECT TOP (5) WITH TIES orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; SQL Server first returned the TOP (5) rows based on orderdate DESC ordering, and it also returned all other rows from the table that had the same orderdate value as in the last of the five rows that were accessed. Using the WITH TIES option, the selection of rows is deterministic, but the presentation order among rows with the same order date isn’t. 11077 2022-05-06 65 1 11076 2022-05-06 9 4 11075 2022-05-06 68 8 11074 2022-05-06 73 7 11073 2022-05-05 58 2 11072 2022-05-05 20 4 11071 2022-05-05 46 1 11070 2022-05-05 44 2 The TOP filter is very useful, but it has two shortcomings—it’s not standard, and it doesn’t support a skipping capability. 2.8. OFFSET-FETCH T-SQL also supports a standard, TOP-like filter, called OFFSET-FETCH, which does support a skipping option, which makes it very useful for paging purposes. According to the SQL standard, the OFFSET-FETCH filter is considered an extension to the ORDER BY clause. With the OFFSET clause indicates how many rows to skip, and with the FETCH clause indicates how many rows to filter after the skipped rows. SELECT orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate, orderid OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY; -- OFFSET 50 ROWS; -- OFFSET 0 ROWS FETCH NEXT 25 ROWS ONLY; Note that a query that uses OFFSET-FETCH must have an ORDER BY clause. Also, contrary to the SQL standard, T-SQL doesn’t support the FETCH clause without the OFFSET clause. However, OFFSET without FETCH is allowed to skip the indicated number of rows and returns all remaining rows in the result. In the syntax for the OFFSET- FETCH filter, the singular and plural forms ROW and ROWS, and the forms FIRST and NEXT are interchangeable to phrase the filter in an intuitive, English-like manner. === OVER A window function is a function that, for each row in the underlying query, operates on a window (set) defined with an OVER clause of rows that is derived from the underlying query result, and computes a scalar (single) result value. SELECT orderid, custid, freight, ROW_NUMBER() OVER(PARTITION BY custid ORDER BY freight) AS rownum FROM Sales.Orders ORDER BY custid, freight; For each row in the underlying query, the OVER clause exposes to the function a subset of the rows from the underlying query’s result set. The OVER clause can restrict the rows in the window by using an optional window partition clause (PARTITION BY). It can define ordering for the calculation (if relevant) using a window order clause (ORDER BY)—not to be confused with the query’s presentation ORDER BY clause. Window functions are defined by the SQL standard, and T-SQL supports a subset of the features from the standard. 2.9. CASE A CASE expression, based on the SQL standard, is a scalar expression that returns a value based on conditional logic. Note that CASE is an (scalar) expression and not a statement; that is, it returns a value and it is allowed wherever scalar expressions are allowed, such as in the SELECT, WHERE, HAVING, and ORDER BY clauses and in CHECK constraints. There are two forms of CASE expressions: simple and searched. The simple CASE expression has a single test value or expression right after the CASE keyword that is compared with a list of possible values or expressions, in the WHEN clauses. If no value in the list is equal to the tested value, the CASE expression returns the value that appears in the ELSE clause (or NULL if an ELSE clause is not present). SELECT supplierid, COUNT(*) AS numproducts, CASE COUNT(*) % 2 WHEN 0 THEN &#39;Even&#39; WHEN 1 THEN &#39;Odd&#39; ELSE &#39;Unknown&#39; END AS countparity FROM Production.Products GROUP BY supplierid; The searched CASE expression returns the value in the THEN clause that is associated with the first WHEN predicate that evaluates to TRUE. If none of the WHEN predicates evaluates to TRUE, the CASE expression returns the value that appears in the ELSE clause (or NULL if an ELSE clause is not present). SELECT orderid, custid, freight, CASE WHEN freight &lt; 1000.00 THEN &#39;Less than 1000&#39; WHEN freight &lt;= 3000.00 THEN &#39;Between 1000 and 3000&#39; WHEN freight &gt; 3000.00 THEN &#39;More than 3000&#39; ELSE &#39;Unknown&#39; END AS valuecategory FROM Sales.Orders; 3. Predicates and Operators T-SQL has language elements in which predicates can be specified—for example, query filters such as WHERE and HAVING, the JOIN operator’s ON clause, CHECK constraints, and others. T-SQL uses three-valued predicate logic, where logical expressions can evaluate to TRUE, FALSE, or UNKNOWN. 3.1. Predicates: IN, BETWEEN, LIKE, EXISTS, and IS NULL The IN predicate is used to check whether a value, or scalar expression, is equal to at least one of the elements in a set. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderid IN(10248, 10249, 10250); The BETWEEN predicate is used to to check whether a value falls within a specified range, INCLUSIVE of the two delimiters of the range. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderid BETWEEN 10300 AND 10310; The LIKE predicate is used to check whether a character string value meets a specified pattern. SELECT empid, firstname, lastname FROM HR.Employees WHERE lastname LIKE N&#39;D%&#39;; Notice the use of the letter N to prefix the string &#39;D%&#39;; it stands for National and is used to denote that a character string is of a Unicode data type (NCHAR or NVARCHAR), as opposed to a regular character data type (CHAR or VARCHAR). The EXISTS or NOT EXISTS predicate is used to test for the presence or absence of rows in a subquery. SELECT custid, companyname FROM Sales.Customers AS C WHERE EXISTS (SELECT * FROM Sales.Orders AS O WHERE O.custid = C.custid); The IS NULL and its opposite IS NOT NULL predicates are used to test for NULL values. SELECT empid, firstname, lastname, mgrid FROM HR.Employees WHERE mgrid IS NULL; 3.2. Three-Valued Logic (3VL) SQL uses three-valued logic (3VL), where expressions can evaluate to one of three states: TRUE, FALSE, or NULL (also called UNKNOWN). It is critical to understand that WHERE and HAVING clauses only accept rows where the condition is TRUE, discarding rows that are FALSE or NULL. The logical operators AND, OR, and NOT behave as follows: NOT Operator: NOT TRUE results in FALSE. NOT FALSE results in TRUE. NOT NULL results in NULL. AND Operator (Pessimistic): It returns TRUE only if both sides are TRUE. It is pessimistic because if one side is FALSE, the result is FALSE, even if the other side is NULL. TRUE AND NULL results in NULL. FALSE AND NULL results in FALSE. NULL AND NULL results in NULL. OR Operator (Optimistic): It returns TRUE if either side is TRUE. It is optimistic because if one side is TRUE, the result is TRUE, even if the other side is NULL. TRUE OR NULL results in TRUE. FALSE OR NULL results in NULL. NULL OR NULL results in NULL. 3.3. Equality and Distinctness In SQL, the way NULL values are compared depends on the context, leading to two different types of comparison logic: Equality-based Comparison is the standard comparison used in predicates like WHERE and JOIN ON. It treats NULL as an unknown value. Because one unknown cannot be said to be equal to another, the expression NULL = NULL evaluates to UNKNOWN, not TRUE. Distinctness-based Comparison is used by operators that need to group rows or find duplicates, such as GROUP BY, UNION, INTERSECT, and EXCEPT. For these operations, two NULL values are treated as not distinct from each other (i.e., they are considered identical) which ensures that rows with NULL values in the same columns are correctly identified as duplicates. The formal SQL standard predicate for this logic is IS [NOT] DISTINCT FROM. It provides a way to compare values while treating two NULL values as equivalent. For example, NULL IS NOT DISTINCT FROM NULL evaluates to TRUE. It is important to note that T-SQL does not support this predicate, even though its set operators use the underlying distinctness logic. 3.4. Comparison Operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, and ALL, SOME, ANY T-SQL supports the comparison operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, !&gt;, and !&lt;, of which the last three are not standard and should be avoided using. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20220101&#39;; The &lt;&gt; (not equal) operator is used to check whether a value is not equal to another value. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &lt;&gt; &#39;20220101&#39;; The ALL keyword is used with a comparison operator to compare a scalar value with every value in a list or result set returned by a subquery. The condition is TRUE if the comparison is TRUE for all values in the list. -- Example: Find products whose list price is greater than ALL list prices in the &#39;Road Bikes&#39; category. SELECT Name, ListPrice FROM Production.Product WHERE ListPrice &gt; ALL (SELECT ListPrice FROM Production.Product WHERE ProductSubcategoryID = 1); The SOME or ANY keyword (they are synonyms) is used with a comparison operator to compare a scalar value with any value in a list or result set returned by a subquery. The condition is TRUE if the comparison is TRUE for at least one value in the list. -- Example: Find products whose list price is greater than SOME list prices in the &#39;Mountain Bikes&#39; category. SELECT Name, ListPrice FROM Production.Product WHERE ListPrice &gt; SOME (SELECT ListPrice FROM Production.Product WHERE ProductSubcategoryID = 2); It&#8217;s important to distinguish between NOT IN and &lt;&gt; ANY: NOT IN means &quot;not equal to value A AND not equal to value B AND not equal to value C&#8230;&#8203;&quot; &lt;&gt; ANY means &quot;not equal to value A OR not equal to value B OR not equal to value C&#8230;&#8203;&quot; For example, if a subquery returns (1, 2, 3): value NOT IN (1, 2, 3) is true if value is not 1 AND not 2 AND not 3. value &lt;&gt; ANY (1, 2, 3) is true if value is not 1 OR not 2 OR not 3. 3.5. Logical Operators: OR, AND, and NOT The logical operators OR, AND, and NOT are used to combine logical expressions. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20220101&#39; AND empid NOT IN(1, 3, 5); 3.6. Arithmetic Operators: +, -, *, /, and % T-SQL supports the four obvious arithmetic operators: +, -, *, and /, and also supports the % operator (modulo), which returns the remainder of integer division. SELECT orderid, productid, qty, unitprice, discount, qty * unitprice * (1 - discount) AS val FROM Sales.OrderDetails; Note that the data type of a scalar expression involving two operands is determined in T-SQL by the operand with the higher data-type precedence. If both operands are of the same data type, the result of the expression is of the same data type as well. If the two operands are of different types, the one with the lower precedence is promoted to the one that is higher. WITH Numbers AS ( SELECT 5 AS IntValue, 2 AS IntDivisor, 5.0 AS FloatValue ) SELECT IntValue / IntDivisor AS IntegerDivisionResult, -- Integer division CAST(IntValue AS NUMERIC(12, 2)) / CAST(IntDivisor AS NUMERIC(12, 2)) AS DecimalDivisionResult, -- Decimal division with casting FloatValue / IntDivisor AS DecimalDivisionFromFloatResult -- Division with a float FROM Numbers; The NUMERIC(12, 2) data type in T-SQL (SQL Server) defines a fixed-precision decimal number. 12 (Precision) → The total number of digits that can be stored (both before and after the decimal point). 2 (Scale) → The number of digits after the decimal point. 1234567890.12 -- Valid (12 digits total: 10 before the decimal, 2 after) | 999999999999.99 -- Valid (max possible value) | 100000000000.00 -- Invalid (13 digits, exceeds precision) | 12345.678 -- Invalid (more than 2 decimal places) | NUMERIC(p, s) and DECIMAL(p, s) are functionally identical in SQL Server. Both store exact numbers (unlike FLOAT or REAL, which are approximate). 4. Query Tuning To simulate a cold cache scenario for query performance measurement, run a manual checkpoint to write dirty buffers to disk and then drop all clean buffers from cache. CHECKPOINT; DBCC DROPCLEANBUFFERS; DBCC DROPCLEANBUFFERS should only be used isolated test environments as it can severely impact server performance. To see the estimated plan in SSMS/ADS by highlighting the query and clicking the Display Estimated Execution Plan (Ctrl+L) button on the SQL Editor toolbar. To see the actual plan by enabling the Include Actual Execution Plan (Ctrl+M) button and executing the query. Actual execution plans are generated after the T-SQL queries or batches execute that includes run-time information like the actual number of rows returned by, and the actual number of executions of, each operator. To enable measuring query performance with the session options STATISTICS IO (for I/O information) and STATISTICS TIME (for time information): SET STATISTICS IO, TIME ON; 4.1. SQL Server Internals A page is an 8-KB unit where SQL Server stores data. With disk-based tables, the page is the smallest I/O unit that SQL Server can read or write. An extent is a unit that contains eight contiguous pages. A table can be organized in one of two ways—either as a heap or as a B- tree (HOBT), technically as a B-tree when it has a clustered index defined on it and as a heap when it doesn’t. A heap is a table that has no clustered index, which means that the data is laid out as a bunch of pages and extents without any order. SQL Server maps the data that belongs to a heap using one or more bitmap pages called index allocation maps (IAMs). An allocation order scan is a heap scan that uses IAM pages to determine which pages and extents belong to the heap and reads them in physical file order, typically resulting in sequential reads when data is not cached. 4.1.1. Indexes All indexes in SQL Server on disk-based tables are structured as B-trees, which are a special case of balanced trees. An index on disk-based tables has a doubly linked list in their leaf level, so SQL Server can scan the rows in the leaf in forward and backward order. A clustered index is structured as a B-tree, and it maintains the entire table’s data, not a copy, in its leaf level. At the leaf level of the clustered index, the order in which data pages are stored on disk may not correspond to the sorted order of the index keys due to page splits. If page x points to next page y, and page y appears before page x in the file, page y is considered an out-of- order page. A nonclustered index is also structured as a B-tree, in contrast to a clustered index, a leaf row in a nonclustered index contains only the index key columns and a row locator value representing a particular data row. With the nonclustered index seek or range scan, it is more efficient because with fewer columns in the leaf row to fit more rows per leaf page. When using multiple predicates, the order of key columns in a nonclustered index is crucial for performance, as it determines whether qualifying rows are stored contiguously in the index leaf, maximizing seeks and minimizing scans. When have multiple equality predicates, place the columns from the predicates in any order in the index key list. When have at most one range predicate, place the columns from the equality predicates first in the key list and the column from the range predicate last. When have multiple range predicates, place the column from the most selective range predicate before the columns from the remaining range predicates. An index order scan is a scan performed on the leaf level of a B-tree index in the sorted order of the index key, using a doubly linked list for inter-page navigation and a row-offset array for intra-page order, supporting both full ordered scans and range scans. An index scan is necessary when the query filters on a non-leading column of the index key to scan a larger portion of the index (or even the entire index) to find the matching entries. An index seek is performed when SQL Server needs to find a certain key or range of keys at the leaf level of the index. An index seek is possible when the query filters on the leading column (or a prefix of the leading columns) of the index key to navigate the B-tree from the root node down to the specific leaf page(s) containing the matching values. In SQL Server, the direction of key columns can be indicated in an index definition (ascending by default). CREATE UNIQUE NONCLUSTERED INDEX [idx] ON [schema1].[Table1] ( [col1], -- same as [col1] ASC [col2] DESC ) The storage engine currently processes parallel scans only in the forward direction; backward scans are processed serially. If parallelism is a critical factor in the performance of the query, arrange a descending index. A filtered index is an index on a subset of rows from the underlying table defined based on a predicate. CREATE NONCLUSTERED INDEX idx_USA_orderdate ON Sales.Orders(orderdate) INCLUDE(orderid, custid, requireddate) WHERE shipcountry = N&#39;USA&#39;; A covering index is an index that contains all the columns required by the query, avoiding lookups to the base table. A clustered index is a covering index because the leaf row is the complete data row. A nonclustered index can be a covering index with an INCLUDE clause listing all non-key columns required by the query. CREATE INDEX idx_nc_cid_i_oid_eid_sid_od_flr ON dbo.Orders(custid) INCLUDE(orderid, empid, shipperid, orderdate, filler); A columnstore index stores data by columns rather than by rows, which leads to substantial performance advantages for analytical queries. A nonclustered columnstore index is a secondary index created on an existing table that is stored in the traditional rowstore format. CREATE NONCLUSTERED COLUMNSTORE INDEX idx_nc_cs ON dbo.Fact(key1, key2, key3, measure1, measure2, measure3, measure4); A clustered columnstore index is the primary storage for the table, with data physically stored in columnstore format. CREATE CLUSTERED COLUMNSTORE INDEX idx_cl_cs ON dbo.FactCS; 4.1.2. Execution Plans In SQL Server, the relational engine, like a brain including the optimizer, produces execution plans for queries, while the storage engine, like muscles, carries out these instructions, sometimes choosing the best of several options based on performance and consistency. When the plan shows a table scan operator, the storage engine has only one option: to use an allocation order scan. When the plan shows an ordered index scan operator (clustered or nonclustered), the storage engine can use only an index order scan. When the plan shows an unordered index scan operator, the storage engine has two options to scan the data: allocation order scan and index order scan. An allocation order scan can return multiple occurrences of rows and skip rows resulting from splits that take place during the scan. The storage engine opts for this option when the index size is greater than 64 pages and the request is running under the Read Uncommitted isolation level. When the query is running under the default Read Committed isolation level or higher, the storage engine will opt for an index order scan to prevent such phenomena from happening because of splits. An index order scan is safer in the sense that it won’t read multiple occurrences of the same row or skip rows because of splits. If an index key is modified after the row was read by an index order scan and the row is moved to a point in the leaf that the scan hasn’t reached yet, the scan will read the row a second time or never reach that row. It can happen in Read Uncommitted, Read Committed, and even Repeatable Read because the update was done to a row that was not yet read, but cannot happen under the isolation levels Serializable, Read Committed Snapshot, and Snapshot. 4.1.3. Cardinality Estimates A query optimizer, the main component in the relational engine (also known as the query processor), is responsible for generating physical execution plans for the queries. A cardinality estimator, that makes cardinality estimates of the number of rows returned by each operator, is employed by the optimizer to make decisions about access methods, join and aggregation algorithms, and memory allocation for sort and hash operations. It is not a simple task to make accurate cardinality estimations without actually running the query and without a time machine. Underestimations will tend to result in the following (not an exhaustive list): For filters, preferring an index seek and lookups to a scan. For aggregates, joins, and distinct, preferring order-based algorithms to hash-based ones. For sort and hash operations, there might be spills to tempdb as a result of an insufficient memory grant. Preferring a serial plan over a parallel one. Overestimations will tend to result in pretty much the inverse of underestimations (again, not an exhaustive list): For filters, preferring a scan to an index seek and lookups. For aggregates, joins, and distinct, preferring hash-based algorithms to order-based ones. For sort and hash operations, there won’t be spills, but very likely there will be a larger memory grant than needed, resulting in wasting memory. Preferring a parallel plan over a serial one. SQL Server relies on statistics about the data in its cardinality estimates. Whenever creating an index, SQL Server creates statistics using a full scan of the data. When additional statistics are needed, SQL Server might create them automatically using a sampled percentage of the data. SQL Server creates three main types of statistics: header, density vectors, and a histogram. CREATE INDEX idx_nc_cid_eid ON dbo.Orders(custid, empid); DBCC SHOW_STATISTICS(N&#39;dbo.Orders&#39;, N&#39;idx_nc_cid_eid&#39;); 4.1.4. Parallel Query Execution Parallel query execution (intraquery parallelism or parallelism) uses multiple processor cores to simultaneously process smaller chunks of data, leveraging modern hardware&#8217;s increased computing power for efficient large-data processing. Parallel processing, splitting work across multiple processor cores, can be implemented using two main models: a factory-line model (where each core performs a single action on data passed between cores) and a stream-based model (where each core processes a subset of data through all required operations). While the factory-line model might seem intuitively better for human tasks, database systems like SQL Server use stream-based models. Processors can efficiently switch between tasks as long as data is in local cache, and minimizing data movement between memory and storage is crucial for performance. Stream-based models can scale much better than factory-line models with large datasets, distributing rows across cores as evenly as possible using various algorithms for parallel execution of all operations on each subset of data. A query plan will be either entirely serial—processed using a single worker thread—or it will include one or more parallel branches, which are areas of the plan that are processed using multiple threads. The query processor can merge parallel streams into a single stream or create parallel streams from a single stream, resulting in plans with interleaved serial and parallel zones. All parallel zones in a plan use the same number of threads, known as the degree of parallelism (DOP), determined by server settings, hints, and runtime conditions. A given set of threads might be reused by multiple zones over the course of the plan. Parallel operators in the execution plan are marked with a circle icon with two arrows. Within a parallel zone, each thread processes a unique stream of rows before passing them to the next zone (serial or parallel). Parallel query plans rely on the Exchange (displayed as Parallelism) operator, which manages worker threads and data streams. Each SQL Server query plan operator has, internally, two logical interfaces: a consumer interface, which takes rows from upstream, and a producer interface, which passes rows downstream. While most operators handle their consumer and producer interfaces on the same thread and process single row streams, Exchange operators involve multiple threads and handle multiple streams, keeping other operators unaware of the parallelism. The number of threads on each side of the exchange depends on the type of exchange: A query plan can be read right-to-left (data flow) or left-to-right (operator logic). Gather Streams operators will have DOP threads on the consumer side and one thread on the producer side. From a data-flow perspective, it merges multiple parallel streams into a single serial stream, marking the end of a parallel zone. From an operator-logic perspective, it starts a parallel zone by invoking parallel worker threads. Distribute Streams operators will have one thread on the consumer side and DOP threads on the producer side. From a data-flow perspective, it splits a serial stream into multiple parallel streams, marking the start of a parallel zone. From an operator-logic perspective, it marks the end of a parallel zone. Repartition Streams operators will have DOP threads on each side of the exchange. From both data-flow and operator-logic perspectives, it redistributes rows from multiple parallel streams onto different threads based on a new scheme, effectively joining two adjacent parallel zones. Parallel query plans use five row distribution strategies across threads on the producer side of Distribute or Repartition exchanges: Hash: Assigns rows to threads based on a hash function, grouping rows with the same hashed value on the same thread (e.g., grouping by ProductID for aggregation). Round Robin: Distributes rows sequentially to each thread in a rotating fashion, often used outside Nested Loops where each row represents independent work. Broadcast: Sends all rows to all threads, used for small row counts when all threads need the complete dataset (e.g., building a hash table). Demand: Producer-side threads receive rows on request, currently used only with aligned partitioned tables. Range: Assigns unique, non-overlapping key ranges to each thread, used only for index building. 4.2. Data Retrieval Strategies SQL Server query optimizer uses various strategies to determine how the storage engine physically retrieves data from tables and indexes. Understanding these strategies, such as table scans, index seeks, and lookups, is crucial for diagnosing query performance and optimizing data access paths. 4.2.1. Unordered Clustered Index Scan or Table Scan A table scan or an unordered clustered index scan involves a scan of all data pages that belong to the table. Full table scans occur primarily in two cases: when all rows are required or when need only a subset of the rows but don’t have a good index to support the filter. When the underlying table is a heap, the plan will show an operator called Table Scan. SELECT * INTO dbo.Orders2 FROM dbo.Orders; ALTER TABLE dbo.Orders2 ADD CONSTRAINT PK_Orders2 PRIMARY KEY NONCLUSTERED (orderid); GO -- table scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orderss; When the underlying table is a B- tree, the plan will show an operator called Clustered Index Scan with an Ordered: False property. The fact that the Ordered property of the Clustered Index Scan operator indicates False means that as far as the relational engine is concerned, the data does not need to be returned from the operator in key order. It is up to the storage engine to determine to employ allocation order scan or index order scan. -- clustered index scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders; 4.2.2. Unordered Covering Nonclustered Index Scan An unordered covering nonclustered index scan is a query access method to retrieve all necessary data for a query solely from the leaf level of a nonclustered index, without accessing the base table&#8217;s data rows. An unordered covering nonclustered index scan is similar to an unordered clustered index scan. -- unordered covering nonclustered index scan SELECT orderid -- PRIMARY KEY NONCLUSTERED (orderid) FROM dbo.Orders; 4.2.3. Ordered Clustered Index Scan An ordered clustered index scan is a full scan of the leaf level of the clustered index that guarantees that the data will be returned to the next operator in index order. -- ordered clustered index scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders ORDER BY orderdate; -- CLUSTERED INDEX (orderdate) 4.2.4. Ordered Covering Nonclustered Index Scan An ordered covering nonclustered index scan is similar to an unordered covering nonclustered index scan, but retrieves data in the order of the index keys. -- ordered covering nonclustered index scan SELECT orderid, orderdate FROM dbo.Orders ORDER BY orderid; -- PRIMARY KEY NONCLUSTERED (orderid) 4.2.5. Nonclustered Index Seek + Range Scan + Lookups A nonclustered index seek + range scan + lookups access method is typically used for small-range queries or point queries using a nonclustered index that doesn’t cover the query. A point query uses equality conditions (=) to target specific values, potentially retrieving zero, one, or multiple rows, while a range query uses range operators (&lt;, &gt;, &lt;=, &gt;=, BETWEEN) to retrieve rows within a specified interval. While the index is capable of supporting the filter, lookups will be required to obtain the remaining columns from the respective data rows due to the index&#8217;s non-covering nature. If the target table is a heap, the lookups will be RID Lookups, each costing one page read. -- nonclustered index seek + range scan + lookups against a heap SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders2 -- heap WHERE orderid &lt;= 25; -- PRIMARY KEY NONCLUSTERED (orderid) If the underlying table is a B-tree, the lookups will be Key Lookups, each costing as many reads as the number of levels in the clustered index. -- nonclustered index seek + range scan + lookups against a B-tree SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders -- B-tree WHERE orderid &lt;= 25; -- PRIMARY KEY NONCLUSTERED (orderid) 4.2.6. Unordered Nonclustered Index Scan + Lookups An unordered nonclustered index scan + lookups access method is typically used by the optimizer when the following conditions are in place: The query has a selective filter. There’s a nonclustered index that contains the filtered column (or columns), but the index isn’t a covering one. The filtered columns are not leading columns in the index key list. -- unordered nonclustered index scan + lookups -- missing index SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders WHERE custid = &#39;C0000000001&#39;; -- NONCLUSTERED INDEX (shipperid, orderdate, custid); It performs a full unordered scan of the leaf level of the index, followed by lookups for qualifying keys, a strategy that becomes less efficient than a full table scan for less selective queries due to the lookup overhead. 4.2.7. Clustered Index Seek + Range Scan A clustered index seek + range scan access method is typically used by the optimizer for range queries where the filter based on the first key column (or columns) of the clustered index. -- clustered index seek + range scan SELECT orderid, custid, empid, shipperid, orderdate FROM dbo.Orders WHERE orderdate = &#39;20140212&#39;; -- CLUSTERED INDEX (orderdate); 4.2.8. Covering Nonclustered Index Seek + Range Scan A covering nonclustered index seek + range scan access method is similar to the access method clustered index seek + range scan, only it uses a nonclustered covering index. -- nonclustered index seek + range scan SELECT orderid, shipperid, orderdate, custid FROM dbo.Orders WHERE shipperid = &#39;C&#39; AND orderdate &gt;= &#39;20140101&#39; AND orderdate &lt; &#39;20150101&#39;; -- NONCLUSTERED INDEX (shipperid, orderdate, custid); 4.3. Tied Rows and Sorting When an ORDER BY clause is used, SQL Server guarantees the result set is sorted according to the specified columns. However, this guarantee does not extend to rows with the same value in the ordering columns—known as tied rows. The order in which tied rows are returned is not guaranteed and can vary between query executions, leading to an unstable sort. This instability occurs because the execution plan only guarantees the explicitly requested order. For tied rows, the database returns them in whatever order is most convenient for that specific execution, which can lead to unexpected behavior, particularly in pagination scenarios. For instance, if a user is paging through a customer&#8217;s order history, an unstable sort could cause the same order to appear on multiple pages or for some orders to be skipped entirely, because the order of that customer&#8217;s orders shifted between page loads. To ensure a consistent and predictable sort, the ORDER BY clause must uniquely identify every row, which can be achieved by adding a tie-breaker—a column or set of columns guaranteed to be unique, such as the table&#8217;s primary key. For example, consider sorting orders by customer. A single customer can have multiple orders, creating tied rows. -- Unstable sort: Order of rows for the same `custid` is not guaranteed. SELECT custid, orderid, orderdate FROM Sales.Orders ORDER BY custid; By adding the unique orderid column as a tie-breaker, the sort becomes deterministic. A secondary sort by orderdate is also a good practice. -- Stable sort: orderdate and orderid act as tie-breakers. SELECT custid, orderid, orderdate FROM Sales.Orders ORDER BY custid, orderdate DESC, orderid DESC; This forces the optimizer to perform a secondary sort on orderdate and then orderid for any tied rows, resulting in a deterministic, or stable, sort that is consistent with every execution. 5. Joins T-SQL supports four table operators: JOIN, APPLY, PIVOT, and UNPIVOT. The JOIN operator is standard, while APPLY, PIVOT, and UNPIVOT are T-SQL extensions. Each table operator acts on input tables, applies a set of logical query processing phases, and returns a table result. A JOIN table operator operates on two input tables and has three fundamental types: A CROSS JOIN applies only one phase, the Cartesian Product. An INNER JOIN applies two phases, the Cartesian Product and the Filter. An OUTER JOIN applies three phases, the Cartesian Product, the Filter, and the Add Outer Rows. These phases describe the logical processing steps involved in different types of SQL joins: The Cartesian Product is the initial step where every row from the first table is combined with every row from the second table, resulting in a new table containing all possible combinations. A Filter is applied after the Cartesian Product, based on the ON clause of the join. Only the rows that satisfy the join condition are kept. Add Outer Rows is a specific phase for outer joins (LEFT, RIGHT, or FULL) that, after filtering, includes in the result set any rows from the outer table(s) that did not find a match in the other table. For a LEFT OUTER JOIN, the outer table is the left table. For a RIGHT OUTER JOIN, the outer table is the right table. For a FULL OUTER JOIN, both tables are considered outer tables. For these non-matching rows, columns from the table where no match was found will contain NULL values. The OUTER keyword is optional for LEFT, RIGHT, and FULL joins (e.g., LEFT JOIN is equivalent to LEFT OUTER JOIN). 5.1. CROSS The cross join is the simplest type of join that implements only one logical query processing phase—a Cartesian Product. It operates on the two tables provided as inputs and produces a Cartesian product of the two, that is, each row from one input is matched with all rows from the other. -- SQL-92 syntax SELECT C.custid, E.empid FROM Sales.Customers AS C CROSS JOIN HR.Employees AS E; -- SQL-89 syntax (not recommended) SELECT C.custid, E.empid FROM Sales.Customers AS C, HR.Employees AS E; -- Self cross joins SELECT E1.empid, E1.firstname, E1.lastname, E2.empid, E2.firstname, E2.lastname FROM HR.Employees AS E1 CROSS JOIN HR.Employees AS E2; DROP TABLE IF EXISTS dbo.Digits; CREATE TABLE dbo.Digits (digit INT NOT NULL PRIMARY KEY); INSERT INTO dbo.Digits(digit) VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9); -- Producing tables of numbers SELECT D3.digit * 100 + D2.digit * 10 + D1.digit + 1 AS n FROM dbo.Digits AS D1 CROSS JOIN dbo.Digits AS D2 CROSS JOIN dbo.Digits AS D3 ORDER BY n; 1 2 3 . . . 998 999 1000 5.2. INNER An inner join applies two logical query processing phases—it applies a Cartesian product between the two input tables like in a cross join, and then it filters rows based on a specified predicate in a designated clause called ON. -- SQL-92 syntax SELECT E.empid, E.firstname, E.lastname, O.orderid FROM HR.Employees AS E INNER JOIN Sales.Orders AS O ON E.empid = O.empid; -- Note that the SQL-89 syntax has no ON clause. SELECT E.empid, E.firstname, E.lastname, O.orderid FROM HR.Employees AS E, Sales.Orders AS O WHERE E.empid = O.empid; As with the WHERE and HAVING clauses, the ON clause also returns only rows for which the predicate evaluates to TRUE, and it does not return rows for which the predicate evaluates to FALSE or UNKNOWN. When a join condition involves only an equality operator, the join is said to be an equi join. When a join condition involves any operator besides equality, the join is said to be a non-equi join. SELECT E1.empid, E1.firstname, E1.lastname, E2.empid, E2.firstname, E2.lastname FROM HR.Employees AS E1 INNER JOIN HR.Employees AS E2 ON E1.empid &lt; E2.empid; Standard SQL supports a concept called natural join, which represents an inner join based on a match between columns with the same name in both sides. T-SQL doesn’t have an implementation of a natural join. For example, T1 NATURAL JOIN T2 joins the rows between T1 and T2 based on a match between the columns with the same names on both sides. A join that has an explicit join predicate like equi join and non-equi join that is based on a binary operator (equality or inequality) is known as a theta join. 5.3. OUTER Outer joins were introduced in SQL-92 and, unlike inner joins and cross joins, have only one standard syntax—the one in which the JOIN keyword is specified between the table names and the join condition is specified in the ON clause. Outer joins apply the two logical processing phases that inner joins apply (Cartesian Product and the ON filter), plus a third phase called Adding Outer Rows that is unique to this type of join. In an outer join, a table is marked as a preserved table by using the keywords LEFT OUTER JOIN, RIGHT OUTER JOIN, or FULL OUTER JOIN between the table names. The OUTER keyword is optional. The LEFT keyword means that the rows of the left table (the one to the left of the JOIN keyword) are preserved; the RIGHT keyword means that the rows in the right table are preserved; and the FULL keyword means that the rows in both the left and right tables are preserved. The third logical query processing phase of an outer join identifies the rows from the preserved table that did not find matches in the other table based on the ON predicate, which adds those rows to the result table produced by the first two phases of the join, and it uses NULLs as placeholders for the attributes from the nonpreserved side of the join in those outer rows. SELECT C.custid, C.companyname, O.orderid FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid; A FULL OUTER JOIN with the condition ON 1=1 is functionally equivalent to a CROSS JOIN. If the predicate in the WHERE clause refers to an attribute from the nonpreserved side of the join using an expression in the form &lt;attribute&gt; &lt;operator&gt; &lt;value&gt;, because attributes from the nonpreserved side of the join are NULLs in outer rows, and an expression in the form NULL &lt;operator&gt; &lt;value&gt; yields UNKNOWN (unless it’s the IS NULL operator explicitly looking for NULLs, or the distinct predicate IS [NOT] DISTINCT FROM), it’s usually an indication of a bug, SELECT C.custid, C.companyname, O.orderid, O.orderdate FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid WHERE O.orderdate &gt;= &#39;20220101&#39;; -- Effectively, the join becomes an inner join. If the predicate in the inner join’s ON clause compares an attribute from the nonpreserved side of the outer join and an attribute from the third table, all outer rows are discarded. Remember that outer rows have NULLs in the attributes from the nonpreserved side of the join, and comparing a NULL with anything yields UNKNOWN. UNKNOWN is filtered out by the ON filter. In other words, such a predicate nullifies the outer join, effectively turning it into an inner join. -- outer rows are dropped whenever any kind of outer join (left, right, or full) is -- followed by a subsequent inner join or right outer join. SELECT C.custid, O.orderid, OD.productid, OD.qty FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid; 5.4. APPLY The nonstandard APPLY operator, like a correlated join, instead of treaing its two inputs as a set, applies the right table (typically a derived table or a TVF) to each row from the left table (evaluated first) and produces a result table with the unified result sets. A CROSS APPLY operator is equavelent to a CROSS JOIN. SELECT S.shipperid, E.empid FROM Sales.Shippers AS S CROSS JOIN HR.Employees AS E; -- =&gt; SELECT S.shipperid, E.empid FROM Sales.Shippers AS S CROSS APPLY HR.Employees AS E; With APPLY, the left side is evaluated first, and the right side is evaluated per row from the left iteratively, and can have references to elements from the left. SELECT C.custid, A.orderid, A.orderdate FROM Sales.Customers AS C CROSS APPLY (SELECT TOP (3) orderid, empid, orderdate, requireddate FROM Sales.Orders AS O WHERE O.custid = C.custid ORDER BY orderdate DESC, orderid DESC) AS A; -- A is a correlated derived table Because the derived table is applied to each left row, the CROSS APPLY operator returns the three most recent orders for each customer. 1 11011 2022-04-09 1 10952 2022-03-16 1 10835 2022-01-15 2 10926 2022-03-04 2 10759 2021-11-28 2 10625 2021-08-08 3 10856 2022-01-28 3 10682 2021-09-25 3 10677 2021-09-22 . . . If the right table expression returns an empty set, the CROSS APPLY operator does not return the corresponding left row. To return rows from the left side even if there are no matches on the right side, use OUTER APPLY. SELECT C.custid, A.orderid, A.orderdate FROM Sales.Customers AS C OUTER APPLY (SELECT orderid, empid, orderdate, requireddate FROM Sales.Orders AS O WHERE O.custid = C.custid AND O.custid in (22, 57) ORDER BY orderdate DESC, orderid DESC OFFSET 0 ROWS FETCH FIRST 3 ROWS ONLY) AS A; 1 NULL NULL 2 NULL NULL 3 NULL NULL It&#8217;s more conventional to work with inline TVFs instead of derived tables. CREATE OR ALTER FUNCTION dbo.TopOrders (@custid AS INT, @n AS INT) RETURNS TABLE AS RETURN SELECT orderid, empid, orderdate, requireddate FROM Sales.Orders WHERE custid = @custid ORDER BY orderdate DESC, requireddate DESC OFFSET 0 ROWS FETCH NEXT @N ROWS ONLY; GO SELECT C.custid, C.companyname, A.orderid, A.empid, A.orderdate, A.requireddate FROM Sales.Customers AS C CROSS APPLY dbo.TopOrders(C.custid, 3) AS A; GO -- cleanup DROP FUNCTION if EXISTS dbo.TopOrders 6. Subqueries SQL supports writing queries within queries, or nesting queries. The outermost query is a query whose result set is returned to the caller and is known as the outer query. The inner query is a query whose result set is used by the outer query and is known as a subquery. A subquery can be either self-contained or correlated. A self-contained subquery has no dependency on tables from the outer query, whereas a correlated subquery does. A subquery can be single-valued, multivalued, or table-valued, that is, a subquery can return a single value, multiple values, or a whole table result. In queries that include a correlated subquery (a.k.a., a repeating subquery), the subquery depends on the outer query for its values, which means that the subquery is executed repeatedly, once for each row that might be selected by the outer query. SELECT custid, orderid, orderdate, empid FROM Sales.Orders AS O1 WHERE orderid = (SELECT MAX(O2.orderid) FROM Sales.Orders AS O2 WHERE O2.custid = O1.custid); A scalar subquery is a subquery that return a single value or NULL and can be anywhere in the outer query where a single-valued expression expected, such as WHERE or SELECT. DECLARE @maxid AS INT = (SELECT MAX(orderid) FROM Sales.Orders); SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE orderid = @maxid; -- substitute the above variable with a scalar self-contained subquery SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE orderid = (SELECT MAX(O.orderid) FROM Sales.Orders AS O); A multi-valued subquery is a subquery that returns multiple values as a single column, and such as the IN predicate, operate on a multi-valued subquery. SELECT orderid FROM Sales.Orders WHERE empid IN (SELECT E.empid FROM HR.Employees AS E WHERE E.lastname LIKE N&#39;D%&#39;); In some cases the database engine optimizes both the subquery and the the join the same way, sometimes joins perform better, and sometimes subqueries perform better. 6.1. Subqueries with IN or NOT IN A subquery introduced with IN or NOT IN provides a set of zero or more values for the outer query&#8217;s filtering. An empty set will cause the IN condition to always be FALSE, and the NOT IN condition to always be TRUE. 6.2. Subqueries with comparison operators Subqueries can be introduced with one of the comparison operators (=, &lt; &gt;, &gt;, &gt; =, &lt;, ! &gt;, ! &lt;, or &lt; =). A subquery introduced with an unmodified comparison operator (a comparison operator not followed by ANY, SOME or ALL) must return a single value rather than a list of values, like subqueries introduced with IN, otherwise SQL Server displays an error message. 6.3. Subqueries with EXISTS or NOT EXISTS A subquery introduced with EXISTS or NOT EXISTS functions as an existence test, returning TRUE or FALSE to the outer query&#8217;s WHERE clause based on the presence or absence of rows, without actually producing data. SELECT custid, companyname FROM Sales.Customers AS C WHERE country = N&#39;Spain&#39; AND EXISTS (SELECT * FROM Sales.Orders AS O WHERE O.custid = C.custid); 7. Table Expressions A table expression is an expression—typically a query—that conceptually returns a table result and as such can be nested as an operand of another table expression. Recall that a table in SQL is the counterpart to a relation in relational theory. A table expression is therefore SQL’s counterpart to a relational expression. A relational expression in relational theory is an expression that returns a relation and as such can be nested as an operand of another relational expression. A named table expression is then a table expression assigned with a name, and interacted with like doing with a base table. T-SQL supports four types of named table expressions: derived tables, common table expressions (CTEs), views, and inline table-valued functions (inline TVFs). 7.1. Derived Tables Derived tables are defined in the FROM clause of an outer query, which treated as if it were a regular table for the outer query, and also sometimes referred to as an inline view. SELECT * FROM (SELECT custid, companyname FROM Sales.Customers WHERE country = N&#39;USA&#39;) AS USACusts; SELECT orderyear, COUNT(DISTINCT custid) AS numcusts FROM (SELECT YEAR(orderdate) AS orderyear, custid FROM Sales.Orders) AS D GROUP BY orderyear; 7.2. CTEs A Common Table Expression (CTE) is a temporary, named result set created from a query, which can then be used within the scope of a single statement such as SELECT, INSERT, UPDATE, or DELETE. A CTE can also refer to itself in what is known as a recursive CTE. WITH &lt;CTE_Name&gt;[(&lt;target_column_list&gt;)] AS ( &lt;inner_query_defining_CTE&gt; ) &lt;outer_query_against_CTE&gt;; CTEs support two forms of column aliasing: inline, which uses the AS keyword to rename columns individually within the SELECT statement, and external, which defines all column names at once in a parenthesized list immediately following the CTE&#8217;s name. Inline aliasing is the most common and recommended method, where each new column name is defined individually inside the SELECT list, directly following the column or expression it refers to. WITH UserCTE AS ( SELECT user_id AS ID, user_name AS Name FROM users ) SELECT ID, Name FROM UserCTE; External aliasing is an alternative method where a complete list of new column names is provided in parentheses immediately after the CTE&#8217;s name, before the query definition begins. While less common, this method is required in certain scenarios, such as defining the column structure for recursive CTEs. WITH UserCTE (ID, Name) AS ( SELECT user_id, user_name FROM users ) SELECT ID, Name FROM UserCTE; A CTE must be immediately consumed by a single SELECT, INSERT, UPDATE, MERGE, or DELETE statement. It can also be used to define the query within a CREATE VIEW statement. CREATE VIEW RecentSalesHires AS -- 1. The CTE is defined first to simplify the logic. WITH SalesEmployees AS ( SELECT employee_id, employee_name, hire_date FROM employees WHERE department = &#39;Sales&#39; AND status = &#39;Active&#39; ) -- 2. The view&#39;s main SELECT statement then uses the CTE. SELECT employee_id, employee_name FROM SalesEmployees WHERE hire_date &gt;= DATE(&#39;now&#39;, &#39;-1 year&#39;); A single, nonrecursive CTE can be defined by the combined results of multiple SELECT queries that are connected by a set operator like UNION ALL, UNION, INTERSECT, or EXCEPT. -- This single CTE is defined by two SELECT statements -- combined with a set operator (UNION). WITH AllContacts AS ( -- The first SELECT query SELECT email_address FROM ActiveCustomers UNION -- The set operator that combines them -- The second SELECT query SELECT email FROM ProspectiveCustomers ) -- Now you can use the CTE, which contains the combined results. SELECT * FROM AllContacts; Each CTE can refer to all previously defined CTEs, and the outer query can refer to all CTEs. WITH -- CTE 1: Finds all employees in the &#39;North America&#39; region. RegionalEmployees AS ( SELECT employee_id, employee_name FROM employees WHERE region = &#39;North America&#39; ), -- CTE 2: Calculates sales totals by joining with the first CTE. -- Note it only passes on the ID and the aggregated total. EmployeeSales AS ( SELECT re.employee_id, SUM(s.sale_amount) AS total_sales FROM sales AS s JOIN RegionalEmployees AS re ON s.employee_id = re.employee_id GROUP BY re.employee_id ) -- The outer query now joins BOTH CTEs to get the required columns. SELECT re.employee_name, -- This column comes from the first CTE. es.total_sales -- This column comes from the second CTE. FROM RegionalEmployees AS re JOIN EmployeeSales AS es ON re.employee_id = es.employee_id WHERE es.total_sales &gt; 500000 ORDER BY es.total_sales DESC; Multiple references in CTEs in table operators like joins WITH YearlyCount AS ( SELECT YEAR(orderdate) AS orderyear, COUNT(DISTINCT custid) AS numcusts FROM Sales.Orders GROUP BY YEAR(orderdate) ) SELECT Cur.orderyear, Cur.numcusts AS curnumcusts, Prv.numcusts AS prvnumcusts, Cur.numcusts - Prv.numcusts AS growth FROM YearlyCount AS Cur LEFT OUTER JOIN YearlyCount AS Prv ON Cur.orderyear = Prv.orderyear + 1; CTEs are unique among table expressions in the sense that they support recursion. Recursive CTEs, like nonrecursive ones, are defined by the SQL standard. WITH &lt;CTE_Name&gt;[(&lt;target_column_list&gt;)] AS ( &lt;anchor_member&gt; UNION ALL &lt;recursive_member&gt; ) &lt;outer_query_against_CTE&gt;; A recursive CTE is defined by at least two queries (more are possible)—at least one query known as the anchor member and at least one query known as the recursive member. The anchor member is a query that returns a valid relational result table —like a query that is used to define a nonrecursive table expression. The anchor member query is invoked only once. The recursive member is a query that has a reference to the CTE name and is invoked repeatedly until it returns an empty set. The reference to the CTE name represents the previous result set. The first time that the recursive member is invoked, the previous result set represents whatever the anchor member returned. In each subsequent invocation of the recursive member, the reference to the CTE name represents the result set returned by the previous invocation of the recursive member. Both queries must be compatible in terms of the number of columns they return and the data types of the corresponding columns. The reference to the CTE name in the outer query represents the unified result sets of the invocation of the anchor member and all invocations of the recursive member. WITH EmpsCTE AS ( SELECT empid, mgrid, firstname, lastname FROM HR.Employees WHERE empid = 2 UNION ALL SELECT C.empid, C.mgrid, C.firstname, C.lastname FROM EmpsCTE AS P INNER JOIN HR.Employees AS C ON C.mgrid = P.empid ) SELECT empid, mgrid, firstname, lastname FROM EmpsCTE; 2 1 Don Funk 3 2 Judy Lew 5 2 Sven Mortensen 6 5 Paul Suurs 7 5 Russell King 9 5 Patricia Doyle 4 3 Yael Peled 8 3 Maria Cameron CTEs are not permitted to nest in SQL, but they can be chained sequentially in a single WITH clause, allowing each CTE to reference any of the ones defined before it to create a step-by-step logical flow. WITH -- 1. The first CTE identifies customers from a specific region. US_Customers AS ( SELECT customer_id, customer_name FROM customers WHERE country = &#39;USA&#39; ), -- 2. The second CTE is &quot;chained&quot; by using the first CTE as its source -- to find the recent orders for only those customers. Recent_US_Orders AS ( SELECT usc.customer_name, o.order_id, o.order_total FROM orders AS o JOIN US_Customers AS usc ON o.customer_id = usc.customer_id WHERE o.order_date &gt;= &#39;2025-01-01&#39; ) -- 3. The final query uses the last CTE in the chain to get the result. SELECT * FROM Recent_US_Orders; 7.3. Views and TVFs Derived tables and CTEs have a single-statement scope, which means they are not reusable. Views and inline table-valued functions (inline TVFs) are two types of table expressions whose definitions are stored as permanent objects in the database, making them reusable. CREATE OR ALTER VIEW Sales.USACusts AS SELECT custid, companyname, contactname, contacttitle, address, city, region, postalcode, country, phone, fax FROM Sales.Customers WHERE country = N&#39;USA&#39;; GO -- The GO command is used here to terminate what’s called a batch in T-SQL. SELECT custid, companyname FROM Sales.USACusts; Remember that a presentation ORDER BY clause is not allowed in the query defining a table expression because a relation isn’t ordered. CREATE OR ALTER VIEW Sales.USACusts AS SELECT custid, companyname, contactname, contacttitle, address, city, region, postalcode, country, phone, fax FROM Sales.Customers WHERE country = N&#39;USA&#39; ORDER BY region; GO Msg 1033, Level 15, State 1, Procedure USACusts, Line 8 The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified. Inline TVFs are reusable table expressions that support input parameters. In most respects, except for the support for input parameters, inline TVFs are similar to views, or parameterized views. T-SQL supports another type of table function called multi-statement TVF, which populates and returns a table variable. CREATE OR ALTER FUNCTION dbo.GetCustOrders (@cid AS INT) RETURNS TABLE AS RETURN SELECT orderid, custid, empid, orderdate, requireddate, shippeddate, shipperid, freight, shipname, shipaddress, shipcity, shipregion, shippostalcode, shipcountry FROM Sales.Orders WHERE custid = @cid; GO SELECT orderid, custid FROM dbo.GetCustOrders(1) AS O; GO SELECT O.orderid, O.custid, OD.productid, OD.qty FROM dbo.GetCustOrders(1) AS O INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid; GO DROP FUNCTION IF EXISTS dbo.GetCustOrders; 8. UNION, UNION ALL, INTERSECT, and EXCEPT Set operators combine rows from two query result sets (or multisets), with some operators removing duplicates to return a set, while others preserve duplicates to return a multiset. T-SQL supports the following operators: UNION, UNION ALL, INTERSECT, and EXCEPT. A set operator compares complete rows between the results of the two input queries involved. Input Query1 &lt;set_operator&gt; Input Query2 [ORDER BY ...]; Because a set operator expects multisets as inputs, the two queries involved cannot have ORDER BY clauses. Remember that a query with an ORDER BY clause does not return a multiset—it returns an ordered result. In terms of logical-query processing, each of the individual queries can have all logical-query processing phases except for a presentation ORDER BY. The operator is applied to the results of the two queries, and the outer ORDER BY clause (if one exists) is applied to the result of the operator. The two input queries must produce results with the same number of columns, and corresponding columns must have compatible data types. The names of the columns in the result are determined by the first query. Still, it’s considered a best practice to make sure that all columns have names in both queries, and that the names of the corresponding columns are the same. When a set operator compares rows between the two inputs, it doesn’t use an equality-based comparison; rather, it uses a distinctness-based comparison. The semantics of distinctness-based comparisons are the same as the ones used by a standard predicate called the distinct predicate that treats NULLs just like non-NULL values for comparison purposes to ensure that two rows with NULL values in the same columns are treated as duplicates, which is often the desired behavior. The SQL standard supports two &quot;flavors&quot; of each operator—DISTINCT (the default) and ALL. The DISTINCT flavor eliminates duplicates and returns a set. ALL doesn’t attempt to remove duplicates and therefore returns a multiset. All three operators in T-SQL support an implicit distinct version, but only the UNION operator supports the ALL version. In terms of syntax, T-SQL implicitly applies the DISTINCT clause unless the ALL keyword is explicitly used. SQL defines precedence among set operators: INTERSECT operator precedes UNION and EXCEPT, and UNION and EXCEPT are evaluated in order of appearance. -- the result is a multiset and not a set SELECT country, region, city FROM HR.Employees UNION ALL SELECT country, region, city FROM Sales.Customers; -- returns distinct locations SELECT country, region, city FROM HR.Employees UNION SELECT country, region, city FROM Sales.Customers; -- returns only distinct rows that appear in both input query results SELECT country, region, city FROM HR.Employees INTERSECT SELECT country, region, city FROM Sales.Customers; -- returns only distinct rows that appear in the first set but not the second SELECT country, region, city FROM HR.Employees EXCEPT SELECT country, region, city FROM Sales.Customers; SELECT country, region, city FROM Production.Suppliers EXCEPT SELECT country, region, city FROM HR.Employees INTERSECT -- evaluated first SELECT country, region, city FROM Sales.Customers; 9. Data Analysis T-SQL in SQL Server offers robust features for data analysis, including window Functions, pivoting, unpivoting, grouping sets, and time series data handling. 9.1. Window Functions A window function is a function that, for each row, computes a scalar result value based on a calculation against a subset as a window of the rows from the underlying query set. Window functions perform calculations on a per-row basis within a defined window of rows, preserving detail, whereas grouped queries lose detail by aggregation. Window functions operate directly on the underlying query result set, while subqueries often start with a fresh view of the data, potentially requiring duplication of query logic. Window functions can define the order of rows for calculations separately from the presentation order of the result set. Window functions are allowed only in the SELECT and ORDER BY clauses of a query. A window function is defined by using the OVER clause with up to three parts: window-partition, window-order, and window-frame. &lt;function&gt;( &lt;expression&gt; ) [ IGNORE NULLS | RESPECT NULLS ] OVER(...) An empty OVER() clause represents the entire underlying query’s result set. The window-partition clause (PARTITION BY) restricts the window to the subset of rows that have the same values in the partitioning columns as in the current row. The window-order clause (ORDER BY) defines ordering, but don’t confuse this with presentation ordering. In a window aggregate function, window ordering supports a frame specification. In a window ranking function, window ordering gives meaning to the rank. The window-frame filters a frame, or a subset, of rows from the window partition between the two specified delimiters, which is defined using the ROWS or RANGE clause. ROWS: Defines the frame based on the number of rows before and after the current row. ROWS BETWEEN &lt;top delimiter&gt; AND &lt;bottom delimiter&gt; UNBOUNDED PRECEDING: Includes all rows from the beginning of the partition up to the current row. n PRECEDING: Includes the current row and the n preceding rows. CURRENT ROW: Includes only the current row. n FOLLOWING: Includes the current row and the n following rows. UNBOUNDED FOLLOWING: Includes all rows from the current row to the end of the partition. RANGE: Defines the frame based on the values of the ORDER BY column. RANGE BETWEEN &lt;top delimiter&gt; AND &lt;bottom delimiter&gt; UNBOUNDED PRECEDING: Includes all rows from the beginning of the partition up to the current row. n PRECEDING: Includes rows where the ORDER BY column&#8217;s value is within n units of the current row&#8217;s value. CURRENT ROW: Includes only the current row. n FOLLOWING: Includes rows where the ORDER BY column&#8217;s value is within n units of the current row&#8217;s value. UNBOUNDED FOLLOWING: Includes all rows from the current row to the end of the partition. -- compute the running-total for each employee and month SELECT empid, ordermonth, val, SUM(val) OVER( PARTITION BY empid -- For an underlying row with employee ID `1`, the window exposed to the function filters only the rows where the employee ID is `1`. ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS runval FROM Sales.EmpOrders; 1 2020-07-01 1614.88 1614.88 1 2020-08-01 5555.90 7170.78 1 2020-09-01 6651.00 13821.78 . . . 9.1.1. Ranking T-SQL supports four ranking functions: ROW_NUMBER, RANK, DENSE_RANK, and NTILE to rank each row with respect to others in the window. SELECT orderid, custid, val, ROW_NUMBER() OVER(ORDER BY val) AS rownum, RANK() OVER(ORDER BY val) AS rank, DENSE_RANK() OVER(ORDER BY val) AS dense_rank, NTILE(10) OVER(ORDER BY val) AS ntile FROM Sales.OrderValues ORDER BY val; orderid custid val rownum rank dense_rank ntile 10782 12 12.50 1 1 1 1 10807 27 18.40 2 2 2 1 10586 66 23.80 3 3 3 1 10767 76 28.00 4 4 4 1 10898 54 30.00 5 5 5 1 10900 88 33.75 6 6 6 1 10883 48 36.00 7 7 7 1 11051 41 36.00 8 7 7 1 10815 71 40.00 9 9 8 1 10674 38 45.00 10 10 9 1 11057 53 45.00 11 10 9 1 10271 75 48.00 12 12 10 1 . . . 10496 81 190.00 83 83 78 1 10793 4 191.10 84 84 79 2 10428 66 192.00 85 85 80 2 . . . The ROW_NUMBER function assigns incremental sequential integers to the rows in the query result based on the mandatory window ordering. The RANK or DENSE_RANK function will produce same value when there are ties in the ordering values, and the difference between the two is that RANK reflects the count of rows that have a lower ordering value than the current row (plus 1), whereas DENSE_RANK reflects the count of distinct ordering values that are lower than the current row (plus 1). The NTILE function assigns a tile number to each row associated the rows in the result with tiles (equally sized groups of rows). If the number of rows can’t be evenly divided by the number of tiles, an extra row is added to each of the first tiles from the remainder. For example, if 102 rows and five tiles were requested, the first two tiles would have 21 rows instead of 20. Window functions are logically evaluated as part of the SELECT list, before the DISTINCT clause is evaluated. -- DISTINCT clause has no effect here, no duplicate rows to remove SELECT DISTINCT val, ROW_NUMBER() OVER(ORDER BY val) AS rownum FROM Sales.OrderValues; -- an alternative solution: GROUP BY phase is processed before the SELECT phase SELECT val, ROW_NUMBER() OVER(ORDER BY val) AS rownum FROM Sales.OrderValues GROUP BY val; 9.1.2. Offset T-SQL supports two pairs of offset functions: LAG and LEAD, and FIRST_VALUE and LAST_VALUE, to return an element from a row that is at a certain offset from the current row or at the beginning or end of a window frame. The LAG and LEAD functions look before and ahead respectively to obtain an element from a row that is at a certain offset from the current row within the partition, based on the indicated ordering. -- the LAG and LEAD functions support window partitions and window-order clauses. LAG(column_name, offset, default_value) OVER(...) LEAD(column_name, offset, default_value) OVER(...) column_name: the functions (which is mandatory) is the element to return. offset: (Optional) An integer specifying the number (1 if not specified) of rows to offset from the current row. default_value: (Optional) A value to be returned if there is no row at the requested offset (which is NULL if not specified otherwise). SELECT custid, orderid, val, LAG(val) OVER(PARTITION BY custid -- same as: LAG(val, 1, NULL) ORDER BY orderdate, orderid) AS prevval, LEAD(val) OVER(PARTITION BY custid -- same as: LEAD(val, 1, NULL) ORDER BY orderdate, orderid) AS nextval FROM Sales.OrderValues ORDER BY custid, orderdate, orderid; custid orderid val prevval nextval . . . 1 10952 471.20 845.80 933.50 1 11011 933.50 471.20 NULL 2 10308 88.80 NULL 479.75 2 10625 479.75 88.80 320.00 . . . The FIRST_VALUE and LAST_VALUE functions return an element from the first and last rows in the window frame, respectively. To obtain the element from the first row in the window partition, use FIRST_VALUE with the window-frame extent ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. To obtain the element from the last row in the window partition, use LAST_VALUE with the window-frame extent ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING. SELECT custid, orderid, val, FIRST_VALUE(val) OVER(PARTITION BY custid ORDER BY orderdate, orderid ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS firstval, LAST_VALUE(val) OVER(PARTITION BY custid ORDER BY orderdate, orderid ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS lastval FROM Sales.OrderValues ORDER BY custid, orderdate, orderid custid orderid val firstval lastval 1 10643 814.50 814.50 933.50 . . . 1 11011 933.50 814.50 933.50 2 10308 88.80 88.80 514.40 . . . 9.1.3. Aggregate The aggregate window functions aggregate the rows in the defined window, and support window-partition, window-order, and window-frame clauses. SELECT orderid, custid, val, 100. * val / SUM(val) OVER() AS pctall, -- percentage out of the grand total 100. * val / SUM(val) OVER(PARTITION BY custid) AS pctcust -- percentage out of the customer total FROM Sales.OrderValues; SELECT empid, ordermonth, val, SUM(val) OVER(PARTITION BY empid ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS runval FROM Sales.EmpOrders; 9.1.4. WINDOW The WINDOW clause defines and names reusable entire window specifications or part of them, improving code readability and maintainability by reducing redundancy in complex queries with multiple window functions. It is available in SQL Server 2022 and higher, as well as in Azure SQL Database, provided that the database compatibility level is set to 160 or higher. SELECT DATABASEPROPERTYEX(N&#39;TSQLV6&#39;, N&#39;CompatibilityLevel&#39;); -- 160 When considering all major query clauses (SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY), place the WINDOW clause between the HAVING and ORDER BY clauses of the query. SELECT empid, ordermonth, val, SUM(val) OVER W AS runsum, MIN(val) OVER W AS runmin, MAX(val) OVER W AS runmax, AVG(val) OVER W AS runavg FROM Sales.EmpOrders WINDOW W AS (PARTITION BY empid -- name an entire window specification ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW); SELECT custid, orderid, val, FIRST_VALUE(val) OVER(PO ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS firstval, LAST_VALUE(val) OVER(PO ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS last FROM Sales.OrderValues WINDOW PO AS (PARTITION BY custid -- name part of a window specification ORDER BY orderdate, orderid) ORDER BY custid, orderdate, orderid; SELECT orderid, custid, orderdate, qty, val, ROW_NUMBER() OVER PO AS ordernum, MAX(orderdate) OVER P AS maxorderdate, SUM(qty) OVER POF AS runsumqty, SUM(val) OVER POF AS runsumval FROM Sales.OrderValues WINDOW P AS ( PARTITION BY custid ), -- recursively reuse one window name within another PO AS ( P ORDER BY orderdate, orderid ), POF AS ( PO ROWS UNBOUNDED PRECEDING ) ORDER BY custid, orderdate, orderid; 9.2. Pivoting Pivoting data involves rotating data from a state of rows to a state of columns, possibly aggregating values along the way, in many cases which is generally handled by the presentation layer for purposes such as reporting. -- create and populate the sample table dbo.Orders USE TSQLV6; DROP TABLE IF EXISTS dbo.Orders; CREATE TABLE dbo.Orders ( orderid INT NOT NULL CONSTRAINT PK_Orders PRIMARY KEY, orderdate DATE NOT NULL, empid INT NOT NULL, custid VARCHAR(5) NOT NULL, qty INT NOT NULL ); INSERT INTO dbo.Orders(orderid, orderdate, empid, custid, qty) VALUES (30001, &#39;20200802&#39;, 3, &#39;A&#39;, 10), (10001, &#39;20201224&#39;, 2, &#39;A&#39;, 12), (10005, &#39;20201224&#39;, 1, &#39;B&#39;, 20), (40001, &#39;20210109&#39;, 2, &#39;A&#39;, 40), (10006, &#39;20210118&#39;, 1, &#39;C&#39;, 14), (20001, &#39;20210212&#39;, 2, &#39;B&#39;, 12), (40005, &#39;20220212&#39;, 3, &#39;A&#39;, 10), (20002, &#39;20220216&#39;, 1, &#39;C&#39;, 20), (30003, &#39;20220418&#39;, 2, &#39;B&#39;, 15), (30004, &#39;20200418&#39;, 3, &#39;C&#39;, 22), (30007, &#39;20220907&#39;, 3, &#39;D&#39;, 30); -- query and return the total order quantity for each employee and customer SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid; empid custid sumqty 2 A 52 3 A 20 1 B 20 2 B 27 1 C 34 3 C 22 3 D 30 Pivoted view of total quantity per employee (on rows) and customer (on columns) empid A B C D 1 NULL 20 34 NULL 2 52 27 NULL NULL 3 20 NULL 22 30 Every pivoting request involves three logical processing phases, each with associated elements: A grouping phase with an associated grouping or on rows element A spreading phase with an associated spreading or on cols element An aggregation phase with an associated aggregation element and aggregate function 9.2.1. Grouped Query SELECT empid, SUM( (3) CASE WHEN custid = &#39;A&#39; THEN qty END (2) ) AS A, SUM(CASE WHEN custid = &#39;B&#39; THEN qty END) AS B, SUM(CASE WHEN custid = &#39;C&#39; THEN qty END) AS C, SUM(CASE WHEN custid = &#39;D&#39; THEN qty END) AS D FROM dbo.Orders GROUP BY empid; (1) 1 The grouping phase is achieved with a GROUP BY clause—in this case, GROUP BY empid. 2 The spreading phase is achieved in the SELECT clause with a CASE expression for each target column. -- returns the quantity from the current row only when -- the current row represents an order for customer A; -- otherwise, the expression returns a NULL. CASE WHEN custid = &#39;A&#39; THEN qty END 3 Finally, the aggregation phase is achieved by applying the relevant aggregate function to the result of each CASE expression. -- produces the result column for customer A SUM(CASE WHEN custid = &#39;A&#39; THEN qty END) AS A 9.2.2. PIVOT Operator T- SQL also supports a proprietary table operator called PIVOT on a source table or table expression provided to it as its left input, pivots the data, and returns a result table. SELECT ... FROM &lt;input_table&gt; PIVOT(&lt;agg_function&gt;(&lt;aggregation_element&gt;) FOR &lt;spreading_element&gt; IN (&lt;list_of_target_columns&gt;)) WHERE ...; The PIVOT operator figures out the grouping elements implicitly by elimination, that are all attributes from the source table that were not specified as either the spreading element or the aggregation element. -- custid is the spreading element -- qty is the aggregation element -- the left empid is the implied grouping element SELECT empid, A, B, C, D FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; As a best practice with the PIVOT operator, always work with a table expression and not query the underlying table directly. -- the dbo.Orders table contains the attributes orderid, orderdate, empid, custid, and qty. -- the remaining attributes (orderid, orderdate, and empid) are all considered the grouping elements SELECT empid, A, B, C, D FROM dbo.Orders PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; The items in the list of the target columns must be referred to as identifiers in the IN clause, and be delimited using square brackets when they are irregular (contain spaces, special characters, or are reserved keywords). SELECT custid, [1], [2], [3], [4] FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR empid IN ([1], [2], [3], [4])) AS P; 9.3. Unpivoting Unpivoting is a technique that rotates data from a state of columns to a state of rows. -- create and populate the sample table dbo.EmpCustOrders USE TSQLV6; DROP TABLE IF EXISTS dbo.EmpCustOrders; CREATE TABLE dbo.EmpCustOrders ( empid INT NOT NULL CONSTRAINT PK_EmpCustOrders PRIMARY KEY, A VARCHAR(5) NULL, B VARCHAR(5) NULL, C VARCHAR(5) NULL, D VARCHAR(5) NULL ); INSERT INTO dbo.EmpCustOrders(empid, A, B, C, D) SELECT empid, A, B, C, D FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; SELECT * FROM dbo.EmpCustOrders; empid A B C D 1 NULL 20 34 NULL 2 52 27 NULL NULL 3 20 NULL 22 30 Unpivoted data returns a row for each employee and customer, along with the order quantity empid custid qty 1 B 20 1 C 34 2 A 52 2 B 27 3 A 20 3 C 22 3 D 30 9.3.1. APPLY Operator -- 1. Producing copies SELECT * FROM dbo.EmpCustOrders CROSS JOIN (VALUES(&#39;A&#39;),(&#39;B&#39;),(&#39;C&#39;),(&#39;D&#39;)) AS C(custid); -- empid A B C D custid -- 1 NULL 20 34 NULL A -- 1 NULL 20 34 NULL B -- 1 NULL 20 34 NULL C -- . . . -- 2. Extracting values SELECT empid, custid, qty FROM dbo.EmpCustOrders -- a join treats its two inputs as a set; -- use the CROSS APPLY operator instead of the CROSS JOIN operator -- to refer to the columns A, B, C, and D from the left side of the join (EmpCustOrders) CROSS APPLY (VALUES(&#39;A&#39;, A),(&#39;B&#39;, B),(&#39;C&#39;, C),(&#39;D&#39;, D)) AS C(custid, qty) -- empid custid qty -- 1 A NULL -- 1 B 20 -- 1 C 34 -- . . . -- 3. Eliminating irrelevant rows SELECT empid, custid, qty FROM dbo.EmpCustOrders CROSS APPLY (VALUES(&#39;A&#39;, A),(&#39;B&#39;, B),(&#39;C&#39;, C),(&#39;D&#39;, D)) AS C(custid, qty) WHERE qty IS NOT NULL; -- discard rows with a NULL in the qty column -- empid custid qty -- 1 B 20 -- 1 C 34 -- 2 A 52 -- . . . 9.3.2. UNPIVOT Operator T- SQL, like the PIVOT operator, also supports the UNPIVOT operator to unpivot data involved producing two result columns from any number of source columns—one to hold the source column names as strings and another to hold the source column values. SELECT ... FROM &lt;input_table&gt; UNPIVOT(&lt;values_column&gt; FOR &lt;names_column&gt; IN(&lt;source_columns&gt;) WHERE ...; SELECT empid, custid, qty FROM dbo.EmpCustOrders UNPIVOT(qty FOR custid IN(A, B, C, D)) AS U; 9.4. Grouping Sets A grouping set is a set of expressions to group the data by in a grouped query (a query with a GROUP BY clause). Traditionally in SQL, a single grouped query defines a single grouping set. -- set(empid, custid) SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid; -- set(empid) SELECT empid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid; -- set(custid) SELECT custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY custid; -- set() SELECT SUM(qty) AS sumqty FROM dbo.Orders; Use UNION ALL with NULL placeholders to combine multiple queries into a single result set for reporting, but potentially lead to two main problems—the length of the code and performance due to multiple scans for separated query. SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid UNION ALL SELECT empid, NULL, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid UNION ALL SELECT NULL, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY custid UNION ALL SELECT NULL, NULL, SUM(qty) AS sumqty FROM dbo.Orders; T-SQL supports the standard GROUPING SETS, CUBE, and ROLLUP subclauses of the GROUP BY clause, and the GROUPING and GROUPING_ID functions to define multiple grouping sets in the same query for reporting and data analysis. The GROUPING SETS subclause is a powerful enhancement to the GROUP BY clause to define multiple grouping sets in the same query. The grouping sets are listed, separated by commas within the parentheses of the GROUPING SETS subclause, and for each grouping set list the members, separated by commas, within parentheses. SQL Server typically needs fewer scans of the data than the number of grouping sets because it can roll up aggregates internally. SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY GROUPING SETS ( (empid, custid), (empid), (custid), () ); The CUBE subclause of the GROUP BY clause provides an abbreviated way to define multiple grouping sets. In the parentheses of the CUBE subclause, provide a set of members separated by commas, and get all possible grouping sets that can be defined based on the input members. In set theory, the set of all subsets of elements that can be produced from a particular set is called the power set. For example, CUBE(a, b, c) is equivalent to GROUPING SETS( (a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), () ). SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); The ROLLUP subclause of the GROUP BY clause also provides an abbreviated way to define multiple grouping sets. Unlike CUBE, which produces all possible grouping sets, ROLLUP assumes a hierarchy among input members and produces only grouping sets that form leading combinations of those members. For example, whereas CUBE(a, b, c) produces all eight possible grouping sets, ROLLUP(a, b, c) produces only four based on the hierarchy a&gt;b&gt;c that is the equivalent of specifying GROUPING SETS( (a, b, c), (a, b), (a), () ) rolling up the aggregations from the most granular level (a, b, c) to higher levels like (a, b) and finally to the total (). -- ROLLUP(YEAR(orderdate), MONTH(orderdate), DAY(orderdate)) -- =&gt; -- GROUPING SETS( -- (YEAR(orderdate), MONTH(orderdate), DAY(orderdate)), -- (YEAR(orderdate), MONTH(orderdate)), -- (YEAR(orderdate)), -- () ) SELECT YEAR(orderdate) AS orderyear, MONTH(orderdate) AS ordermonth, DAY(orderdate) AS orderday, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY ROLLUP(YEAR(orderdate), MONTH(orderdate), DAY(orderdate)) The GROUPING and GROUPING_ID functions are used to identify which columns in a GROUP BY clause are included in a group set or or are represented by a NULL placeholder in the aggregated result set. GROUPING: returns 1 when the element isn’t part of the grouping set and 0 otherwise. SELECT GROUPING(empid) AS grpemp, GROUPING(custid) AS grpcust, empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); grpemp grpcust empid custid sumqty 0 0 2 A 52 0 0 3 A 20 1 0 NULL A 72 . . . GROUPING_ID: returns an integer bitmap in which each bit represents a different input element—the rightmost element represented by the rightmost bit. SELECT GROUPING_ID(empid, custid) AS groupingset, empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); groupingset empid custid sumqty 0 2 A 52 -- 00 0 3 A 20 -- 00 2 NULL A 72 -- 10 . . . 9.5. Time Series Time series data is data representing a series of events, or measurements, typically taken at regular time intervals. Time series data analysis usually involves organizing the data in groups, also known as buckets, and then aggregating some measures per bucket. 10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE SQL has a set of statements known as Data Manipulation Language (DML) that includes the statements SELECT, INSERT, UPDATE, DELETE, TRUNCATE, and MERGE. 10.1. INSERT T-SQL provides several statements for inserting data into tables: INSERT VALUES, INSERT SELECT, INSERT EXEC, SELECT INTO, and BULK INSERT. 10.1.1. INSERT VALUES The standard INSERT VALUES statement is used to insert rows into a table based on specified values. INSERT INTO dbo.Orders(orderid, orderdate, empid, custid) VALUES(10001, &#39;20220212&#39;, 3, &#39;A&#39;); Specifying the target column names right after the table name is optional, but by doing so, it can control the value-column associations instead of relying on the order of the columns in the CREATE TABLE statement. In T-SQL, specifying the INTO clause is optional. If a value for a column is NOT specified, Microsoft SQL Server will use a default value if one was defined for the column. If a default value isn’t defined and the column allows NULLs, a NULL will be used. If no default is defined and the column does not allow NULLs and does not somehow get its value automatically, the INSERT statement will fail. T-SQL supports an enhanced standard VALUES clause that can be used to specify multiple rows separated by commas. The enhanced standard VALUES statement is processed as a transaction, meaning that if any row fails to enter the table, none of the rows in the statement enters the table. INSERT INTO dbo.Orders (orderid, orderdate, empid, custid) VALUES (10003, &#39;20220213&#39;, 4, &#39;B&#39;), (10004, &#39;20220214&#39;, 1, &#39;A&#39;), (10005, &#39;20220213&#39;, 1, &#39;C&#39;), (10006, &#39;20220215&#39;, 3, &#39;C&#39;); The enhanced VALUES clause can be used as a table-value constructor to construct a derived table. SELECT * FROM ( VALUES (10003, &#39;20220213&#39;, 4, &#39;B&#39;), (10004, &#39;20220214&#39;, 1, &#39;A&#39;), (10005, &#39;20220213&#39;, 1, &#39;C&#39;), (10006, &#39;20220215&#39;, 3, &#39;C&#39;) ) AS O(orderid, orderdate, empid, custid); -- alias(es) to the table, and the target columns 10.1.2. INSERT SELECT The standard INSERT SELECT statement inserts a set of rows returned by a SELECT query into a target table. The INSERT SELECT statement is performed as a transaction, so if any row fails to enter the target table, none of the rows enters the table. INSERT INTO dbo.Orders(orderid, orderdate, empid, custid) SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE shipcountry = N&#39;UK&#39;; If a system function such as SYSDATETIME is included in the inserted query, the function gets invoked only once for the entire query and not once per row. The exception to this rule is if globally unique identifiers (GUIDs) is generated using the NEWID function, which gets invoked per row. 10.1.3. INSERT EXEC The INSERT EXEC statement is used to insert a result set returned from a stored procedure or a dynamic SQL batch into a target table. CREATE OR ALTER PROC Sales.GetOrders @country AS NVARCHAR(40) AS SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE shipcountry = @country; GO INSERT INTO dbo.Orders (orderid, orderdate, empid, custid) EXEC Sales.GetOrders @country = N&#39;France&#39;; 10.1.4. SELECT INTO The SELECT INTO statement is a nonstandard (not part of the ISO and ANSI SQL) T-SQL statement that CREATEs a target table and populates it with the result set of a query. DROP TABLE IF EXISTS dbo.Orders; SELECT orderid, orderdate, empid, custid INTO dbo.Orders FROM Sales.Orders; -- SELECT INTO statement with set operations DROP TABLE IF EXISTS dbo.Locations; SELECT country, region, city INTO dbo.Locations FROM Sales.Customers EXCEPT SELECT country, region, city FROM HR.Employees; The target table’s structure and data are based on the source table. The SELECT INTO statement copies from the source the base structure (such as column names, types, nullability, and identity property) and the data, but does not copy from the source constraints, indexes, triggers, column properties, and permissions. 10.1.5. BULK INSERT The BULK INSERT statement is a server-side T-SQL command for high-speed data loading that requires the data file to reside on a local or network path accessible to the SQL Server service account, as the path is resolved by the server, not the client. BULK INSERT dbo.Orders FROM &#39;\ServerName\Share\orders.txt&#39; -- Path must be accessible by the SQL Server service WITH ( DATAFILETYPE = &#39;char&#39;, FIELDTERMINATOR = &#39;,&#39;, ROWTERMINATOR = &#39;\n&#39;, BATCHSIZE = 10000, TABLOCK ); While BULK INSERT on an on-premises SQL Server requires a local or UNC path, it can natively access files in Azure Blob Storage when used with Azure SQL Database or Azure SQL Managed Instance. -- Example for Azure SQL -- 1. Define the external data source (once) CREATE EXTERNAL DATA SOURCE MyBlobStorage WITH ( TYPE = BLOB_STORAGE, LOCATION = &#39;https://myaccount.blob.core.windows.net/mycontainer&#39; -- Plus credential setup ); -- 2. Use it in BULK INSERT BULK INSERT dbo.Orders FROM &#39;data/orders.csv&#39; -- Path is relative to the container WITH (DATA_SOURCE = &#39;MyBlobStorage&#39;); bcp and SqlBulkCopy bcp (Bulk Copy Program) is a client-side command-line utility for script-automated data transfer, streaming filesystem-based files from a client machine to SQL Server. # Import data from a local client file to the Orders table bcp MyDatabase.dbo.Orders in C:\Data\orders.csv -c -T -S MyServerName SqlBulkCopy is an ADO.NET class offering maximum ETL flexibility by enabling applications to programmatically stream data directly into SQL Server from in-memory sources like a DataTable or any IDataReader implementation. This example demonstrates a robust and highly performant pattern for upserting (inserting or updating) data in SQL Server. It uses SqlBulkCopy to quickly upload a batch of data into a temporary staging table and then uses a MERGE statement to apply those changes to a final destination table. The destination table is configured as a system-versioned temporal table, which automatically keeps a full history of all data changes. -- Create the main table to store product data CREATE TABLE dbo.Products ( Id INT PRIMARY KEY, Name NVARCHAR(255) NOT NULL, Category NVARCHAR(100) NOT NULL, Price DECIMAL(18, 2) NOT NULL, LastModified DATETIME2 NOT NULL, -- Columns for system-versioning ValidFrom DATETIME2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL, ValidTo DATETIME2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL, PERIOD FOR SYSTEM_TIME (ValidFrom, ValidTo) ) WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.ProductsHistory)); /// &lt;summary&gt; /// Represents a product entity. /// &lt;/summary&gt; public class Product { public int Id { get; set; } public string Name { get; set; } public string Category { get; set; } public decimal Price { get; set; } public DateTime LastModified { get; set; } } /// &lt;summary&gt; /// Performs a high-performance bulk &quot;upsert&quot; operation for a list of products. /// It stages the data in a temporary table and then merges it into the final destination table. /// &lt;/summary&gt; /// &lt;param name=&quot;connection&quot;&gt;An open SqlConnection to use.&lt;/param&gt; /// &lt;param name=&quot;products&quot;&gt;An enumerable of Product objects to upsert.&lt;/param&gt; public async Task UpsertProductsAsync(SqlConnection connection, IEnumerable&lt;Product&gt; products) { // Create an in-memory DataTable to hold the data var productData = new DataTable(); productData.Columns.Add(&quot;Id&quot;, typeof(int)); productData.Columns.Add(&quot;Name&quot;, typeof(string)); productData.Columns.Add(&quot;Category&quot;, typeof(string)); productData.Columns.Add(&quot;Price&quot;, typeof(decimal)); productData.Columns.Add(&quot;LastModified&quot;, typeof(DateTime)); foreach (var p in products) { productData.Rows.Add(p.Id, p.Name, p.Category, p.Price, p.LastModified); } await using var transaction = (SqlTransaction)await connection.BeginTransactionAsync(); try { // 1. Create a temporary table to stage the data var createTempTableCmd = connection.CreateCommand(); createTempTableCmd.Transaction = transaction; createTempTableCmd.CommandText = @&quot; CREATE TABLE #ProductStaging ( Id INT PRIMARY KEY, Name NVARCHAR(255) NOT NULL, Category NVARCHAR(100) NOT NULL, Price DECIMAL(18, 2) NOT NULL, LastModified DATETIME2 NOT NULL );&quot;; await createTempTableCmd.ExecuteNonQueryAsync(); // 2. Bulk load the data from the DataTable into the staging table await using (var bulkCopy = new SqlBulkCopy(connection, SqlBulkCopyOptions.Default, transaction)) { bulkCopy.DestinationTableName = &quot;#ProductStaging&quot;; bulkCopy.BatchSize = 5000; // Add column mappings to ensure data goes into the correct columns bulkCopy.ColumnMappings.Add(&quot;Id&quot;, &quot;Id&quot;); bulkCopy.ColumnMappings.Add(&quot;Name&quot;, &quot;Name&quot;); bulkCopy.ColumnMappings.Add(&quot;Category&quot;, &quot;Category&quot;); bulkCopy.ColumnMappings.Add(&quot;Price&quot;, &quot;Price&quot;); bulkCopy.ColumnMappings.Add(&quot;LastModified&quot;, &quot;LastModified&quot;); await bulkCopy.WriteToServerAsync(productData); } // 3. Merge the staged data into the final Products table var mergeCmd = connection.CreateCommand(); mergeCmd.Transaction = transaction; mergeCmd.CommandText = @&quot; MERGE dbo.Products AS target USING #ProductStaging AS source ON target.Id = source.Id WHEN MATCHED THEN UPDATE SET target.Name = source.Name, target.Category = source.Category, target.Price = source.Price, target.LastModified = source.LastModified WHEN NOT MATCHED BY TARGET THEN INSERT (Id, Name, Category, Price, LastModified) VALUES (source.Id, source.Name, source.Category, source.Price, source.LastModified);&quot;; await mergeCmd.ExecuteNonQueryAsync(); // If all operations were successful, commit the transaction await transaction.CommitAsync(); } catch (Exception) { // If any operation fails, roll back the entire transaction await transaction.RollbackAsync(); throw; } } 10.2. DELETE and TRUNCATE T-SQL provides two statements for deleting rows from a table: DELETE and TRUNCATE. The DELETE statement is a standard statement used to delete data from a table based on an optional filter predicate. DELETE FROM dbo.Orders WHERE orderdate &lt; &#39;20210101&#39;; The DELETE statement tends to be expensive when deleting a large number of rows, mainly because it’s a fully logged operation. The standard TRUNCATE statement deletes all rows from a table without filter. TRUNCATE TABLE dbo.T1; The advantage that TRUNCATE has over DELETE is that the former is minimally logged, whereas the latter is fully logged, resulting in significant performance differences. TRUNCATE resets the identity value back to the original seed, but DELETE doesn’t—even when used without a filter. The TRUNCATE statement is not allowed when the target table is referenced by a foreign-key constraint, even if the referencing table is empty and even if the foreign key is disabled. The TRUNCATE statement can be used to truncate individual partitions in a partitioned table. TRUNCATE TABLE dbo.T1 WITH ( PARTITIONS(1, 3, 5, 7 TO 10) ); T-SQL supports a nonstandard DELETE syntax based on joins to delete rows from one table based on a filter against attributes in related rows from another table. DELETE FROM O FROM dbo.Orders AS O INNER JOIN dbo.Customers AS C ON O.custid = C.custid WHERE C.country = N&#39;USA&#39;; 10.3. UPDATE T-SQL supports a standard UPDATE statement to update rows in a table, and also supports nonstandard forms of the UPDATE statement with joins and with variables. The UPDATE statement is a standard statement to update a subset of rows in a table. To identify the subset of rows to update, specify a predicate in a WHERE clause. Specify the assignment of values to columns in a SET clause, separated by commas. UPDATE dbo.OrderDetails SET discount = discount + 0.05 WHERE productid = 51; T-SQL supports compound assignment operators: += (plus equal), −= (minus equal), *= (multiplication equal), /= (division equal), %= (modulo equal), and others. UPDATE dbo.OrderDetails SET discount += 0.05 WHERE productid = 51; All-at-once operations: all expressions that appear in the same logical phase are evaluated as a set, logically at the same point in time. -- the assignments take place all at once, meaning that both assignments use the same value of col1—the value before the update. UPDATE dbo.T1 SET col1 = col1 + 10, col2 = col1 + 10; -- swap the values in the columns col1 and col2 UPDATE dbo.T1 SET col1 = col2, col2 = col1; The UPDATE statement also supports a nonstandard form based on joins that serves a filtering purpose. UPDATE OD SET discount += 0.05 FROM dbo.OrderDetails AS OD INNER JOIN dbo.Orders AS O ON OD.orderid = O.orderid WHERE O.custid = 1; -- same task by using standard code (recommended) UPDATE dbo.OrderDetails SET discount += 0.05 WHERE EXISTS (SELECT * FROM dbo.Orders AS O WHERE O.orderid = OrderDetails.orderid AND O.custid = 1); T-SQL supports a proprietary UPDATE syntax that both updates data in a table and assigns values to variables at the same time. DECLARE @nextval AS INT; UPDATE dbo.MySequences SET @nextval = val += 1 WHERE id = &#39;SEQ1&#39;; SELECT @nextval; 10.4. MERGE T-SQL supports a statement called MERGE to merge data from a source into a target, applying different actions (INSERT, UPDATE, and DELETE) based on conditional logic. A task achieved by a single MERGE statement typically translates to a combination of several other DML statements (INSERT, UPDATE, and DELETE) without MERGE. MERGE INTO dbo.Customers AS TGT USING dbo.CustomersStage AS SRC ON TGT.custid = SRC.custid WHEN MATCHED THEN UPDATE SET TGT.companyname = SRC.companyname, TGT.phone = SRC.phone, TGT.address = SRC.address WHEN NOT MATCHED THEN INSERT (custid, companyname, phone, address) VALUES (SRC.custid, SRC.companyname, SRC.phone, SRC.address); 11. System-Versioned Temporal Tables Temporal tables provide a powerful mechanism for tracking changes to data over time to easily capture and query historical versions of data, which is crucial for various scenarios such as auditing, data analysis, and data recovery. Track Data Changes: Capture all modifications (insertions, updates, deletions) to the data over time. Audit Data Modifications: Track who made changes, when they were made, and the previous state of the data for auditing and compliance purposes. Perform Point-in-Time Analysis: Analyze data as it existed at any point in the past. Data Recovery: Easily restore previous versions of data in case of accidental deletions or updates. Support Slowly Changing Dimensions: Efficiently manage slowly changing dimensions (SCDs) in data warehousing. The SQL standard supports three types of temporal tables: System-versioned temporal tables rely on the system transaction time to define the validity period of a row. Application-time period tables rely on the application’s definition of the validity period of a row. Bitemporal combines the two types just mentioned (transaction and valid time). SQL Server 2022 supports only system-versioned temporal tables. A system-versioned temporal table has two columns representing the validity period of the row, plus a linked history table with a mirrored schema holding older states of modified rows. To create a system-versioned temporal table, make sure the table definition has all the following elements: CREATE TABLE dbo.Employees ( empid INT NOT NULL CONSTRAINT PK_Employees PRIMARY KEY, (1) empname VARCHAR(25) NOT NULL, department VARCHAR(50) NOT NULL, salary NUMERIC(10, 2) NOT NULL, validfrom DATETIME2(0) GENERATED ALWAYS AS ROW START HIDDEN NOT NULL, (2) validto DATETIME2(0) GENERATED ALWAYS AS ROW END HIDDEN NOT NULL, (2) PERIOD FOR SYSTEM_TIME (validfrom, validto) (3) ) WITH ( SYSTEM_VERSIONING = ON (4) ( HISTORY_TABLE = dbo.EmployeesHistory, (5) HISTORY_RETENTION_PERIOD = 5 YEARS (6) ) ); 1 A primary key 2 Two columns defined as DATETIME2 with any precision, which are non-nullable and represent the start and end of the row’s validity period in the UTC time zone A start column that should be marked with the option GENERATED ALWAYS AS ROW START An end column that should be marked with the option GENERATED ALWAYS AS ROW END Optionally, the period columns can be marked as hidden so that when querying the table with SELECT * they won’t be returned and when inserting data they’ll be ignored. The modification times that SQL Server records in the period columns reflect the transaction start time. If a long-running transaction that started at point in time T1 and ended at T2, SQL Server will record T1 as the modification time for all statements. 3 A designation of the period columns with the option PERIOD FOR SYSTEM_TIME (&lt;startcol&gt;, &lt;endcol&gt;) 4 The table option SYSTEM_VERSIONING, which should be set to ON 5 A linked history table (which SQL Server can create automatically) to hold the past states of modified rows If do not specify a name for the table, SQL Server assigns one using the form MSSQL_TemporalHistoryFor_&lt;object_id&gt;, where object_id is the object ID of the current table. 6 Optionally, define a history retention policy using the HISTORY_RETENTION_PERIOD subclause of the SYSTEM_VERSIONING clause. To drop a system-versioned table, first disable system versioning with an ALTER TABLE command, and then manually drop the current and history tables. IF OBJECT_ID(N&#39;dbo.Employees&#39;, N&#39;U&#39;) IS NOT NULL BEGIN ALTER TABLE dbo.Employees SET ( SYSTEM_VERSIONING = OFF ); DROP TABLE IF EXISTS dbo.EmployeesHistory; DROP TABLE IF EXISTS dbo.Employees; END; When modifying data, interact with the current table, issuing normal data-modification statements. SQL Server automatically updates the period columns and moves older versions of rows to the history table. INSERT INTO dbo.Employees (empid, empname, department, salary) VALUES(1, &#39;Sara&#39;, &#39;IT&#39; , 50000.00), (2, &#39;Don&#39; , &#39;HR&#39; , 45000.00), (3, &#39;Judy&#39;, &#39;Sales&#39; , 55000.00), (4, &#39;Yael&#39;, &#39;Marketing&#39;, 55000.00), (5, &#39;Sven&#39;, &#39;IT&#39; , 45000.00), (6, &#39;Paul&#39;, &#39;Sales&#39; , 40000.00); -- current table has the six new rows SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees; -- history table is empty at this point SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory; -- SQL Server moves the deleted row to the history table, setting its validto value to the deletion time. DELETE FROM dbo.Employees WHERE empid = 6; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory; -- 6 Paul Sales 40000.00 2025-01-15 03:42:15 2025-01-15 03:44:53 -- An update of a row is treated as a delete plus an insert. UPDATE dbo.Employees SET salary *= 1.05 WHERE department = &#39;IT&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees WHERE department = &#39;IT&#39;; -- 1 Sara IT 52500.00 2025-01-15 03:47:42 9999-12-31 23:59:59 -- 5 Sven IT 47250.00 2025-01-15 03:47:42 9999-12-31 23:59:59 SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory WHERE department = &#39;IT&#39;; -- 1 Sara IT 50000.00 2025-01-15 03:42:15 2025-01-15 03:47:42 -- 5 Sven IT 45000.00 2025-01-15 03:42:15 2025-01-15 03:47:42 When querying data, for the current state, simply query the current table as usual, and to see a past state, correct to a certain point or period of time, query the current table followed by the FOR SYSTEM_TIME clause, plus a subclause that indicates more specifics. SQL Server will retrieve the data from both the current and history tables as needed. Table 1. Qualifying rows for FOR SYSTEM_TIME subclauses [&lt;datetime2 value&gt;] Subclause Qualifying rows AS OF @datetime validfrom &lt;= @datetime AND validto &gt; @datetime FROM @start TO @end validfrom &lt; @end AND validto &gt; @start BETWEEN @start AND @end validfrom &lt;= @end AND validto &gt; @start CONTAINED IN(@start, @end) validfrom &gt;= @start AND validto &lt;= @end ALL All rows from both tables (T-SQL*) DECLARE @datetime AS DATETIME2 = &#39;2025-01-15 03:45:00&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees FOR SYSTEM_TIME AS OF @datetime; -- same as DECLARE @datetime AS DATETIME2 = &#39;2025-01-15 03:45:00&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees WHERE validfrom &lt;= @datetime AND validto &gt; @datetime UNION ALL SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory WHERE validfrom &lt;= @datetime AND validto &gt; @datetime 12. Transactions and Concurrency A transaction is a unit of work that might include multiple activities that query and modify data and that can also change the data definition. Transaction boundaries can be defined either explicitly or implicitly. A transaction explicitly is defined beginning with a BEGIN TRAN (or BEGIN TRANSACTION) statement, and end explicitly with a COMMIT TRAN statement to commit it and with a ROLLBACK TRAN (or ROLLBACK TRANSACTION) statement to undo its changes. BEGIN TRAN; INSERT INTO dbo.T1(keycol, col1, col2) VALUES(4, 101, &#39;C&#39;); INSERT INTO dbo.T2(keycol, col1, col2) VALUES(4, 201, &#39;X&#39;); COMMIT TRAN; If the boundaries of a transaction isn&#8217;t marked explicitly, by default, SQL Server treats each individual statement as a transaction, which is known as an auto-commit mode. Transactions have four properties—atomicity, consistency, isolation, and durability— abbreviated with the acronym ACID: Atomicity: A transaction is an atomic unit of work. Either all changes in the transaction take place or none do. If the system fails before a transaction is completed (before the commit instruction is recorded in the transaction log), upon restart, SQL Server undoes the changes that took place. Also, if errors are encountered during the transaction and the error is considered severe enough, such as the target filegroup being full when trying to insert data, SQL Server automatically rolls back the transaction. Consistency: The term consistency refers to the state of the data that the relational database management system (RDBMS) as concurrent transactions modify and query it, which is a subjective term, and depends on an application’s needs. Isolation: Isolation ensures that transactions access only consistent data through a mechanism called isolation levels. With disk-based tables, SQL Server supports two different models to handle isolation: one based purely on locking, and another based on a combination of locking and row versioning. The model based on locking is the default in a box product. In this model, readers require shared locks. If the current state of the data is inconsistent, readers are blocked until the state of the data becomes consistent. The model based on locking and row versioning is the default in Azure SQL Database. In this model, readers don’t take shared locks and don’t need to wait. If the current state of the data is inconsistent, the reader gets an older consistent state. Durability: The durability property means that once a commit instruction is acknowledged by the database engine, the transaction’s changes are guaranteed to be durable—or in other words, persist—in the database. A commit is acknowledged by getting control back to the application and running the next line of code. Data changes are always written to the database’s transaction log on disk before they are written to the data portion of the database on disk. After the commit instruction is recorded in the transaction log on disk, the transaction is considered durable even if the change hasn’t yet made it to the data portion on disk. When the system starts, either normally or after a system failure, SQL Server runs a recovery process in each database that involves analyzing the log, then applying a redo phase, and then applying an undo phase. The redo phase involves rolling forward (replaying) all the changes from any transaction whose commit instruction is written to the log but whose changes haven’t yet made it to the data portion. The undo phase involves rolling back (undoing) the changes from any transaction whose commit instruction was not recorded in the log. -- Start a new transaction BEGIN TRAN; -- Declare a variable DECLARE @neworderid AS INT; -- Insert a new order into the Sales.Orders table INSERT INTO Sales.Orders (custid, empid, orderdate, requireddate, shippeddate, shipperid, freight, shipname, shipaddress, shipcity, shippostalcode, shipcountry) VALUES (85, 5, &#39;20220212&#39;, &#39;20220301&#39;, &#39;20220216&#39;, 3, 32.38, N&#39;Ship to 85-B&#39;, N&#39;6789 rue de l&#39;&#39;Abbaye&#39;, N&#39;Reims&#39;, N&#39;10345&#39;, N&#39;France&#39;); -- Save the new order ID in a variable SET @neworderid = SCOPE_IDENTITY(); -- Return the new order ID SELECT @neworderid AS neworderid; -- Insert order lines for the new order into Sales.OrderDetails INSERT INTO Sales.OrderDetails (orderid, productid, unitprice, qty, discount) VALUES(@neworderid, 11, 14.00, 12, 0.000), (@neworderid, 42, 9.80, 10, 0.000), (@neworderid, 72, 34.80, 5, 0.000); -- Commit the transaction COMMIT TRAN; 12.1. Locks and Blocking By default, a SQL Server box product uses a pure locking model to enforce the isolation property of transactions, whereas Azure SQL Database uses the row-versioning model by default. -- turn off the database property READ_COMMITTED_SNAPSHOT to switch to the locking model as the default ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT OFF; 12.1.1. Locks Locks are control resources obtained by a transaction to guard data resources, preventing conflicting or incompatible access by other transactions. 12.1.1.1. Lock Modes and Compatibility When trying to modify data, a transaction requests an exclusive lock on the data resource, regardless of the isolation level. If granted, the exclusive lock is held until the end of the transaction. For single- statement transactions, this means that the lock is held until the statement completes. For multistatement transactions, this means that the lock is held until all statements complete and the transaction is ended by a COMMIT TRAN or ROLLBACK TRAN command. As for reading data, the defaults are different for a SQL Server box product and Azure SQL Database. In SQL Server, the default isolation level is called READ COMMITTED. In this isolation, when trying to read data, by default a transaction requests a shared lock on the data resource and releases the lock as soon as the read statement is done with that resource. In Azure SQL Database, the default isolation level is called READ COMMITTED SNAPSHOT. Instead of relying only on locking, this isolation level relies on a combination of locking and row versioning. Under this isolation level, readers do not require shared locks, and therefore they never wait; they rely on the row-versioning technology to provide the expected isolation. Under the READ COMMITTED isolation level, if a transaction modifies rows, until the transaction completes, another transaction can’t read the same rows. This approach to concurrency control is known as the pessimistic concurrency approach. Under the READ COMMITTED SNAPSHOT isolation level, if a transaction modifies rows, another transaction trying to read the data will get the last committed state of the rows that was available when the statement started. This approach to concurrency control is known as the optimistic concurrency approach. READ COMMITTED SNAPSHOT is an MVCC-based implementation of the READ COMMITTED isolation level in SQL Server. Table 2. Lock compatibility of exclusive and shared locks Requested mode Granted Exclusive (X) Granted Shared (S) Exclusive No No Shared No Yes A “No” in the intersection means that the locks are incompatible and the requested mode is denied; the requester must wait. A “Yes” in the intersection means that the locks are compatible and the requested mode is accepted. 12.1.1.2. Lockable Resource Types SQL Server can lock different types of resources that include rows (RID in a heap, key in an index), pages, objects (for example, tables), databases, and others. Rows reside within pages, and pages are the physical data blocks that contain table or index data. To obtain a lock on a certain resource type, a transaction must first obtain intent locks of the same mode on higher levels of granularity to efficiently detect incompatible lock requests on higher levels of granularity and prevent the granting of those. SQL Server determines dynamically which resource types to lock. Naturally, for ideal concurrency, it’s best to lock only what needs to be locked—namely, only the affected rows. However, locks require memory resources and internal management overhead. So SQL Server considers both concurrency and system resources when it’s choosing which resource types to lock. When SQL Server estimates that a transaction will interact with a small number of rows, it tends to use row locks. With larger numbers of rows, SQL Server tends to use page locks. SQL Server might first acquire fine-grained locks (such as row or page locks) and, in certain circumstances, try to escalate the fine-grained locks to a table lock to preserve memory. 12.1.2. Blocking When one transaction holds a lock on a data resource and another transaction requests an incompatible lock on the same resource, the request is blocked and the requester enters a wait state. By default, the blocked request keeps waiting until the blocker releases the interfering lock. To restrict the amount of time the session waits for a lock, set a session option called LOCK_TIMEOUT. Specify a value in milliseconds—such as 5000 for 5 seconds, 0 for an immediate timeout, and –1 for no timeout (which is the default). SET LOCK_TIMEOUT 5000; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Msg 1222, Level 16, State 51, Line 3 Lock request time out period exceeded. To remove the lock timeout value, set it back to the default (no timeout), and issue the query again. SET LOCK_TIMEOUT -1; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; The dynamic management view (DMV) sys.dm_tran_locks can be used to get lock information, including both locks granted to sessions and locks sessions waiting for. -- Connection 1: hold exclusive lock to write BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; -- no COMMIT TRAN or ROLLBACK TRAN, the transaction remains open, and the lock is still held -- Connection 2: needs a shared lock to read, but be blocked and has to wait SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 3 SELECT -- use * to explore other available attributes request_session_id AS sid, resource_type AS restype, resource_database_id AS dbid, DB_NAME(resource_database_id) AS dbname, resource_description AS res, resource_associated_entity_id AS resid, request_mode AS mode, request_status AS status FROM sys.dm_tran_locks; sid restype dbid dbname res resid mode status 52 DATABASE 6 TSQLV6 0 S GRANT 56 DATABASE 6 TSQLV6 0 S GRANT 59 DATABASE 6 TSQLV6 0 S GRANT 52 PAGE 6 TSQLV6 1:456 72057594046251008 IS GRANT 56 PAGE 6 TSQLV6 1:456 72057594046251008 IX GRANT 52 OBJECT 6 TSQLV6 1029578706 IS GRANT 56 OBJECT 6 TSQLV6 1029578706 IX GRANT 56 KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 X GRANT 52 KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 S WAIT Each session is identified by a unique session ID. A session’s ID can be determined by querying the function @@SPID. If working with SQL Server Management Studio, the session ID could be found in parentheses to the right of the login name in the status bar at the bottom of the query window that has the focus, and also in the caption of the connected query window. By observing that both sessions lock a row with the same res and resid values, session 52 is waiting for a shared lock on a row in the sample database TSQLV6 that is being held as an exclusive lock by session 56. The involved table can be figured out by moving upward in the lock hierarchy for either session 52 or 56 and inspecting the intent locks on the object (table) where the row resides. The OBJECT_NAME function can be used to translate the object ID (1029578706, in this example) that appears under the resid attribute in the object lock, that is Production.Products. SELECT OBJECT_NAME(1029578706); -- Products The sys.dm_tran_locks view gives the information about the IDs of the sessions involved in the blocking chain, that is, two or more sessions that are involved in the blocking situation, such as session x blocking session y, session y blocking session z, and so on—hence the use of the term chain. The DMV sys.dm_exec_connections can be used to get information about the connections associated with those session IDs and filter only the session IDs that are involved: SELECT -- use * to explore session_id AS sid, connect_time, last_read, last_write, most_recent_sql_handle FROM sys.dm_exec_connections WHERE session_id IN(52, 56); 52 2025-01-13 14:50:57.367 2025-01-13 14:54:07.930 2025-01-13 14:54:07.923 0x0200000063FC7D052E09844778CDD615CFE7A2D1FB4118020000000000000000000000000000000000000000 56 2025-01-13 14:53:33.587 2025-01-13 14:53:52.560 2025-01-13 14:53:52.560 0x020000008FAC322CF2FC73472F8E93B0DF1994A69639ED090000000000000000000000000000000000000000 A binary value holding a handle to the most recent SQL batch run by the connection. The handle can be provided as an input parameter to a table function called sys.dm_exec_sql_text, and the function returns the batch of code represented by the handle. SELECT session_id, text FROM sys.dm_exec_connections CROSS APPLY sys.dm_exec_sql_text(most_recent_sql_handle) AS ST WHERE session_id IN(52, 56); 52 (@1 tinyint)SELECT [productid],[unitprice] FROM [Production].[Products] WHERE [productid]=@1 56 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; Starting with SQL Server 2016, the function sys.dm_exec_input_buffer instead of sys.dm_exec_sql_text can be used to get the code that the sessions of interest submitted last. SELECT session_id, event_info FROM sys.dm_exec_connections CROSS APPLY sys.dm_exec_input_buffer(session_id, NULL) AS IB WHERE session_id IN(52, 56); The DMV sys.dm_exec_sessions can be used to find a lot of useful information about the sessions involved in a blocking situation. SELECT -- use * to explore session_id AS sid, login_time, host_name, program_name, login_name, nt_user_name, last_request_start_time, last_request_end_time FROM sys.dm_exec_sessions WHERE session_id IN(52, 56); Another DMV sys.dm_exec_requests can probably be used to find useful for troubleshooting blocking situations. SELECT -- use * to explore session_id AS sid, blocking_session_id, command, sql_handle, database_id, wait_type, wait_time, wait_resource FROM sys.dm_exec_requests WHERE blocking_session_id &gt; 0; To terminate the blocker—for example, if realizing that as a result of a bug in the application the transaction remained open and nothing in the application can close it—do so by using the KILL &lt;session_id&gt; command. KILL 56; 12.2. Isolation Levels Isolation levels determine the level of consistency when interacting with data. In the default isolation level in a box product, a reader uses shared locks on the target resources and a writer uses exclusive locks. SQL Server supports four isolation levels that are based on the pure locking model: READ UNCOMMITTED, READ COMMITTED (the default in a SQL Server box product), REPEATABLE READ, and SERIALIZABLE. SQL Server also supports two isolation levels that are based on a combination of locking and row versioning: SNAPSHOT and READ COMMITTED SNAPSHOT (the default in Azure SQL Database). SNAPSHOT and READ COMMITTED SNAPSHOT are in a sense the row-versioning counterparts of READ COMMITTED and SERIALIZABLE, respectively. The isolation level of the whole session can be set by using the following command: SET TRANSACTION ISOLATION LEVEL &lt;isolationname&gt;; The isolation level of a query can be set by using a table hint: SELECT ... FROM &lt;table&gt; WITH (&lt;isolationname&gt;); With the first four isolation levels, the higher the isolation level, the stricter the locks are that readers request and the longer their duration is; therefore, the higher the isolation level is, the higher the consistency is and the lower the concurrency is. With the two row-versioning-based isolation levels, SQL Server is able to store previous committed versions of rows in a version store. Readers do not request shared locks; instead, if the current version of the rows is not what they are supposed to see, SQL Server provides them with an older version. Table 3. Isolation level properties Isolation level Allows uncommitted reads? Allows nonrepeatable reads? Allows lost updates? Allows phantom reads? Detects update conflicts? Uses row versioning? READ UNCOMMITTED Yes Yes Yes Yes No No READ COMMITTED No Yes Yes Yes No No REPEATABLE READ No No No Yes No No SERIALIZABLE No No No No No No SNAPSHOT No No No No Yes Yes READ COMMITTED SNAPSHOT No Yes Yes Yes No Yes 12.2.1. READ UNCOMMITTED READ UNCOMMITTED is the lowest available isolation level, that is, a reader doesn’t ask for a shared lock. A reader that doesn’t ask for a shared lock can never be in conflict with a writer that is holding an exclusive lock, so that the reader can read uncommitted changes (also known as dirty reads). It also means the reader won’t interfere with a writer that asks for an exclusive lock, that is, a writer can change data while a reader that is running under the READ UNCOMMITTED isolation level reads data. Open a transaction, update the unit price of product 2 by adding 1.00 to its current price (19.00), and then query the product’s row -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 Set the isolation level to READ UNCOMMITTED and query the row for product 2. The query returned the state of the row after the change, even though the change was not committed -- Connection 2 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 Keep in mind that Connection 1 might apply further changes to the row later in the transaction or even roll back at some point. -- Connection 1 ROLLBACK TRAN; The above rollback undoes the update of product 2, changing its price back to 19.00. The value 20.00 that the reader got was never committed which is called dirty read. 12.2.2. READ COMMITTED The lowest isolation level that prevents dirty reads is READ COMMITTED, which is also the default isolation level in SQL Server (the box product), to prevent uncommitted reads by requiring a reader to obtain a shared lock. -- Connection 1 -- open a transaction, update the price of product 2, and query the row to show the new price BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 2 -- Keep in mind that this isolation level is the default, so unless previously changed the session’s isolation level, it isn&#39;t needed to set it explicitly. -- The SELECT statement is currently blocked because it needs a shared lock to be able to read the row, and this shared lock request is in conflict with the exclusive lock held by the writer in Connection 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 1 -- commit the transaction COMMIT TRAN; -- Connection 2 2 20.00 -- restore the unitprice of the product 2 UPDATE Production.Products SET unitprice -= 1.00 -- 19.00 WHERE productid = 2; In terms of the duration of locks, in the READ COMMITTED isolation level, a reader holds the shared lock only until it’s done with the resource. It doesn’t keep the lock until the end of the transaction; in fact, it doesn’t even keep the lock until the end of the statement, that means that in between two reads of the same data resource in the same transaction, no lock is held on the resource. Therefore, another transaction can modify the resource in between those two reads, and the reader might get different values in each read, which is called nonrepeatable reads or inconsistent analysis. 12.2.3. REPEATABLE READ The isolation level REPEATABLE READ can be used to get repeatable reads, or consistent analysis to ensure that no one can change values in between reads that take place in the same transaction, that is, not only does a reader need a shared lock to be able to read, but it also holds the lock until the end of the transaction. The REPEATABLE READ but not by lower isolation levels can also prevent another phenomenon called a lost update that happens when two transactions read a value, make calculations based on what they read, and then update the value. In isolation levels lower than REPEATABLE READ no lock is held on the resource after the read, both transactions can update the value, and whichever transaction updates the value last “wins,” overwriting the other transaction’s update. In REPEATABLE READ, both sides keep their shared locks after the first read, so neither can acquire an exclusive lock later in order to update, which results in a deadlock, and the update conflict is prevented. -- Connection 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- keep holding a shared lock on the row for product 2 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 -- Connection 2 -- blocked the modifier’s request for an exclusive lock in conflict with the reader’s granted shared lock. UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; -- Connection 1 -- the second read got the same unit price for product 2 as the first read SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; -- commit the transaction and release the shared lock -- Connection 2 -- obtain the exclusive lock it was waiting for and update the row 12.2.4. SERIALIZABLE Under the REPEATABLE READ isolation level, readers keep shared locks until the end of the transaction that locks only resources (e.g., rows) that the query found the first time it ran, not rows that weren’t there when the query ran, so that a second read in the same transaction might return new rows as well, which happens if, in between the reads, another transaction inserts new rows that satisfy the reader’s query filter, which are called phantoms, and such reads are called phantom reads. The SERIALIZABLE isolation level can be used to prevent phantom reads, that requires a reader to obtain a shared lock on the whole range of keys that qualify for the query’s filter to be able to read, and it keeps the lock until the end of the transaction. -- Connection 1 -- set the transaction isolation level to SERIALIZABLE, open a transaction, and query all products with category 1 SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; BEGIN TRAN SELECT productid, productname, categoryid, unitprice FROM Production.Products WHERE categoryid = 1; -- Connection 2 -- In all isolation levels that are lower than SERIALIZABLE, such an attempt would be successful. -- In the SERIALIZABLE isolation level, the attempt is blocked. INSERT INTO Production.Products (productname, supplierid, categoryid, unitprice, discontinued) VALUES(&#39;Product ABCDE&#39;, 1, 1, 20.00, 0); sid restype dbid dbname res resid mode status 55 (Connection 1) KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 RangeS-S GRANT 64 (Connection 2) KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 X WAIT -- Connection 1 -- get the same output as before, with no phantoms SELECT productid, productname, categoryid, unitprice FROM Production.Products WHERE categoryid = 1; COMMIT TRAN; -- transaction is committed and the shared key-range lock is released 12.2.5. Multi-Version Concurrency Control With the row-versioning technology, SQL Server can store previous versions of committed rows in a version store. If the Accelerated Database Recovery (ADR) feature is not enabled in the database, the version store resides in the tempdb database. If ADR is enabled, the version store resides in the user database in question. SQL Server supports two isolation levels, called SNAPSHOT and READ COMMITTED SNAPSHOT, that are based on this row-versioning technology. The SNAPSHOT isolation level is logically similar to the SERIALIZABLE isolation level in terms of the types of consistency problems that can or cannot happen. The READ COMMITTED SNAPSHOT isolation level is similar to the READ COMMITTED isolation level. Readers using isolation levels based on row versioning do not acquire shared locks, so they don’t wait when the requested data is exclusively locked. In other words, readers don’t block writers and writers don’t block readers. Readers still get levels of consistency similar to SERIALIZABLE and READ COMMITTED. SQL Server provides readers with an older version of the row if the current version is not the one they are supposed to see. Note that if enabling any of the row-versioning-based isolation levels (which are enabled in Azure SQL Database by default), the DELETE and UPDATE statements need to copy the version of the row before the change to the version store (Copy-on-Write); INSERT statements don’t need to write anything to the version store, because no earlier version of the row exists. But it’s important to be aware that enabling any of the isolation levels that are based on row versioning might have a negative impact on the performance of updates and deletes. The performance of readers usually improves, sometimes dramatically, because they do not acquire shared locks and don’t need to wait when data is exclusively locked or its version is not the expected one. 12.2.5.1. SNAPSHOT The SNAPSHOT isolation level, relies on row versioning instead of using shared locks, guarantees the reader to get the last committed version of the row that was available when the transaction started to get committed reads and repeatable reads, and not phantom reads. To work with the SNAPSHOT isolation level in a SQL Server box product instance (enabled by default in Azure SQL Database), first enable the option at the database level by running the following code in any open query window: ALTER DATABASE TSQLV6 SET ALLOW_SNAPSHOT_ISOLATION ON; Open a transaction, update the price of product 2 by adding 1.00 to its current price of 19.00, and show the new price. -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 If someone begins a transaction using the SNAPSHOT isolation level, that session can request the version before the update. -- Connection 2 SET TRANSACTION ISOLATION LEVEL SNAPSHOT; BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 If a transaction were under the SERIALIZABLE isolation level, the query would be blocked. -- Connection 3 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; -- by default in SQL Server SET LOCK_TIMEOUT 5000; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Msg 1222, Level 16, State 51, Line 5 Lock request time out period exceeded. Go back to Connection 1, and commit the transaction. -- at this point, the current version of the row with the price of 20.00 is a committed version. COMMIT TRAN; Go back to Connection 2, and run the following code. -- still get the last committed version of the row that was available when the transaction started (with a price of 19.00). SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; 2 19.00 12.2.5.2. Conflict Detection The SNAPSHOT isolation level prevents update conflicts, but unlike the REPEATABLE READ and SERIALIZABLE isolation levels that do so by generating a deadlock, the SNAPSHOT isolation level generates a more specific error, indicating that an update conflict was detected by examining the version store to figure out whether another transaction modified the data between a read and a write that took place in a transaction. Set the transaction isolation level to SNAPSHOT, open a transaction, and read the row for product 2. -- Connection 1 SET TRANSACTION ISOLATION LEVEL SNAPSHOT; BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 Update the price of the product queried previously to 20.00, and commit the transaction. -- Connection 1 UPDATE Production.Products SET unitprice = 20.00 WHERE productid = 2; COMMIT TRAN; No other transaction modified the row between the read, calculation, and write; therefore, there was no update conflict and SQL Server allowed the update to take place. Restore the price of product 2 back to 19.00: UPDATE Production.Products SET unitprice = 19.00 WHERE productid = 2; Next, run the following code in Connection 1, again, to open a transaction, and read the row for product 2: -- Connection 1 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Next, run the following code in Connection 2 to update the price of product 2 to 25.00: -- Connection 2 UPDATE Production.Products SET unitprice = 25.00 WHERE productid = 2; Go back to Connection 1, and try to update the price of the product to 20.00: UPDATE Production.Products SET unitprice = 20.00 WHERE productid = 2; SQL Server detected that this time another transaction modified the data between the read and write; therefore, it fails the transaction with the following error: Msg 3960, Level 16, State 2, Line 1 Snapshot isolation transaction aborted due to update conflict. You cannot use snapshot isolation to access table &#39;Production.Products&#39; directly or indirectly in database &#39;TSQLV6&#39; to update, delete, or insert the row that has been modified or deleted by another transaction. Retry the transaction or change the isolation level for the update/delete statement. 12.2.5.3. READ COMMITTED SNAPSHOT The READ COMMITTED SNAPSHOT isolation level is also based on row versioning, but differs from the SNAPSHOT isolation level in that instead of providing a reader with a transaction-level consistent view of the data, it provides the reader with a statement-level consistent view of the data, and also does not detect update conflicts. To make a reader to acquire a shared lock under READ COMMITTED SNAPSHOT, add a table hint called READCOMMITTEDLOCK to the SELECT statements, as in SELECT * FROM dbo.T1 WITH (READCOMMITTEDLOCK). To enable the use of the READ COMMITTED SNAPSHOT isolation level in a SQL Server box product (enabled by default in Azure SQL Database), turn on a database option called READ_COMMITTED_SNAPSHOT. ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT ON; Unlike the SNAPSHOT isolation level, this flag changes the meaning, or semantics, of the READ COMMITTED isolation level to READ COMMITTED SNAPSHOT, which means that when this database flag is turned on, unless explicitly changing the session’s isolation level, READ COMMITTED SNAPSHOT is the default. Run the following code in Connection 1 to open a transaction, update the row for product 2, and read the row, leaving the transaction open: -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 In Connection 2, open a transaction and read the row for product 2, leaving the transaction open: -- Connection 2 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 Run the following code in Connection 1 to commit the transaction: -- Connection 1 COMMIT TRAN; Now run the code in Connection 2 to read the row for product 2 again, and commit the transaction: -- Connection 2 -- get the last committed version of the row that was available when the statement started (20.00) and not when the transaction started (19.00) SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; 2 19.00 Close all connections. Open a new connection, and run the following code to disable the isolation levels that are based on row versioning in the TSQLV6 database: ALTER DATABASE TSQLV6 SET ALLOW_SNAPSHOT_ISOLATION OFF; ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT OFF; 12.3. Deadlocks A deadlock is a situation in which two or more sessions block each other. An example of a two- session deadlock is when session A blocks session B and session B blocks session A. An example of a deadlock involving more than two sessions is when session A blocks session B, session B blocks session C, and session C blocks session A. In any of these cases, SQL Server detects the deadlock and intervenes by terminating one of the transactions. If SQL Server did not intervene, the sessions involved would remain deadlocked forever. Unless otherwise specified (DEADLOCK_PRIORITY), SQL Server chooses to terminate the transaction that did the least work (based on the activity written to the transaction log), because rolling that transaction’s work back is the cheapest option. Run the following code in Connection 1 to open a new transaction, update a row in the Production.Products table for product 2, and leave the transaction open: -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; Run the following code in Connection 2 to open a new transaction, update a row in the Sales.OrderDetails table for product 2, and leave the transaction open: -- Connection 2 BEGIN TRAN; UPDATE Sales.OrderDetails SET unitprice += 1.00 WHERE productid = 2; Run the following code in Connection 1 to attempt to query the rows for product 2 in the Sales.OrderDetails table, and commit the transaction: -- Connection 1 -- needs a shared lock to be able to perform its read, but blocked by Connection 2 SELECT orderid, productid, unitprice FROM Sales.OrderDetails WHERE productid = 2; COMMIT TRAN; Next, run the following code in Connection 2 to attempt to query the row for product 2 in the Production.Products table and commit the transaction: -- Connection 2 -- needs a shared lock to be able to perform its read, but blocked by Connection 1 SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; At this point, each of the sessions blocks the other —results a deadlock. SQL Server identifies the deadlock (typically within a few seconds), chooses one of the sessions involved as the deadlock victim, and terminates its transaction with the following error: Msg 1205, Level 13, State 51, Line 3 Transaction (Process ID 57) was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction. Deadlocks are expensive because they involve undoing work that has already been done and then, usually with some error-handling logic, redoing the work. Obviously, the longer the transactions are, the longer locks are kept, increasing the probability of deadlocks. Keep transactions as short as possible, taking activities out of the transaction that aren’t logically supposed to be part of the same unit of work. For example, don’t use transactions that require user input to finish! One typical deadlock, also called a deadly embrace deadlock (e.g., the above example), happens when transactions access resources in inverse order. By swapping the order in one of the transactions, you can prevent this type of deadlock from happening—assuming that it makes no logical difference to your application. Deadlocks often also happen when there is no real logical conflict (for example, trying to access the same rows), because of a lack of good indexing to support query filters. For example, suppose both statements in the transaction in Connection 2 filtered product 5. Now that the statements in Connection 1 handle product 2 and the statements in Connection 2 handle product 5, there shouldn’t be any conflict. However, if indexes aren&#8217;t defined on the productid column in the tables to support the filter, SQL Server has to scan (and lock) all rows in the table, that is, of course, can lead to a deadlock. While scanning the entire table, both connections might attempt to acquire locks on the same or overlapping table pages, leading to a deadlock situation even though they are working with different product data. In short, good index design can help mitigate the occurrences of deadlocks that have no real logical conflict. Another option to consider to mitigate deadlock occurrences is the choice of isolation level. The SELECT statements in the example needed shared locks because they ran under the READ COMMITTED isolation level. If using the READ COMMITTED SNAPSHOT isolation level, readers will not need shared locks, and deadlocks that evolve because of the involvement of shared locks can be eliminated. 13. Programmable Objects Programmable objects in SQL Server are reusable code blocks that extend the capabilities of the database beyond basic data storage and retrieval. 13.1. Variables A variable is used to temporarily store data values for later use in the same batch in which they were declared, and a batch is one or more T-SQL statements sent to Microsoft SQL Server for execution as a single unit. Use a DECLARE statement to declare one or more variables, and use a SET statement to assign a value to a single variable. -- declares two variables called @i and @j of INT data type and assigns it the value 10 and 20 DECLARE @i AS INT, @j AS INT; -- SET statement can operate on only one variable at a time SET @i = 10; SEt @j = 20; Alternatively, a variable can be declared and initialized in the same statement, like this: DECLARE @i AS INT = 10, @j AS INT = 20; When assign a value to a scalar variable, the value must be the result of a scalar expression. DECLARE @empname AS NVARCHAR(61); -- a scalar subquery SET @empname = (SELECT firstname + N&#39; &#39; + lastname FROM HR.Employees WHERE empid = 3); -- a scalar subquery fails at run time if it returns more than one value DECLARE @empname AS NVARCHAR(61); SET @empname = (SELECT firstname + N&#39; &#39; + lastname FROM HR.Employees WHERE mgrid = 2); Msg 512, Level 16, State 1, Line 2 Subquery returned more than 1 value. This is not permitted when the subquery follows =, !=, &lt;, &lt;= , &gt;, &gt;= or when the subquery is used as an expression. T-SQL also supports a nonstandard assignment SELECT statement to query data and assign multiple values obtained from the same row to multiple variables by using a single statement. DECLARE @firstname AS NVARCHAR(20), @lastname AS NVARCHAR(40); -- if the query has more than one qualifying row, the values in the variables are those from the last row that SQL Server happened to access. SELECT @firstname = firstname, @lastname = lastname FROM HR.Employees WHERE empid = 3; SELECT @firstname AS firstname, @lastname AS lastname; 13.2. Batchs A batch is one or more T-SQL statements sent by a client application to SQL Server for execution as a single unit. A transaction is an atomic unit of work. A batch can have multiple transactions, and a transaction can be submitted in parts as multiple batches. Client application programming interfaces (APIs) such as ADO.NET provide methods for submitting a batch of code to SQL Server for execution. SQL Server utilities such as SQL Server Management Studio (SSMS), Azure Data Studio (ADS), SQLCMD, and OSQL provide a client tool command called GO that signals the end of a batch. Note that the GO command is a client tool command and not a T-SQL server command, and do not terminate the GO command with a semicolon. A batch is a set of commands that are parsed and executed as a unit. If the parsing is successful, SQL Server then attempts to execute the batch. In the event of a syntax error in the batch, the whole batch is not submitted to SQL Server for execution. -- Valid batch PRINT &#39;First batch&#39;; USE TSQLV6; GO -- Invalid batch PRINT &#39;Second batch&#39;; SELECT custid FROM Sales.Customers; SELECT orderid FOM Sales.Orders; GO -- Valid batch PRINT &#39;Third batch&#39;; SELECT empid FROM HR.Employees; First batch Msg 102, Level 15, State 1, Line 8 Incorrect syntax near &#39;Sales&#39;. Third batch A variable is local to the batch in which it’s defined, that is, it can’t be referred to in another batch. DECLARE @i AS INT = 10; -- Succeeds PRINT @i; GO -- Fails PRINT @i; 10 Msg 137, Level 15, State 2, Line 6 Must declare the scalar variable &quot;@i&quot;. The CREATE statements cannot be combined with other statements in the same batch. -- CREATE DEFAULT, CREATE FUNCTION, CREATE PROCEDURE, CREATE RULE, CREATE SCHEMA, CREATE TRIGGER, and CREATE VIEW DROP VIEW IF EXISTS Sales.MyView; -- GO -- To get around the problem, add a GO command here CREATE VIEW Sales.MyView AS SELECT YEAR(orderdate) AS orderyear, COUNT (*) AS numorders FROM Sales.Orders GROUP BY YEAR(orderdate); GO Msg 111, Level 15, State 1, Line 3 &#39;CREATE VIEW&#39; must be the first statement in a query batch. A batch is a unit of resolution (also known as binding), that means that checking the existence of objects and columns happens at the batch level. When applying schema changes to an object and try to manipulate the object data in the same batch, SQL Server might not be aware of the schema changes yet and fail the data-manipulation statement with a resolution error. DROP TABLE IF EXISTS dbo.T1; CREATE TABLE dbo.T1(col1 INT); GO ALTER TABLE dbo.T1 ADD col2 INT; -- GO -- To get around the problem, add a GO command here SELECT col1, col2 FROM dbo.T1; -- Invalid column name &#39;col2&#39;. GO DROP TABLE IF EXISTS dbo.T1; The GO command is not really a T-SQL command; it’s actually a command used by SQL Server’s client tools, such as SSMS, to denote the end of a batch. It also supports an argument indicating how many times you want to execute the batch. DROP TABLE IF EXISTS dbo.T1; CREATE TABLE dbo.T1(col1 INT IDENTITY); GO SET NOCOUNT ON; INSERT INTO dbo.T1 DEFAULT VALUES; GO 100 SELECT SUM(col1) FROM dbo.T1; -- (1 + 100) * 100 / 2 = 5050 GO DROP TABLE IF EXISTS dbo.T1; 13.3. Flow Elements: IF and WHILE T-SQL provides basic forms of control with flow elements to control the flow of the code, including the IF . . . ELSE element and the WHILE element. The IF . . . ELSE element is used to control the flow of a code based on the result of a predicate. IF YEAR(SYSDATETIME()) &lt;&gt; YEAR(DATEADD(day, 1, SYSDATETIME())) -- a statement or statement block that is executed if the predicate is TRUE PRINT &#39;Today is the last day of the year.&#39;; -- optionally a statement or statement block that is executed if the predicate is FALSE or UNKNOWN. ELSE BEGIN -- mark the boundaries of a statement block with the BEGIN and END keywords IF MONTH(SYSDATETIME()) &lt;&gt; MONTH(DATEADD(day, 1, SYSDATETIME())) PRINT &#39;Today is the last day of the month but not the last day of the year.&#39;; ELSE PRINT &#39;Today is not the last day of the month.&#39;; END DECLARE @score AS INT = CAST(RAND() * 100 AS INT); IF @score &gt; 90 PRINT &#39;A&#39;; ELSE IF @score &gt; 80 PRINT &#39;B&#39;; ELSE IF @score &gt; 70 PRINT &#39;C&#39;; ELSE IF @score &gt; 60 PRINT &#39;D&#39;; ELSE PRINT &#39;F&#39;; -- CASE is expression, instead of statement DECLARE @score AS INT = CAST(RAND() * 100 AS INT); SELECT CASE WHEN @score &gt;= 90 THEN &#39;A&#39; WHEN @score &gt;= 80 THEN &#39;B&#39; WHEN @score &gt;= 70 THEN &#39;C&#39; WHEN @score &gt;= 60 THEN &#39;D&#39; ELSE &#39;F&#39; END AS Grade; The WHILE element executes a statement or statement block repeatedly while the predicate specified after the WHILE keyword is TRUE, otherwise, the loop terminates when the predicate is FALSE or UNKNOWN. DECLARE @i AS INT = 0; WHILE @i &lt;= 10 BEGIN SET @i = @i + 1; IF @i = 3 CONTINUE; -- skip the rest of the activity in the current iteration and evaluate the loop’s predicate again PRINT @i; IF @i = 7 BREAK; -- break out of the current loop and proceed to execute the statement that appears after the loop’s body END; 13.4. Cursors SQL and T-SQL also support an object called cursor to process rows from a result of a query one at a time and in a requested order. Primarily, the use of cursors contradicts the fundamental principles of the relational model, which is grounded in set theory. Cursors, due to their record-by-record processing, incur significant overhead compared to set-based operations, resulting in significantly slower execution times even for similar underlying physical processing. Cursor solutions, being imperative, tend to be longer, less readable, and harder to maintain than the declarative set solutions. Working with a cursor generally involves the following steps: Declare the cursor based on a query. Open the cursor. Fetch attribute values from the first cursor record into variables. While not reaching the end of the cursor (the value of a function called @@FETCH_STATUS is 0), loop through the cursor records. In each iteration of the loop, perform the processing needed for the current row, and then fetch the attribute values from the next row into the variables. Close the cursor. Deallocate the cursor. DROP VIEW IF EXISTS Sales.CustOrders; GO CREATE VIEW Sales.CustOrders AS SELECT DISTINCT O.custid, O.orderdate AS ordermonth, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid GROUP BY o.custid, O.orderdate GO -- Suppress messages indicating how many rows were affected SET NOCOUNT ON; -- Declare table variable to hold the final result DECLARE @Result AS TABLE ( custid INT, ordermonth DATE, qty INT, runqty INT, PRIMARY KEY(custid, ordermonth) ); -- Declare local variables that are used to store intermediate variables DECLARE @custid AS INT, @prvcustid AS INT, @ordermonth AS DATE, @qty AS INT, @runqty AS INT; -- Step 1: Declare the cursor based on a query DECLARE C CURSOR FAST_FORWARD /* read only, forward only */ FOR SELECT custid, ordermonth, qty FROM Sales.CustOrders ORDER BY custid, ordermonth; -- Step 2: Open the cursor OPEN C; -- Step 3: Fetch attribute values from the first cursor record into variables FETCH NEXT FROM C INTO @custid, @ordermonth, @qty; -- Initialize variables SELECT @prvcustid = @custid, @runqty = 0; -- Step 4: Loop through the cursor records while last fetch was -- In each iteration: -- Reset variables if customer ID changes -- Compute current running total and insert into table -- Fetch next cursor record WHILE @@FETCH_STATUS = 0 BEGIN IF @custid &lt;&gt; @prvcustid SELECT @prvcustid = @custid, @runqty = 0; SET @runqty = @runqty + @qty; INSERT INTO @Result VALUES(@custid, @ordermonth, @qty, @runqty); FETCH NEXT FROM C INTO @custid, @ordermonth, @qty; END; -- Step 5: Close the cursor CLOSE C; -- Step 6: Deallocate the cursor DEALLOCATE C; -- Enable showing messages indicating how many rows were affected SET NOCOUNT OFF; -- Query the table variable to return the final result SELECT custid, CONVERT(VARCHAR(7), ordermonth, 121) AS ordermonth, qty, runqty FROM @Result ORDER BY custid, ordermonth; -- address the same task with a window function SELECT custid, ordermonth, qty, SUM(qty) OVER(PARTITION BY custid ORDER BY ordermonth ROWS UNBOUNDED PRECEDING) AS runqty FROM Sales.CustOrders ORDER BY custid, ordermonth; 13.5. Temporary Tables Temporary tables are temporary storage structures within a SQL Server database. Unlike permanent tables, they are designed for short-term data storage and have limited lifespans. SQL Server supports three kinds of temporary tables to be more conveniental to work with than permanent tables in such cases: local temporary tables, global temporary tables, and table variables. All three kinds of temporary tables are created in the tempdb database. It&#8217;s crucial to distinguish temporary tables (local, global, table variables) from system-versioned temporal tables. Temporary Tables: Primarily used for temporary storage within a specific session or batch, often for intermediate results or data manipulation. System-Versioned Temporal Tables: Specifically designed to track the history of data changes over time. 13.5.1. Local Temporary Tables A local temporary table is created by naming it with a single number sign (#) as a prefix, such as #T1. A local temporary table is visible only to the session that created it, in the creating level and all inner levels in the call stack (inner procedures, triggers, and dynamic batches). A local temporary table is destroyed automatically by SQL Server when the creating level in the call stack goes out of scope. A suffix is added to the table name by SQL Server internally that makes it unique in tempdb. DROP TABLE IF EXISTS #MyOrderTotalsByYear; GO CREATE TABLE #MyOrderTotalsByYear ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); INSERT INTO #MyOrderTotalsByYear(orderyear, qty) SELECT YEAR(O.orderdate) AS orderyear, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON OD.orderid = O.orderid GROUP BY YEAR(orderdate); SELECT Cur.orderyear, Cur.qty AS curyearqty, Prv.qty AS prvyearq FROM #MyOrderTotalsByYear AS Cur LEFT OUTER JOIN #MyOrderTotalsByYear AS Prv ON Cur.orderyear = Prv.orderyear + 1; -- clean up resources as soon as possible DROP TABLE IF EXISTS #MyOrderTotalsByYear; 13.5.2. Global Temporary Tables A global temporary table is created by naming it with a double number sign (##) as a prefix, such as ##T1. A global temporary table is visible to all other sessions. A global temporary table is destroyed automatically by SQL Server when the creating session disconnects and there are no active references to the table. -- creates a global temporary table called ##Globals with columns called id and val CREATE TABLE ##Globals ( id sysname NOT NULL PRIMARY KEY, val SQL_VARIANT NOT NULL ); -- anyone can insert rows into the table. INSERT INTO ##Globals(id, val) VALUES(N&#39;I&#39;, CAST(10 AS INT)); -- anyone can modify and retrieve data from the table. SELECT val FROM ##Globals WHERE id = N&#39;I&#39;; -- explicitly destroy the global temporary table DROP TABLE IF EXISTS ##Globals; 13.5.3. Table Variables A table variable is a local, temporary table-like data structure declared within a single batch. As with local temporary tables, table variables have a physical presence as a table in the tempdb database. Like local temporary tables, table variables are visible only to the creating session, but because they are variables they have a more limited scope: only the current batch. If an explicit transaction is rolled back, changes made to temporary tables in that transaction are rolled back as well; however, changes made to table variables by statements that completed in the transaction aren’t rolled back. In terms of performance, usually it makes more sense to use table variables with small volumes of data (only a few rows) and to use local temporary tables otherwise. DECLARE @MyOrderTotalsByYear TABLE ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); INSERT INTO @MyOrderTotalsByYear(orderyear, qty) SELECT YEAR(O.orderdate) AS orderyear, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON OD.orderid = O.orderid GROUP BY YEAR(orderdate); SELECT Cur.orderyear, Cur.qty AS curyearqty, Prv.qty AS prvyearqty FROM @MyOrderTotalsByYear AS Cur LEFT OUTER JOIN @MyOrderTotalsByYear AS Prv ON Cur.orderyear = Prv.orderyear + 1; A table type is a user-defined data structure that defines the schema (columns, data types) of a table to be reused as the table definition of table variables and input parameters of stored procedures and user-defined functions. -- create a table type called dbo.OrderTotalsByYear DROP TYPE IF EXISTS dbo.OrderTotalsByYear; CREATE TYPE dbo.OrderTotalsByYear AS TABLE ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); -- simply specify dbo.OrderTotalsByYear as the variable’s type DECLARE @MyOrderTotalsByYear AS dbo.OrderTotalsByYear; 13.6. Dynamic SQL A dynamic SQL in SQL Server is a batch of T-SQL code as a character string that can be executed by using the EXEC command and the sp_executesql stored procedure. The EXEC (short for EXECUTE) command accepts a regular or Unicode character string in parentheses as input and executes the batch of code within the character string. DECLARE @sql AS VARCHAR(100); SET @sql = &#39;PRINT &#39;&#39;This message was printed by a dynamic SQL batch&#39;&#39;&#39; EXEC(@sql); The sp_executesql stored procedure is an alternative tool to the EXEC command for executing dynamic SQL code. It’s more secure and more flexible in the sense that it has an interface; that is, it supports input and output parameters. In terms of security, parameters that appear in the code cannot be considered part of the code—they can only be considered operands in expressions. Note that unlike EXEC, sp_executesql supports only Unicode character strings as the input batch of code. The sp_executesql stored procedure can perform better than EXEC because its parameterization aids in reusing cached execution plans, which incur cost when SQL Server needs to create them anew. An execution plan is the physical processing plan SQL Server produces for a query, with the set of instructions describing which objects to access, in what order, which indexes to use, how to access them, which join algorithms to use, and so on. One of the requirements for reusing a previously cached plan is that the query string be the same as the one for which the cached plan was created. DECLARE @sql AS NVARCHAR(100); SET @sql = N&#39;SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderid = @orderid;&#39;; EXEC sp_executesql @stmt = @sql, -- a Unicode character string holding the batch of code @params = N&#39;@orderid AS INT&#39;, -- a Unicode character string holding the declarations of input and output parameters @orderid = 10248; -- an input parameter called @orderid 13.7. Routines Routines are programmable objects that encapsulate code to calculate a result or to execute activity. SQL Server supports three types of routines: user-defined functions, stored procedures, and triggers. 13.7.1. User-defined Functions A user-defined function (UDF) is used to encapsulate logic that calculates something, possibly based on input parameters, and return a result. SQL Server supports scalar and table-valued UDFs. Scalar UDFs return a single value; table-valued UDFs return a table. Scalar UDFs can appear anywhere in the query where an expression that returns a single value can appear (for example, in the SELECT list). Table UDFs can appear in the FROM clause of a query. UDFs are not allowed to have any side effects, that means UDFs are not allowed to apply any schema or data changes in the database. CREATE OR ALTER FUNCTION dbo.GetNewID() RETURNS UNIQUEIDENTIFIER AS BEGIN RETURN NEWID(); -- Invalid use of a side-effecting operator &#39;newid&#39; within a function. END; -- create a UDF called dbo.GetAge that returns the age of a person DROP FUNCTION IF EXISTS dbo.GetAge; GO CREATE OR ALTER FUNCTION dbo.GetAge ( @birthdate AS DATE, -- a specified birth date (@birthdate argument) @eventdate AS DATE -- a specified event date (@eventdate argument) ) RETURNS INT AS BEGIN RETURN -- a RETURN clause that returns a value DATEDIFF(year, @birthdate, @eventdate) - CASE WHEN 100 * MONTH(@eventdate) + DAY(@eventdate) &lt; 100 * MONTH(@birthdate) + DAY(@birthdate) THEN 1 ELSE 0 END; END; GO -- use a UDF in a query SELECT empid, firstname, lastname, birthdate, dbo.GetAge(birthdate, SYSDATETIME()) AS age FROM HR.Employees; 13.7.2. Stored Procedures Stored procedures are routines that encapsulate logic with input and output parameters, return result sets of queries, and can have side effects. Stored procedures encapsulate logic, allowing for centralized modification and ensuring all users utilize the updated implementation. Stored procedures give better control of security. A user permissions can be granted to execute the procedure without granting the user direct permissions to perform the underlying activities to ensure that all the required validations and auditing always take place. Stored procedures with parameters can help prevent SQL injection. All error-handling code can be incorporated within a procedure, silently taking corrective action where relevant. Stored procedures give performance benefits. Parameterized queries within stored procedures enhance performance by leveraging cached execution plans. Stored procedures reduce network traffic by minimizing data exchange between the client and server. -- create a stored procedure called Sales.GetCustomerOrders CREATE OR ALTER PROC Sales.GetCustomerOrders -- a customer ID (@custid) and a date range (@fromdate and @todate) as inputs @custid AS INT, @fromdate AS DATETIME = &#39;19000101&#39;, -- default 19000101 @todate AS DATETIME = &#39;99991231&#39;, -- default 99991231 @numrows AS INT OUTPUT -- the number of affected rows (@numrows) as an output AS SET NOCOUNT ON; -- suppress messages indicating affected rows by DML SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE custid = @custid AND orderdate &gt;= @fromdate AND orderdate &lt; @todate; SET @numrows = @@rowcount; -- execute the procedure, and absorb the value of the output parameter @numrows in the variable @rc DECLARE @rc AS INT; EXEC Sales.GetCustomerOrders @custid = 1, @fromdate = &#39;20210101&#39;, @todate = &#39;20220101&#39;, @numrows = @rc OUTPUT; SELECT @rc AS numrows; 13.7.3. Triggers A trigger is a special kind of stored procedure attached to an event—one that cannot be executed explicitly. SQL Server supports the association of triggers with two kinds of events: data manipulation events (DML triggers) such as INSERT, and data definition events (DDL triggers) such as CREATE TABLE. A trigger is considered part of the transaction that includes the event that caused the trigger to fire. Triggers in SQL Server fire per statement and not per modified row. 13.7.3.1. DML Triggers SQL Server supports two kinds of DML triggers: after and instead of. An after trigger fires after the event it’s associated with finishes and can be defined only on permanent tables. An instead of trigger fires instead of the event it’s associated with and can be defined on permanent tables and views. In the trigger’s code, pseudo tables called inserted and deleted that contain the rows that were affected by the modification that caused the trigger to fire can be accessed. The inserted table holds the new image of the affected rows in the case of INSERT and UPDATE actions. The deleted table holds the old image of the affected rows in the case of DELETE and UPDATE actions. In the case of instead of triggers, the inserted and deleted tables contain the rows that were supposed to be affected by the modification that caused the trigger to fire. -- create a table called dbo.T1, and a table called dbo.T1_Audit DROP TABLE IF EXISTS dbo.T1_Audit, dbo.T1; CREATE TABLE dbo.T1 ( keycol INT NOT NULL PRIMARY KEY, datacol VARCHAR(10) NOT NULL ); CREATE TABLE dbo.T1_Audit ( audit_lsn INT NOT NULL IDENTITY PRIMARY KEY, -- audit log serial number dt DATETIME2(3) NOT NULL DEFAULT(SYSDATETIME()), login_name sysname NOT NULL DEFAULT(ORIGINAL_LOGIN()), keycol INT NOT NULL, datacol VARCHAR(10) NOT NULL ); GO -- create the AFTER INSERT trigger trg_T1_insert_audit on the T1 table to audit insertions CREATE OR ALTER TRIGGER trg_T1_insert_audit ON dbo.T1 AFTER INSERT AS SET NOCOUNT ON; INSERT INTO dbo.T1_Audit(keycol, datacol) SELECT keycol, datacol FROM inserted; GO -- trigger fires after each statement INSERT INTO dbo.T1(keycol, datacol) VALUES(10, &#39;a&#39;); INSERT INTO dbo.T1(keycol, datacol) VALUES(30, &#39;x&#39;); INSERT INTO dbo.T1(keycol, datacol) VALUES(20, &#39;g&#39;); GO SELECT audit_lsn, dt, login_name, keycol, datacol FROM dbo.T1_Audit; -- 1 2025-01-15 16:03:50.997 sa 10 a -- 2 2025-01-15 16:03:51.004 sa 30 x -- 3 2025-01-15 16:03:51.008 sa 20 g GO -- cleanup DROP TABLE dbo.T1_Audit, dbo.T1; 13.7.3.2. DDL Triggers SQL Server supports DDL triggers, which can be used for purposes such as auditing, policy enforcement, and change management. SQL Server box product supports the creation of DDL triggers at two scopes, the database scope and the server scope, depending on the scope of the event. Azure SQL Database currently supports only database triggers. SQL Server supports only after DDL triggers; it doesn’t support instead of DDL triggers. Within the trigger, information about the event that caused the trigger to fire can be obtained by querying a function called EVENTDATA, which returns the event information as an XML instance. -- creates the dbo.AuditDDLEvents table to hold the audit information DROP TABLE IF EXISTS dbo.AuditDDLEvents; CREATE TABLE dbo.AuditDDLEvents ( audit_lsn INT NOT NULL IDENTITY, posttime DATETIME2(3) NOT NULL, eventtype sysname NOT NULL, loginname sysname NOT NULL, schemaname sysname NOT NULL, objectname sysname NOT NULL, targetobjectname sysname NULL, eventdata XML NOT NULL, CONSTRAINT PK_AuditDDLEvents PRIMARY KEY(audit_lsn) ); GO -- create the trg_audit_ddl_events audit trigger on the database by using the event group DDL_DATABASE_LEVEL_EVENTS CREATE OR ALTER TRIGGER trg_audit_ddl_events ON DATABASE FOR DDL_DATABASE_LEVEL_EVENTS AS SET NOCOUNT ON; DECLARE @eventdata AS XML = eventdata(); INSERT INTO dbo.AuditDDLEvents( posttime, eventtype, loginname, schemaname, objectname, targetobjectname, eventdata) VALUES( @eventdata.value(&#39;(/EVENT_INSTANCE/PostTime)[1]&#39;, &#39;VARCHAR(23)&#39;), -- XQuery expressions @eventdata.value(&#39;(/EVENT_INSTANCE/EventType)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/LoginName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/SchemaName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/ObjectName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/TargetObjectName)[1]&#39;, &#39;sysname&#39;), @eventdata); GO -- test the trigger CREATE TABLE dbo.T1(col1 INT NOT NULL PRIMARY KEY); ALTER TABLE dbo.T1 ADD col2 INT NULL; ALTER TABLE dbo.T1 ALTER COLUMN col2 INT NOT NULL; CREATE NONCLUSTERED INDEX idx1 ON dbo.T1(col2); GO SELECT * FROM dbo.AuditDDLEvents; GO -- cleanup DROP TRIGGER IF EXISTS trg_audit_ddl_events ON DATABASE; DROP TABLE IF EXISTS dbo.AuditDDLEvents, dbo.T1; 13.8. Error Handling: TRY-CATCH The TRY. . .CATCH construct in SQL Server handles errors by placing the usual T-SQL code in a TRY block and placing all the error-handling code in the adjacent CATCH block. If the TRY block has no error, the CATCH block is simply skipped. If the TRY block has an error, control is passed to the corresponding CATCH block. BEGIN TRY -- TRY block (between the BEGIN TRY and END TRY keywords) PRINT 10/0; PRINT &#39;No error&#39;; END TRY BEGIN CATCH -- CATCH block (between the BEGIN CATCH and END CATCH keywords) PRINT &#39; Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39; Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); END CATCH; SQL Server also provides a set of functions to get information about the error. The ERROR_NUMBER function returns an integer with the number of the error. The ERROR_MESSAGE function returns error-message text. To get the list of error numbers and messages, query the sys.messages catalog view. The ERROR_SEVERITY and ERROR_STATE functions return the error severity and state. The ERROR_LINE function returns the line number in the code where the error happened. The ERROR_PROCEDURE function returns the name of the procedure in which the error happened and returns NULL if the error did not happen within a procedure. -- create a table called dbo.Employees DROP TABLE IF EXISTS dbo.Employees; CREATE TABLE dbo.Employees ( empid INT NOT NULL, empname VARCHAR(25) NOT NULL, mgrid INT NULL, CONSTRAINT PK_Employees PRIMARY KEY(empid), CONSTRAINT CHK_Employees_empid CHECK(empid &gt; 0), CONSTRAINT FK_Employees_Employees FOREIGN KEY(mgrid) REFERENCES dbo.Employees(empid) ); BEGIN TRY INSERT INTO dbo.Employees(empid, empname, mgrid) VALUES(1, &#39;Emp1&#39;, NULL); -- Also try with empid = 0, &#39;A&#39;, NULL END TRY BEGIN CATCH IF ERROR_NUMBER() = 2627 BEGIN PRINT &#39; Handling PK violation...&#39;; END; ELSE IF ERROR_NUMBER() = 547 BEGIN PRINT &#39; Handling CHECK/FK constraint violation...&#39;; END; ELSE IF ERROR_NUMBER() = 515 BEGIN PRINT &#39; Handling NULL violation...&#39;; END; ELSE IF ERROR_NUMBER() = 245 BEGIN PRINT &#39; Handling conversion error...&#39;; END; ELSE BEGIN PRINT &#39;Re-throwing error...&#39;; THROW; -- re-throws the error END; PRINT &#39; Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39; Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39; Error Severity: &#39; + CAST(ERROR_SEVERITY() AS VARCHAR(10)); PRINT &#39; Error State : &#39; + CAST(ERROR_STATE() AS VARCHAR(10)); PRINT &#39; Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); PRINT &#39; Error Proc : &#39; + COALESCE(ERROR_PROCEDURE(), &#39;Not within a procedure&#39;); END CATCH; -- a stored procedure that encapsulates reusable error-handling code CREATE OR ALTER PROC dbo.ErrInsertHandler AS SET NOCOUNT ON; IF ERROR_NUMBER() = 2627 BEGIN PRINT &#39;Handling PK violation...&#39;; END; ELSE IF ERROR_NUMBER() = 547 BEGIN PRINT &#39;Handling CHECK/FK constraint violation...&#39;; END; ELSE IF ERROR_NUMBER() = 515 BEGIN PRINT &#39;Handling NULL violation...&#39;; END; ELSE IF ERROR_NUMBER() = 245 BEGIN PRINT &#39;Handling conversion error...&#39;; END; PRINT &#39;Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39;Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39;Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39;Error Severity: &#39; + CAST(ERROR_SEVERITY() AS VARCHAR(10)); PRINT &#39;Error State : &#39; + CAST(ERROR_STATE() AS VARCHAR(10)); PRINT &#39;Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); PRINT &#39;Error Proc : &#39; + COALESCE(ERROR_PROCEDURE(), &#39;Not within a procedure&#39;); GO BEGIN TRY INSERT INTO dbo.Employees(empid, empname, mgrid) VALUES(1, &#39;Emp1&#39;, NULL); END TRY BEGIN CATCH IF ERROR_NUMBER() IN (2627, 547, 515, 245) EXEC dbo.ErrInsertHandler; ELSE THROW; END CATCH; GO -- clean up DROP TABLE IF EXISTS dbo.Employees; DROP PROC IF EXISTS dbo.ErrInsertHandler; 14. JSON JSON is a widely-used text format for data exchange in modern applications and for storing unstructured data. SQL Server 2016 and later versions provide built-in functions that integrate JSON with relational data, enabling the storage and querying of JSON documents within the database and the formatting of relational query results as JSON text. A native JSON data type, available in Azure SQL and in preview for SQL Server 2025, stores JSON in an optimized binary format, which provides more efficient reads, writes, and storage compared to traditional string types, while maintaining compatibility with existing query functions. 14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY ISJSON() checks if a string contains valid JSON. JSON_VALUE() extracts a single scalar value (like a string or number). JSON_QUERY() extracts a JSON object or an array. JSON_MODIFY() updates a property within a JSON string and returns the new string. These functions use a JavaScript-like path syntax to reference nested elements, and the extracted values can be used in any part of a T-SQL query, such as WHERE or ORDER BY clauses. The path expressions for JSON_VALUE, JSON_QUERY, and JSON_MODIFY can be prefixed with lax (the default) or strict. lax mode returns NULL (or an empty result for JSON_QUERY) if the path is not found, whereas strict mode will raise an error. If the input JSON expression is NULL, all JSON functions will return NULL. However, if the input is not NULL but is an invalid JSON text, the functions will raise an error. It is a best practice to use ISJSON() to validate the input before applying other JSON functions. -- Declare a variable to hold JSON data DECLARE @person NVARCHAR(MAX) = &#39;{ &quot;name&quot;: &quot;Jane Doe&quot;, &quot;status&quot;: &quot;Active&quot;, &quot;location&quot;: { &quot;city&quot;: &quot;Belgrade&quot;, &quot;country&quot;: &quot;Serbia&quot; }, &quot;skills&quot;: [ &quot;T-SQL&quot;, &quot;Power BI&quot; ] }&#39;; -- Check if the JSON is valid before querying IF ISJSON(@person) &gt; 0 BEGIN -- Extract values and use them in a SELECT statement -- This uses the default &#39;lax&#39; mode. A non-existent path would return NULL. SELECT JSON_VALUE(@person, &#39;$.name&#39;) AS Name, JSON_VALUE(@person, &#39;$.location.city&#39;) AS City, JSON_QUERY(@person, &#39;$.skills&#39;) AS Skills, JSON_VALUE(@person, &#39;$.info.age&#39;) AS Age; -- This path doesn&#39;t exist, will return NULL -- Using &#39;strict&#39; mode will cause an error if the path is not found. -- SELECT JSON_VALUE(@person, &#39;strict $.info.age&#39;); -- This would raise an error. -- Modify the city from &quot;Belgrade&quot; to &quot;London&quot; SET @person = JSON_MODIFY(@person, &#39;$.location.city&#39;, &#39;London&#39;); -- Display the updated JSON SELECT @person AS UpdatedPersonJSON; END The ISJSON function returns 1 for valid JSON, 0 for invalid, and NULL for a NULL input, and the conditions ISJSON(col) &gt; 0 and ISJSON(col) = 1 are functionally identical for validation and result in the same execution plan. 14.2. OPENJSON The OPENJSON rowset function transforms JSON text into a structured rowset to enable standard T-SQL querying, requiring database compatibility level 130 or higher. By default, the function returns first-level key/value pairs from a JSON object or all elements with their indexes from a JSON array. It operates in two primary modes: Default Schema (without a WITH clause) returns a key-value table with key, value, and type columns, which is useful for inspecting a document&#8217;s structure. DECLARE @json NVARCHAR(MAX) = &#39;{ &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 45, &quot;isStudent&quot;: false, &quot;skills&quot;: [ &quot;SQL&quot;, &quot;C#&quot; ] }&#39;; -- Use the default schema to return a key-value table SELECT * FROM OPENJSON(@json); Result Set key value type --- name John Doe 1 age 45 2 isStudent false 0 skills [&quot;SQL&quot;,&quot;C#&quot;] 4 Explicit Schema (with a WITH clause) shreds a JSON array into a relational format by mapping user-defined columns, data types, and JSON paths in an explicit schema definition. DECLARE @json NVARCHAR(MAX) = N&#39;[ { &quot;OrderNumber&quot;: &quot;SO43659&quot;, &quot;OrderDate&quot;: &quot;2024-05-31&quot;, &quot;Customer&quot;: &quot;AW29825&quot;, &quot;Quantity&quot;: 1 }, { &quot;OrderNumber&quot;: &quot;SO43661&quot;, &quot;OrderDate&quot;: &quot;2024-06-01&quot;, &quot;Customer&quot;: &quot;AW73565&quot;, &quot;Quantity&quot;: 3 } ]&#39;; -- Use an explicit schema to define the output table structure SELECT * FROM OPENJSON(@json) WITH ( Number VARCHAR(200) &#39;$.OrderNumber&#39;, [Date] DATETIME &#39;$.OrderDate&#39;, CustomerAcct VARCHAR(200) &#39;$.Customer&#39;, Qty INT &#39;$.Quantity&#39; ); Result Set Number Date CustomerAcct Qty --- SO43659 2024-05-31 00:00:00.000 AW29825 1 SO43661 2024-06-01 00:00:00.000 AW73565 3 JSON documents might have sub-elements and hierarchical data that can&#8217;t be directly mapped into the standard relational columns. To flatten hierarchical JSON, a primary OPENJSON call extracts a nested array as a JSON text fragment using the AS JSON option, which is then unnested by a second OPENJSON call via an APPLY operator. DECLARE @json NVARCHAR(MAX) = N&#39;[ {&quot;id&quot;: 2, &quot;info&quot;: {&quot;name&quot;: &quot;John&quot;, &quot;surname&quot;: &quot;Smith&quot;}, &quot;age&quot;: 25}, {&quot;id&quot;: 5, &quot;info&quot;: {&quot;name&quot;: &quot;Jane&quot;, &quot;surname&quot;: &quot;Smith&quot;, &quot;skills&quot;: [&quot;SQL&quot;, &quot;C#&quot;, &quot;Azure&quot;]}, &quot;dob&quot;: &quot;2005-11-04T12:00:00&quot;} ]&#39;; SELECT id, firstName, lastName, age, dateOfBirth, skill FROM OPENJSON(@json) WITH ( id INT &#39;strict $.id&#39;, firstName NVARCHAR(50) &#39;$.info.name&#39;, lastName NVARCHAR(50) &#39;$.info.surname&#39;, age INT, dateOfBirth DATETIME2 &#39;$.dob&#39;, skills NVARCHAR(MAX) &#39;$.info.skills&#39; AS JSON ) OUTER APPLY OPENJSON(skills) WITH (skill NVARCHAR(8) &#39;$&#39;); Result Set id firstName lastName age dateOfBirth skill --- 2 John Smith 25 NULL NULL 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 SQL 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 C# 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 Azure 14.3. FOR JSON The FOR JSON clause in a SELECT statement formats query results into JSON text, delegating the formatting task from the client application to the database. It operates in two primary modes: FOR JSON AUTO automatically creates a nested JSON structure based on the tables used in the SELECT statement and their join relationships. FOR JSON PATH provides explicit control over the output format, allowing for the creation of custom nested objects and arrays using dot notation (i.e., &#39;Order.Details.ProductID&#39;) in column aliases. Further customization is available through options like ROOT to add a top-level element, INCLUDE_NULL_VALUES to retain properties with null values, and WITHOUT_ARRAY_WRAPPER to remove the default surrounding array brackets, which is useful for generating a single JSON object from a single-row result. Example SELECT TOP 2 SalesOrderID AS &#39;Order.ID&#39;, OrderDate AS &#39;Order.Date&#39;, AccountNumber AS &#39;Customer.Account&#39; FROM Sales.SalesOrderHeader FOR JSON PATH, ROOT(&#39;Orders&#39;); Result Set { &quot;Orders&quot;: [ { &quot;Order&quot;: { &quot;ID&quot;: 43659, &quot;Date&quot;: &quot;2011-05-31T00:00:00&quot;, &quot;Customer&quot;: { &quot;Account&quot;: &quot;10-4020-000676&quot; } } }, { &quot;Order&quot;: { &quot;ID&quot;: 43660, &quot;Date&quot;: &quot;2011-05-31T00:00:00&quot;, &quot;Customer&quot;: { &quot;Account&quot;: &quot;10-4020-000117&quot; } } } ] } 15. Vectors and embeddings The SQL Database Engine supports storing and querying structured and unstructured data, including performing vector search, which is beneficial for unified data search without external services. Vectors are ordered arrays of numbers (typically floats) representing data (e.g., pixel values, text ASCII values). Vectorization is the process of converting data into vectors, which are efficiently stored using the SQL Server VECTOR data type. Vector features are available in SQL Server 2025 (17.x) Preview, Azure SQL Database, and Azure SQL Managed Instance (configured with the Always-up-to-date update policy). 15.1. Embeddings Embeddings are a specialized type of vector that capture important features of data, often generated by deep learning models, with the ability of representing semantic similarity between various data entities, such as words or images. Azure OpenAI provides models for creating text embeddings, which can be stored in SQL Server alongside their data to enable vector search for similar data points. Storing generated embeddings in a SQL Server database allows for co-location with the represented data and facilitates vector search queries to find similar data points. 15.2. Vector search Vector search refers to the process of finding vectors in a dataset that are similar to a specific query vector. Similarity is measured using distance metrics like cosine distance; closer vectors indicate higher similarity. SQL Server provides built-in support for vectors via the VECTOR data type, storing data in an optimized binary format yet is exposed as JSON arrays for convenience. Vectors, typically managed as arrays of floats, can be created by casting JSON arrays to the VECTOR data type. For example: SELECT CAST(&#39;[1.0, -0.2, 30]&#39; AS VECTOR(3)) AS v1, CAST(JSON_ARRAY(1.0, -0.2, 30) AS VECTOR(3)) AS v2; DECLARE @v1 VECTOR(3) = &#39;[1.0, -0.2, 30]&#39;; DECLARE @v2 VECTOR(3) = JSON_ARRAY(1.0, -0.2, 30); SELECT @v1 as v1, @v2 as v2; DECLARE @v VECTOR(3) = &#39;[1.0, -0.2, 30]&#39;; SELECT CAST(@v AS NVARCHAR(MAX)) AS s, CAST(@v AS JSON) AS j 15.2.1. Exact nearest neighbor (k-NN) search and vector distance Exact search, also known as k-nearest neighbor (k-NN) search, involves calculating the distance between a given vector and all other vectors in a dataset, sorting the results, and selecting the closest neighbors based on a specified distance metric. k-nearest neighbor (k-NN) search guarantees precise nearest neighbor retrieval by performing an exhaustive distance calculation across all indexed vectors, making it computationally intensive but suitable for smaller datasets or when accuracy is paramount. Vector distance functions, such as Euclidean distance, cosine similarity, and dot product, measure vector closeness and are essential for accurate k-NN searches. In the SQL Database Engine, k-NN searches utilize the VECTOR_DISTANCE function for efficient distance calculation and nearest neighbor retrieval. The terms &quot;exact search,&quot; &quot;k-nearest neighbor (k-NN) search,&quot; and &quot;exact nearest neighbor (ENN) vector search&quot; are used interchangeably to refer to this precise, exhaustive search method. The following example shows how to do k-NN to return the top 10 most similar vectors stored in the content_vector table to the given query vector @qv. DECLARE @qv VECTOR(1536) = AI_GENERATE_EMBEDDINGS(N&#39;Pink Floyd music style&#39; USE MODEL Ada2Embeddings); SELECT TOP (10) id, VECTOR_DISTANCE(&#39;cosine&#39;, @qv, [content_vector]) AS distance, title FROM [dbo].[wikipedia_articles_embeddings] ORDER BY distance Exact search is recommended for datasets with fewer than 50,000 vectors. Larger tables can use exact search if search predicates effectively reduce the number of vectors for neighbor search to 50,000 or fewer. 15.2.2. Approximate nearest neighbors (ANN) and vector index Approximate vector index and vector search are in preview and currently only available in SQL Server 2025 (17.x) Preview. Approximate Nearest Neighbors (ANN) offers a high-performance alternative to the slow and resource-intensive exact k-nearest neighbors (k-NN) search. While k-NN requires comparing a query vector against every vector in a database, ANN trades a small degree of accuracy (recall) for a massive gain in search speed, making it a practical solution for large-scale vector search. Recall is a metric that measures the proportion of relevant items successfully retrieved out of all truly relevant items. In vector search, recall specifically quantifies how many of the exact nearest neighbors found by an exhaustive search are successfully identified by an Approximate Nearest Neighbors (ANN) algorithm. It serves as a crucial measure of the approximation&#8217;s quality, with a perfect recall of 1 indicating that the ANN algorithm found all the exact nearest neighbors. For AI applications, the inherent approximation of vector embeddings makes ANN a highly advantageous trade-off over exact k-NN, offering significant performance and resource benefits well-suited for operational databases. A vector index is a data structure optimized for efficiently finding approximate nearest neighbors in high-dimensional vector spaces, thereby returning approximate results for ANN searches, unlike traditional relational database indexes (e.g., B-trees, LSM-trees) designed for exact lookups and range queries on scalar values. In the SQL Database engine, vector indexes are based on the DiskANN algorithm. DiskANN is a graph-based system that indexes and searches large vector datasets by creating a navigable graph to quickly find the closest match to a given vector. DiskANN efficiently uses SSDs and minimal memory to handle significantly more data than in-memory indices, while maintaining high queries per second (QPS) and low latency, ensuring a balance between memory, CPU and I/O usage and search performance. An approximate nearest neighbors algorithm search can be done first creating a vector index using the CREATE VECTOR INDEX T-SQL command and then using VECTOR_SEARCH T-SQL function to run the approximate search. DECLARE @qv VECTOR(1536) = AI_GENERATE_EMBEDDINGS(N&#39;Pink Floyd music style&#39; USE MODEL Ada2Embeddings); SELECT t.id, s.distance, t.title FROM VECTOR_SEARCH( TABLE = [dbo].[wikipedia_articles_embeddings] AS t, COLUMN = [content_vector], SIMILAR_TO = @qv, METRIC = &#39;cosine&#39;, TOP_N = 10 ) AS s ORDER BY s.distance Appendix A: Data Types A data type is an attribute that specifies the type of data that the object can hold: integer data, character data, monetary data, date and time data, binary strings, and so on. [3] Data types can be converted either implicitly or explicitly. Implicit conversions are not visible to the user. SQL Server automatically converts the data from one data type to another. Explicit conversions use the CAST or CONVERT functions. Use CAST instead of CONVERT to write Transact-SQL program code to comply with ISO. Use CONVERT instead of CAST to take advantage of the style functionality in CONVERT. CAST ( expression AS data_type [ ( length ) ] ) CONVERT ( data_type [ ( length ) ] , expression [ , style ] ) SELECT CAST(123 AS VARCHAR(10)), CONVERT(VARCHAR(10), 123) -- same result: integer to string SELECT CONVERT(VARCHAR(10), GETDATE(), 101) -- date to string in MM/dd/yyyy format A.1. Character SQL Server supports two kinds of character data type pairs: regular kind (CHAR and VARCHAR) and N-kind (NCHAR and NVARCHAR). Each of the type pairs can support different character encoding systems, and can result in different encoded byte lengths and on-disk storage sizes, based on the effective collation of the data and the character code range in use. The regular types, with UTF-8 collation, use the UTF-8 encoding system and support full range of Unicode characters. The N-kind types, with supplementary character collation (SC), use the UTF-16 encoding system and support the full range of Unicode characters. Otherwise, they support only the subset of characters from the UCS-2 character encoding system. The VARCHAR(size) defines the maximum size in bytes, while the NVARCHAR(size) defines the size in byte pairs. The literals of regular type character are enclosed in single quotes, while N-kind type require a preceding &#39;N&#39;. Any data type without the VAR element (CHAR, NCHAR) in its name has a fixed length, that is, SQL Server preserves the maximum space in the row based on the column’s defined size and not on the actual user data that is stored. A data type with the VAR element (VARCHAR, NVARCHAR) in its name has a variable length, that is, SQL Server uses as much storage space in the row as required to store the actual character string, plus two extra bytes for offset data. Updates of variable-length data types can be less efficient than those of fixed-length types due to potential row expansion and data movement. Variable-length data types can use the MAX specifier, allowing for up to 2GB per value. Any value with a size up to a certain threshold (8,000 bytes by default) can be stored inline in the row. Any value with a size above the threshold is stored external to the row as a large object (LOB). The collation is a property of character data that encapsulates several aspects: language support, sort order, case sensitivity, accent sensitivity, and more. -- get the set of supported collations and their descriptions SELECT name, description FROM sys.fn_helpcollations(); In an on-premises SQL Server implementation and Azure SQL Managed Instance, collation can be defined at four different levels: instance, database, column, and expression. The lowest level is the effective one that is used. SELECT DATABASEPROPERTYEX(DB_NAME(), &#39;Collation&#39;); -- SQL_Latin1_General_CP1_CI_AS In Azure SQL Database, collation can be defined at the database, column, and expression levels. T-SQL provides the plus-sign (+) operator and the CONCAT and CONCAT_WS functions to concatenate strings. SELECT empid, firstname + N&#39; &#39; + lastname AS fullname FROM HR.Employees; Standard SQL dictates that a concatenation with a NULL should yield a NULL. SELECT custid, country, region, city, country + N&#39;,&#39; + region + N&#39;,&#39; + city AS location FROM Sales.Customers; custid country region city location 9 France NULL Marseille NULL 10 Canada BC Tsawassen Canada,BC,Tsawassen To treat a NULL as an empty string—or more accurately, to substitute a NULL with an empty string—use the COALESCE function that accepts a list of input values and returns the first that is not NULL. SELECT custid, country, region, city, country + COALESCE(N&#39;,&#39; + region, N&#39;&#39;) + N&#39;,&#39; + city AS location FROM Sales.Customers; custid country region city location 8 Spain NULL Madrid Spain,Madrid 9 France NULL Marseille France,Marseille T-SQL supports a function called CONCAT, which accepts a list of inputs for concatenation and automatically substitutes NULLs with empty strings. SELECT custid, country, region, city, CONCAT(country, N&#39;,&#39; + region, N&#39;,&#39; + city) AS location FROM Sales.Customers; T-SQL also supports a function called CONCAT_WS, which accepts the separator as the first parameter, specifying it only once, and then the list of inputs for concatenation. SELECT custid, country, region, city, CONCAT_WS(N&#39;,&#39;, country, region, city) AS location FROM Sales.Customers; The PATINDEX function returns the position of the first occurrence of a pattern, similar to the patterns used by the LIKE predicate in T-SQL, within a string. PATINDEX(pattern, string) SELECT PATINDEX(&#39;%[0-9]%&#39;, &#39;abcd123efgh&#39;); -- 5 T-SQL provides a predicate called LIKE to check whether a character string matches a specified pattern. The % (percent sign) wildcard represents a string of any size, including an empty string. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;D%&#39;; empid lastname 1 Davis 9 Doyle The _ (underscore) wildcard represents a single character. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;_e%&#39;; empid lastname 3 Lew 4 Peled The square bracket wildcard [&lt;list of characters&gt;], with a list of characters (such as [ABC]), represents a single character that must be one of the characters specified in the list. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[ABC]%&#39;; empid lastname 8 Cameron The square bracket wildcard [&lt;character&gt;-&lt;character&gt;], with a character range (such as [A–E]), represents a single character that must be within the specified range. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[A-E]%&#39;; empid lastname 8 Cameron 1 Davis 9 Doyle The square bracket wildcard [^&lt;character list or range&gt;], with a caret sign (^) followed by a character list or range (such as [^A–E]), represents a single character that is not in the specified character list or range. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[^A-E]%&#39;; empid lastname 2 Funk 7 King To search for a character that is also a wildcard, use an escape character before it in the LIKE pattern, and specify the escape character using the ESCAPE keyword. A character put in front of a wildcard character to indicate that the wildcard is interpreted as a regular character and not as a wildcard. escape_character is a character expression that has no default and must evaluate to only one character. -- specify character (!, @, $, or #) as the escape character col1 LIKE &#39;%!_%&#39; ESCAPE &#39;!&#39; col1 LIKE &#39;%@_%&#39; ESCAPE &#39;@&#39; col1 LIKE &#39;%$%_&#39; ESCAPE &#39;$&#39; col1 LIKE &#39;%#%_&#39; ESCAPE &#39;#&#39; A.2. Date and Time T-SQL supports six date and time data types: The legacy types DATETIME and SMALLDATETIME include date and time components that are inseparable. DATETIME &#39;YYYYMMDD hh:mm:ss.nnn&#39; &#39;20220212 12:30:15.123&#39; DATETIME &#39;YYYYMMDD&#39; &#39;20220212&#39; SMALLDATETIME &#39;YYYYMMDD hh:mm&#39; &#39;20220212 12:30&#39; SMALLDATETIME &#39;YYYYMMDD&#39; &#39;20220212&#39; The DATE and TIME data types provide a separation between the date and time components. DATE &#39;YYYYMMDD&#39; &#39;20220212&#39; TIME &#39;hh:mm:ss.nnnnnnn&#39; &#39;12:30:15.1234567&#39; The DATETIME2 data type has a bigger date range and better precision than the legacy types. DATETIME2 &#39;YYYYMMDD hh:mm:ss.nnnnnnn&#39; &#39;20220212 12:30:15.1234567&#39; The DATETIMEOFFSET data type is similar to DATETIME2, but it also includes the offset from UTC. DATETIMEOFFSET &#39;YYYYMMDD hh:mm:ss.nnnnnnn [+|-]hh:mm&#39; &#39;20220212 12:30:15.1234567 +02:00&#39; SELECT GETDATE() UNION ALL -- DATETIME current date and time SELECT CURRENT_TIMESTAMP UNION ALL -- DATETIME same as GETDATE but SQL-compliant SELECT GETUTCDATE() UNION ALL -- DATETIME current date and time in UTC SELECT SYSDATETIME() UNION ALL -- DATETIME2 current date and time SELECT SYSUTCDATETIME() UNION ALL -- DATETIME2 current date and time in UTC SELECT SYSDATETIMEOFFSET() -- DATETIME2 current date and time in UTC with Time Zone 2025-01-18 15:07:52.9766667 +00:00 2025-01-18 15:07:52.9766667 +00:00 2025-01-18 07:07:52.9766667 +00:00 2025-01-18 15:07:52.9755919 +00:00 2025-01-18 07:07:52.9755919 +00:00 2025-01-18 15:07:52.9755919 +08:00 T-SQL doesn’t provide the means to express a date and time literal; instead, a convertible literal of a different type can be specified—explicitly or implicitly—to a date and time data type. It is a best practice to use character strings with language-neutral formats to express date and time values. SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderdate = &#39;20220212&#39;; -- equivalent to: WHERE orderdate = CAST(&#39;20220212&#39; AS DATE); Each login has a default language, which affects how date and time literals are interpreted. SET LANGUAGE British; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-12-02 SET LANGUAGE us_english; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-02-12 The DATEFORMAT setting, expressed as a combination of the characters d, m, and y, determines how SQL Server interprets date and time literals from character strings (e.g., &#39;mdy&#39; for US English, &#39;dmy&#39; for British English). SET DATEFORMAT dmy; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-12-02 SET DATEFORMAT mdy; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-02-12 The LANGUAGE/DATEFORMAT setting affects only the way the values inputed are interpreted, and have no impact on the format used in the output for presentation purposes. SQL Server may not efficiently utilize indexes when functions like YEAR are applied to the column within the WHERE clause. SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE YEAR(orderdate) = 2021; -- better SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20210101&#39; AND orderdate &lt; &#39;20220101&#39;; References [1] Itzik Ben-Gan T-SQL Fundamentals. 3rd edition, Microsoft Press; August 3, 2016 [2] Itzik Ben-Gan, Adam Machanic, Dejan Sarka, Kevin Farlee T-SQL Querying. 1st Edition Microsoft Press; March 6, 2015 [3] https://learn.microsoft.com/en-us/sql/t-sql/language-reference" />
<meta property="og:description" content="SQL (pronounced /ˌɛsˌkjuˈɛl/ S-Q-L; or alternatively as /ˈsiːkwəl/ &quot;sequel&quot;) stands for Structured Query Language, which is both an ANSI and ISO standard language that was designed to query and manage data in relational database management systems (RDBMSs). An RDBMS is a database management system based on the relational model (a semantic model for representing data), which in turn is based on two mathematical branches: set theory and predicate logic. &quot;NULL marker&quot; or just &quot;NULL&quot; (/nʌl/) is not a NULL value but rather a marker for a missing value. SQL comprises several sub-languages for managing different aspects of a database: Data Definition Language (DDL) defines and manages the structure of database objects with statements such as CREATE, ALTER, and DROP. Data Manipulation Language (DML) retrieves and modifies data using statements like SELECT, INSERT, UPDATE, DELETE, and MERGE. Data Control Language (DCL) manages data access and user permissions through statements such as GRANT and REVOKE. Transaction Control Language (TCL) controls the lifecycle of transactions with statements like COMMIT and ROLLBACK. Microsoft provides T-SQL as a dialect of, or an extension to, SQL in SQL Server—its on-premises RDBMS flavor, and in Azure SQL and Azure Synapse Analytics—its cloud-based RDBMS flavors. T-SQL is based on standard SQL, but it also provides some nonstandard or proprietary extensions. Moreover, T-SQL does not implement all of standard SQL. To run T-SQL code against a database, a client application needs to connect to a SQL Server instance and be in the context of, or use, the relevant database. In both SQL Server and Azure SQL Managed Instance, the application can still access objects from other databases by adding the database name as a prefix. Azure SQL Database does not support cross-database/three-part name queries. SQL Server supports a feature called contained databases that breaks the connection between a database user and an instance-level login. The user (Windows or SQL authenticated) is fully contained within the specific database and is not tied to a login at the instance level. When connecting to SQL Server, the user needs to specify the database to connect, and the user cannot subsequently switch to other user databases. Unless specified otherwise, all T-SQL references to the name of a database object can be a four-part name in the following form: -- Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views server_name.[database_name].[schema_name].object_name | database_name.[schema_name].object_name | schema_name.object_name | object_name 1. Data Integrity 1.1. PRIMARY KEY 1.2. UNIQUE 1.3. FOREIGN KEY 1.4. CHECK 1.5. DEFAULT 2. Logical Query Processing 2.1. FROM 2.2. WHERE 2.3. GROUP BY 2.4. HAVING 2.5. SELECT 2.6. ORDER BY 2.7. TOP 2.8. OFFSET-FETCH 2.9. CASE 3. Predicates and Operators 3.1. Predicates: IN, BETWEEN, LIKE, EXISTS, and IS NULL 3.2. Three-Valued Logic (3VL) 3.3. Equality and Distinctness 3.4. Comparison Operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, and ALL, SOME, ANY 3.5. Logical Operators: OR, AND, and NOT 3.6. Arithmetic Operators: +, -, *, /, and % 4. Query Tuning 4.1. SQL Server Internals 4.1.1. Indexes 4.1.2. Execution Plans 4.1.3. Cardinality Estimates 4.1.4. Parallel Query Execution 4.2. Data Retrieval Strategies 4.2.1. Unordered Clustered Index Scan or Table Scan 4.2.2. Unordered Covering Nonclustered Index Scan 4.2.3. Ordered Clustered Index Scan 4.2.4. Ordered Covering Nonclustered Index Scan 4.2.5. Nonclustered Index Seek + Range Scan + Lookups 4.2.6. Unordered Nonclustered Index Scan + Lookups 4.2.7. Clustered Index Seek + Range Scan 4.2.8. Covering Nonclustered Index Seek + Range Scan 4.3. Tied Rows and Sorting 5. Joins 5.1. CROSS 5.2. INNER 5.3. OUTER 5.4. APPLY 6. Subqueries 6.1. Subqueries with IN or NOT IN 6.2. Subqueries with comparison operators 6.3. Subqueries with EXISTS or NOT EXISTS 7. Table Expressions 7.1. Derived Tables 7.2. CTEs 7.3. Views and TVFs 8. UNION, UNION ALL, INTERSECT, and EXCEPT 9. Data Analysis 9.1. Window Functions 9.1.1. Ranking 9.1.2. Offset 9.1.3. Aggregate 9.1.4. WINDOW 9.2. Pivoting 9.2.1. Grouped Query 9.2.2. PIVOT Operator 9.3. Unpivoting 9.3.1. APPLY Operator 9.3.2. UNPIVOT Operator 9.4. Grouping Sets 9.5. Time Series 10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE 10.1. INSERT 10.1.1. INSERT VALUES 10.1.2. INSERT SELECT 10.1.3. INSERT EXEC 10.1.4. SELECT INTO 10.1.5. BULK INSERT 10.2. DELETE and TRUNCATE 10.3. UPDATE 10.4. MERGE 11. System-Versioned Temporal Tables 12. Transactions and Concurrency 12.1. Locks and Blocking 12.1.1. Locks 12.1.1.1. Lock Modes and Compatibility 12.1.1.2. Lockable Resource Types 12.1.2. Blocking 12.2. Isolation Levels 12.2.1. READ UNCOMMITTED 12.2.2. READ COMMITTED 12.2.3. REPEATABLE READ 12.2.4. SERIALIZABLE 12.2.5. Multi-Version Concurrency Control 12.2.5.1. SNAPSHOT 12.2.5.2. Conflict Detection 12.2.5.3. READ COMMITTED SNAPSHOT 12.3. Deadlocks 13. Programmable Objects 13.1. Variables 13.2. Batchs 13.3. Flow Elements: IF and WHILE 13.4. Cursors 13.5. Temporary Tables 13.5.1. Local Temporary Tables 13.5.2. Global Temporary Tables 13.5.3. Table Variables 13.6. Dynamic SQL 13.7. Routines 13.7.1. User-defined Functions 13.7.2. Stored Procedures 13.7.3. Triggers 13.7.3.1. DML Triggers 13.7.3.2. DDL Triggers 13.8. Error Handling: TRY-CATCH 14. JSON 14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY 14.2. OPENJSON 14.3. FOR JSON 15. Vectors and embeddings 15.1. Embeddings 15.2. Vector search 15.2.1. Exact nearest neighbor (k-NN) search and vector distance 15.2.2. Approximate nearest neighbors (ANN) and vector index Appendix A: Data Types A.1. Character A.2. Date and Time References 1. Data Integrity SQL provides several mechanisms for enforcing data integrity: PRIMARY KEY constraint FOREIGN KEY constraint with actions like CASCADE, SET NULL, RESTRICT NOT NULL constraint CHECK constraint UNIQUE constraint DEFAULT constraint Triggers Stored procedures USE TSQLV6; DROP TABLE IF EXISTS dbo.Employees; CREATE TABLE dbo.Employees ( empid INT NOT NULL, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, hiredate DATE NOT NULL, mgrid INT NULL, ssn VARCHAR(20) NOT NULL, salary MONEY NOT NULL ); 1.1. PRIMARY KEY A primary key constraint enforces the uniqueness of rows and also disallows NULLs in the constraint attributes. Each unique combination of values in the constraint attributes can appear only once in the table—in other words, only in one row. An attempt to define a primary key constraint on a column that allows NULLs will be rejected by the RDBMS. Each table can have only one primary key. ALTER TABLE dbo.Employees ADD CONSTRAINT PK_Employees PRIMARY KEY (empid); To enforce the uniqueness of the logical primary key constraint, SQL Server will create a unique index behind the scenes. A unique index is a physical object used by SQL Server to enforce uniqueness. Indexes (not necessarily unique ones) are also used to speed up queries by avoiding sorting and unnecessary full table scans (similar to indexes in books). 1.2. UNIQUE A unique constraint enforces the uniqueness of rows, allowing to implement the concept of alternate keys from the relational model in a database. Unlike with primary keys, multiple unique constraints can be defined within the same table. Also, a unique constraint is not restricted to columns defined as NOT NULL. ALTER TABLE dbo.Employees ADD CONSTRAINT UNQ_Employees_ssn UNIQUE(ssn); For the purpose of enforcing a unique constraint, SQL Server handles NULLs just like non-NULL values. Consequently, for example, a single-column unique constraint allows only one NULL in the constrained column. However, the SQL standard defines NULL-handling by a unique constraint differently, like so: “A unique constraint on T is satisfied if and only if there do not exist two rows R1 and R2 of T such that R1 and R2 have the same non-NULL values in the unique columns.” In other words, only the non-NULL values are compared to determine whether duplicates exist. Consequently, a standard single-column unique constraint would allow multiple NULLs in the constrained column. 1.3. FOREIGN KEY A foreign key enforces referential integrity. It is defined on one or more attributes in what’s called the referencing table and points to candidate key (primary key or unique constraint) attributes in what’s called the referenced table. Note that the referencing and referenced tables can be one and the same. The foreign key’s purpose is to restrict the values allowed in the foreign key columns to those that exist in the referenced columns. DROP TABLE IF EXISTS dbo.Orders; CREATE TABLE dbo.Orders ( orderid INT NOT NULL, empid INT NOT NULL, custid VARCHAR(10) NOT NULL, orderts DATETIME2 NOT NULL, qty INT NOT NULL, CONSTRAINT PK_Orders PRIMARY KEY (orderid) ); -- enforce an integrity rule that restricts the values supported by the empid column in the Orders table to the values that exist in the empid column in the Employees table. ALTER TABLE dbo.Orders ADD CONSTRAINT FK_Orders_Employees FOREIGN KEY(empid) REFERENCES dbo.Employees(empid); -- restrict the values supported by the mgrid column in the Employees table to the values that exist in the empid column of the same table. ALTER TABLE dbo.Employees ADD CONSTRAINT FK_Employees_Employees FOREIGN KEY(mgrid) REFERENCES dbo.Employees(empid); Note that NULLs are allowed in the foreign key columns (mgrid in the last example) even if there are no NULLs in the referenced candidate key columns. 1.4. CHECK A check constraint is used to define a predicate that a row must meet to be entered into the table or to be modified. ALTER TABLE dbo.Employees ADD CONSTRAINT CHK_Employees_salary CHECK(salary &gt; 0.00); Note that a check constraint rejects an attempt to insert or update a row when the predicate evaluates to FALSE. The modification will be accepted when the predicate evaluates to either TRUE or UNKNOWN. 1.5. DEFAULT A default constraint is associated with a particular attribute. It’s an expression that is used as the default value when an explicit value is not specified for the attribute when inserting a row. ALTER TABLE dbo.Orders ADD CONSTRAINT DFT_Orders_orderts DEFAULT(SYSDATETIME()) FOR orderts; When done, run the following code for cleanup: DROP TABLE IF EXISTS dbo.Orders, dbo.Employees; 2. Logical Query Processing The logical query processing in standard SQL defines how a query should be processed and the final result achieved. Logical query-processing step numbers (5) SELECT (5-2) DISTINCT (7) TOP(&lt;top_specification&gt;) (5-1) &lt;select_list&gt; (1) FROM (1-J) &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; ON &lt;on_predicate&gt; | (1-A) &lt;left_table&gt; &lt;apply_type&gt; APPLY &lt;right_input_table&gt; AS &lt;alias&gt; | (1-P) &lt;left_table&gt; PIVOT(&lt;pivot_specification&gt;) AS &lt;alias&gt; | (1-U) &lt;left_table&gt; UNPIVOT(&lt;unpivot_specification&gt;) AS &lt;alias&gt; (2) WHERE &lt;where_predicate&gt; (3) GROUP BY &lt;group_by_specification&gt; (4) HAVING &lt;having_predicate&gt; (6) ORDER BY &lt;order_by_list&gt; (7) OFFSET &lt;offset_specification&gt; ROWS FETCH NEXT &lt;fetch_specification&gt; ROWS ONLY; The database engine is free to physically process a query differently by rearranging processing phases, as long as the final result would be the same as that dictated by logical query processing. The database engine’s query optimizer can—and in fact, often does—apply many transformation rules and shortcuts in the physical processing of a query as part of query optimization. USE TSQLV6; SELECT empid, YEAR (orderdate) AS orderyear, COUNT(*) AS numorder FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR (orderdate) HAVING COUNT(*) &gt; 1 ORDER BY empid, orderyear; If an identifier is irregular—for example, if it has embedded spaces or special characters, starts with a digit, or is a reserved keyword—it must be delimited. There are a couple of ways to delimit identifiers in T-SQL. One is the standard SQL form using double quotes—for example, &quot;Order Details&quot;. Another is the T-SQL- specific form using square brackets—for example, [Order Details]. In most programming languages, the lines of code are processed in the order that they are written. In SQL, things are different. Even though the SELECT clause appears first in the query, it is logically processed almost last. The clauses are logically processed in the following order: FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) HAVING COUNT(*) &gt; 1 SELECT empid, YEAR(orderdate) AS orderyear, COUNT(*) AS numorders ORDER BY empid, orderyear FROM &#8594; WHERE &#8594; GROUP BY &#8594; HAVING &#8594; SELECT &#8594; Expressions &#8594; DISTINCT &#8594; ORDER BY &#8594; TOP/OFFSET-FETCH 2.1. FROM The FROM clause is the very first query clause that is logically processed, which is used to specify the names of the tables to query and table operators that operate on those tables. FROM Sales.Orders 2.2. WHERE In the WHERE clause, a predicate, or logical expression is specified to filter the rows returned by the FROM phase. FROM Sales.Orders WHERE custid = 71 T-SQL uses three-valued predicate logic, where logical expressions can evaluate to TRUE, FALSE, or UNKNOWN. With three-valued logic, saying “returns TRUE” is not the same as saying “does not return FALSE.” The WHERE phase returns rows for which the logical expression evaluates to TRUE, and it doesn’t return rows for which the logical expression evaluates to FALSE or UNKNOWN. 2.3. GROUP BY The GROUP BY phase is used to arrange the rows returned by the previous logical query processing phase in groups determined by the elements, or expressions. FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) If the query is a grouped query, all phases subsequent to the GROUP BY phase— including HAVING, SELECT, and ORDER BY—operate on groups as opposed to operating on individual rows. Each group is ultimately represented by a single row in the final result of the query. All expressions specified in clauses that are processed in phases subsequent to the GROUP BY phase are required to guarantee returning a scalar (single value) per group. SELECT empid, YEAR(orderdate) AS orderyear, freight -- sum(freight) AS totalfreight FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate); Msg 8120, Level 16, State 1, Line 1 Column &#39;Sales.Orders.freight&#39; is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause. Total execution time: 00:00:00.016 Expressions based on elements that participate in the GROUP BY clause meet the requirement because, by definition, each such element represents a distinct value per group. Elements that do not participate in the GROUP BY clause are allowed only as inputs to an aggregate function such as COUNT, SUM, AVG, MIN, or MAX. Note that all aggregate functions that are applied to an input expression ignore NULLs. The COUNT(*) function isn’t applied to any input expression; it just counts rows irrespective of what those rows contain. For example, consider a group of five rows with the values 30, 10, NULL, 10, 10 in a column called qty. The expression COUNT(*) returns 5 because there are five rows in the group, whereas COUNT(qty) returns 4 because there are four known (non-NULL) values. To handle only distinct (unique) occurrences of known values, specify the DISTINCT keyword before the input expression to the aggregate function, like COUNT(DISTINCT qty), AVG(DISTINCT qty) and so on. 2.4. HAVING Whereas the WHERE clause is a row filter, the HAVING clause is a group filter. Only groups for which the HAVING predicate evaluates to TRUE are returned by the HAVING phase to the next logical query processing phase. Groups for which the predicate evaluates to FALSE or UNKNOWN are discarded. The HAVING clause is processed after the rows have been grouped, so aggregate functions can be referred to in the HAVING filter predicate. SELECT empid, YEAR(orderdate) AS orderyear, SUM(freight) AS totalfreight FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) -- filters only groups (employee and order year) with more than one row, and total freight with more than 500.0 HAVING COUNT(*) &gt; 1 AND SUM(freight) &gt; 500.0 ORDER BY empid, YEAR(orderdate) 1 2021 711.13 2 2022 672.16 4 2022 651.83 6 2021 628.31 7 2022 1231.56 2.5. SELECT The SELECT clause is where to specify the attributes (columns) to return in the result table of the query. SELECT empid, YEAR(orderdate) AS orderyear, COUNT(*) AS numorders FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) HAVING COUNT(*) &gt; 1 The SELECT clause is processed after the FROM, WHERE, GROUP BY, and HAVING clauses, which means that aliases assigned to expressions in the SELECT clause do not exist as far as clauses that are processed before the SELECT clause are concerned. It’s a typical mistake to try and refer to expression aliases in clauses that are processed before the SELECT clause, such as in the following example in which the attempt is made in the WHERE clause: SELECT orderid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE orderyear &gt; 2021; Msg 207, Level 16, State 1, Line 3 Invalid column name &#39;orderyear&#39;. One way around this problem is to repeat the expression YEAR(orderdate) in both the WHERE and SELECT clauses: SELECT orderid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE YEAR(orderdate) &gt; 2021; In addition to supporting the AS clause, T-SQL supports the form &lt;expression&gt; AS &lt;alias&gt;, and also supports the forms &lt;alias&gt; = &lt;expression&gt; (“alias equals expression”) and &lt;expression&gt; &lt;alias&gt; (“expression space alias”). In relational theory, a relational expression is applied to one or more input relations using operators from relational algebra, and returns a relation as output, that is, a relation in SQL is a table, and a relational expression in SQL is a table expression. Recall that a relation’s body is a set of tuples, and a set has no duplicates. Unlike relational theory, which is based on mathematical set theory, SQL is based on multiset theory. The mathematical term multiset, or bag, is similar in some aspects to a set, but it does allow duplicates. A table in SQL isn’t required to have a key. Without a key, the table can have duplicate rows and therefore isn’t relational. Even if the table does have a key, a SELECT query against the table can still return duplicate rows. SQL query results do not have keys. SQL provides the means to remove duplicates using the DISTINCT clause to return a relational result. SELECT DISTINCT empid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE custid = 71; 2.6. ORDER BY In terms of logical query processing, ORDER BY comes after SELECT. With T-SQL, elements can also be specified in the ORDER BY clause that do not appear in the SELECT clause, meaning to sort by something that don’t necessarily want to be returned. SELECT empid, firstname, lastname, country FROM HR.Employees ORDER BY hiredate; SELECT empid, firstname, lastname, country FROM HR.Employees ORDER BY CASE country WHEN &#39;USA&#39; THEN 1 WHEN &#39;CHN&#39; THEN 2 WHEN &#39;JPN&#39; THEN 3 WHEN &#39;DEU&#39; THEN 4 WHEN &#39;CAN&#39; THEN 5 WHEN &#39;KOR&#39; THEN 6 ELSE 7 END, empid; -- tie-breaker However, when the DISTINCT clause is specified, the ORDER BY are restricted to list only elements that appear in the SELECT list. SELECT DISTINCT empid, firstname, lastname, country FROM HR.Employees ORDER BY hiredate; Msg 145, Level 15, State 1, Line 1 ORDER BY items must appear in the select list if SELECT DISTINCT is specified. ASC is the default sort order. NULL values are treated as the lowest possible values. One of the most important points to understand about SQL is that a table—be it an existing table in the database or a table result returned by a query—has no guaranteed order. That’s because a table is supposed to represent a set of rows (or multiset, if it has duplicates), and a set has no order. It means that when querying a table without specifying an ORDER BY clause, SQL Server is free to return the rows in the output in any order. The only way to guarantee the presentation order in the result is with an ORDER BY clause. However, realizing that if specifying an ORDER BY clause, the result can’t qualify as a table, because it is ordered. Standard SQL calls such a result a cursor. 2.7. TOP The TOP filter is a proprietary T-SQL feature that can be used to limit the number or percentage of rows queried returns. It relies on two elements as part of its specification: one is the number or percent of rows to return, and the other is the ordering. SELECT TOP (5) orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; Note that the TOP filter is handled after DISTINCT. The TOP can use option with the PERCENT keyword, in which case SQL Server calculates the number of rows to return based on a percentage of the number of qualifying rows, rounded up. SELECT TOP (1) PERCENT orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; The query returns nine rows because the Orders table has 830 rows, and 1 percent of 830, rounded up, is 9. 11074 2022-05-06 73 7 11075 2022-05-06 68 8 11076 2022-05-06 9 4 11077 2022-05-06 65 1 11070 2022-05-05 44 2 11071 2022-05-05 46 1 11072 2022-05-05 20 4 11073 2022-05-05 58 2 11067 2022-05-04 17 1 In the above query, notice that the ORDER BY list is not unique (because no primary key or unique constraint is defined on the orderdate column). In other words, the ordering is not strict total ordering. Multiple rows can have the same order date. In such a case, the ordering among rows with the same order date is undefined, which makes the query nondeterministic—more than one result can be considered correct. In case of ties, SQL Server filters rows based on optimization choices and physical access order. Note that when using the TOP filter in a query without an ORDER BY clause, the ordering is completely undefined—SQL Server returns whichever n rows it happens to physically access first, where n is the requested number of rows. To make the query be deterministic, a strict total ordering is needed; in other words, add a tie-breaker. SELECT TOP (5) orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC, orderid DESC; -- the row with the greater order ID value will be preferred. 11077 2022-05-06 65 1 11076 2022-05-06 9 4 11075 2022-05-06 68 8 11074 2022-05-06 73 7 11073 2022-05-05 58 2 Instead of adding a tie-breaker to the ORDER BY list, a request can be made to return all ties by adding the WITH TIES option. SELECT TOP (5) WITH TIES orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; SQL Server first returned the TOP (5) rows based on orderdate DESC ordering, and it also returned all other rows from the table that had the same orderdate value as in the last of the five rows that were accessed. Using the WITH TIES option, the selection of rows is deterministic, but the presentation order among rows with the same order date isn’t. 11077 2022-05-06 65 1 11076 2022-05-06 9 4 11075 2022-05-06 68 8 11074 2022-05-06 73 7 11073 2022-05-05 58 2 11072 2022-05-05 20 4 11071 2022-05-05 46 1 11070 2022-05-05 44 2 The TOP filter is very useful, but it has two shortcomings—it’s not standard, and it doesn’t support a skipping capability. 2.8. OFFSET-FETCH T-SQL also supports a standard, TOP-like filter, called OFFSET-FETCH, which does support a skipping option, which makes it very useful for paging purposes. According to the SQL standard, the OFFSET-FETCH filter is considered an extension to the ORDER BY clause. With the OFFSET clause indicates how many rows to skip, and with the FETCH clause indicates how many rows to filter after the skipped rows. SELECT orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate, orderid OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY; -- OFFSET 50 ROWS; -- OFFSET 0 ROWS FETCH NEXT 25 ROWS ONLY; Note that a query that uses OFFSET-FETCH must have an ORDER BY clause. Also, contrary to the SQL standard, T-SQL doesn’t support the FETCH clause without the OFFSET clause. However, OFFSET without FETCH is allowed to skip the indicated number of rows and returns all remaining rows in the result. In the syntax for the OFFSET- FETCH filter, the singular and plural forms ROW and ROWS, and the forms FIRST and NEXT are interchangeable to phrase the filter in an intuitive, English-like manner. === OVER A window function is a function that, for each row in the underlying query, operates on a window (set) defined with an OVER clause of rows that is derived from the underlying query result, and computes a scalar (single) result value. SELECT orderid, custid, freight, ROW_NUMBER() OVER(PARTITION BY custid ORDER BY freight) AS rownum FROM Sales.Orders ORDER BY custid, freight; For each row in the underlying query, the OVER clause exposes to the function a subset of the rows from the underlying query’s result set. The OVER clause can restrict the rows in the window by using an optional window partition clause (PARTITION BY). It can define ordering for the calculation (if relevant) using a window order clause (ORDER BY)—not to be confused with the query’s presentation ORDER BY clause. Window functions are defined by the SQL standard, and T-SQL supports a subset of the features from the standard. 2.9. CASE A CASE expression, based on the SQL standard, is a scalar expression that returns a value based on conditional logic. Note that CASE is an (scalar) expression and not a statement; that is, it returns a value and it is allowed wherever scalar expressions are allowed, such as in the SELECT, WHERE, HAVING, and ORDER BY clauses and in CHECK constraints. There are two forms of CASE expressions: simple and searched. The simple CASE expression has a single test value or expression right after the CASE keyword that is compared with a list of possible values or expressions, in the WHEN clauses. If no value in the list is equal to the tested value, the CASE expression returns the value that appears in the ELSE clause (or NULL if an ELSE clause is not present). SELECT supplierid, COUNT(*) AS numproducts, CASE COUNT(*) % 2 WHEN 0 THEN &#39;Even&#39; WHEN 1 THEN &#39;Odd&#39; ELSE &#39;Unknown&#39; END AS countparity FROM Production.Products GROUP BY supplierid; The searched CASE expression returns the value in the THEN clause that is associated with the first WHEN predicate that evaluates to TRUE. If none of the WHEN predicates evaluates to TRUE, the CASE expression returns the value that appears in the ELSE clause (or NULL if an ELSE clause is not present). SELECT orderid, custid, freight, CASE WHEN freight &lt; 1000.00 THEN &#39;Less than 1000&#39; WHEN freight &lt;= 3000.00 THEN &#39;Between 1000 and 3000&#39; WHEN freight &gt; 3000.00 THEN &#39;More than 3000&#39; ELSE &#39;Unknown&#39; END AS valuecategory FROM Sales.Orders; 3. Predicates and Operators T-SQL has language elements in which predicates can be specified—for example, query filters such as WHERE and HAVING, the JOIN operator’s ON clause, CHECK constraints, and others. T-SQL uses three-valued predicate logic, where logical expressions can evaluate to TRUE, FALSE, or UNKNOWN. 3.1. Predicates: IN, BETWEEN, LIKE, EXISTS, and IS NULL The IN predicate is used to check whether a value, or scalar expression, is equal to at least one of the elements in a set. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderid IN(10248, 10249, 10250); The BETWEEN predicate is used to to check whether a value falls within a specified range, INCLUSIVE of the two delimiters of the range. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderid BETWEEN 10300 AND 10310; The LIKE predicate is used to check whether a character string value meets a specified pattern. SELECT empid, firstname, lastname FROM HR.Employees WHERE lastname LIKE N&#39;D%&#39;; Notice the use of the letter N to prefix the string &#39;D%&#39;; it stands for National and is used to denote that a character string is of a Unicode data type (NCHAR or NVARCHAR), as opposed to a regular character data type (CHAR or VARCHAR). The EXISTS or NOT EXISTS predicate is used to test for the presence or absence of rows in a subquery. SELECT custid, companyname FROM Sales.Customers AS C WHERE EXISTS (SELECT * FROM Sales.Orders AS O WHERE O.custid = C.custid); The IS NULL and its opposite IS NOT NULL predicates are used to test for NULL values. SELECT empid, firstname, lastname, mgrid FROM HR.Employees WHERE mgrid IS NULL; 3.2. Three-Valued Logic (3VL) SQL uses three-valued logic (3VL), where expressions can evaluate to one of three states: TRUE, FALSE, or NULL (also called UNKNOWN). It is critical to understand that WHERE and HAVING clauses only accept rows where the condition is TRUE, discarding rows that are FALSE or NULL. The logical operators AND, OR, and NOT behave as follows: NOT Operator: NOT TRUE results in FALSE. NOT FALSE results in TRUE. NOT NULL results in NULL. AND Operator (Pessimistic): It returns TRUE only if both sides are TRUE. It is pessimistic because if one side is FALSE, the result is FALSE, even if the other side is NULL. TRUE AND NULL results in NULL. FALSE AND NULL results in FALSE. NULL AND NULL results in NULL. OR Operator (Optimistic): It returns TRUE if either side is TRUE. It is optimistic because if one side is TRUE, the result is TRUE, even if the other side is NULL. TRUE OR NULL results in TRUE. FALSE OR NULL results in NULL. NULL OR NULL results in NULL. 3.3. Equality and Distinctness In SQL, the way NULL values are compared depends on the context, leading to two different types of comparison logic: Equality-based Comparison is the standard comparison used in predicates like WHERE and JOIN ON. It treats NULL as an unknown value. Because one unknown cannot be said to be equal to another, the expression NULL = NULL evaluates to UNKNOWN, not TRUE. Distinctness-based Comparison is used by operators that need to group rows or find duplicates, such as GROUP BY, UNION, INTERSECT, and EXCEPT. For these operations, two NULL values are treated as not distinct from each other (i.e., they are considered identical) which ensures that rows with NULL values in the same columns are correctly identified as duplicates. The formal SQL standard predicate for this logic is IS [NOT] DISTINCT FROM. It provides a way to compare values while treating two NULL values as equivalent. For example, NULL IS NOT DISTINCT FROM NULL evaluates to TRUE. It is important to note that T-SQL does not support this predicate, even though its set operators use the underlying distinctness logic. 3.4. Comparison Operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, and ALL, SOME, ANY T-SQL supports the comparison operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, !&gt;, and !&lt;, of which the last three are not standard and should be avoided using. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20220101&#39;; The &lt;&gt; (not equal) operator is used to check whether a value is not equal to another value. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &lt;&gt; &#39;20220101&#39;; The ALL keyword is used with a comparison operator to compare a scalar value with every value in a list or result set returned by a subquery. The condition is TRUE if the comparison is TRUE for all values in the list. -- Example: Find products whose list price is greater than ALL list prices in the &#39;Road Bikes&#39; category. SELECT Name, ListPrice FROM Production.Product WHERE ListPrice &gt; ALL (SELECT ListPrice FROM Production.Product WHERE ProductSubcategoryID = 1); The SOME or ANY keyword (they are synonyms) is used with a comparison operator to compare a scalar value with any value in a list or result set returned by a subquery. The condition is TRUE if the comparison is TRUE for at least one value in the list. -- Example: Find products whose list price is greater than SOME list prices in the &#39;Mountain Bikes&#39; category. SELECT Name, ListPrice FROM Production.Product WHERE ListPrice &gt; SOME (SELECT ListPrice FROM Production.Product WHERE ProductSubcategoryID = 2); It&#8217;s important to distinguish between NOT IN and &lt;&gt; ANY: NOT IN means &quot;not equal to value A AND not equal to value B AND not equal to value C&#8230;&#8203;&quot; &lt;&gt; ANY means &quot;not equal to value A OR not equal to value B OR not equal to value C&#8230;&#8203;&quot; For example, if a subquery returns (1, 2, 3): value NOT IN (1, 2, 3) is true if value is not 1 AND not 2 AND not 3. value &lt;&gt; ANY (1, 2, 3) is true if value is not 1 OR not 2 OR not 3. 3.5. Logical Operators: OR, AND, and NOT The logical operators OR, AND, and NOT are used to combine logical expressions. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20220101&#39; AND empid NOT IN(1, 3, 5); 3.6. Arithmetic Operators: +, -, *, /, and % T-SQL supports the four obvious arithmetic operators: +, -, *, and /, and also supports the % operator (modulo), which returns the remainder of integer division. SELECT orderid, productid, qty, unitprice, discount, qty * unitprice * (1 - discount) AS val FROM Sales.OrderDetails; Note that the data type of a scalar expression involving two operands is determined in T-SQL by the operand with the higher data-type precedence. If both operands are of the same data type, the result of the expression is of the same data type as well. If the two operands are of different types, the one with the lower precedence is promoted to the one that is higher. WITH Numbers AS ( SELECT 5 AS IntValue, 2 AS IntDivisor, 5.0 AS FloatValue ) SELECT IntValue / IntDivisor AS IntegerDivisionResult, -- Integer division CAST(IntValue AS NUMERIC(12, 2)) / CAST(IntDivisor AS NUMERIC(12, 2)) AS DecimalDivisionResult, -- Decimal division with casting FloatValue / IntDivisor AS DecimalDivisionFromFloatResult -- Division with a float FROM Numbers; The NUMERIC(12, 2) data type in T-SQL (SQL Server) defines a fixed-precision decimal number. 12 (Precision) → The total number of digits that can be stored (both before and after the decimal point). 2 (Scale) → The number of digits after the decimal point. 1234567890.12 -- Valid (12 digits total: 10 before the decimal, 2 after) | 999999999999.99 -- Valid (max possible value) | 100000000000.00 -- Invalid (13 digits, exceeds precision) | 12345.678 -- Invalid (more than 2 decimal places) | NUMERIC(p, s) and DECIMAL(p, s) are functionally identical in SQL Server. Both store exact numbers (unlike FLOAT or REAL, which are approximate). 4. Query Tuning To simulate a cold cache scenario for query performance measurement, run a manual checkpoint to write dirty buffers to disk and then drop all clean buffers from cache. CHECKPOINT; DBCC DROPCLEANBUFFERS; DBCC DROPCLEANBUFFERS should only be used isolated test environments as it can severely impact server performance. To see the estimated plan in SSMS/ADS by highlighting the query and clicking the Display Estimated Execution Plan (Ctrl+L) button on the SQL Editor toolbar. To see the actual plan by enabling the Include Actual Execution Plan (Ctrl+M) button and executing the query. Actual execution plans are generated after the T-SQL queries or batches execute that includes run-time information like the actual number of rows returned by, and the actual number of executions of, each operator. To enable measuring query performance with the session options STATISTICS IO (for I/O information) and STATISTICS TIME (for time information): SET STATISTICS IO, TIME ON; 4.1. SQL Server Internals A page is an 8-KB unit where SQL Server stores data. With disk-based tables, the page is the smallest I/O unit that SQL Server can read or write. An extent is a unit that contains eight contiguous pages. A table can be organized in one of two ways—either as a heap or as a B- tree (HOBT), technically as a B-tree when it has a clustered index defined on it and as a heap when it doesn’t. A heap is a table that has no clustered index, which means that the data is laid out as a bunch of pages and extents without any order. SQL Server maps the data that belongs to a heap using one or more bitmap pages called index allocation maps (IAMs). An allocation order scan is a heap scan that uses IAM pages to determine which pages and extents belong to the heap and reads them in physical file order, typically resulting in sequential reads when data is not cached. 4.1.1. Indexes All indexes in SQL Server on disk-based tables are structured as B-trees, which are a special case of balanced trees. An index on disk-based tables has a doubly linked list in their leaf level, so SQL Server can scan the rows in the leaf in forward and backward order. A clustered index is structured as a B-tree, and it maintains the entire table’s data, not a copy, in its leaf level. At the leaf level of the clustered index, the order in which data pages are stored on disk may not correspond to the sorted order of the index keys due to page splits. If page x points to next page y, and page y appears before page x in the file, page y is considered an out-of- order page. A nonclustered index is also structured as a B-tree, in contrast to a clustered index, a leaf row in a nonclustered index contains only the index key columns and a row locator value representing a particular data row. With the nonclustered index seek or range scan, it is more efficient because with fewer columns in the leaf row to fit more rows per leaf page. When using multiple predicates, the order of key columns in a nonclustered index is crucial for performance, as it determines whether qualifying rows are stored contiguously in the index leaf, maximizing seeks and minimizing scans. When have multiple equality predicates, place the columns from the predicates in any order in the index key list. When have at most one range predicate, place the columns from the equality predicates first in the key list and the column from the range predicate last. When have multiple range predicates, place the column from the most selective range predicate before the columns from the remaining range predicates. An index order scan is a scan performed on the leaf level of a B-tree index in the sorted order of the index key, using a doubly linked list for inter-page navigation and a row-offset array for intra-page order, supporting both full ordered scans and range scans. An index scan is necessary when the query filters on a non-leading column of the index key to scan a larger portion of the index (or even the entire index) to find the matching entries. An index seek is performed when SQL Server needs to find a certain key or range of keys at the leaf level of the index. An index seek is possible when the query filters on the leading column (or a prefix of the leading columns) of the index key to navigate the B-tree from the root node down to the specific leaf page(s) containing the matching values. In SQL Server, the direction of key columns can be indicated in an index definition (ascending by default). CREATE UNIQUE NONCLUSTERED INDEX [idx] ON [schema1].[Table1] ( [col1], -- same as [col1] ASC [col2] DESC ) The storage engine currently processes parallel scans only in the forward direction; backward scans are processed serially. If parallelism is a critical factor in the performance of the query, arrange a descending index. A filtered index is an index on a subset of rows from the underlying table defined based on a predicate. CREATE NONCLUSTERED INDEX idx_USA_orderdate ON Sales.Orders(orderdate) INCLUDE(orderid, custid, requireddate) WHERE shipcountry = N&#39;USA&#39;; A covering index is an index that contains all the columns required by the query, avoiding lookups to the base table. A clustered index is a covering index because the leaf row is the complete data row. A nonclustered index can be a covering index with an INCLUDE clause listing all non-key columns required by the query. CREATE INDEX idx_nc_cid_i_oid_eid_sid_od_flr ON dbo.Orders(custid) INCLUDE(orderid, empid, shipperid, orderdate, filler); A columnstore index stores data by columns rather than by rows, which leads to substantial performance advantages for analytical queries. A nonclustered columnstore index is a secondary index created on an existing table that is stored in the traditional rowstore format. CREATE NONCLUSTERED COLUMNSTORE INDEX idx_nc_cs ON dbo.Fact(key1, key2, key3, measure1, measure2, measure3, measure4); A clustered columnstore index is the primary storage for the table, with data physically stored in columnstore format. CREATE CLUSTERED COLUMNSTORE INDEX idx_cl_cs ON dbo.FactCS; 4.1.2. Execution Plans In SQL Server, the relational engine, like a brain including the optimizer, produces execution plans for queries, while the storage engine, like muscles, carries out these instructions, sometimes choosing the best of several options based on performance and consistency. When the plan shows a table scan operator, the storage engine has only one option: to use an allocation order scan. When the plan shows an ordered index scan operator (clustered or nonclustered), the storage engine can use only an index order scan. When the plan shows an unordered index scan operator, the storage engine has two options to scan the data: allocation order scan and index order scan. An allocation order scan can return multiple occurrences of rows and skip rows resulting from splits that take place during the scan. The storage engine opts for this option when the index size is greater than 64 pages and the request is running under the Read Uncommitted isolation level. When the query is running under the default Read Committed isolation level or higher, the storage engine will opt for an index order scan to prevent such phenomena from happening because of splits. An index order scan is safer in the sense that it won’t read multiple occurrences of the same row or skip rows because of splits. If an index key is modified after the row was read by an index order scan and the row is moved to a point in the leaf that the scan hasn’t reached yet, the scan will read the row a second time or never reach that row. It can happen in Read Uncommitted, Read Committed, and even Repeatable Read because the update was done to a row that was not yet read, but cannot happen under the isolation levels Serializable, Read Committed Snapshot, and Snapshot. 4.1.3. Cardinality Estimates A query optimizer, the main component in the relational engine (also known as the query processor), is responsible for generating physical execution plans for the queries. A cardinality estimator, that makes cardinality estimates of the number of rows returned by each operator, is employed by the optimizer to make decisions about access methods, join and aggregation algorithms, and memory allocation for sort and hash operations. It is not a simple task to make accurate cardinality estimations without actually running the query and without a time machine. Underestimations will tend to result in the following (not an exhaustive list): For filters, preferring an index seek and lookups to a scan. For aggregates, joins, and distinct, preferring order-based algorithms to hash-based ones. For sort and hash operations, there might be spills to tempdb as a result of an insufficient memory grant. Preferring a serial plan over a parallel one. Overestimations will tend to result in pretty much the inverse of underestimations (again, not an exhaustive list): For filters, preferring a scan to an index seek and lookups. For aggregates, joins, and distinct, preferring hash-based algorithms to order-based ones. For sort and hash operations, there won’t be spills, but very likely there will be a larger memory grant than needed, resulting in wasting memory. Preferring a parallel plan over a serial one. SQL Server relies on statistics about the data in its cardinality estimates. Whenever creating an index, SQL Server creates statistics using a full scan of the data. When additional statistics are needed, SQL Server might create them automatically using a sampled percentage of the data. SQL Server creates three main types of statistics: header, density vectors, and a histogram. CREATE INDEX idx_nc_cid_eid ON dbo.Orders(custid, empid); DBCC SHOW_STATISTICS(N&#39;dbo.Orders&#39;, N&#39;idx_nc_cid_eid&#39;); 4.1.4. Parallel Query Execution Parallel query execution (intraquery parallelism or parallelism) uses multiple processor cores to simultaneously process smaller chunks of data, leveraging modern hardware&#8217;s increased computing power for efficient large-data processing. Parallel processing, splitting work across multiple processor cores, can be implemented using two main models: a factory-line model (where each core performs a single action on data passed between cores) and a stream-based model (where each core processes a subset of data through all required operations). While the factory-line model might seem intuitively better for human tasks, database systems like SQL Server use stream-based models. Processors can efficiently switch between tasks as long as data is in local cache, and minimizing data movement between memory and storage is crucial for performance. Stream-based models can scale much better than factory-line models with large datasets, distributing rows across cores as evenly as possible using various algorithms for parallel execution of all operations on each subset of data. A query plan will be either entirely serial—processed using a single worker thread—or it will include one or more parallel branches, which are areas of the plan that are processed using multiple threads. The query processor can merge parallel streams into a single stream or create parallel streams from a single stream, resulting in plans with interleaved serial and parallel zones. All parallel zones in a plan use the same number of threads, known as the degree of parallelism (DOP), determined by server settings, hints, and runtime conditions. A given set of threads might be reused by multiple zones over the course of the plan. Parallel operators in the execution plan are marked with a circle icon with two arrows. Within a parallel zone, each thread processes a unique stream of rows before passing them to the next zone (serial or parallel). Parallel query plans rely on the Exchange (displayed as Parallelism) operator, which manages worker threads and data streams. Each SQL Server query plan operator has, internally, two logical interfaces: a consumer interface, which takes rows from upstream, and a producer interface, which passes rows downstream. While most operators handle their consumer and producer interfaces on the same thread and process single row streams, Exchange operators involve multiple threads and handle multiple streams, keeping other operators unaware of the parallelism. The number of threads on each side of the exchange depends on the type of exchange: A query plan can be read right-to-left (data flow) or left-to-right (operator logic). Gather Streams operators will have DOP threads on the consumer side and one thread on the producer side. From a data-flow perspective, it merges multiple parallel streams into a single serial stream, marking the end of a parallel zone. From an operator-logic perspective, it starts a parallel zone by invoking parallel worker threads. Distribute Streams operators will have one thread on the consumer side and DOP threads on the producer side. From a data-flow perspective, it splits a serial stream into multiple parallel streams, marking the start of a parallel zone. From an operator-logic perspective, it marks the end of a parallel zone. Repartition Streams operators will have DOP threads on each side of the exchange. From both data-flow and operator-logic perspectives, it redistributes rows from multiple parallel streams onto different threads based on a new scheme, effectively joining two adjacent parallel zones. Parallel query plans use five row distribution strategies across threads on the producer side of Distribute or Repartition exchanges: Hash: Assigns rows to threads based on a hash function, grouping rows with the same hashed value on the same thread (e.g., grouping by ProductID for aggregation). Round Robin: Distributes rows sequentially to each thread in a rotating fashion, often used outside Nested Loops where each row represents independent work. Broadcast: Sends all rows to all threads, used for small row counts when all threads need the complete dataset (e.g., building a hash table). Demand: Producer-side threads receive rows on request, currently used only with aligned partitioned tables. Range: Assigns unique, non-overlapping key ranges to each thread, used only for index building. 4.2. Data Retrieval Strategies SQL Server query optimizer uses various strategies to determine how the storage engine physically retrieves data from tables and indexes. Understanding these strategies, such as table scans, index seeks, and lookups, is crucial for diagnosing query performance and optimizing data access paths. 4.2.1. Unordered Clustered Index Scan or Table Scan A table scan or an unordered clustered index scan involves a scan of all data pages that belong to the table. Full table scans occur primarily in two cases: when all rows are required or when need only a subset of the rows but don’t have a good index to support the filter. When the underlying table is a heap, the plan will show an operator called Table Scan. SELECT * INTO dbo.Orders2 FROM dbo.Orders; ALTER TABLE dbo.Orders2 ADD CONSTRAINT PK_Orders2 PRIMARY KEY NONCLUSTERED (orderid); GO -- table scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orderss; When the underlying table is a B- tree, the plan will show an operator called Clustered Index Scan with an Ordered: False property. The fact that the Ordered property of the Clustered Index Scan operator indicates False means that as far as the relational engine is concerned, the data does not need to be returned from the operator in key order. It is up to the storage engine to determine to employ allocation order scan or index order scan. -- clustered index scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders; 4.2.2. Unordered Covering Nonclustered Index Scan An unordered covering nonclustered index scan is a query access method to retrieve all necessary data for a query solely from the leaf level of a nonclustered index, without accessing the base table&#8217;s data rows. An unordered covering nonclustered index scan is similar to an unordered clustered index scan. -- unordered covering nonclustered index scan SELECT orderid -- PRIMARY KEY NONCLUSTERED (orderid) FROM dbo.Orders; 4.2.3. Ordered Clustered Index Scan An ordered clustered index scan is a full scan of the leaf level of the clustered index that guarantees that the data will be returned to the next operator in index order. -- ordered clustered index scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders ORDER BY orderdate; -- CLUSTERED INDEX (orderdate) 4.2.4. Ordered Covering Nonclustered Index Scan An ordered covering nonclustered index scan is similar to an unordered covering nonclustered index scan, but retrieves data in the order of the index keys. -- ordered covering nonclustered index scan SELECT orderid, orderdate FROM dbo.Orders ORDER BY orderid; -- PRIMARY KEY NONCLUSTERED (orderid) 4.2.5. Nonclustered Index Seek + Range Scan + Lookups A nonclustered index seek + range scan + lookups access method is typically used for small-range queries or point queries using a nonclustered index that doesn’t cover the query. A point query uses equality conditions (=) to target specific values, potentially retrieving zero, one, or multiple rows, while a range query uses range operators (&lt;, &gt;, &lt;=, &gt;=, BETWEEN) to retrieve rows within a specified interval. While the index is capable of supporting the filter, lookups will be required to obtain the remaining columns from the respective data rows due to the index&#8217;s non-covering nature. If the target table is a heap, the lookups will be RID Lookups, each costing one page read. -- nonclustered index seek + range scan + lookups against a heap SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders2 -- heap WHERE orderid &lt;= 25; -- PRIMARY KEY NONCLUSTERED (orderid) If the underlying table is a B-tree, the lookups will be Key Lookups, each costing as many reads as the number of levels in the clustered index. -- nonclustered index seek + range scan + lookups against a B-tree SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders -- B-tree WHERE orderid &lt;= 25; -- PRIMARY KEY NONCLUSTERED (orderid) 4.2.6. Unordered Nonclustered Index Scan + Lookups An unordered nonclustered index scan + lookups access method is typically used by the optimizer when the following conditions are in place: The query has a selective filter. There’s a nonclustered index that contains the filtered column (or columns), but the index isn’t a covering one. The filtered columns are not leading columns in the index key list. -- unordered nonclustered index scan + lookups -- missing index SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders WHERE custid = &#39;C0000000001&#39;; -- NONCLUSTERED INDEX (shipperid, orderdate, custid); It performs a full unordered scan of the leaf level of the index, followed by lookups for qualifying keys, a strategy that becomes less efficient than a full table scan for less selective queries due to the lookup overhead. 4.2.7. Clustered Index Seek + Range Scan A clustered index seek + range scan access method is typically used by the optimizer for range queries where the filter based on the first key column (or columns) of the clustered index. -- clustered index seek + range scan SELECT orderid, custid, empid, shipperid, orderdate FROM dbo.Orders WHERE orderdate = &#39;20140212&#39;; -- CLUSTERED INDEX (orderdate); 4.2.8. Covering Nonclustered Index Seek + Range Scan A covering nonclustered index seek + range scan access method is similar to the access method clustered index seek + range scan, only it uses a nonclustered covering index. -- nonclustered index seek + range scan SELECT orderid, shipperid, orderdate, custid FROM dbo.Orders WHERE shipperid = &#39;C&#39; AND orderdate &gt;= &#39;20140101&#39; AND orderdate &lt; &#39;20150101&#39;; -- NONCLUSTERED INDEX (shipperid, orderdate, custid); 4.3. Tied Rows and Sorting When an ORDER BY clause is used, SQL Server guarantees the result set is sorted according to the specified columns. However, this guarantee does not extend to rows with the same value in the ordering columns—known as tied rows. The order in which tied rows are returned is not guaranteed and can vary between query executions, leading to an unstable sort. This instability occurs because the execution plan only guarantees the explicitly requested order. For tied rows, the database returns them in whatever order is most convenient for that specific execution, which can lead to unexpected behavior, particularly in pagination scenarios. For instance, if a user is paging through a customer&#8217;s order history, an unstable sort could cause the same order to appear on multiple pages or for some orders to be skipped entirely, because the order of that customer&#8217;s orders shifted between page loads. To ensure a consistent and predictable sort, the ORDER BY clause must uniquely identify every row, which can be achieved by adding a tie-breaker—a column or set of columns guaranteed to be unique, such as the table&#8217;s primary key. For example, consider sorting orders by customer. A single customer can have multiple orders, creating tied rows. -- Unstable sort: Order of rows for the same `custid` is not guaranteed. SELECT custid, orderid, orderdate FROM Sales.Orders ORDER BY custid; By adding the unique orderid column as a tie-breaker, the sort becomes deterministic. A secondary sort by orderdate is also a good practice. -- Stable sort: orderdate and orderid act as tie-breakers. SELECT custid, orderid, orderdate FROM Sales.Orders ORDER BY custid, orderdate DESC, orderid DESC; This forces the optimizer to perform a secondary sort on orderdate and then orderid for any tied rows, resulting in a deterministic, or stable, sort that is consistent with every execution. 5. Joins T-SQL supports four table operators: JOIN, APPLY, PIVOT, and UNPIVOT. The JOIN operator is standard, while APPLY, PIVOT, and UNPIVOT are T-SQL extensions. Each table operator acts on input tables, applies a set of logical query processing phases, and returns a table result. A JOIN table operator operates on two input tables and has three fundamental types: A CROSS JOIN applies only one phase, the Cartesian Product. An INNER JOIN applies two phases, the Cartesian Product and the Filter. An OUTER JOIN applies three phases, the Cartesian Product, the Filter, and the Add Outer Rows. These phases describe the logical processing steps involved in different types of SQL joins: The Cartesian Product is the initial step where every row from the first table is combined with every row from the second table, resulting in a new table containing all possible combinations. A Filter is applied after the Cartesian Product, based on the ON clause of the join. Only the rows that satisfy the join condition are kept. Add Outer Rows is a specific phase for outer joins (LEFT, RIGHT, or FULL) that, after filtering, includes in the result set any rows from the outer table(s) that did not find a match in the other table. For a LEFT OUTER JOIN, the outer table is the left table. For a RIGHT OUTER JOIN, the outer table is the right table. For a FULL OUTER JOIN, both tables are considered outer tables. For these non-matching rows, columns from the table where no match was found will contain NULL values. The OUTER keyword is optional for LEFT, RIGHT, and FULL joins (e.g., LEFT JOIN is equivalent to LEFT OUTER JOIN). 5.1. CROSS The cross join is the simplest type of join that implements only one logical query processing phase—a Cartesian Product. It operates on the two tables provided as inputs and produces a Cartesian product of the two, that is, each row from one input is matched with all rows from the other. -- SQL-92 syntax SELECT C.custid, E.empid FROM Sales.Customers AS C CROSS JOIN HR.Employees AS E; -- SQL-89 syntax (not recommended) SELECT C.custid, E.empid FROM Sales.Customers AS C, HR.Employees AS E; -- Self cross joins SELECT E1.empid, E1.firstname, E1.lastname, E2.empid, E2.firstname, E2.lastname FROM HR.Employees AS E1 CROSS JOIN HR.Employees AS E2; DROP TABLE IF EXISTS dbo.Digits; CREATE TABLE dbo.Digits (digit INT NOT NULL PRIMARY KEY); INSERT INTO dbo.Digits(digit) VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9); -- Producing tables of numbers SELECT D3.digit * 100 + D2.digit * 10 + D1.digit + 1 AS n FROM dbo.Digits AS D1 CROSS JOIN dbo.Digits AS D2 CROSS JOIN dbo.Digits AS D3 ORDER BY n; 1 2 3 . . . 998 999 1000 5.2. INNER An inner join applies two logical query processing phases—it applies a Cartesian product between the two input tables like in a cross join, and then it filters rows based on a specified predicate in a designated clause called ON. -- SQL-92 syntax SELECT E.empid, E.firstname, E.lastname, O.orderid FROM HR.Employees AS E INNER JOIN Sales.Orders AS O ON E.empid = O.empid; -- Note that the SQL-89 syntax has no ON clause. SELECT E.empid, E.firstname, E.lastname, O.orderid FROM HR.Employees AS E, Sales.Orders AS O WHERE E.empid = O.empid; As with the WHERE and HAVING clauses, the ON clause also returns only rows for which the predicate evaluates to TRUE, and it does not return rows for which the predicate evaluates to FALSE or UNKNOWN. When a join condition involves only an equality operator, the join is said to be an equi join. When a join condition involves any operator besides equality, the join is said to be a non-equi join. SELECT E1.empid, E1.firstname, E1.lastname, E2.empid, E2.firstname, E2.lastname FROM HR.Employees AS E1 INNER JOIN HR.Employees AS E2 ON E1.empid &lt; E2.empid; Standard SQL supports a concept called natural join, which represents an inner join based on a match between columns with the same name in both sides. T-SQL doesn’t have an implementation of a natural join. For example, T1 NATURAL JOIN T2 joins the rows between T1 and T2 based on a match between the columns with the same names on both sides. A join that has an explicit join predicate like equi join and non-equi join that is based on a binary operator (equality or inequality) is known as a theta join. 5.3. OUTER Outer joins were introduced in SQL-92 and, unlike inner joins and cross joins, have only one standard syntax—the one in which the JOIN keyword is specified between the table names and the join condition is specified in the ON clause. Outer joins apply the two logical processing phases that inner joins apply (Cartesian Product and the ON filter), plus a third phase called Adding Outer Rows that is unique to this type of join. In an outer join, a table is marked as a preserved table by using the keywords LEFT OUTER JOIN, RIGHT OUTER JOIN, or FULL OUTER JOIN between the table names. The OUTER keyword is optional. The LEFT keyword means that the rows of the left table (the one to the left of the JOIN keyword) are preserved; the RIGHT keyword means that the rows in the right table are preserved; and the FULL keyword means that the rows in both the left and right tables are preserved. The third logical query processing phase of an outer join identifies the rows from the preserved table that did not find matches in the other table based on the ON predicate, which adds those rows to the result table produced by the first two phases of the join, and it uses NULLs as placeholders for the attributes from the nonpreserved side of the join in those outer rows. SELECT C.custid, C.companyname, O.orderid FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid; A FULL OUTER JOIN with the condition ON 1=1 is functionally equivalent to a CROSS JOIN. If the predicate in the WHERE clause refers to an attribute from the nonpreserved side of the join using an expression in the form &lt;attribute&gt; &lt;operator&gt; &lt;value&gt;, because attributes from the nonpreserved side of the join are NULLs in outer rows, and an expression in the form NULL &lt;operator&gt; &lt;value&gt; yields UNKNOWN (unless it’s the IS NULL operator explicitly looking for NULLs, or the distinct predicate IS [NOT] DISTINCT FROM), it’s usually an indication of a bug, SELECT C.custid, C.companyname, O.orderid, O.orderdate FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid WHERE O.orderdate &gt;= &#39;20220101&#39;; -- Effectively, the join becomes an inner join. If the predicate in the inner join’s ON clause compares an attribute from the nonpreserved side of the outer join and an attribute from the third table, all outer rows are discarded. Remember that outer rows have NULLs in the attributes from the nonpreserved side of the join, and comparing a NULL with anything yields UNKNOWN. UNKNOWN is filtered out by the ON filter. In other words, such a predicate nullifies the outer join, effectively turning it into an inner join. -- outer rows are dropped whenever any kind of outer join (left, right, or full) is -- followed by a subsequent inner join or right outer join. SELECT C.custid, O.orderid, OD.productid, OD.qty FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid; 5.4. APPLY The nonstandard APPLY operator, like a correlated join, instead of treaing its two inputs as a set, applies the right table (typically a derived table or a TVF) to each row from the left table (evaluated first) and produces a result table with the unified result sets. A CROSS APPLY operator is equavelent to a CROSS JOIN. SELECT S.shipperid, E.empid FROM Sales.Shippers AS S CROSS JOIN HR.Employees AS E; -- =&gt; SELECT S.shipperid, E.empid FROM Sales.Shippers AS S CROSS APPLY HR.Employees AS E; With APPLY, the left side is evaluated first, and the right side is evaluated per row from the left iteratively, and can have references to elements from the left. SELECT C.custid, A.orderid, A.orderdate FROM Sales.Customers AS C CROSS APPLY (SELECT TOP (3) orderid, empid, orderdate, requireddate FROM Sales.Orders AS O WHERE O.custid = C.custid ORDER BY orderdate DESC, orderid DESC) AS A; -- A is a correlated derived table Because the derived table is applied to each left row, the CROSS APPLY operator returns the three most recent orders for each customer. 1 11011 2022-04-09 1 10952 2022-03-16 1 10835 2022-01-15 2 10926 2022-03-04 2 10759 2021-11-28 2 10625 2021-08-08 3 10856 2022-01-28 3 10682 2021-09-25 3 10677 2021-09-22 . . . If the right table expression returns an empty set, the CROSS APPLY operator does not return the corresponding left row. To return rows from the left side even if there are no matches on the right side, use OUTER APPLY. SELECT C.custid, A.orderid, A.orderdate FROM Sales.Customers AS C OUTER APPLY (SELECT orderid, empid, orderdate, requireddate FROM Sales.Orders AS O WHERE O.custid = C.custid AND O.custid in (22, 57) ORDER BY orderdate DESC, orderid DESC OFFSET 0 ROWS FETCH FIRST 3 ROWS ONLY) AS A; 1 NULL NULL 2 NULL NULL 3 NULL NULL It&#8217;s more conventional to work with inline TVFs instead of derived tables. CREATE OR ALTER FUNCTION dbo.TopOrders (@custid AS INT, @n AS INT) RETURNS TABLE AS RETURN SELECT orderid, empid, orderdate, requireddate FROM Sales.Orders WHERE custid = @custid ORDER BY orderdate DESC, requireddate DESC OFFSET 0 ROWS FETCH NEXT @N ROWS ONLY; GO SELECT C.custid, C.companyname, A.orderid, A.empid, A.orderdate, A.requireddate FROM Sales.Customers AS C CROSS APPLY dbo.TopOrders(C.custid, 3) AS A; GO -- cleanup DROP FUNCTION if EXISTS dbo.TopOrders 6. Subqueries SQL supports writing queries within queries, or nesting queries. The outermost query is a query whose result set is returned to the caller and is known as the outer query. The inner query is a query whose result set is used by the outer query and is known as a subquery. A subquery can be either self-contained or correlated. A self-contained subquery has no dependency on tables from the outer query, whereas a correlated subquery does. A subquery can be single-valued, multivalued, or table-valued, that is, a subquery can return a single value, multiple values, or a whole table result. In queries that include a correlated subquery (a.k.a., a repeating subquery), the subquery depends on the outer query for its values, which means that the subquery is executed repeatedly, once for each row that might be selected by the outer query. SELECT custid, orderid, orderdate, empid FROM Sales.Orders AS O1 WHERE orderid = (SELECT MAX(O2.orderid) FROM Sales.Orders AS O2 WHERE O2.custid = O1.custid); A scalar subquery is a subquery that return a single value or NULL and can be anywhere in the outer query where a single-valued expression expected, such as WHERE or SELECT. DECLARE @maxid AS INT = (SELECT MAX(orderid) FROM Sales.Orders); SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE orderid = @maxid; -- substitute the above variable with a scalar self-contained subquery SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE orderid = (SELECT MAX(O.orderid) FROM Sales.Orders AS O); A multi-valued subquery is a subquery that returns multiple values as a single column, and such as the IN predicate, operate on a multi-valued subquery. SELECT orderid FROM Sales.Orders WHERE empid IN (SELECT E.empid FROM HR.Employees AS E WHERE E.lastname LIKE N&#39;D%&#39;); In some cases the database engine optimizes both the subquery and the the join the same way, sometimes joins perform better, and sometimes subqueries perform better. 6.1. Subqueries with IN or NOT IN A subquery introduced with IN or NOT IN provides a set of zero or more values for the outer query&#8217;s filtering. An empty set will cause the IN condition to always be FALSE, and the NOT IN condition to always be TRUE. 6.2. Subqueries with comparison operators Subqueries can be introduced with one of the comparison operators (=, &lt; &gt;, &gt;, &gt; =, &lt;, ! &gt;, ! &lt;, or &lt; =). A subquery introduced with an unmodified comparison operator (a comparison operator not followed by ANY, SOME or ALL) must return a single value rather than a list of values, like subqueries introduced with IN, otherwise SQL Server displays an error message. 6.3. Subqueries with EXISTS or NOT EXISTS A subquery introduced with EXISTS or NOT EXISTS functions as an existence test, returning TRUE or FALSE to the outer query&#8217;s WHERE clause based on the presence or absence of rows, without actually producing data. SELECT custid, companyname FROM Sales.Customers AS C WHERE country = N&#39;Spain&#39; AND EXISTS (SELECT * FROM Sales.Orders AS O WHERE O.custid = C.custid); 7. Table Expressions A table expression is an expression—typically a query—that conceptually returns a table result and as such can be nested as an operand of another table expression. Recall that a table in SQL is the counterpart to a relation in relational theory. A table expression is therefore SQL’s counterpart to a relational expression. A relational expression in relational theory is an expression that returns a relation and as such can be nested as an operand of another relational expression. A named table expression is then a table expression assigned with a name, and interacted with like doing with a base table. T-SQL supports four types of named table expressions: derived tables, common table expressions (CTEs), views, and inline table-valued functions (inline TVFs). 7.1. Derived Tables Derived tables are defined in the FROM clause of an outer query, which treated as if it were a regular table for the outer query, and also sometimes referred to as an inline view. SELECT * FROM (SELECT custid, companyname FROM Sales.Customers WHERE country = N&#39;USA&#39;) AS USACusts; SELECT orderyear, COUNT(DISTINCT custid) AS numcusts FROM (SELECT YEAR(orderdate) AS orderyear, custid FROM Sales.Orders) AS D GROUP BY orderyear; 7.2. CTEs A Common Table Expression (CTE) is a temporary, named result set created from a query, which can then be used within the scope of a single statement such as SELECT, INSERT, UPDATE, or DELETE. A CTE can also refer to itself in what is known as a recursive CTE. WITH &lt;CTE_Name&gt;[(&lt;target_column_list&gt;)] AS ( &lt;inner_query_defining_CTE&gt; ) &lt;outer_query_against_CTE&gt;; CTEs support two forms of column aliasing: inline, which uses the AS keyword to rename columns individually within the SELECT statement, and external, which defines all column names at once in a parenthesized list immediately following the CTE&#8217;s name. Inline aliasing is the most common and recommended method, where each new column name is defined individually inside the SELECT list, directly following the column or expression it refers to. WITH UserCTE AS ( SELECT user_id AS ID, user_name AS Name FROM users ) SELECT ID, Name FROM UserCTE; External aliasing is an alternative method where a complete list of new column names is provided in parentheses immediately after the CTE&#8217;s name, before the query definition begins. While less common, this method is required in certain scenarios, such as defining the column structure for recursive CTEs. WITH UserCTE (ID, Name) AS ( SELECT user_id, user_name FROM users ) SELECT ID, Name FROM UserCTE; A CTE must be immediately consumed by a single SELECT, INSERT, UPDATE, MERGE, or DELETE statement. It can also be used to define the query within a CREATE VIEW statement. CREATE VIEW RecentSalesHires AS -- 1. The CTE is defined first to simplify the logic. WITH SalesEmployees AS ( SELECT employee_id, employee_name, hire_date FROM employees WHERE department = &#39;Sales&#39; AND status = &#39;Active&#39; ) -- 2. The view&#39;s main SELECT statement then uses the CTE. SELECT employee_id, employee_name FROM SalesEmployees WHERE hire_date &gt;= DATE(&#39;now&#39;, &#39;-1 year&#39;); A single, nonrecursive CTE can be defined by the combined results of multiple SELECT queries that are connected by a set operator like UNION ALL, UNION, INTERSECT, or EXCEPT. -- This single CTE is defined by two SELECT statements -- combined with a set operator (UNION). WITH AllContacts AS ( -- The first SELECT query SELECT email_address FROM ActiveCustomers UNION -- The set operator that combines them -- The second SELECT query SELECT email FROM ProspectiveCustomers ) -- Now you can use the CTE, which contains the combined results. SELECT * FROM AllContacts; Each CTE can refer to all previously defined CTEs, and the outer query can refer to all CTEs. WITH -- CTE 1: Finds all employees in the &#39;North America&#39; region. RegionalEmployees AS ( SELECT employee_id, employee_name FROM employees WHERE region = &#39;North America&#39; ), -- CTE 2: Calculates sales totals by joining with the first CTE. -- Note it only passes on the ID and the aggregated total. EmployeeSales AS ( SELECT re.employee_id, SUM(s.sale_amount) AS total_sales FROM sales AS s JOIN RegionalEmployees AS re ON s.employee_id = re.employee_id GROUP BY re.employee_id ) -- The outer query now joins BOTH CTEs to get the required columns. SELECT re.employee_name, -- This column comes from the first CTE. es.total_sales -- This column comes from the second CTE. FROM RegionalEmployees AS re JOIN EmployeeSales AS es ON re.employee_id = es.employee_id WHERE es.total_sales &gt; 500000 ORDER BY es.total_sales DESC; Multiple references in CTEs in table operators like joins WITH YearlyCount AS ( SELECT YEAR(orderdate) AS orderyear, COUNT(DISTINCT custid) AS numcusts FROM Sales.Orders GROUP BY YEAR(orderdate) ) SELECT Cur.orderyear, Cur.numcusts AS curnumcusts, Prv.numcusts AS prvnumcusts, Cur.numcusts - Prv.numcusts AS growth FROM YearlyCount AS Cur LEFT OUTER JOIN YearlyCount AS Prv ON Cur.orderyear = Prv.orderyear + 1; CTEs are unique among table expressions in the sense that they support recursion. Recursive CTEs, like nonrecursive ones, are defined by the SQL standard. WITH &lt;CTE_Name&gt;[(&lt;target_column_list&gt;)] AS ( &lt;anchor_member&gt; UNION ALL &lt;recursive_member&gt; ) &lt;outer_query_against_CTE&gt;; A recursive CTE is defined by at least two queries (more are possible)—at least one query known as the anchor member and at least one query known as the recursive member. The anchor member is a query that returns a valid relational result table —like a query that is used to define a nonrecursive table expression. The anchor member query is invoked only once. The recursive member is a query that has a reference to the CTE name and is invoked repeatedly until it returns an empty set. The reference to the CTE name represents the previous result set. The first time that the recursive member is invoked, the previous result set represents whatever the anchor member returned. In each subsequent invocation of the recursive member, the reference to the CTE name represents the result set returned by the previous invocation of the recursive member. Both queries must be compatible in terms of the number of columns they return and the data types of the corresponding columns. The reference to the CTE name in the outer query represents the unified result sets of the invocation of the anchor member and all invocations of the recursive member. WITH EmpsCTE AS ( SELECT empid, mgrid, firstname, lastname FROM HR.Employees WHERE empid = 2 UNION ALL SELECT C.empid, C.mgrid, C.firstname, C.lastname FROM EmpsCTE AS P INNER JOIN HR.Employees AS C ON C.mgrid = P.empid ) SELECT empid, mgrid, firstname, lastname FROM EmpsCTE; 2 1 Don Funk 3 2 Judy Lew 5 2 Sven Mortensen 6 5 Paul Suurs 7 5 Russell King 9 5 Patricia Doyle 4 3 Yael Peled 8 3 Maria Cameron CTEs are not permitted to nest in SQL, but they can be chained sequentially in a single WITH clause, allowing each CTE to reference any of the ones defined before it to create a step-by-step logical flow. WITH -- 1. The first CTE identifies customers from a specific region. US_Customers AS ( SELECT customer_id, customer_name FROM customers WHERE country = &#39;USA&#39; ), -- 2. The second CTE is &quot;chained&quot; by using the first CTE as its source -- to find the recent orders for only those customers. Recent_US_Orders AS ( SELECT usc.customer_name, o.order_id, o.order_total FROM orders AS o JOIN US_Customers AS usc ON o.customer_id = usc.customer_id WHERE o.order_date &gt;= &#39;2025-01-01&#39; ) -- 3. The final query uses the last CTE in the chain to get the result. SELECT * FROM Recent_US_Orders; 7.3. Views and TVFs Derived tables and CTEs have a single-statement scope, which means they are not reusable. Views and inline table-valued functions (inline TVFs) are two types of table expressions whose definitions are stored as permanent objects in the database, making them reusable. CREATE OR ALTER VIEW Sales.USACusts AS SELECT custid, companyname, contactname, contacttitle, address, city, region, postalcode, country, phone, fax FROM Sales.Customers WHERE country = N&#39;USA&#39;; GO -- The GO command is used here to terminate what’s called a batch in T-SQL. SELECT custid, companyname FROM Sales.USACusts; Remember that a presentation ORDER BY clause is not allowed in the query defining a table expression because a relation isn’t ordered. CREATE OR ALTER VIEW Sales.USACusts AS SELECT custid, companyname, contactname, contacttitle, address, city, region, postalcode, country, phone, fax FROM Sales.Customers WHERE country = N&#39;USA&#39; ORDER BY region; GO Msg 1033, Level 15, State 1, Procedure USACusts, Line 8 The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified. Inline TVFs are reusable table expressions that support input parameters. In most respects, except for the support for input parameters, inline TVFs are similar to views, or parameterized views. T-SQL supports another type of table function called multi-statement TVF, which populates and returns a table variable. CREATE OR ALTER FUNCTION dbo.GetCustOrders (@cid AS INT) RETURNS TABLE AS RETURN SELECT orderid, custid, empid, orderdate, requireddate, shippeddate, shipperid, freight, shipname, shipaddress, shipcity, shipregion, shippostalcode, shipcountry FROM Sales.Orders WHERE custid = @cid; GO SELECT orderid, custid FROM dbo.GetCustOrders(1) AS O; GO SELECT O.orderid, O.custid, OD.productid, OD.qty FROM dbo.GetCustOrders(1) AS O INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid; GO DROP FUNCTION IF EXISTS dbo.GetCustOrders; 8. UNION, UNION ALL, INTERSECT, and EXCEPT Set operators combine rows from two query result sets (or multisets), with some operators removing duplicates to return a set, while others preserve duplicates to return a multiset. T-SQL supports the following operators: UNION, UNION ALL, INTERSECT, and EXCEPT. A set operator compares complete rows between the results of the two input queries involved. Input Query1 &lt;set_operator&gt; Input Query2 [ORDER BY ...]; Because a set operator expects multisets as inputs, the two queries involved cannot have ORDER BY clauses. Remember that a query with an ORDER BY clause does not return a multiset—it returns an ordered result. In terms of logical-query processing, each of the individual queries can have all logical-query processing phases except for a presentation ORDER BY. The operator is applied to the results of the two queries, and the outer ORDER BY clause (if one exists) is applied to the result of the operator. The two input queries must produce results with the same number of columns, and corresponding columns must have compatible data types. The names of the columns in the result are determined by the first query. Still, it’s considered a best practice to make sure that all columns have names in both queries, and that the names of the corresponding columns are the same. When a set operator compares rows between the two inputs, it doesn’t use an equality-based comparison; rather, it uses a distinctness-based comparison. The semantics of distinctness-based comparisons are the same as the ones used by a standard predicate called the distinct predicate that treats NULLs just like non-NULL values for comparison purposes to ensure that two rows with NULL values in the same columns are treated as duplicates, which is often the desired behavior. The SQL standard supports two &quot;flavors&quot; of each operator—DISTINCT (the default) and ALL. The DISTINCT flavor eliminates duplicates and returns a set. ALL doesn’t attempt to remove duplicates and therefore returns a multiset. All three operators in T-SQL support an implicit distinct version, but only the UNION operator supports the ALL version. In terms of syntax, T-SQL implicitly applies the DISTINCT clause unless the ALL keyword is explicitly used. SQL defines precedence among set operators: INTERSECT operator precedes UNION and EXCEPT, and UNION and EXCEPT are evaluated in order of appearance. -- the result is a multiset and not a set SELECT country, region, city FROM HR.Employees UNION ALL SELECT country, region, city FROM Sales.Customers; -- returns distinct locations SELECT country, region, city FROM HR.Employees UNION SELECT country, region, city FROM Sales.Customers; -- returns only distinct rows that appear in both input query results SELECT country, region, city FROM HR.Employees INTERSECT SELECT country, region, city FROM Sales.Customers; -- returns only distinct rows that appear in the first set but not the second SELECT country, region, city FROM HR.Employees EXCEPT SELECT country, region, city FROM Sales.Customers; SELECT country, region, city FROM Production.Suppliers EXCEPT SELECT country, region, city FROM HR.Employees INTERSECT -- evaluated first SELECT country, region, city FROM Sales.Customers; 9. Data Analysis T-SQL in SQL Server offers robust features for data analysis, including window Functions, pivoting, unpivoting, grouping sets, and time series data handling. 9.1. Window Functions A window function is a function that, for each row, computes a scalar result value based on a calculation against a subset as a window of the rows from the underlying query set. Window functions perform calculations on a per-row basis within a defined window of rows, preserving detail, whereas grouped queries lose detail by aggregation. Window functions operate directly on the underlying query result set, while subqueries often start with a fresh view of the data, potentially requiring duplication of query logic. Window functions can define the order of rows for calculations separately from the presentation order of the result set. Window functions are allowed only in the SELECT and ORDER BY clauses of a query. A window function is defined by using the OVER clause with up to three parts: window-partition, window-order, and window-frame. &lt;function&gt;( &lt;expression&gt; ) [ IGNORE NULLS | RESPECT NULLS ] OVER(...) An empty OVER() clause represents the entire underlying query’s result set. The window-partition clause (PARTITION BY) restricts the window to the subset of rows that have the same values in the partitioning columns as in the current row. The window-order clause (ORDER BY) defines ordering, but don’t confuse this with presentation ordering. In a window aggregate function, window ordering supports a frame specification. In a window ranking function, window ordering gives meaning to the rank. The window-frame filters a frame, or a subset, of rows from the window partition between the two specified delimiters, which is defined using the ROWS or RANGE clause. ROWS: Defines the frame based on the number of rows before and after the current row. ROWS BETWEEN &lt;top delimiter&gt; AND &lt;bottom delimiter&gt; UNBOUNDED PRECEDING: Includes all rows from the beginning of the partition up to the current row. n PRECEDING: Includes the current row and the n preceding rows. CURRENT ROW: Includes only the current row. n FOLLOWING: Includes the current row and the n following rows. UNBOUNDED FOLLOWING: Includes all rows from the current row to the end of the partition. RANGE: Defines the frame based on the values of the ORDER BY column. RANGE BETWEEN &lt;top delimiter&gt; AND &lt;bottom delimiter&gt; UNBOUNDED PRECEDING: Includes all rows from the beginning of the partition up to the current row. n PRECEDING: Includes rows where the ORDER BY column&#8217;s value is within n units of the current row&#8217;s value. CURRENT ROW: Includes only the current row. n FOLLOWING: Includes rows where the ORDER BY column&#8217;s value is within n units of the current row&#8217;s value. UNBOUNDED FOLLOWING: Includes all rows from the current row to the end of the partition. -- compute the running-total for each employee and month SELECT empid, ordermonth, val, SUM(val) OVER( PARTITION BY empid -- For an underlying row with employee ID `1`, the window exposed to the function filters only the rows where the employee ID is `1`. ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS runval FROM Sales.EmpOrders; 1 2020-07-01 1614.88 1614.88 1 2020-08-01 5555.90 7170.78 1 2020-09-01 6651.00 13821.78 . . . 9.1.1. Ranking T-SQL supports four ranking functions: ROW_NUMBER, RANK, DENSE_RANK, and NTILE to rank each row with respect to others in the window. SELECT orderid, custid, val, ROW_NUMBER() OVER(ORDER BY val) AS rownum, RANK() OVER(ORDER BY val) AS rank, DENSE_RANK() OVER(ORDER BY val) AS dense_rank, NTILE(10) OVER(ORDER BY val) AS ntile FROM Sales.OrderValues ORDER BY val; orderid custid val rownum rank dense_rank ntile 10782 12 12.50 1 1 1 1 10807 27 18.40 2 2 2 1 10586 66 23.80 3 3 3 1 10767 76 28.00 4 4 4 1 10898 54 30.00 5 5 5 1 10900 88 33.75 6 6 6 1 10883 48 36.00 7 7 7 1 11051 41 36.00 8 7 7 1 10815 71 40.00 9 9 8 1 10674 38 45.00 10 10 9 1 11057 53 45.00 11 10 9 1 10271 75 48.00 12 12 10 1 . . . 10496 81 190.00 83 83 78 1 10793 4 191.10 84 84 79 2 10428 66 192.00 85 85 80 2 . . . The ROW_NUMBER function assigns incremental sequential integers to the rows in the query result based on the mandatory window ordering. The RANK or DENSE_RANK function will produce same value when there are ties in the ordering values, and the difference between the two is that RANK reflects the count of rows that have a lower ordering value than the current row (plus 1), whereas DENSE_RANK reflects the count of distinct ordering values that are lower than the current row (plus 1). The NTILE function assigns a tile number to each row associated the rows in the result with tiles (equally sized groups of rows). If the number of rows can’t be evenly divided by the number of tiles, an extra row is added to each of the first tiles from the remainder. For example, if 102 rows and five tiles were requested, the first two tiles would have 21 rows instead of 20. Window functions are logically evaluated as part of the SELECT list, before the DISTINCT clause is evaluated. -- DISTINCT clause has no effect here, no duplicate rows to remove SELECT DISTINCT val, ROW_NUMBER() OVER(ORDER BY val) AS rownum FROM Sales.OrderValues; -- an alternative solution: GROUP BY phase is processed before the SELECT phase SELECT val, ROW_NUMBER() OVER(ORDER BY val) AS rownum FROM Sales.OrderValues GROUP BY val; 9.1.2. Offset T-SQL supports two pairs of offset functions: LAG and LEAD, and FIRST_VALUE and LAST_VALUE, to return an element from a row that is at a certain offset from the current row or at the beginning or end of a window frame. The LAG and LEAD functions look before and ahead respectively to obtain an element from a row that is at a certain offset from the current row within the partition, based on the indicated ordering. -- the LAG and LEAD functions support window partitions and window-order clauses. LAG(column_name, offset, default_value) OVER(...) LEAD(column_name, offset, default_value) OVER(...) column_name: the functions (which is mandatory) is the element to return. offset: (Optional) An integer specifying the number (1 if not specified) of rows to offset from the current row. default_value: (Optional) A value to be returned if there is no row at the requested offset (which is NULL if not specified otherwise). SELECT custid, orderid, val, LAG(val) OVER(PARTITION BY custid -- same as: LAG(val, 1, NULL) ORDER BY orderdate, orderid) AS prevval, LEAD(val) OVER(PARTITION BY custid -- same as: LEAD(val, 1, NULL) ORDER BY orderdate, orderid) AS nextval FROM Sales.OrderValues ORDER BY custid, orderdate, orderid; custid orderid val prevval nextval . . . 1 10952 471.20 845.80 933.50 1 11011 933.50 471.20 NULL 2 10308 88.80 NULL 479.75 2 10625 479.75 88.80 320.00 . . . The FIRST_VALUE and LAST_VALUE functions return an element from the first and last rows in the window frame, respectively. To obtain the element from the first row in the window partition, use FIRST_VALUE with the window-frame extent ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. To obtain the element from the last row in the window partition, use LAST_VALUE with the window-frame extent ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING. SELECT custid, orderid, val, FIRST_VALUE(val) OVER(PARTITION BY custid ORDER BY orderdate, orderid ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS firstval, LAST_VALUE(val) OVER(PARTITION BY custid ORDER BY orderdate, orderid ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS lastval FROM Sales.OrderValues ORDER BY custid, orderdate, orderid custid orderid val firstval lastval 1 10643 814.50 814.50 933.50 . . . 1 11011 933.50 814.50 933.50 2 10308 88.80 88.80 514.40 . . . 9.1.3. Aggregate The aggregate window functions aggregate the rows in the defined window, and support window-partition, window-order, and window-frame clauses. SELECT orderid, custid, val, 100. * val / SUM(val) OVER() AS pctall, -- percentage out of the grand total 100. * val / SUM(val) OVER(PARTITION BY custid) AS pctcust -- percentage out of the customer total FROM Sales.OrderValues; SELECT empid, ordermonth, val, SUM(val) OVER(PARTITION BY empid ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS runval FROM Sales.EmpOrders; 9.1.4. WINDOW The WINDOW clause defines and names reusable entire window specifications or part of them, improving code readability and maintainability by reducing redundancy in complex queries with multiple window functions. It is available in SQL Server 2022 and higher, as well as in Azure SQL Database, provided that the database compatibility level is set to 160 or higher. SELECT DATABASEPROPERTYEX(N&#39;TSQLV6&#39;, N&#39;CompatibilityLevel&#39;); -- 160 When considering all major query clauses (SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY), place the WINDOW clause between the HAVING and ORDER BY clauses of the query. SELECT empid, ordermonth, val, SUM(val) OVER W AS runsum, MIN(val) OVER W AS runmin, MAX(val) OVER W AS runmax, AVG(val) OVER W AS runavg FROM Sales.EmpOrders WINDOW W AS (PARTITION BY empid -- name an entire window specification ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW); SELECT custid, orderid, val, FIRST_VALUE(val) OVER(PO ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS firstval, LAST_VALUE(val) OVER(PO ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS last FROM Sales.OrderValues WINDOW PO AS (PARTITION BY custid -- name part of a window specification ORDER BY orderdate, orderid) ORDER BY custid, orderdate, orderid; SELECT orderid, custid, orderdate, qty, val, ROW_NUMBER() OVER PO AS ordernum, MAX(orderdate) OVER P AS maxorderdate, SUM(qty) OVER POF AS runsumqty, SUM(val) OVER POF AS runsumval FROM Sales.OrderValues WINDOW P AS ( PARTITION BY custid ), -- recursively reuse one window name within another PO AS ( P ORDER BY orderdate, orderid ), POF AS ( PO ROWS UNBOUNDED PRECEDING ) ORDER BY custid, orderdate, orderid; 9.2. Pivoting Pivoting data involves rotating data from a state of rows to a state of columns, possibly aggregating values along the way, in many cases which is generally handled by the presentation layer for purposes such as reporting. -- create and populate the sample table dbo.Orders USE TSQLV6; DROP TABLE IF EXISTS dbo.Orders; CREATE TABLE dbo.Orders ( orderid INT NOT NULL CONSTRAINT PK_Orders PRIMARY KEY, orderdate DATE NOT NULL, empid INT NOT NULL, custid VARCHAR(5) NOT NULL, qty INT NOT NULL ); INSERT INTO dbo.Orders(orderid, orderdate, empid, custid, qty) VALUES (30001, &#39;20200802&#39;, 3, &#39;A&#39;, 10), (10001, &#39;20201224&#39;, 2, &#39;A&#39;, 12), (10005, &#39;20201224&#39;, 1, &#39;B&#39;, 20), (40001, &#39;20210109&#39;, 2, &#39;A&#39;, 40), (10006, &#39;20210118&#39;, 1, &#39;C&#39;, 14), (20001, &#39;20210212&#39;, 2, &#39;B&#39;, 12), (40005, &#39;20220212&#39;, 3, &#39;A&#39;, 10), (20002, &#39;20220216&#39;, 1, &#39;C&#39;, 20), (30003, &#39;20220418&#39;, 2, &#39;B&#39;, 15), (30004, &#39;20200418&#39;, 3, &#39;C&#39;, 22), (30007, &#39;20220907&#39;, 3, &#39;D&#39;, 30); -- query and return the total order quantity for each employee and customer SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid; empid custid sumqty 2 A 52 3 A 20 1 B 20 2 B 27 1 C 34 3 C 22 3 D 30 Pivoted view of total quantity per employee (on rows) and customer (on columns) empid A B C D 1 NULL 20 34 NULL 2 52 27 NULL NULL 3 20 NULL 22 30 Every pivoting request involves three logical processing phases, each with associated elements: A grouping phase with an associated grouping or on rows element A spreading phase with an associated spreading or on cols element An aggregation phase with an associated aggregation element and aggregate function 9.2.1. Grouped Query SELECT empid, SUM( (3) CASE WHEN custid = &#39;A&#39; THEN qty END (2) ) AS A, SUM(CASE WHEN custid = &#39;B&#39; THEN qty END) AS B, SUM(CASE WHEN custid = &#39;C&#39; THEN qty END) AS C, SUM(CASE WHEN custid = &#39;D&#39; THEN qty END) AS D FROM dbo.Orders GROUP BY empid; (1) 1 The grouping phase is achieved with a GROUP BY clause—in this case, GROUP BY empid. 2 The spreading phase is achieved in the SELECT clause with a CASE expression for each target column. -- returns the quantity from the current row only when -- the current row represents an order for customer A; -- otherwise, the expression returns a NULL. CASE WHEN custid = &#39;A&#39; THEN qty END 3 Finally, the aggregation phase is achieved by applying the relevant aggregate function to the result of each CASE expression. -- produces the result column for customer A SUM(CASE WHEN custid = &#39;A&#39; THEN qty END) AS A 9.2.2. PIVOT Operator T- SQL also supports a proprietary table operator called PIVOT on a source table or table expression provided to it as its left input, pivots the data, and returns a result table. SELECT ... FROM &lt;input_table&gt; PIVOT(&lt;agg_function&gt;(&lt;aggregation_element&gt;) FOR &lt;spreading_element&gt; IN (&lt;list_of_target_columns&gt;)) WHERE ...; The PIVOT operator figures out the grouping elements implicitly by elimination, that are all attributes from the source table that were not specified as either the spreading element or the aggregation element. -- custid is the spreading element -- qty is the aggregation element -- the left empid is the implied grouping element SELECT empid, A, B, C, D FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; As a best practice with the PIVOT operator, always work with a table expression and not query the underlying table directly. -- the dbo.Orders table contains the attributes orderid, orderdate, empid, custid, and qty. -- the remaining attributes (orderid, orderdate, and empid) are all considered the grouping elements SELECT empid, A, B, C, D FROM dbo.Orders PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; The items in the list of the target columns must be referred to as identifiers in the IN clause, and be delimited using square brackets when they are irregular (contain spaces, special characters, or are reserved keywords). SELECT custid, [1], [2], [3], [4] FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR empid IN ([1], [2], [3], [4])) AS P; 9.3. Unpivoting Unpivoting is a technique that rotates data from a state of columns to a state of rows. -- create and populate the sample table dbo.EmpCustOrders USE TSQLV6; DROP TABLE IF EXISTS dbo.EmpCustOrders; CREATE TABLE dbo.EmpCustOrders ( empid INT NOT NULL CONSTRAINT PK_EmpCustOrders PRIMARY KEY, A VARCHAR(5) NULL, B VARCHAR(5) NULL, C VARCHAR(5) NULL, D VARCHAR(5) NULL ); INSERT INTO dbo.EmpCustOrders(empid, A, B, C, D) SELECT empid, A, B, C, D FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; SELECT * FROM dbo.EmpCustOrders; empid A B C D 1 NULL 20 34 NULL 2 52 27 NULL NULL 3 20 NULL 22 30 Unpivoted data returns a row for each employee and customer, along with the order quantity empid custid qty 1 B 20 1 C 34 2 A 52 2 B 27 3 A 20 3 C 22 3 D 30 9.3.1. APPLY Operator -- 1. Producing copies SELECT * FROM dbo.EmpCustOrders CROSS JOIN (VALUES(&#39;A&#39;),(&#39;B&#39;),(&#39;C&#39;),(&#39;D&#39;)) AS C(custid); -- empid A B C D custid -- 1 NULL 20 34 NULL A -- 1 NULL 20 34 NULL B -- 1 NULL 20 34 NULL C -- . . . -- 2. Extracting values SELECT empid, custid, qty FROM dbo.EmpCustOrders -- a join treats its two inputs as a set; -- use the CROSS APPLY operator instead of the CROSS JOIN operator -- to refer to the columns A, B, C, and D from the left side of the join (EmpCustOrders) CROSS APPLY (VALUES(&#39;A&#39;, A),(&#39;B&#39;, B),(&#39;C&#39;, C),(&#39;D&#39;, D)) AS C(custid, qty) -- empid custid qty -- 1 A NULL -- 1 B 20 -- 1 C 34 -- . . . -- 3. Eliminating irrelevant rows SELECT empid, custid, qty FROM dbo.EmpCustOrders CROSS APPLY (VALUES(&#39;A&#39;, A),(&#39;B&#39;, B),(&#39;C&#39;, C),(&#39;D&#39;, D)) AS C(custid, qty) WHERE qty IS NOT NULL; -- discard rows with a NULL in the qty column -- empid custid qty -- 1 B 20 -- 1 C 34 -- 2 A 52 -- . . . 9.3.2. UNPIVOT Operator T- SQL, like the PIVOT operator, also supports the UNPIVOT operator to unpivot data involved producing two result columns from any number of source columns—one to hold the source column names as strings and another to hold the source column values. SELECT ... FROM &lt;input_table&gt; UNPIVOT(&lt;values_column&gt; FOR &lt;names_column&gt; IN(&lt;source_columns&gt;) WHERE ...; SELECT empid, custid, qty FROM dbo.EmpCustOrders UNPIVOT(qty FOR custid IN(A, B, C, D)) AS U; 9.4. Grouping Sets A grouping set is a set of expressions to group the data by in a grouped query (a query with a GROUP BY clause). Traditionally in SQL, a single grouped query defines a single grouping set. -- set(empid, custid) SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid; -- set(empid) SELECT empid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid; -- set(custid) SELECT custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY custid; -- set() SELECT SUM(qty) AS sumqty FROM dbo.Orders; Use UNION ALL with NULL placeholders to combine multiple queries into a single result set for reporting, but potentially lead to two main problems—the length of the code and performance due to multiple scans for separated query. SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid UNION ALL SELECT empid, NULL, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid UNION ALL SELECT NULL, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY custid UNION ALL SELECT NULL, NULL, SUM(qty) AS sumqty FROM dbo.Orders; T-SQL supports the standard GROUPING SETS, CUBE, and ROLLUP subclauses of the GROUP BY clause, and the GROUPING and GROUPING_ID functions to define multiple grouping sets in the same query for reporting and data analysis. The GROUPING SETS subclause is a powerful enhancement to the GROUP BY clause to define multiple grouping sets in the same query. The grouping sets are listed, separated by commas within the parentheses of the GROUPING SETS subclause, and for each grouping set list the members, separated by commas, within parentheses. SQL Server typically needs fewer scans of the data than the number of grouping sets because it can roll up aggregates internally. SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY GROUPING SETS ( (empid, custid), (empid), (custid), () ); The CUBE subclause of the GROUP BY clause provides an abbreviated way to define multiple grouping sets. In the parentheses of the CUBE subclause, provide a set of members separated by commas, and get all possible grouping sets that can be defined based on the input members. In set theory, the set of all subsets of elements that can be produced from a particular set is called the power set. For example, CUBE(a, b, c) is equivalent to GROUPING SETS( (a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), () ). SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); The ROLLUP subclause of the GROUP BY clause also provides an abbreviated way to define multiple grouping sets. Unlike CUBE, which produces all possible grouping sets, ROLLUP assumes a hierarchy among input members and produces only grouping sets that form leading combinations of those members. For example, whereas CUBE(a, b, c) produces all eight possible grouping sets, ROLLUP(a, b, c) produces only four based on the hierarchy a&gt;b&gt;c that is the equivalent of specifying GROUPING SETS( (a, b, c), (a, b), (a), () ) rolling up the aggregations from the most granular level (a, b, c) to higher levels like (a, b) and finally to the total (). -- ROLLUP(YEAR(orderdate), MONTH(orderdate), DAY(orderdate)) -- =&gt; -- GROUPING SETS( -- (YEAR(orderdate), MONTH(orderdate), DAY(orderdate)), -- (YEAR(orderdate), MONTH(orderdate)), -- (YEAR(orderdate)), -- () ) SELECT YEAR(orderdate) AS orderyear, MONTH(orderdate) AS ordermonth, DAY(orderdate) AS orderday, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY ROLLUP(YEAR(orderdate), MONTH(orderdate), DAY(orderdate)) The GROUPING and GROUPING_ID functions are used to identify which columns in a GROUP BY clause are included in a group set or or are represented by a NULL placeholder in the aggregated result set. GROUPING: returns 1 when the element isn’t part of the grouping set and 0 otherwise. SELECT GROUPING(empid) AS grpemp, GROUPING(custid) AS grpcust, empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); grpemp grpcust empid custid sumqty 0 0 2 A 52 0 0 3 A 20 1 0 NULL A 72 . . . GROUPING_ID: returns an integer bitmap in which each bit represents a different input element—the rightmost element represented by the rightmost bit. SELECT GROUPING_ID(empid, custid) AS groupingset, empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); groupingset empid custid sumqty 0 2 A 52 -- 00 0 3 A 20 -- 00 2 NULL A 72 -- 10 . . . 9.5. Time Series Time series data is data representing a series of events, or measurements, typically taken at regular time intervals. Time series data analysis usually involves organizing the data in groups, also known as buckets, and then aggregating some measures per bucket. 10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE SQL has a set of statements known as Data Manipulation Language (DML) that includes the statements SELECT, INSERT, UPDATE, DELETE, TRUNCATE, and MERGE. 10.1. INSERT T-SQL provides several statements for inserting data into tables: INSERT VALUES, INSERT SELECT, INSERT EXEC, SELECT INTO, and BULK INSERT. 10.1.1. INSERT VALUES The standard INSERT VALUES statement is used to insert rows into a table based on specified values. INSERT INTO dbo.Orders(orderid, orderdate, empid, custid) VALUES(10001, &#39;20220212&#39;, 3, &#39;A&#39;); Specifying the target column names right after the table name is optional, but by doing so, it can control the value-column associations instead of relying on the order of the columns in the CREATE TABLE statement. In T-SQL, specifying the INTO clause is optional. If a value for a column is NOT specified, Microsoft SQL Server will use a default value if one was defined for the column. If a default value isn’t defined and the column allows NULLs, a NULL will be used. If no default is defined and the column does not allow NULLs and does not somehow get its value automatically, the INSERT statement will fail. T-SQL supports an enhanced standard VALUES clause that can be used to specify multiple rows separated by commas. The enhanced standard VALUES statement is processed as a transaction, meaning that if any row fails to enter the table, none of the rows in the statement enters the table. INSERT INTO dbo.Orders (orderid, orderdate, empid, custid) VALUES (10003, &#39;20220213&#39;, 4, &#39;B&#39;), (10004, &#39;20220214&#39;, 1, &#39;A&#39;), (10005, &#39;20220213&#39;, 1, &#39;C&#39;), (10006, &#39;20220215&#39;, 3, &#39;C&#39;); The enhanced VALUES clause can be used as a table-value constructor to construct a derived table. SELECT * FROM ( VALUES (10003, &#39;20220213&#39;, 4, &#39;B&#39;), (10004, &#39;20220214&#39;, 1, &#39;A&#39;), (10005, &#39;20220213&#39;, 1, &#39;C&#39;), (10006, &#39;20220215&#39;, 3, &#39;C&#39;) ) AS O(orderid, orderdate, empid, custid); -- alias(es) to the table, and the target columns 10.1.2. INSERT SELECT The standard INSERT SELECT statement inserts a set of rows returned by a SELECT query into a target table. The INSERT SELECT statement is performed as a transaction, so if any row fails to enter the target table, none of the rows enters the table. INSERT INTO dbo.Orders(orderid, orderdate, empid, custid) SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE shipcountry = N&#39;UK&#39;; If a system function such as SYSDATETIME is included in the inserted query, the function gets invoked only once for the entire query and not once per row. The exception to this rule is if globally unique identifiers (GUIDs) is generated using the NEWID function, which gets invoked per row. 10.1.3. INSERT EXEC The INSERT EXEC statement is used to insert a result set returned from a stored procedure or a dynamic SQL batch into a target table. CREATE OR ALTER PROC Sales.GetOrders @country AS NVARCHAR(40) AS SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE shipcountry = @country; GO INSERT INTO dbo.Orders (orderid, orderdate, empid, custid) EXEC Sales.GetOrders @country = N&#39;France&#39;; 10.1.4. SELECT INTO The SELECT INTO statement is a nonstandard (not part of the ISO and ANSI SQL) T-SQL statement that CREATEs a target table and populates it with the result set of a query. DROP TABLE IF EXISTS dbo.Orders; SELECT orderid, orderdate, empid, custid INTO dbo.Orders FROM Sales.Orders; -- SELECT INTO statement with set operations DROP TABLE IF EXISTS dbo.Locations; SELECT country, region, city INTO dbo.Locations FROM Sales.Customers EXCEPT SELECT country, region, city FROM HR.Employees; The target table’s structure and data are based on the source table. The SELECT INTO statement copies from the source the base structure (such as column names, types, nullability, and identity property) and the data, but does not copy from the source constraints, indexes, triggers, column properties, and permissions. 10.1.5. BULK INSERT The BULK INSERT statement is a server-side T-SQL command for high-speed data loading that requires the data file to reside on a local or network path accessible to the SQL Server service account, as the path is resolved by the server, not the client. BULK INSERT dbo.Orders FROM &#39;\ServerName\Share\orders.txt&#39; -- Path must be accessible by the SQL Server service WITH ( DATAFILETYPE = &#39;char&#39;, FIELDTERMINATOR = &#39;,&#39;, ROWTERMINATOR = &#39;\n&#39;, BATCHSIZE = 10000, TABLOCK ); While BULK INSERT on an on-premises SQL Server requires a local or UNC path, it can natively access files in Azure Blob Storage when used with Azure SQL Database or Azure SQL Managed Instance. -- Example for Azure SQL -- 1. Define the external data source (once) CREATE EXTERNAL DATA SOURCE MyBlobStorage WITH ( TYPE = BLOB_STORAGE, LOCATION = &#39;https://myaccount.blob.core.windows.net/mycontainer&#39; -- Plus credential setup ); -- 2. Use it in BULK INSERT BULK INSERT dbo.Orders FROM &#39;data/orders.csv&#39; -- Path is relative to the container WITH (DATA_SOURCE = &#39;MyBlobStorage&#39;); bcp and SqlBulkCopy bcp (Bulk Copy Program) is a client-side command-line utility for script-automated data transfer, streaming filesystem-based files from a client machine to SQL Server. # Import data from a local client file to the Orders table bcp MyDatabase.dbo.Orders in C:\Data\orders.csv -c -T -S MyServerName SqlBulkCopy is an ADO.NET class offering maximum ETL flexibility by enabling applications to programmatically stream data directly into SQL Server from in-memory sources like a DataTable or any IDataReader implementation. This example demonstrates a robust and highly performant pattern for upserting (inserting or updating) data in SQL Server. It uses SqlBulkCopy to quickly upload a batch of data into a temporary staging table and then uses a MERGE statement to apply those changes to a final destination table. The destination table is configured as a system-versioned temporal table, which automatically keeps a full history of all data changes. -- Create the main table to store product data CREATE TABLE dbo.Products ( Id INT PRIMARY KEY, Name NVARCHAR(255) NOT NULL, Category NVARCHAR(100) NOT NULL, Price DECIMAL(18, 2) NOT NULL, LastModified DATETIME2 NOT NULL, -- Columns for system-versioning ValidFrom DATETIME2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL, ValidTo DATETIME2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL, PERIOD FOR SYSTEM_TIME (ValidFrom, ValidTo) ) WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.ProductsHistory)); /// &lt;summary&gt; /// Represents a product entity. /// &lt;/summary&gt; public class Product { public int Id { get; set; } public string Name { get; set; } public string Category { get; set; } public decimal Price { get; set; } public DateTime LastModified { get; set; } } /// &lt;summary&gt; /// Performs a high-performance bulk &quot;upsert&quot; operation for a list of products. /// It stages the data in a temporary table and then merges it into the final destination table. /// &lt;/summary&gt; /// &lt;param name=&quot;connection&quot;&gt;An open SqlConnection to use.&lt;/param&gt; /// &lt;param name=&quot;products&quot;&gt;An enumerable of Product objects to upsert.&lt;/param&gt; public async Task UpsertProductsAsync(SqlConnection connection, IEnumerable&lt;Product&gt; products) { // Create an in-memory DataTable to hold the data var productData = new DataTable(); productData.Columns.Add(&quot;Id&quot;, typeof(int)); productData.Columns.Add(&quot;Name&quot;, typeof(string)); productData.Columns.Add(&quot;Category&quot;, typeof(string)); productData.Columns.Add(&quot;Price&quot;, typeof(decimal)); productData.Columns.Add(&quot;LastModified&quot;, typeof(DateTime)); foreach (var p in products) { productData.Rows.Add(p.Id, p.Name, p.Category, p.Price, p.LastModified); } await using var transaction = (SqlTransaction)await connection.BeginTransactionAsync(); try { // 1. Create a temporary table to stage the data var createTempTableCmd = connection.CreateCommand(); createTempTableCmd.Transaction = transaction; createTempTableCmd.CommandText = @&quot; CREATE TABLE #ProductStaging ( Id INT PRIMARY KEY, Name NVARCHAR(255) NOT NULL, Category NVARCHAR(100) NOT NULL, Price DECIMAL(18, 2) NOT NULL, LastModified DATETIME2 NOT NULL );&quot;; await createTempTableCmd.ExecuteNonQueryAsync(); // 2. Bulk load the data from the DataTable into the staging table await using (var bulkCopy = new SqlBulkCopy(connection, SqlBulkCopyOptions.Default, transaction)) { bulkCopy.DestinationTableName = &quot;#ProductStaging&quot;; bulkCopy.BatchSize = 5000; // Add column mappings to ensure data goes into the correct columns bulkCopy.ColumnMappings.Add(&quot;Id&quot;, &quot;Id&quot;); bulkCopy.ColumnMappings.Add(&quot;Name&quot;, &quot;Name&quot;); bulkCopy.ColumnMappings.Add(&quot;Category&quot;, &quot;Category&quot;); bulkCopy.ColumnMappings.Add(&quot;Price&quot;, &quot;Price&quot;); bulkCopy.ColumnMappings.Add(&quot;LastModified&quot;, &quot;LastModified&quot;); await bulkCopy.WriteToServerAsync(productData); } // 3. Merge the staged data into the final Products table var mergeCmd = connection.CreateCommand(); mergeCmd.Transaction = transaction; mergeCmd.CommandText = @&quot; MERGE dbo.Products AS target USING #ProductStaging AS source ON target.Id = source.Id WHEN MATCHED THEN UPDATE SET target.Name = source.Name, target.Category = source.Category, target.Price = source.Price, target.LastModified = source.LastModified WHEN NOT MATCHED BY TARGET THEN INSERT (Id, Name, Category, Price, LastModified) VALUES (source.Id, source.Name, source.Category, source.Price, source.LastModified);&quot;; await mergeCmd.ExecuteNonQueryAsync(); // If all operations were successful, commit the transaction await transaction.CommitAsync(); } catch (Exception) { // If any operation fails, roll back the entire transaction await transaction.RollbackAsync(); throw; } } 10.2. DELETE and TRUNCATE T-SQL provides two statements for deleting rows from a table: DELETE and TRUNCATE. The DELETE statement is a standard statement used to delete data from a table based on an optional filter predicate. DELETE FROM dbo.Orders WHERE orderdate &lt; &#39;20210101&#39;; The DELETE statement tends to be expensive when deleting a large number of rows, mainly because it’s a fully logged operation. The standard TRUNCATE statement deletes all rows from a table without filter. TRUNCATE TABLE dbo.T1; The advantage that TRUNCATE has over DELETE is that the former is minimally logged, whereas the latter is fully logged, resulting in significant performance differences. TRUNCATE resets the identity value back to the original seed, but DELETE doesn’t—even when used without a filter. The TRUNCATE statement is not allowed when the target table is referenced by a foreign-key constraint, even if the referencing table is empty and even if the foreign key is disabled. The TRUNCATE statement can be used to truncate individual partitions in a partitioned table. TRUNCATE TABLE dbo.T1 WITH ( PARTITIONS(1, 3, 5, 7 TO 10) ); T-SQL supports a nonstandard DELETE syntax based on joins to delete rows from one table based on a filter against attributes in related rows from another table. DELETE FROM O FROM dbo.Orders AS O INNER JOIN dbo.Customers AS C ON O.custid = C.custid WHERE C.country = N&#39;USA&#39;; 10.3. UPDATE T-SQL supports a standard UPDATE statement to update rows in a table, and also supports nonstandard forms of the UPDATE statement with joins and with variables. The UPDATE statement is a standard statement to update a subset of rows in a table. To identify the subset of rows to update, specify a predicate in a WHERE clause. Specify the assignment of values to columns in a SET clause, separated by commas. UPDATE dbo.OrderDetails SET discount = discount + 0.05 WHERE productid = 51; T-SQL supports compound assignment operators: += (plus equal), −= (minus equal), *= (multiplication equal), /= (division equal), %= (modulo equal), and others. UPDATE dbo.OrderDetails SET discount += 0.05 WHERE productid = 51; All-at-once operations: all expressions that appear in the same logical phase are evaluated as a set, logically at the same point in time. -- the assignments take place all at once, meaning that both assignments use the same value of col1—the value before the update. UPDATE dbo.T1 SET col1 = col1 + 10, col2 = col1 + 10; -- swap the values in the columns col1 and col2 UPDATE dbo.T1 SET col1 = col2, col2 = col1; The UPDATE statement also supports a nonstandard form based on joins that serves a filtering purpose. UPDATE OD SET discount += 0.05 FROM dbo.OrderDetails AS OD INNER JOIN dbo.Orders AS O ON OD.orderid = O.orderid WHERE O.custid = 1; -- same task by using standard code (recommended) UPDATE dbo.OrderDetails SET discount += 0.05 WHERE EXISTS (SELECT * FROM dbo.Orders AS O WHERE O.orderid = OrderDetails.orderid AND O.custid = 1); T-SQL supports a proprietary UPDATE syntax that both updates data in a table and assigns values to variables at the same time. DECLARE @nextval AS INT; UPDATE dbo.MySequences SET @nextval = val += 1 WHERE id = &#39;SEQ1&#39;; SELECT @nextval; 10.4. MERGE T-SQL supports a statement called MERGE to merge data from a source into a target, applying different actions (INSERT, UPDATE, and DELETE) based on conditional logic. A task achieved by a single MERGE statement typically translates to a combination of several other DML statements (INSERT, UPDATE, and DELETE) without MERGE. MERGE INTO dbo.Customers AS TGT USING dbo.CustomersStage AS SRC ON TGT.custid = SRC.custid WHEN MATCHED THEN UPDATE SET TGT.companyname = SRC.companyname, TGT.phone = SRC.phone, TGT.address = SRC.address WHEN NOT MATCHED THEN INSERT (custid, companyname, phone, address) VALUES (SRC.custid, SRC.companyname, SRC.phone, SRC.address); 11. System-Versioned Temporal Tables Temporal tables provide a powerful mechanism for tracking changes to data over time to easily capture and query historical versions of data, which is crucial for various scenarios such as auditing, data analysis, and data recovery. Track Data Changes: Capture all modifications (insertions, updates, deletions) to the data over time. Audit Data Modifications: Track who made changes, when they were made, and the previous state of the data for auditing and compliance purposes. Perform Point-in-Time Analysis: Analyze data as it existed at any point in the past. Data Recovery: Easily restore previous versions of data in case of accidental deletions or updates. Support Slowly Changing Dimensions: Efficiently manage slowly changing dimensions (SCDs) in data warehousing. The SQL standard supports three types of temporal tables: System-versioned temporal tables rely on the system transaction time to define the validity period of a row. Application-time period tables rely on the application’s definition of the validity period of a row. Bitemporal combines the two types just mentioned (transaction and valid time). SQL Server 2022 supports only system-versioned temporal tables. A system-versioned temporal table has two columns representing the validity period of the row, plus a linked history table with a mirrored schema holding older states of modified rows. To create a system-versioned temporal table, make sure the table definition has all the following elements: CREATE TABLE dbo.Employees ( empid INT NOT NULL CONSTRAINT PK_Employees PRIMARY KEY, (1) empname VARCHAR(25) NOT NULL, department VARCHAR(50) NOT NULL, salary NUMERIC(10, 2) NOT NULL, validfrom DATETIME2(0) GENERATED ALWAYS AS ROW START HIDDEN NOT NULL, (2) validto DATETIME2(0) GENERATED ALWAYS AS ROW END HIDDEN NOT NULL, (2) PERIOD FOR SYSTEM_TIME (validfrom, validto) (3) ) WITH ( SYSTEM_VERSIONING = ON (4) ( HISTORY_TABLE = dbo.EmployeesHistory, (5) HISTORY_RETENTION_PERIOD = 5 YEARS (6) ) ); 1 A primary key 2 Two columns defined as DATETIME2 with any precision, which are non-nullable and represent the start and end of the row’s validity period in the UTC time zone A start column that should be marked with the option GENERATED ALWAYS AS ROW START An end column that should be marked with the option GENERATED ALWAYS AS ROW END Optionally, the period columns can be marked as hidden so that when querying the table with SELECT * they won’t be returned and when inserting data they’ll be ignored. The modification times that SQL Server records in the period columns reflect the transaction start time. If a long-running transaction that started at point in time T1 and ended at T2, SQL Server will record T1 as the modification time for all statements. 3 A designation of the period columns with the option PERIOD FOR SYSTEM_TIME (&lt;startcol&gt;, &lt;endcol&gt;) 4 The table option SYSTEM_VERSIONING, which should be set to ON 5 A linked history table (which SQL Server can create automatically) to hold the past states of modified rows If do not specify a name for the table, SQL Server assigns one using the form MSSQL_TemporalHistoryFor_&lt;object_id&gt;, where object_id is the object ID of the current table. 6 Optionally, define a history retention policy using the HISTORY_RETENTION_PERIOD subclause of the SYSTEM_VERSIONING clause. To drop a system-versioned table, first disable system versioning with an ALTER TABLE command, and then manually drop the current and history tables. IF OBJECT_ID(N&#39;dbo.Employees&#39;, N&#39;U&#39;) IS NOT NULL BEGIN ALTER TABLE dbo.Employees SET ( SYSTEM_VERSIONING = OFF ); DROP TABLE IF EXISTS dbo.EmployeesHistory; DROP TABLE IF EXISTS dbo.Employees; END; When modifying data, interact with the current table, issuing normal data-modification statements. SQL Server automatically updates the period columns and moves older versions of rows to the history table. INSERT INTO dbo.Employees (empid, empname, department, salary) VALUES(1, &#39;Sara&#39;, &#39;IT&#39; , 50000.00), (2, &#39;Don&#39; , &#39;HR&#39; , 45000.00), (3, &#39;Judy&#39;, &#39;Sales&#39; , 55000.00), (4, &#39;Yael&#39;, &#39;Marketing&#39;, 55000.00), (5, &#39;Sven&#39;, &#39;IT&#39; , 45000.00), (6, &#39;Paul&#39;, &#39;Sales&#39; , 40000.00); -- current table has the six new rows SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees; -- history table is empty at this point SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory; -- SQL Server moves the deleted row to the history table, setting its validto value to the deletion time. DELETE FROM dbo.Employees WHERE empid = 6; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory; -- 6 Paul Sales 40000.00 2025-01-15 03:42:15 2025-01-15 03:44:53 -- An update of a row is treated as a delete plus an insert. UPDATE dbo.Employees SET salary *= 1.05 WHERE department = &#39;IT&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees WHERE department = &#39;IT&#39;; -- 1 Sara IT 52500.00 2025-01-15 03:47:42 9999-12-31 23:59:59 -- 5 Sven IT 47250.00 2025-01-15 03:47:42 9999-12-31 23:59:59 SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory WHERE department = &#39;IT&#39;; -- 1 Sara IT 50000.00 2025-01-15 03:42:15 2025-01-15 03:47:42 -- 5 Sven IT 45000.00 2025-01-15 03:42:15 2025-01-15 03:47:42 When querying data, for the current state, simply query the current table as usual, and to see a past state, correct to a certain point or period of time, query the current table followed by the FOR SYSTEM_TIME clause, plus a subclause that indicates more specifics. SQL Server will retrieve the data from both the current and history tables as needed. Table 1. Qualifying rows for FOR SYSTEM_TIME subclauses [&lt;datetime2 value&gt;] Subclause Qualifying rows AS OF @datetime validfrom &lt;= @datetime AND validto &gt; @datetime FROM @start TO @end validfrom &lt; @end AND validto &gt; @start BETWEEN @start AND @end validfrom &lt;= @end AND validto &gt; @start CONTAINED IN(@start, @end) validfrom &gt;= @start AND validto &lt;= @end ALL All rows from both tables (T-SQL*) DECLARE @datetime AS DATETIME2 = &#39;2025-01-15 03:45:00&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees FOR SYSTEM_TIME AS OF @datetime; -- same as DECLARE @datetime AS DATETIME2 = &#39;2025-01-15 03:45:00&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees WHERE validfrom &lt;= @datetime AND validto &gt; @datetime UNION ALL SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory WHERE validfrom &lt;= @datetime AND validto &gt; @datetime 12. Transactions and Concurrency A transaction is a unit of work that might include multiple activities that query and modify data and that can also change the data definition. Transaction boundaries can be defined either explicitly or implicitly. A transaction explicitly is defined beginning with a BEGIN TRAN (or BEGIN TRANSACTION) statement, and end explicitly with a COMMIT TRAN statement to commit it and with a ROLLBACK TRAN (or ROLLBACK TRANSACTION) statement to undo its changes. BEGIN TRAN; INSERT INTO dbo.T1(keycol, col1, col2) VALUES(4, 101, &#39;C&#39;); INSERT INTO dbo.T2(keycol, col1, col2) VALUES(4, 201, &#39;X&#39;); COMMIT TRAN; If the boundaries of a transaction isn&#8217;t marked explicitly, by default, SQL Server treats each individual statement as a transaction, which is known as an auto-commit mode. Transactions have four properties—atomicity, consistency, isolation, and durability— abbreviated with the acronym ACID: Atomicity: A transaction is an atomic unit of work. Either all changes in the transaction take place or none do. If the system fails before a transaction is completed (before the commit instruction is recorded in the transaction log), upon restart, SQL Server undoes the changes that took place. Also, if errors are encountered during the transaction and the error is considered severe enough, such as the target filegroup being full when trying to insert data, SQL Server automatically rolls back the transaction. Consistency: The term consistency refers to the state of the data that the relational database management system (RDBMS) as concurrent transactions modify and query it, which is a subjective term, and depends on an application’s needs. Isolation: Isolation ensures that transactions access only consistent data through a mechanism called isolation levels. With disk-based tables, SQL Server supports two different models to handle isolation: one based purely on locking, and another based on a combination of locking and row versioning. The model based on locking is the default in a box product. In this model, readers require shared locks. If the current state of the data is inconsistent, readers are blocked until the state of the data becomes consistent. The model based on locking and row versioning is the default in Azure SQL Database. In this model, readers don’t take shared locks and don’t need to wait. If the current state of the data is inconsistent, the reader gets an older consistent state. Durability: The durability property means that once a commit instruction is acknowledged by the database engine, the transaction’s changes are guaranteed to be durable—or in other words, persist—in the database. A commit is acknowledged by getting control back to the application and running the next line of code. Data changes are always written to the database’s transaction log on disk before they are written to the data portion of the database on disk. After the commit instruction is recorded in the transaction log on disk, the transaction is considered durable even if the change hasn’t yet made it to the data portion on disk. When the system starts, either normally or after a system failure, SQL Server runs a recovery process in each database that involves analyzing the log, then applying a redo phase, and then applying an undo phase. The redo phase involves rolling forward (replaying) all the changes from any transaction whose commit instruction is written to the log but whose changes haven’t yet made it to the data portion. The undo phase involves rolling back (undoing) the changes from any transaction whose commit instruction was not recorded in the log. -- Start a new transaction BEGIN TRAN; -- Declare a variable DECLARE @neworderid AS INT; -- Insert a new order into the Sales.Orders table INSERT INTO Sales.Orders (custid, empid, orderdate, requireddate, shippeddate, shipperid, freight, shipname, shipaddress, shipcity, shippostalcode, shipcountry) VALUES (85, 5, &#39;20220212&#39;, &#39;20220301&#39;, &#39;20220216&#39;, 3, 32.38, N&#39;Ship to 85-B&#39;, N&#39;6789 rue de l&#39;&#39;Abbaye&#39;, N&#39;Reims&#39;, N&#39;10345&#39;, N&#39;France&#39;); -- Save the new order ID in a variable SET @neworderid = SCOPE_IDENTITY(); -- Return the new order ID SELECT @neworderid AS neworderid; -- Insert order lines for the new order into Sales.OrderDetails INSERT INTO Sales.OrderDetails (orderid, productid, unitprice, qty, discount) VALUES(@neworderid, 11, 14.00, 12, 0.000), (@neworderid, 42, 9.80, 10, 0.000), (@neworderid, 72, 34.80, 5, 0.000); -- Commit the transaction COMMIT TRAN; 12.1. Locks and Blocking By default, a SQL Server box product uses a pure locking model to enforce the isolation property of transactions, whereas Azure SQL Database uses the row-versioning model by default. -- turn off the database property READ_COMMITTED_SNAPSHOT to switch to the locking model as the default ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT OFF; 12.1.1. Locks Locks are control resources obtained by a transaction to guard data resources, preventing conflicting or incompatible access by other transactions. 12.1.1.1. Lock Modes and Compatibility When trying to modify data, a transaction requests an exclusive lock on the data resource, regardless of the isolation level. If granted, the exclusive lock is held until the end of the transaction. For single- statement transactions, this means that the lock is held until the statement completes. For multistatement transactions, this means that the lock is held until all statements complete and the transaction is ended by a COMMIT TRAN or ROLLBACK TRAN command. As for reading data, the defaults are different for a SQL Server box product and Azure SQL Database. In SQL Server, the default isolation level is called READ COMMITTED. In this isolation, when trying to read data, by default a transaction requests a shared lock on the data resource and releases the lock as soon as the read statement is done with that resource. In Azure SQL Database, the default isolation level is called READ COMMITTED SNAPSHOT. Instead of relying only on locking, this isolation level relies on a combination of locking and row versioning. Under this isolation level, readers do not require shared locks, and therefore they never wait; they rely on the row-versioning technology to provide the expected isolation. Under the READ COMMITTED isolation level, if a transaction modifies rows, until the transaction completes, another transaction can’t read the same rows. This approach to concurrency control is known as the pessimistic concurrency approach. Under the READ COMMITTED SNAPSHOT isolation level, if a transaction modifies rows, another transaction trying to read the data will get the last committed state of the rows that was available when the statement started. This approach to concurrency control is known as the optimistic concurrency approach. READ COMMITTED SNAPSHOT is an MVCC-based implementation of the READ COMMITTED isolation level in SQL Server. Table 2. Lock compatibility of exclusive and shared locks Requested mode Granted Exclusive (X) Granted Shared (S) Exclusive No No Shared No Yes A “No” in the intersection means that the locks are incompatible and the requested mode is denied; the requester must wait. A “Yes” in the intersection means that the locks are compatible and the requested mode is accepted. 12.1.1.2. Lockable Resource Types SQL Server can lock different types of resources that include rows (RID in a heap, key in an index), pages, objects (for example, tables), databases, and others. Rows reside within pages, and pages are the physical data blocks that contain table or index data. To obtain a lock on a certain resource type, a transaction must first obtain intent locks of the same mode on higher levels of granularity to efficiently detect incompatible lock requests on higher levels of granularity and prevent the granting of those. SQL Server determines dynamically which resource types to lock. Naturally, for ideal concurrency, it’s best to lock only what needs to be locked—namely, only the affected rows. However, locks require memory resources and internal management overhead. So SQL Server considers both concurrency and system resources when it’s choosing which resource types to lock. When SQL Server estimates that a transaction will interact with a small number of rows, it tends to use row locks. With larger numbers of rows, SQL Server tends to use page locks. SQL Server might first acquire fine-grained locks (such as row or page locks) and, in certain circumstances, try to escalate the fine-grained locks to a table lock to preserve memory. 12.1.2. Blocking When one transaction holds a lock on a data resource and another transaction requests an incompatible lock on the same resource, the request is blocked and the requester enters a wait state. By default, the blocked request keeps waiting until the blocker releases the interfering lock. To restrict the amount of time the session waits for a lock, set a session option called LOCK_TIMEOUT. Specify a value in milliseconds—such as 5000 for 5 seconds, 0 for an immediate timeout, and –1 for no timeout (which is the default). SET LOCK_TIMEOUT 5000; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Msg 1222, Level 16, State 51, Line 3 Lock request time out period exceeded. To remove the lock timeout value, set it back to the default (no timeout), and issue the query again. SET LOCK_TIMEOUT -1; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; The dynamic management view (DMV) sys.dm_tran_locks can be used to get lock information, including both locks granted to sessions and locks sessions waiting for. -- Connection 1: hold exclusive lock to write BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; -- no COMMIT TRAN or ROLLBACK TRAN, the transaction remains open, and the lock is still held -- Connection 2: needs a shared lock to read, but be blocked and has to wait SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 3 SELECT -- use * to explore other available attributes request_session_id AS sid, resource_type AS restype, resource_database_id AS dbid, DB_NAME(resource_database_id) AS dbname, resource_description AS res, resource_associated_entity_id AS resid, request_mode AS mode, request_status AS status FROM sys.dm_tran_locks; sid restype dbid dbname res resid mode status 52 DATABASE 6 TSQLV6 0 S GRANT 56 DATABASE 6 TSQLV6 0 S GRANT 59 DATABASE 6 TSQLV6 0 S GRANT 52 PAGE 6 TSQLV6 1:456 72057594046251008 IS GRANT 56 PAGE 6 TSQLV6 1:456 72057594046251008 IX GRANT 52 OBJECT 6 TSQLV6 1029578706 IS GRANT 56 OBJECT 6 TSQLV6 1029578706 IX GRANT 56 KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 X GRANT 52 KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 S WAIT Each session is identified by a unique session ID. A session’s ID can be determined by querying the function @@SPID. If working with SQL Server Management Studio, the session ID could be found in parentheses to the right of the login name in the status bar at the bottom of the query window that has the focus, and also in the caption of the connected query window. By observing that both sessions lock a row with the same res and resid values, session 52 is waiting for a shared lock on a row in the sample database TSQLV6 that is being held as an exclusive lock by session 56. The involved table can be figured out by moving upward in the lock hierarchy for either session 52 or 56 and inspecting the intent locks on the object (table) where the row resides. The OBJECT_NAME function can be used to translate the object ID (1029578706, in this example) that appears under the resid attribute in the object lock, that is Production.Products. SELECT OBJECT_NAME(1029578706); -- Products The sys.dm_tran_locks view gives the information about the IDs of the sessions involved in the blocking chain, that is, two or more sessions that are involved in the blocking situation, such as session x blocking session y, session y blocking session z, and so on—hence the use of the term chain. The DMV sys.dm_exec_connections can be used to get information about the connections associated with those session IDs and filter only the session IDs that are involved: SELECT -- use * to explore session_id AS sid, connect_time, last_read, last_write, most_recent_sql_handle FROM sys.dm_exec_connections WHERE session_id IN(52, 56); 52 2025-01-13 14:50:57.367 2025-01-13 14:54:07.930 2025-01-13 14:54:07.923 0x0200000063FC7D052E09844778CDD615CFE7A2D1FB4118020000000000000000000000000000000000000000 56 2025-01-13 14:53:33.587 2025-01-13 14:53:52.560 2025-01-13 14:53:52.560 0x020000008FAC322CF2FC73472F8E93B0DF1994A69639ED090000000000000000000000000000000000000000 A binary value holding a handle to the most recent SQL batch run by the connection. The handle can be provided as an input parameter to a table function called sys.dm_exec_sql_text, and the function returns the batch of code represented by the handle. SELECT session_id, text FROM sys.dm_exec_connections CROSS APPLY sys.dm_exec_sql_text(most_recent_sql_handle) AS ST WHERE session_id IN(52, 56); 52 (@1 tinyint)SELECT [productid],[unitprice] FROM [Production].[Products] WHERE [productid]=@1 56 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; Starting with SQL Server 2016, the function sys.dm_exec_input_buffer instead of sys.dm_exec_sql_text can be used to get the code that the sessions of interest submitted last. SELECT session_id, event_info FROM sys.dm_exec_connections CROSS APPLY sys.dm_exec_input_buffer(session_id, NULL) AS IB WHERE session_id IN(52, 56); The DMV sys.dm_exec_sessions can be used to find a lot of useful information about the sessions involved in a blocking situation. SELECT -- use * to explore session_id AS sid, login_time, host_name, program_name, login_name, nt_user_name, last_request_start_time, last_request_end_time FROM sys.dm_exec_sessions WHERE session_id IN(52, 56); Another DMV sys.dm_exec_requests can probably be used to find useful for troubleshooting blocking situations. SELECT -- use * to explore session_id AS sid, blocking_session_id, command, sql_handle, database_id, wait_type, wait_time, wait_resource FROM sys.dm_exec_requests WHERE blocking_session_id &gt; 0; To terminate the blocker—for example, if realizing that as a result of a bug in the application the transaction remained open and nothing in the application can close it—do so by using the KILL &lt;session_id&gt; command. KILL 56; 12.2. Isolation Levels Isolation levels determine the level of consistency when interacting with data. In the default isolation level in a box product, a reader uses shared locks on the target resources and a writer uses exclusive locks. SQL Server supports four isolation levels that are based on the pure locking model: READ UNCOMMITTED, READ COMMITTED (the default in a SQL Server box product), REPEATABLE READ, and SERIALIZABLE. SQL Server also supports two isolation levels that are based on a combination of locking and row versioning: SNAPSHOT and READ COMMITTED SNAPSHOT (the default in Azure SQL Database). SNAPSHOT and READ COMMITTED SNAPSHOT are in a sense the row-versioning counterparts of READ COMMITTED and SERIALIZABLE, respectively. The isolation level of the whole session can be set by using the following command: SET TRANSACTION ISOLATION LEVEL &lt;isolationname&gt;; The isolation level of a query can be set by using a table hint: SELECT ... FROM &lt;table&gt; WITH (&lt;isolationname&gt;); With the first four isolation levels, the higher the isolation level, the stricter the locks are that readers request and the longer their duration is; therefore, the higher the isolation level is, the higher the consistency is and the lower the concurrency is. With the two row-versioning-based isolation levels, SQL Server is able to store previous committed versions of rows in a version store. Readers do not request shared locks; instead, if the current version of the rows is not what they are supposed to see, SQL Server provides them with an older version. Table 3. Isolation level properties Isolation level Allows uncommitted reads? Allows nonrepeatable reads? Allows lost updates? Allows phantom reads? Detects update conflicts? Uses row versioning? READ UNCOMMITTED Yes Yes Yes Yes No No READ COMMITTED No Yes Yes Yes No No REPEATABLE READ No No No Yes No No SERIALIZABLE No No No No No No SNAPSHOT No No No No Yes Yes READ COMMITTED SNAPSHOT No Yes Yes Yes No Yes 12.2.1. READ UNCOMMITTED READ UNCOMMITTED is the lowest available isolation level, that is, a reader doesn’t ask for a shared lock. A reader that doesn’t ask for a shared lock can never be in conflict with a writer that is holding an exclusive lock, so that the reader can read uncommitted changes (also known as dirty reads). It also means the reader won’t interfere with a writer that asks for an exclusive lock, that is, a writer can change data while a reader that is running under the READ UNCOMMITTED isolation level reads data. Open a transaction, update the unit price of product 2 by adding 1.00 to its current price (19.00), and then query the product’s row -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 Set the isolation level to READ UNCOMMITTED and query the row for product 2. The query returned the state of the row after the change, even though the change was not committed -- Connection 2 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 Keep in mind that Connection 1 might apply further changes to the row later in the transaction or even roll back at some point. -- Connection 1 ROLLBACK TRAN; The above rollback undoes the update of product 2, changing its price back to 19.00. The value 20.00 that the reader got was never committed which is called dirty read. 12.2.2. READ COMMITTED The lowest isolation level that prevents dirty reads is READ COMMITTED, which is also the default isolation level in SQL Server (the box product), to prevent uncommitted reads by requiring a reader to obtain a shared lock. -- Connection 1 -- open a transaction, update the price of product 2, and query the row to show the new price BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 2 -- Keep in mind that this isolation level is the default, so unless previously changed the session’s isolation level, it isn&#39;t needed to set it explicitly. -- The SELECT statement is currently blocked because it needs a shared lock to be able to read the row, and this shared lock request is in conflict with the exclusive lock held by the writer in Connection 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 1 -- commit the transaction COMMIT TRAN; -- Connection 2 2 20.00 -- restore the unitprice of the product 2 UPDATE Production.Products SET unitprice -= 1.00 -- 19.00 WHERE productid = 2; In terms of the duration of locks, in the READ COMMITTED isolation level, a reader holds the shared lock only until it’s done with the resource. It doesn’t keep the lock until the end of the transaction; in fact, it doesn’t even keep the lock until the end of the statement, that means that in between two reads of the same data resource in the same transaction, no lock is held on the resource. Therefore, another transaction can modify the resource in between those two reads, and the reader might get different values in each read, which is called nonrepeatable reads or inconsistent analysis. 12.2.3. REPEATABLE READ The isolation level REPEATABLE READ can be used to get repeatable reads, or consistent analysis to ensure that no one can change values in between reads that take place in the same transaction, that is, not only does a reader need a shared lock to be able to read, but it also holds the lock until the end of the transaction. The REPEATABLE READ but not by lower isolation levels can also prevent another phenomenon called a lost update that happens when two transactions read a value, make calculations based on what they read, and then update the value. In isolation levels lower than REPEATABLE READ no lock is held on the resource after the read, both transactions can update the value, and whichever transaction updates the value last “wins,” overwriting the other transaction’s update. In REPEATABLE READ, both sides keep their shared locks after the first read, so neither can acquire an exclusive lock later in order to update, which results in a deadlock, and the update conflict is prevented. -- Connection 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- keep holding a shared lock on the row for product 2 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 -- Connection 2 -- blocked the modifier’s request for an exclusive lock in conflict with the reader’s granted shared lock. UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; -- Connection 1 -- the second read got the same unit price for product 2 as the first read SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; -- commit the transaction and release the shared lock -- Connection 2 -- obtain the exclusive lock it was waiting for and update the row 12.2.4. SERIALIZABLE Under the REPEATABLE READ isolation level, readers keep shared locks until the end of the transaction that locks only resources (e.g., rows) that the query found the first time it ran, not rows that weren’t there when the query ran, so that a second read in the same transaction might return new rows as well, which happens if, in between the reads, another transaction inserts new rows that satisfy the reader’s query filter, which are called phantoms, and such reads are called phantom reads. The SERIALIZABLE isolation level can be used to prevent phantom reads, that requires a reader to obtain a shared lock on the whole range of keys that qualify for the query’s filter to be able to read, and it keeps the lock until the end of the transaction. -- Connection 1 -- set the transaction isolation level to SERIALIZABLE, open a transaction, and query all products with category 1 SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; BEGIN TRAN SELECT productid, productname, categoryid, unitprice FROM Production.Products WHERE categoryid = 1; -- Connection 2 -- In all isolation levels that are lower than SERIALIZABLE, such an attempt would be successful. -- In the SERIALIZABLE isolation level, the attempt is blocked. INSERT INTO Production.Products (productname, supplierid, categoryid, unitprice, discontinued) VALUES(&#39;Product ABCDE&#39;, 1, 1, 20.00, 0); sid restype dbid dbname res resid mode status 55 (Connection 1) KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 RangeS-S GRANT 64 (Connection 2) KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 X WAIT -- Connection 1 -- get the same output as before, with no phantoms SELECT productid, productname, categoryid, unitprice FROM Production.Products WHERE categoryid = 1; COMMIT TRAN; -- transaction is committed and the shared key-range lock is released 12.2.5. Multi-Version Concurrency Control With the row-versioning technology, SQL Server can store previous versions of committed rows in a version store. If the Accelerated Database Recovery (ADR) feature is not enabled in the database, the version store resides in the tempdb database. If ADR is enabled, the version store resides in the user database in question. SQL Server supports two isolation levels, called SNAPSHOT and READ COMMITTED SNAPSHOT, that are based on this row-versioning technology. The SNAPSHOT isolation level is logically similar to the SERIALIZABLE isolation level in terms of the types of consistency problems that can or cannot happen. The READ COMMITTED SNAPSHOT isolation level is similar to the READ COMMITTED isolation level. Readers using isolation levels based on row versioning do not acquire shared locks, so they don’t wait when the requested data is exclusively locked. In other words, readers don’t block writers and writers don’t block readers. Readers still get levels of consistency similar to SERIALIZABLE and READ COMMITTED. SQL Server provides readers with an older version of the row if the current version is not the one they are supposed to see. Note that if enabling any of the row-versioning-based isolation levels (which are enabled in Azure SQL Database by default), the DELETE and UPDATE statements need to copy the version of the row before the change to the version store (Copy-on-Write); INSERT statements don’t need to write anything to the version store, because no earlier version of the row exists. But it’s important to be aware that enabling any of the isolation levels that are based on row versioning might have a negative impact on the performance of updates and deletes. The performance of readers usually improves, sometimes dramatically, because they do not acquire shared locks and don’t need to wait when data is exclusively locked or its version is not the expected one. 12.2.5.1. SNAPSHOT The SNAPSHOT isolation level, relies on row versioning instead of using shared locks, guarantees the reader to get the last committed version of the row that was available when the transaction started to get committed reads and repeatable reads, and not phantom reads. To work with the SNAPSHOT isolation level in a SQL Server box product instance (enabled by default in Azure SQL Database), first enable the option at the database level by running the following code in any open query window: ALTER DATABASE TSQLV6 SET ALLOW_SNAPSHOT_ISOLATION ON; Open a transaction, update the price of product 2 by adding 1.00 to its current price of 19.00, and show the new price. -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 If someone begins a transaction using the SNAPSHOT isolation level, that session can request the version before the update. -- Connection 2 SET TRANSACTION ISOLATION LEVEL SNAPSHOT; BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 If a transaction were under the SERIALIZABLE isolation level, the query would be blocked. -- Connection 3 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; -- by default in SQL Server SET LOCK_TIMEOUT 5000; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Msg 1222, Level 16, State 51, Line 5 Lock request time out period exceeded. Go back to Connection 1, and commit the transaction. -- at this point, the current version of the row with the price of 20.00 is a committed version. COMMIT TRAN; Go back to Connection 2, and run the following code. -- still get the last committed version of the row that was available when the transaction started (with a price of 19.00). SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; 2 19.00 12.2.5.2. Conflict Detection The SNAPSHOT isolation level prevents update conflicts, but unlike the REPEATABLE READ and SERIALIZABLE isolation levels that do so by generating a deadlock, the SNAPSHOT isolation level generates a more specific error, indicating that an update conflict was detected by examining the version store to figure out whether another transaction modified the data between a read and a write that took place in a transaction. Set the transaction isolation level to SNAPSHOT, open a transaction, and read the row for product 2. -- Connection 1 SET TRANSACTION ISOLATION LEVEL SNAPSHOT; BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 Update the price of the product queried previously to 20.00, and commit the transaction. -- Connection 1 UPDATE Production.Products SET unitprice = 20.00 WHERE productid = 2; COMMIT TRAN; No other transaction modified the row between the read, calculation, and write; therefore, there was no update conflict and SQL Server allowed the update to take place. Restore the price of product 2 back to 19.00: UPDATE Production.Products SET unitprice = 19.00 WHERE productid = 2; Next, run the following code in Connection 1, again, to open a transaction, and read the row for product 2: -- Connection 1 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Next, run the following code in Connection 2 to update the price of product 2 to 25.00: -- Connection 2 UPDATE Production.Products SET unitprice = 25.00 WHERE productid = 2; Go back to Connection 1, and try to update the price of the product to 20.00: UPDATE Production.Products SET unitprice = 20.00 WHERE productid = 2; SQL Server detected that this time another transaction modified the data between the read and write; therefore, it fails the transaction with the following error: Msg 3960, Level 16, State 2, Line 1 Snapshot isolation transaction aborted due to update conflict. You cannot use snapshot isolation to access table &#39;Production.Products&#39; directly or indirectly in database &#39;TSQLV6&#39; to update, delete, or insert the row that has been modified or deleted by another transaction. Retry the transaction or change the isolation level for the update/delete statement. 12.2.5.3. READ COMMITTED SNAPSHOT The READ COMMITTED SNAPSHOT isolation level is also based on row versioning, but differs from the SNAPSHOT isolation level in that instead of providing a reader with a transaction-level consistent view of the data, it provides the reader with a statement-level consistent view of the data, and also does not detect update conflicts. To make a reader to acquire a shared lock under READ COMMITTED SNAPSHOT, add a table hint called READCOMMITTEDLOCK to the SELECT statements, as in SELECT * FROM dbo.T1 WITH (READCOMMITTEDLOCK). To enable the use of the READ COMMITTED SNAPSHOT isolation level in a SQL Server box product (enabled by default in Azure SQL Database), turn on a database option called READ_COMMITTED_SNAPSHOT. ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT ON; Unlike the SNAPSHOT isolation level, this flag changes the meaning, or semantics, of the READ COMMITTED isolation level to READ COMMITTED SNAPSHOT, which means that when this database flag is turned on, unless explicitly changing the session’s isolation level, READ COMMITTED SNAPSHOT is the default. Run the following code in Connection 1 to open a transaction, update the row for product 2, and read the row, leaving the transaction open: -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 In Connection 2, open a transaction and read the row for product 2, leaving the transaction open: -- Connection 2 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 Run the following code in Connection 1 to commit the transaction: -- Connection 1 COMMIT TRAN; Now run the code in Connection 2 to read the row for product 2 again, and commit the transaction: -- Connection 2 -- get the last committed version of the row that was available when the statement started (20.00) and not when the transaction started (19.00) SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; 2 19.00 Close all connections. Open a new connection, and run the following code to disable the isolation levels that are based on row versioning in the TSQLV6 database: ALTER DATABASE TSQLV6 SET ALLOW_SNAPSHOT_ISOLATION OFF; ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT OFF; 12.3. Deadlocks A deadlock is a situation in which two or more sessions block each other. An example of a two- session deadlock is when session A blocks session B and session B blocks session A. An example of a deadlock involving more than two sessions is when session A blocks session B, session B blocks session C, and session C blocks session A. In any of these cases, SQL Server detects the deadlock and intervenes by terminating one of the transactions. If SQL Server did not intervene, the sessions involved would remain deadlocked forever. Unless otherwise specified (DEADLOCK_PRIORITY), SQL Server chooses to terminate the transaction that did the least work (based on the activity written to the transaction log), because rolling that transaction’s work back is the cheapest option. Run the following code in Connection 1 to open a new transaction, update a row in the Production.Products table for product 2, and leave the transaction open: -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; Run the following code in Connection 2 to open a new transaction, update a row in the Sales.OrderDetails table for product 2, and leave the transaction open: -- Connection 2 BEGIN TRAN; UPDATE Sales.OrderDetails SET unitprice += 1.00 WHERE productid = 2; Run the following code in Connection 1 to attempt to query the rows for product 2 in the Sales.OrderDetails table, and commit the transaction: -- Connection 1 -- needs a shared lock to be able to perform its read, but blocked by Connection 2 SELECT orderid, productid, unitprice FROM Sales.OrderDetails WHERE productid = 2; COMMIT TRAN; Next, run the following code in Connection 2 to attempt to query the row for product 2 in the Production.Products table and commit the transaction: -- Connection 2 -- needs a shared lock to be able to perform its read, but blocked by Connection 1 SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; At this point, each of the sessions blocks the other —results a deadlock. SQL Server identifies the deadlock (typically within a few seconds), chooses one of the sessions involved as the deadlock victim, and terminates its transaction with the following error: Msg 1205, Level 13, State 51, Line 3 Transaction (Process ID 57) was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction. Deadlocks are expensive because they involve undoing work that has already been done and then, usually with some error-handling logic, redoing the work. Obviously, the longer the transactions are, the longer locks are kept, increasing the probability of deadlocks. Keep transactions as short as possible, taking activities out of the transaction that aren’t logically supposed to be part of the same unit of work. For example, don’t use transactions that require user input to finish! One typical deadlock, also called a deadly embrace deadlock (e.g., the above example), happens when transactions access resources in inverse order. By swapping the order in one of the transactions, you can prevent this type of deadlock from happening—assuming that it makes no logical difference to your application. Deadlocks often also happen when there is no real logical conflict (for example, trying to access the same rows), because of a lack of good indexing to support query filters. For example, suppose both statements in the transaction in Connection 2 filtered product 5. Now that the statements in Connection 1 handle product 2 and the statements in Connection 2 handle product 5, there shouldn’t be any conflict. However, if indexes aren&#8217;t defined on the productid column in the tables to support the filter, SQL Server has to scan (and lock) all rows in the table, that is, of course, can lead to a deadlock. While scanning the entire table, both connections might attempt to acquire locks on the same or overlapping table pages, leading to a deadlock situation even though they are working with different product data. In short, good index design can help mitigate the occurrences of deadlocks that have no real logical conflict. Another option to consider to mitigate deadlock occurrences is the choice of isolation level. The SELECT statements in the example needed shared locks because they ran under the READ COMMITTED isolation level. If using the READ COMMITTED SNAPSHOT isolation level, readers will not need shared locks, and deadlocks that evolve because of the involvement of shared locks can be eliminated. 13. Programmable Objects Programmable objects in SQL Server are reusable code blocks that extend the capabilities of the database beyond basic data storage and retrieval. 13.1. Variables A variable is used to temporarily store data values for later use in the same batch in which they were declared, and a batch is one or more T-SQL statements sent to Microsoft SQL Server for execution as a single unit. Use a DECLARE statement to declare one or more variables, and use a SET statement to assign a value to a single variable. -- declares two variables called @i and @j of INT data type and assigns it the value 10 and 20 DECLARE @i AS INT, @j AS INT; -- SET statement can operate on only one variable at a time SET @i = 10; SEt @j = 20; Alternatively, a variable can be declared and initialized in the same statement, like this: DECLARE @i AS INT = 10, @j AS INT = 20; When assign a value to a scalar variable, the value must be the result of a scalar expression. DECLARE @empname AS NVARCHAR(61); -- a scalar subquery SET @empname = (SELECT firstname + N&#39; &#39; + lastname FROM HR.Employees WHERE empid = 3); -- a scalar subquery fails at run time if it returns more than one value DECLARE @empname AS NVARCHAR(61); SET @empname = (SELECT firstname + N&#39; &#39; + lastname FROM HR.Employees WHERE mgrid = 2); Msg 512, Level 16, State 1, Line 2 Subquery returned more than 1 value. This is not permitted when the subquery follows =, !=, &lt;, &lt;= , &gt;, &gt;= or when the subquery is used as an expression. T-SQL also supports a nonstandard assignment SELECT statement to query data and assign multiple values obtained from the same row to multiple variables by using a single statement. DECLARE @firstname AS NVARCHAR(20), @lastname AS NVARCHAR(40); -- if the query has more than one qualifying row, the values in the variables are those from the last row that SQL Server happened to access. SELECT @firstname = firstname, @lastname = lastname FROM HR.Employees WHERE empid = 3; SELECT @firstname AS firstname, @lastname AS lastname; 13.2. Batchs A batch is one or more T-SQL statements sent by a client application to SQL Server for execution as a single unit. A transaction is an atomic unit of work. A batch can have multiple transactions, and a transaction can be submitted in parts as multiple batches. Client application programming interfaces (APIs) such as ADO.NET provide methods for submitting a batch of code to SQL Server for execution. SQL Server utilities such as SQL Server Management Studio (SSMS), Azure Data Studio (ADS), SQLCMD, and OSQL provide a client tool command called GO that signals the end of a batch. Note that the GO command is a client tool command and not a T-SQL server command, and do not terminate the GO command with a semicolon. A batch is a set of commands that are parsed and executed as a unit. If the parsing is successful, SQL Server then attempts to execute the batch. In the event of a syntax error in the batch, the whole batch is not submitted to SQL Server for execution. -- Valid batch PRINT &#39;First batch&#39;; USE TSQLV6; GO -- Invalid batch PRINT &#39;Second batch&#39;; SELECT custid FROM Sales.Customers; SELECT orderid FOM Sales.Orders; GO -- Valid batch PRINT &#39;Third batch&#39;; SELECT empid FROM HR.Employees; First batch Msg 102, Level 15, State 1, Line 8 Incorrect syntax near &#39;Sales&#39;. Third batch A variable is local to the batch in which it’s defined, that is, it can’t be referred to in another batch. DECLARE @i AS INT = 10; -- Succeeds PRINT @i; GO -- Fails PRINT @i; 10 Msg 137, Level 15, State 2, Line 6 Must declare the scalar variable &quot;@i&quot;. The CREATE statements cannot be combined with other statements in the same batch. -- CREATE DEFAULT, CREATE FUNCTION, CREATE PROCEDURE, CREATE RULE, CREATE SCHEMA, CREATE TRIGGER, and CREATE VIEW DROP VIEW IF EXISTS Sales.MyView; -- GO -- To get around the problem, add a GO command here CREATE VIEW Sales.MyView AS SELECT YEAR(orderdate) AS orderyear, COUNT (*) AS numorders FROM Sales.Orders GROUP BY YEAR(orderdate); GO Msg 111, Level 15, State 1, Line 3 &#39;CREATE VIEW&#39; must be the first statement in a query batch. A batch is a unit of resolution (also known as binding), that means that checking the existence of objects and columns happens at the batch level. When applying schema changes to an object and try to manipulate the object data in the same batch, SQL Server might not be aware of the schema changes yet and fail the data-manipulation statement with a resolution error. DROP TABLE IF EXISTS dbo.T1; CREATE TABLE dbo.T1(col1 INT); GO ALTER TABLE dbo.T1 ADD col2 INT; -- GO -- To get around the problem, add a GO command here SELECT col1, col2 FROM dbo.T1; -- Invalid column name &#39;col2&#39;. GO DROP TABLE IF EXISTS dbo.T1; The GO command is not really a T-SQL command; it’s actually a command used by SQL Server’s client tools, such as SSMS, to denote the end of a batch. It also supports an argument indicating how many times you want to execute the batch. DROP TABLE IF EXISTS dbo.T1; CREATE TABLE dbo.T1(col1 INT IDENTITY); GO SET NOCOUNT ON; INSERT INTO dbo.T1 DEFAULT VALUES; GO 100 SELECT SUM(col1) FROM dbo.T1; -- (1 + 100) * 100 / 2 = 5050 GO DROP TABLE IF EXISTS dbo.T1; 13.3. Flow Elements: IF and WHILE T-SQL provides basic forms of control with flow elements to control the flow of the code, including the IF . . . ELSE element and the WHILE element. The IF . . . ELSE element is used to control the flow of a code based on the result of a predicate. IF YEAR(SYSDATETIME()) &lt;&gt; YEAR(DATEADD(day, 1, SYSDATETIME())) -- a statement or statement block that is executed if the predicate is TRUE PRINT &#39;Today is the last day of the year.&#39;; -- optionally a statement or statement block that is executed if the predicate is FALSE or UNKNOWN. ELSE BEGIN -- mark the boundaries of a statement block with the BEGIN and END keywords IF MONTH(SYSDATETIME()) &lt;&gt; MONTH(DATEADD(day, 1, SYSDATETIME())) PRINT &#39;Today is the last day of the month but not the last day of the year.&#39;; ELSE PRINT &#39;Today is not the last day of the month.&#39;; END DECLARE @score AS INT = CAST(RAND() * 100 AS INT); IF @score &gt; 90 PRINT &#39;A&#39;; ELSE IF @score &gt; 80 PRINT &#39;B&#39;; ELSE IF @score &gt; 70 PRINT &#39;C&#39;; ELSE IF @score &gt; 60 PRINT &#39;D&#39;; ELSE PRINT &#39;F&#39;; -- CASE is expression, instead of statement DECLARE @score AS INT = CAST(RAND() * 100 AS INT); SELECT CASE WHEN @score &gt;= 90 THEN &#39;A&#39; WHEN @score &gt;= 80 THEN &#39;B&#39; WHEN @score &gt;= 70 THEN &#39;C&#39; WHEN @score &gt;= 60 THEN &#39;D&#39; ELSE &#39;F&#39; END AS Grade; The WHILE element executes a statement or statement block repeatedly while the predicate specified after the WHILE keyword is TRUE, otherwise, the loop terminates when the predicate is FALSE or UNKNOWN. DECLARE @i AS INT = 0; WHILE @i &lt;= 10 BEGIN SET @i = @i + 1; IF @i = 3 CONTINUE; -- skip the rest of the activity in the current iteration and evaluate the loop’s predicate again PRINT @i; IF @i = 7 BREAK; -- break out of the current loop and proceed to execute the statement that appears after the loop’s body END; 13.4. Cursors SQL and T-SQL also support an object called cursor to process rows from a result of a query one at a time and in a requested order. Primarily, the use of cursors contradicts the fundamental principles of the relational model, which is grounded in set theory. Cursors, due to their record-by-record processing, incur significant overhead compared to set-based operations, resulting in significantly slower execution times even for similar underlying physical processing. Cursor solutions, being imperative, tend to be longer, less readable, and harder to maintain than the declarative set solutions. Working with a cursor generally involves the following steps: Declare the cursor based on a query. Open the cursor. Fetch attribute values from the first cursor record into variables. While not reaching the end of the cursor (the value of a function called @@FETCH_STATUS is 0), loop through the cursor records. In each iteration of the loop, perform the processing needed for the current row, and then fetch the attribute values from the next row into the variables. Close the cursor. Deallocate the cursor. DROP VIEW IF EXISTS Sales.CustOrders; GO CREATE VIEW Sales.CustOrders AS SELECT DISTINCT O.custid, O.orderdate AS ordermonth, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid GROUP BY o.custid, O.orderdate GO -- Suppress messages indicating how many rows were affected SET NOCOUNT ON; -- Declare table variable to hold the final result DECLARE @Result AS TABLE ( custid INT, ordermonth DATE, qty INT, runqty INT, PRIMARY KEY(custid, ordermonth) ); -- Declare local variables that are used to store intermediate variables DECLARE @custid AS INT, @prvcustid AS INT, @ordermonth AS DATE, @qty AS INT, @runqty AS INT; -- Step 1: Declare the cursor based on a query DECLARE C CURSOR FAST_FORWARD /* read only, forward only */ FOR SELECT custid, ordermonth, qty FROM Sales.CustOrders ORDER BY custid, ordermonth; -- Step 2: Open the cursor OPEN C; -- Step 3: Fetch attribute values from the first cursor record into variables FETCH NEXT FROM C INTO @custid, @ordermonth, @qty; -- Initialize variables SELECT @prvcustid = @custid, @runqty = 0; -- Step 4: Loop through the cursor records while last fetch was -- In each iteration: -- Reset variables if customer ID changes -- Compute current running total and insert into table -- Fetch next cursor record WHILE @@FETCH_STATUS = 0 BEGIN IF @custid &lt;&gt; @prvcustid SELECT @prvcustid = @custid, @runqty = 0; SET @runqty = @runqty + @qty; INSERT INTO @Result VALUES(@custid, @ordermonth, @qty, @runqty); FETCH NEXT FROM C INTO @custid, @ordermonth, @qty; END; -- Step 5: Close the cursor CLOSE C; -- Step 6: Deallocate the cursor DEALLOCATE C; -- Enable showing messages indicating how many rows were affected SET NOCOUNT OFF; -- Query the table variable to return the final result SELECT custid, CONVERT(VARCHAR(7), ordermonth, 121) AS ordermonth, qty, runqty FROM @Result ORDER BY custid, ordermonth; -- address the same task with a window function SELECT custid, ordermonth, qty, SUM(qty) OVER(PARTITION BY custid ORDER BY ordermonth ROWS UNBOUNDED PRECEDING) AS runqty FROM Sales.CustOrders ORDER BY custid, ordermonth; 13.5. Temporary Tables Temporary tables are temporary storage structures within a SQL Server database. Unlike permanent tables, they are designed for short-term data storage and have limited lifespans. SQL Server supports three kinds of temporary tables to be more conveniental to work with than permanent tables in such cases: local temporary tables, global temporary tables, and table variables. All three kinds of temporary tables are created in the tempdb database. It&#8217;s crucial to distinguish temporary tables (local, global, table variables) from system-versioned temporal tables. Temporary Tables: Primarily used for temporary storage within a specific session or batch, often for intermediate results or data manipulation. System-Versioned Temporal Tables: Specifically designed to track the history of data changes over time. 13.5.1. Local Temporary Tables A local temporary table is created by naming it with a single number sign (#) as a prefix, such as #T1. A local temporary table is visible only to the session that created it, in the creating level and all inner levels in the call stack (inner procedures, triggers, and dynamic batches). A local temporary table is destroyed automatically by SQL Server when the creating level in the call stack goes out of scope. A suffix is added to the table name by SQL Server internally that makes it unique in tempdb. DROP TABLE IF EXISTS #MyOrderTotalsByYear; GO CREATE TABLE #MyOrderTotalsByYear ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); INSERT INTO #MyOrderTotalsByYear(orderyear, qty) SELECT YEAR(O.orderdate) AS orderyear, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON OD.orderid = O.orderid GROUP BY YEAR(orderdate); SELECT Cur.orderyear, Cur.qty AS curyearqty, Prv.qty AS prvyearq FROM #MyOrderTotalsByYear AS Cur LEFT OUTER JOIN #MyOrderTotalsByYear AS Prv ON Cur.orderyear = Prv.orderyear + 1; -- clean up resources as soon as possible DROP TABLE IF EXISTS #MyOrderTotalsByYear; 13.5.2. Global Temporary Tables A global temporary table is created by naming it with a double number sign (##) as a prefix, such as ##T1. A global temporary table is visible to all other sessions. A global temporary table is destroyed automatically by SQL Server when the creating session disconnects and there are no active references to the table. -- creates a global temporary table called ##Globals with columns called id and val CREATE TABLE ##Globals ( id sysname NOT NULL PRIMARY KEY, val SQL_VARIANT NOT NULL ); -- anyone can insert rows into the table. INSERT INTO ##Globals(id, val) VALUES(N&#39;I&#39;, CAST(10 AS INT)); -- anyone can modify and retrieve data from the table. SELECT val FROM ##Globals WHERE id = N&#39;I&#39;; -- explicitly destroy the global temporary table DROP TABLE IF EXISTS ##Globals; 13.5.3. Table Variables A table variable is a local, temporary table-like data structure declared within a single batch. As with local temporary tables, table variables have a physical presence as a table in the tempdb database. Like local temporary tables, table variables are visible only to the creating session, but because they are variables they have a more limited scope: only the current batch. If an explicit transaction is rolled back, changes made to temporary tables in that transaction are rolled back as well; however, changes made to table variables by statements that completed in the transaction aren’t rolled back. In terms of performance, usually it makes more sense to use table variables with small volumes of data (only a few rows) and to use local temporary tables otherwise. DECLARE @MyOrderTotalsByYear TABLE ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); INSERT INTO @MyOrderTotalsByYear(orderyear, qty) SELECT YEAR(O.orderdate) AS orderyear, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON OD.orderid = O.orderid GROUP BY YEAR(orderdate); SELECT Cur.orderyear, Cur.qty AS curyearqty, Prv.qty AS prvyearqty FROM @MyOrderTotalsByYear AS Cur LEFT OUTER JOIN @MyOrderTotalsByYear AS Prv ON Cur.orderyear = Prv.orderyear + 1; A table type is a user-defined data structure that defines the schema (columns, data types) of a table to be reused as the table definition of table variables and input parameters of stored procedures and user-defined functions. -- create a table type called dbo.OrderTotalsByYear DROP TYPE IF EXISTS dbo.OrderTotalsByYear; CREATE TYPE dbo.OrderTotalsByYear AS TABLE ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); -- simply specify dbo.OrderTotalsByYear as the variable’s type DECLARE @MyOrderTotalsByYear AS dbo.OrderTotalsByYear; 13.6. Dynamic SQL A dynamic SQL in SQL Server is a batch of T-SQL code as a character string that can be executed by using the EXEC command and the sp_executesql stored procedure. The EXEC (short for EXECUTE) command accepts a regular or Unicode character string in parentheses as input and executes the batch of code within the character string. DECLARE @sql AS VARCHAR(100); SET @sql = &#39;PRINT &#39;&#39;This message was printed by a dynamic SQL batch&#39;&#39;&#39; EXEC(@sql); The sp_executesql stored procedure is an alternative tool to the EXEC command for executing dynamic SQL code. It’s more secure and more flexible in the sense that it has an interface; that is, it supports input and output parameters. In terms of security, parameters that appear in the code cannot be considered part of the code—they can only be considered operands in expressions. Note that unlike EXEC, sp_executesql supports only Unicode character strings as the input batch of code. The sp_executesql stored procedure can perform better than EXEC because its parameterization aids in reusing cached execution plans, which incur cost when SQL Server needs to create them anew. An execution plan is the physical processing plan SQL Server produces for a query, with the set of instructions describing which objects to access, in what order, which indexes to use, how to access them, which join algorithms to use, and so on. One of the requirements for reusing a previously cached plan is that the query string be the same as the one for which the cached plan was created. DECLARE @sql AS NVARCHAR(100); SET @sql = N&#39;SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderid = @orderid;&#39;; EXEC sp_executesql @stmt = @sql, -- a Unicode character string holding the batch of code @params = N&#39;@orderid AS INT&#39;, -- a Unicode character string holding the declarations of input and output parameters @orderid = 10248; -- an input parameter called @orderid 13.7. Routines Routines are programmable objects that encapsulate code to calculate a result or to execute activity. SQL Server supports three types of routines: user-defined functions, stored procedures, and triggers. 13.7.1. User-defined Functions A user-defined function (UDF) is used to encapsulate logic that calculates something, possibly based on input parameters, and return a result. SQL Server supports scalar and table-valued UDFs. Scalar UDFs return a single value; table-valued UDFs return a table. Scalar UDFs can appear anywhere in the query where an expression that returns a single value can appear (for example, in the SELECT list). Table UDFs can appear in the FROM clause of a query. UDFs are not allowed to have any side effects, that means UDFs are not allowed to apply any schema or data changes in the database. CREATE OR ALTER FUNCTION dbo.GetNewID() RETURNS UNIQUEIDENTIFIER AS BEGIN RETURN NEWID(); -- Invalid use of a side-effecting operator &#39;newid&#39; within a function. END; -- create a UDF called dbo.GetAge that returns the age of a person DROP FUNCTION IF EXISTS dbo.GetAge; GO CREATE OR ALTER FUNCTION dbo.GetAge ( @birthdate AS DATE, -- a specified birth date (@birthdate argument) @eventdate AS DATE -- a specified event date (@eventdate argument) ) RETURNS INT AS BEGIN RETURN -- a RETURN clause that returns a value DATEDIFF(year, @birthdate, @eventdate) - CASE WHEN 100 * MONTH(@eventdate) + DAY(@eventdate) &lt; 100 * MONTH(@birthdate) + DAY(@birthdate) THEN 1 ELSE 0 END; END; GO -- use a UDF in a query SELECT empid, firstname, lastname, birthdate, dbo.GetAge(birthdate, SYSDATETIME()) AS age FROM HR.Employees; 13.7.2. Stored Procedures Stored procedures are routines that encapsulate logic with input and output parameters, return result sets of queries, and can have side effects. Stored procedures encapsulate logic, allowing for centralized modification and ensuring all users utilize the updated implementation. Stored procedures give better control of security. A user permissions can be granted to execute the procedure without granting the user direct permissions to perform the underlying activities to ensure that all the required validations and auditing always take place. Stored procedures with parameters can help prevent SQL injection. All error-handling code can be incorporated within a procedure, silently taking corrective action where relevant. Stored procedures give performance benefits. Parameterized queries within stored procedures enhance performance by leveraging cached execution plans. Stored procedures reduce network traffic by minimizing data exchange between the client and server. -- create a stored procedure called Sales.GetCustomerOrders CREATE OR ALTER PROC Sales.GetCustomerOrders -- a customer ID (@custid) and a date range (@fromdate and @todate) as inputs @custid AS INT, @fromdate AS DATETIME = &#39;19000101&#39;, -- default 19000101 @todate AS DATETIME = &#39;99991231&#39;, -- default 99991231 @numrows AS INT OUTPUT -- the number of affected rows (@numrows) as an output AS SET NOCOUNT ON; -- suppress messages indicating affected rows by DML SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE custid = @custid AND orderdate &gt;= @fromdate AND orderdate &lt; @todate; SET @numrows = @@rowcount; -- execute the procedure, and absorb the value of the output parameter @numrows in the variable @rc DECLARE @rc AS INT; EXEC Sales.GetCustomerOrders @custid = 1, @fromdate = &#39;20210101&#39;, @todate = &#39;20220101&#39;, @numrows = @rc OUTPUT; SELECT @rc AS numrows; 13.7.3. Triggers A trigger is a special kind of stored procedure attached to an event—one that cannot be executed explicitly. SQL Server supports the association of triggers with two kinds of events: data manipulation events (DML triggers) such as INSERT, and data definition events (DDL triggers) such as CREATE TABLE. A trigger is considered part of the transaction that includes the event that caused the trigger to fire. Triggers in SQL Server fire per statement and not per modified row. 13.7.3.1. DML Triggers SQL Server supports two kinds of DML triggers: after and instead of. An after trigger fires after the event it’s associated with finishes and can be defined only on permanent tables. An instead of trigger fires instead of the event it’s associated with and can be defined on permanent tables and views. In the trigger’s code, pseudo tables called inserted and deleted that contain the rows that were affected by the modification that caused the trigger to fire can be accessed. The inserted table holds the new image of the affected rows in the case of INSERT and UPDATE actions. The deleted table holds the old image of the affected rows in the case of DELETE and UPDATE actions. In the case of instead of triggers, the inserted and deleted tables contain the rows that were supposed to be affected by the modification that caused the trigger to fire. -- create a table called dbo.T1, and a table called dbo.T1_Audit DROP TABLE IF EXISTS dbo.T1_Audit, dbo.T1; CREATE TABLE dbo.T1 ( keycol INT NOT NULL PRIMARY KEY, datacol VARCHAR(10) NOT NULL ); CREATE TABLE dbo.T1_Audit ( audit_lsn INT NOT NULL IDENTITY PRIMARY KEY, -- audit log serial number dt DATETIME2(3) NOT NULL DEFAULT(SYSDATETIME()), login_name sysname NOT NULL DEFAULT(ORIGINAL_LOGIN()), keycol INT NOT NULL, datacol VARCHAR(10) NOT NULL ); GO -- create the AFTER INSERT trigger trg_T1_insert_audit on the T1 table to audit insertions CREATE OR ALTER TRIGGER trg_T1_insert_audit ON dbo.T1 AFTER INSERT AS SET NOCOUNT ON; INSERT INTO dbo.T1_Audit(keycol, datacol) SELECT keycol, datacol FROM inserted; GO -- trigger fires after each statement INSERT INTO dbo.T1(keycol, datacol) VALUES(10, &#39;a&#39;); INSERT INTO dbo.T1(keycol, datacol) VALUES(30, &#39;x&#39;); INSERT INTO dbo.T1(keycol, datacol) VALUES(20, &#39;g&#39;); GO SELECT audit_lsn, dt, login_name, keycol, datacol FROM dbo.T1_Audit; -- 1 2025-01-15 16:03:50.997 sa 10 a -- 2 2025-01-15 16:03:51.004 sa 30 x -- 3 2025-01-15 16:03:51.008 sa 20 g GO -- cleanup DROP TABLE dbo.T1_Audit, dbo.T1; 13.7.3.2. DDL Triggers SQL Server supports DDL triggers, which can be used for purposes such as auditing, policy enforcement, and change management. SQL Server box product supports the creation of DDL triggers at two scopes, the database scope and the server scope, depending on the scope of the event. Azure SQL Database currently supports only database triggers. SQL Server supports only after DDL triggers; it doesn’t support instead of DDL triggers. Within the trigger, information about the event that caused the trigger to fire can be obtained by querying a function called EVENTDATA, which returns the event information as an XML instance. -- creates the dbo.AuditDDLEvents table to hold the audit information DROP TABLE IF EXISTS dbo.AuditDDLEvents; CREATE TABLE dbo.AuditDDLEvents ( audit_lsn INT NOT NULL IDENTITY, posttime DATETIME2(3) NOT NULL, eventtype sysname NOT NULL, loginname sysname NOT NULL, schemaname sysname NOT NULL, objectname sysname NOT NULL, targetobjectname sysname NULL, eventdata XML NOT NULL, CONSTRAINT PK_AuditDDLEvents PRIMARY KEY(audit_lsn) ); GO -- create the trg_audit_ddl_events audit trigger on the database by using the event group DDL_DATABASE_LEVEL_EVENTS CREATE OR ALTER TRIGGER trg_audit_ddl_events ON DATABASE FOR DDL_DATABASE_LEVEL_EVENTS AS SET NOCOUNT ON; DECLARE @eventdata AS XML = eventdata(); INSERT INTO dbo.AuditDDLEvents( posttime, eventtype, loginname, schemaname, objectname, targetobjectname, eventdata) VALUES( @eventdata.value(&#39;(/EVENT_INSTANCE/PostTime)[1]&#39;, &#39;VARCHAR(23)&#39;), -- XQuery expressions @eventdata.value(&#39;(/EVENT_INSTANCE/EventType)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/LoginName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/SchemaName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/ObjectName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/TargetObjectName)[1]&#39;, &#39;sysname&#39;), @eventdata); GO -- test the trigger CREATE TABLE dbo.T1(col1 INT NOT NULL PRIMARY KEY); ALTER TABLE dbo.T1 ADD col2 INT NULL; ALTER TABLE dbo.T1 ALTER COLUMN col2 INT NOT NULL; CREATE NONCLUSTERED INDEX idx1 ON dbo.T1(col2); GO SELECT * FROM dbo.AuditDDLEvents; GO -- cleanup DROP TRIGGER IF EXISTS trg_audit_ddl_events ON DATABASE; DROP TABLE IF EXISTS dbo.AuditDDLEvents, dbo.T1; 13.8. Error Handling: TRY-CATCH The TRY. . .CATCH construct in SQL Server handles errors by placing the usual T-SQL code in a TRY block and placing all the error-handling code in the adjacent CATCH block. If the TRY block has no error, the CATCH block is simply skipped. If the TRY block has an error, control is passed to the corresponding CATCH block. BEGIN TRY -- TRY block (between the BEGIN TRY and END TRY keywords) PRINT 10/0; PRINT &#39;No error&#39;; END TRY BEGIN CATCH -- CATCH block (between the BEGIN CATCH and END CATCH keywords) PRINT &#39; Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39; Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); END CATCH; SQL Server also provides a set of functions to get information about the error. The ERROR_NUMBER function returns an integer with the number of the error. The ERROR_MESSAGE function returns error-message text. To get the list of error numbers and messages, query the sys.messages catalog view. The ERROR_SEVERITY and ERROR_STATE functions return the error severity and state. The ERROR_LINE function returns the line number in the code where the error happened. The ERROR_PROCEDURE function returns the name of the procedure in which the error happened and returns NULL if the error did not happen within a procedure. -- create a table called dbo.Employees DROP TABLE IF EXISTS dbo.Employees; CREATE TABLE dbo.Employees ( empid INT NOT NULL, empname VARCHAR(25) NOT NULL, mgrid INT NULL, CONSTRAINT PK_Employees PRIMARY KEY(empid), CONSTRAINT CHK_Employees_empid CHECK(empid &gt; 0), CONSTRAINT FK_Employees_Employees FOREIGN KEY(mgrid) REFERENCES dbo.Employees(empid) ); BEGIN TRY INSERT INTO dbo.Employees(empid, empname, mgrid) VALUES(1, &#39;Emp1&#39;, NULL); -- Also try with empid = 0, &#39;A&#39;, NULL END TRY BEGIN CATCH IF ERROR_NUMBER() = 2627 BEGIN PRINT &#39; Handling PK violation...&#39;; END; ELSE IF ERROR_NUMBER() = 547 BEGIN PRINT &#39; Handling CHECK/FK constraint violation...&#39;; END; ELSE IF ERROR_NUMBER() = 515 BEGIN PRINT &#39; Handling NULL violation...&#39;; END; ELSE IF ERROR_NUMBER() = 245 BEGIN PRINT &#39; Handling conversion error...&#39;; END; ELSE BEGIN PRINT &#39;Re-throwing error...&#39;; THROW; -- re-throws the error END; PRINT &#39; Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39; Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39; Error Severity: &#39; + CAST(ERROR_SEVERITY() AS VARCHAR(10)); PRINT &#39; Error State : &#39; + CAST(ERROR_STATE() AS VARCHAR(10)); PRINT &#39; Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); PRINT &#39; Error Proc : &#39; + COALESCE(ERROR_PROCEDURE(), &#39;Not within a procedure&#39;); END CATCH; -- a stored procedure that encapsulates reusable error-handling code CREATE OR ALTER PROC dbo.ErrInsertHandler AS SET NOCOUNT ON; IF ERROR_NUMBER() = 2627 BEGIN PRINT &#39;Handling PK violation...&#39;; END; ELSE IF ERROR_NUMBER() = 547 BEGIN PRINT &#39;Handling CHECK/FK constraint violation...&#39;; END; ELSE IF ERROR_NUMBER() = 515 BEGIN PRINT &#39;Handling NULL violation...&#39;; END; ELSE IF ERROR_NUMBER() = 245 BEGIN PRINT &#39;Handling conversion error...&#39;; END; PRINT &#39;Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39;Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39;Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39;Error Severity: &#39; + CAST(ERROR_SEVERITY() AS VARCHAR(10)); PRINT &#39;Error State : &#39; + CAST(ERROR_STATE() AS VARCHAR(10)); PRINT &#39;Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); PRINT &#39;Error Proc : &#39; + COALESCE(ERROR_PROCEDURE(), &#39;Not within a procedure&#39;); GO BEGIN TRY INSERT INTO dbo.Employees(empid, empname, mgrid) VALUES(1, &#39;Emp1&#39;, NULL); END TRY BEGIN CATCH IF ERROR_NUMBER() IN (2627, 547, 515, 245) EXEC dbo.ErrInsertHandler; ELSE THROW; END CATCH; GO -- clean up DROP TABLE IF EXISTS dbo.Employees; DROP PROC IF EXISTS dbo.ErrInsertHandler; 14. JSON JSON is a widely-used text format for data exchange in modern applications and for storing unstructured data. SQL Server 2016 and later versions provide built-in functions that integrate JSON with relational data, enabling the storage and querying of JSON documents within the database and the formatting of relational query results as JSON text. A native JSON data type, available in Azure SQL and in preview for SQL Server 2025, stores JSON in an optimized binary format, which provides more efficient reads, writes, and storage compared to traditional string types, while maintaining compatibility with existing query functions. 14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY ISJSON() checks if a string contains valid JSON. JSON_VALUE() extracts a single scalar value (like a string or number). JSON_QUERY() extracts a JSON object or an array. JSON_MODIFY() updates a property within a JSON string and returns the new string. These functions use a JavaScript-like path syntax to reference nested elements, and the extracted values can be used in any part of a T-SQL query, such as WHERE or ORDER BY clauses. The path expressions for JSON_VALUE, JSON_QUERY, and JSON_MODIFY can be prefixed with lax (the default) or strict. lax mode returns NULL (or an empty result for JSON_QUERY) if the path is not found, whereas strict mode will raise an error. If the input JSON expression is NULL, all JSON functions will return NULL. However, if the input is not NULL but is an invalid JSON text, the functions will raise an error. It is a best practice to use ISJSON() to validate the input before applying other JSON functions. -- Declare a variable to hold JSON data DECLARE @person NVARCHAR(MAX) = &#39;{ &quot;name&quot;: &quot;Jane Doe&quot;, &quot;status&quot;: &quot;Active&quot;, &quot;location&quot;: { &quot;city&quot;: &quot;Belgrade&quot;, &quot;country&quot;: &quot;Serbia&quot; }, &quot;skills&quot;: [ &quot;T-SQL&quot;, &quot;Power BI&quot; ] }&#39;; -- Check if the JSON is valid before querying IF ISJSON(@person) &gt; 0 BEGIN -- Extract values and use them in a SELECT statement -- This uses the default &#39;lax&#39; mode. A non-existent path would return NULL. SELECT JSON_VALUE(@person, &#39;$.name&#39;) AS Name, JSON_VALUE(@person, &#39;$.location.city&#39;) AS City, JSON_QUERY(@person, &#39;$.skills&#39;) AS Skills, JSON_VALUE(@person, &#39;$.info.age&#39;) AS Age; -- This path doesn&#39;t exist, will return NULL -- Using &#39;strict&#39; mode will cause an error if the path is not found. -- SELECT JSON_VALUE(@person, &#39;strict $.info.age&#39;); -- This would raise an error. -- Modify the city from &quot;Belgrade&quot; to &quot;London&quot; SET @person = JSON_MODIFY(@person, &#39;$.location.city&#39;, &#39;London&#39;); -- Display the updated JSON SELECT @person AS UpdatedPersonJSON; END The ISJSON function returns 1 for valid JSON, 0 for invalid, and NULL for a NULL input, and the conditions ISJSON(col) &gt; 0 and ISJSON(col) = 1 are functionally identical for validation and result in the same execution plan. 14.2. OPENJSON The OPENJSON rowset function transforms JSON text into a structured rowset to enable standard T-SQL querying, requiring database compatibility level 130 or higher. By default, the function returns first-level key/value pairs from a JSON object or all elements with their indexes from a JSON array. It operates in two primary modes: Default Schema (without a WITH clause) returns a key-value table with key, value, and type columns, which is useful for inspecting a document&#8217;s structure. DECLARE @json NVARCHAR(MAX) = &#39;{ &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 45, &quot;isStudent&quot;: false, &quot;skills&quot;: [ &quot;SQL&quot;, &quot;C#&quot; ] }&#39;; -- Use the default schema to return a key-value table SELECT * FROM OPENJSON(@json); Result Set key value type --- name John Doe 1 age 45 2 isStudent false 0 skills [&quot;SQL&quot;,&quot;C#&quot;] 4 Explicit Schema (with a WITH clause) shreds a JSON array into a relational format by mapping user-defined columns, data types, and JSON paths in an explicit schema definition. DECLARE @json NVARCHAR(MAX) = N&#39;[ { &quot;OrderNumber&quot;: &quot;SO43659&quot;, &quot;OrderDate&quot;: &quot;2024-05-31&quot;, &quot;Customer&quot;: &quot;AW29825&quot;, &quot;Quantity&quot;: 1 }, { &quot;OrderNumber&quot;: &quot;SO43661&quot;, &quot;OrderDate&quot;: &quot;2024-06-01&quot;, &quot;Customer&quot;: &quot;AW73565&quot;, &quot;Quantity&quot;: 3 } ]&#39;; -- Use an explicit schema to define the output table structure SELECT * FROM OPENJSON(@json) WITH ( Number VARCHAR(200) &#39;$.OrderNumber&#39;, [Date] DATETIME &#39;$.OrderDate&#39;, CustomerAcct VARCHAR(200) &#39;$.Customer&#39;, Qty INT &#39;$.Quantity&#39; ); Result Set Number Date CustomerAcct Qty --- SO43659 2024-05-31 00:00:00.000 AW29825 1 SO43661 2024-06-01 00:00:00.000 AW73565 3 JSON documents might have sub-elements and hierarchical data that can&#8217;t be directly mapped into the standard relational columns. To flatten hierarchical JSON, a primary OPENJSON call extracts a nested array as a JSON text fragment using the AS JSON option, which is then unnested by a second OPENJSON call via an APPLY operator. DECLARE @json NVARCHAR(MAX) = N&#39;[ {&quot;id&quot;: 2, &quot;info&quot;: {&quot;name&quot;: &quot;John&quot;, &quot;surname&quot;: &quot;Smith&quot;}, &quot;age&quot;: 25}, {&quot;id&quot;: 5, &quot;info&quot;: {&quot;name&quot;: &quot;Jane&quot;, &quot;surname&quot;: &quot;Smith&quot;, &quot;skills&quot;: [&quot;SQL&quot;, &quot;C#&quot;, &quot;Azure&quot;]}, &quot;dob&quot;: &quot;2005-11-04T12:00:00&quot;} ]&#39;; SELECT id, firstName, lastName, age, dateOfBirth, skill FROM OPENJSON(@json) WITH ( id INT &#39;strict $.id&#39;, firstName NVARCHAR(50) &#39;$.info.name&#39;, lastName NVARCHAR(50) &#39;$.info.surname&#39;, age INT, dateOfBirth DATETIME2 &#39;$.dob&#39;, skills NVARCHAR(MAX) &#39;$.info.skills&#39; AS JSON ) OUTER APPLY OPENJSON(skills) WITH (skill NVARCHAR(8) &#39;$&#39;); Result Set id firstName lastName age dateOfBirth skill --- 2 John Smith 25 NULL NULL 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 SQL 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 C# 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 Azure 14.3. FOR JSON The FOR JSON clause in a SELECT statement formats query results into JSON text, delegating the formatting task from the client application to the database. It operates in two primary modes: FOR JSON AUTO automatically creates a nested JSON structure based on the tables used in the SELECT statement and their join relationships. FOR JSON PATH provides explicit control over the output format, allowing for the creation of custom nested objects and arrays using dot notation (i.e., &#39;Order.Details.ProductID&#39;) in column aliases. Further customization is available through options like ROOT to add a top-level element, INCLUDE_NULL_VALUES to retain properties with null values, and WITHOUT_ARRAY_WRAPPER to remove the default surrounding array brackets, which is useful for generating a single JSON object from a single-row result. Example SELECT TOP 2 SalesOrderID AS &#39;Order.ID&#39;, OrderDate AS &#39;Order.Date&#39;, AccountNumber AS &#39;Customer.Account&#39; FROM Sales.SalesOrderHeader FOR JSON PATH, ROOT(&#39;Orders&#39;); Result Set { &quot;Orders&quot;: [ { &quot;Order&quot;: { &quot;ID&quot;: 43659, &quot;Date&quot;: &quot;2011-05-31T00:00:00&quot;, &quot;Customer&quot;: { &quot;Account&quot;: &quot;10-4020-000676&quot; } } }, { &quot;Order&quot;: { &quot;ID&quot;: 43660, &quot;Date&quot;: &quot;2011-05-31T00:00:00&quot;, &quot;Customer&quot;: { &quot;Account&quot;: &quot;10-4020-000117&quot; } } } ] } 15. Vectors and embeddings The SQL Database Engine supports storing and querying structured and unstructured data, including performing vector search, which is beneficial for unified data search without external services. Vectors are ordered arrays of numbers (typically floats) representing data (e.g., pixel values, text ASCII values). Vectorization is the process of converting data into vectors, which are efficiently stored using the SQL Server VECTOR data type. Vector features are available in SQL Server 2025 (17.x) Preview, Azure SQL Database, and Azure SQL Managed Instance (configured with the Always-up-to-date update policy). 15.1. Embeddings Embeddings are a specialized type of vector that capture important features of data, often generated by deep learning models, with the ability of representing semantic similarity between various data entities, such as words or images. Azure OpenAI provides models for creating text embeddings, which can be stored in SQL Server alongside their data to enable vector search for similar data points. Storing generated embeddings in a SQL Server database allows for co-location with the represented data and facilitates vector search queries to find similar data points. 15.2. Vector search Vector search refers to the process of finding vectors in a dataset that are similar to a specific query vector. Similarity is measured using distance metrics like cosine distance; closer vectors indicate higher similarity. SQL Server provides built-in support for vectors via the VECTOR data type, storing data in an optimized binary format yet is exposed as JSON arrays for convenience. Vectors, typically managed as arrays of floats, can be created by casting JSON arrays to the VECTOR data type. For example: SELECT CAST(&#39;[1.0, -0.2, 30]&#39; AS VECTOR(3)) AS v1, CAST(JSON_ARRAY(1.0, -0.2, 30) AS VECTOR(3)) AS v2; DECLARE @v1 VECTOR(3) = &#39;[1.0, -0.2, 30]&#39;; DECLARE @v2 VECTOR(3) = JSON_ARRAY(1.0, -0.2, 30); SELECT @v1 as v1, @v2 as v2; DECLARE @v VECTOR(3) = &#39;[1.0, -0.2, 30]&#39;; SELECT CAST(@v AS NVARCHAR(MAX)) AS s, CAST(@v AS JSON) AS j 15.2.1. Exact nearest neighbor (k-NN) search and vector distance Exact search, also known as k-nearest neighbor (k-NN) search, involves calculating the distance between a given vector and all other vectors in a dataset, sorting the results, and selecting the closest neighbors based on a specified distance metric. k-nearest neighbor (k-NN) search guarantees precise nearest neighbor retrieval by performing an exhaustive distance calculation across all indexed vectors, making it computationally intensive but suitable for smaller datasets or when accuracy is paramount. Vector distance functions, such as Euclidean distance, cosine similarity, and dot product, measure vector closeness and are essential for accurate k-NN searches. In the SQL Database Engine, k-NN searches utilize the VECTOR_DISTANCE function for efficient distance calculation and nearest neighbor retrieval. The terms &quot;exact search,&quot; &quot;k-nearest neighbor (k-NN) search,&quot; and &quot;exact nearest neighbor (ENN) vector search&quot; are used interchangeably to refer to this precise, exhaustive search method. The following example shows how to do k-NN to return the top 10 most similar vectors stored in the content_vector table to the given query vector @qv. DECLARE @qv VECTOR(1536) = AI_GENERATE_EMBEDDINGS(N&#39;Pink Floyd music style&#39; USE MODEL Ada2Embeddings); SELECT TOP (10) id, VECTOR_DISTANCE(&#39;cosine&#39;, @qv, [content_vector]) AS distance, title FROM [dbo].[wikipedia_articles_embeddings] ORDER BY distance Exact search is recommended for datasets with fewer than 50,000 vectors. Larger tables can use exact search if search predicates effectively reduce the number of vectors for neighbor search to 50,000 or fewer. 15.2.2. Approximate nearest neighbors (ANN) and vector index Approximate vector index and vector search are in preview and currently only available in SQL Server 2025 (17.x) Preview. Approximate Nearest Neighbors (ANN) offers a high-performance alternative to the slow and resource-intensive exact k-nearest neighbors (k-NN) search. While k-NN requires comparing a query vector against every vector in a database, ANN trades a small degree of accuracy (recall) for a massive gain in search speed, making it a practical solution for large-scale vector search. Recall is a metric that measures the proportion of relevant items successfully retrieved out of all truly relevant items. In vector search, recall specifically quantifies how many of the exact nearest neighbors found by an exhaustive search are successfully identified by an Approximate Nearest Neighbors (ANN) algorithm. It serves as a crucial measure of the approximation&#8217;s quality, with a perfect recall of 1 indicating that the ANN algorithm found all the exact nearest neighbors. For AI applications, the inherent approximation of vector embeddings makes ANN a highly advantageous trade-off over exact k-NN, offering significant performance and resource benefits well-suited for operational databases. A vector index is a data structure optimized for efficiently finding approximate nearest neighbors in high-dimensional vector spaces, thereby returning approximate results for ANN searches, unlike traditional relational database indexes (e.g., B-trees, LSM-trees) designed for exact lookups and range queries on scalar values. In the SQL Database engine, vector indexes are based on the DiskANN algorithm. DiskANN is a graph-based system that indexes and searches large vector datasets by creating a navigable graph to quickly find the closest match to a given vector. DiskANN efficiently uses SSDs and minimal memory to handle significantly more data than in-memory indices, while maintaining high queries per second (QPS) and low latency, ensuring a balance between memory, CPU and I/O usage and search performance. An approximate nearest neighbors algorithm search can be done first creating a vector index using the CREATE VECTOR INDEX T-SQL command and then using VECTOR_SEARCH T-SQL function to run the approximate search. DECLARE @qv VECTOR(1536) = AI_GENERATE_EMBEDDINGS(N&#39;Pink Floyd music style&#39; USE MODEL Ada2Embeddings); SELECT t.id, s.distance, t.title FROM VECTOR_SEARCH( TABLE = [dbo].[wikipedia_articles_embeddings] AS t, COLUMN = [content_vector], SIMILAR_TO = @qv, METRIC = &#39;cosine&#39;, TOP_N = 10 ) AS s ORDER BY s.distance Appendix A: Data Types A data type is an attribute that specifies the type of data that the object can hold: integer data, character data, monetary data, date and time data, binary strings, and so on. [3] Data types can be converted either implicitly or explicitly. Implicit conversions are not visible to the user. SQL Server automatically converts the data from one data type to another. Explicit conversions use the CAST or CONVERT functions. Use CAST instead of CONVERT to write Transact-SQL program code to comply with ISO. Use CONVERT instead of CAST to take advantage of the style functionality in CONVERT. CAST ( expression AS data_type [ ( length ) ] ) CONVERT ( data_type [ ( length ) ] , expression [ , style ] ) SELECT CAST(123 AS VARCHAR(10)), CONVERT(VARCHAR(10), 123) -- same result: integer to string SELECT CONVERT(VARCHAR(10), GETDATE(), 101) -- date to string in MM/dd/yyyy format A.1. Character SQL Server supports two kinds of character data type pairs: regular kind (CHAR and VARCHAR) and N-kind (NCHAR and NVARCHAR). Each of the type pairs can support different character encoding systems, and can result in different encoded byte lengths and on-disk storage sizes, based on the effective collation of the data and the character code range in use. The regular types, with UTF-8 collation, use the UTF-8 encoding system and support full range of Unicode characters. The N-kind types, with supplementary character collation (SC), use the UTF-16 encoding system and support the full range of Unicode characters. Otherwise, they support only the subset of characters from the UCS-2 character encoding system. The VARCHAR(size) defines the maximum size in bytes, while the NVARCHAR(size) defines the size in byte pairs. The literals of regular type character are enclosed in single quotes, while N-kind type require a preceding &#39;N&#39;. Any data type without the VAR element (CHAR, NCHAR) in its name has a fixed length, that is, SQL Server preserves the maximum space in the row based on the column’s defined size and not on the actual user data that is stored. A data type with the VAR element (VARCHAR, NVARCHAR) in its name has a variable length, that is, SQL Server uses as much storage space in the row as required to store the actual character string, plus two extra bytes for offset data. Updates of variable-length data types can be less efficient than those of fixed-length types due to potential row expansion and data movement. Variable-length data types can use the MAX specifier, allowing for up to 2GB per value. Any value with a size up to a certain threshold (8,000 bytes by default) can be stored inline in the row. Any value with a size above the threshold is stored external to the row as a large object (LOB). The collation is a property of character data that encapsulates several aspects: language support, sort order, case sensitivity, accent sensitivity, and more. -- get the set of supported collations and their descriptions SELECT name, description FROM sys.fn_helpcollations(); In an on-premises SQL Server implementation and Azure SQL Managed Instance, collation can be defined at four different levels: instance, database, column, and expression. The lowest level is the effective one that is used. SELECT DATABASEPROPERTYEX(DB_NAME(), &#39;Collation&#39;); -- SQL_Latin1_General_CP1_CI_AS In Azure SQL Database, collation can be defined at the database, column, and expression levels. T-SQL provides the plus-sign (+) operator and the CONCAT and CONCAT_WS functions to concatenate strings. SELECT empid, firstname + N&#39; &#39; + lastname AS fullname FROM HR.Employees; Standard SQL dictates that a concatenation with a NULL should yield a NULL. SELECT custid, country, region, city, country + N&#39;,&#39; + region + N&#39;,&#39; + city AS location FROM Sales.Customers; custid country region city location 9 France NULL Marseille NULL 10 Canada BC Tsawassen Canada,BC,Tsawassen To treat a NULL as an empty string—or more accurately, to substitute a NULL with an empty string—use the COALESCE function that accepts a list of input values and returns the first that is not NULL. SELECT custid, country, region, city, country + COALESCE(N&#39;,&#39; + region, N&#39;&#39;) + N&#39;,&#39; + city AS location FROM Sales.Customers; custid country region city location 8 Spain NULL Madrid Spain,Madrid 9 France NULL Marseille France,Marseille T-SQL supports a function called CONCAT, which accepts a list of inputs for concatenation and automatically substitutes NULLs with empty strings. SELECT custid, country, region, city, CONCAT(country, N&#39;,&#39; + region, N&#39;,&#39; + city) AS location FROM Sales.Customers; T-SQL also supports a function called CONCAT_WS, which accepts the separator as the first parameter, specifying it only once, and then the list of inputs for concatenation. SELECT custid, country, region, city, CONCAT_WS(N&#39;,&#39;, country, region, city) AS location FROM Sales.Customers; The PATINDEX function returns the position of the first occurrence of a pattern, similar to the patterns used by the LIKE predicate in T-SQL, within a string. PATINDEX(pattern, string) SELECT PATINDEX(&#39;%[0-9]%&#39;, &#39;abcd123efgh&#39;); -- 5 T-SQL provides a predicate called LIKE to check whether a character string matches a specified pattern. The % (percent sign) wildcard represents a string of any size, including an empty string. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;D%&#39;; empid lastname 1 Davis 9 Doyle The _ (underscore) wildcard represents a single character. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;_e%&#39;; empid lastname 3 Lew 4 Peled The square bracket wildcard [&lt;list of characters&gt;], with a list of characters (such as [ABC]), represents a single character that must be one of the characters specified in the list. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[ABC]%&#39;; empid lastname 8 Cameron The square bracket wildcard [&lt;character&gt;-&lt;character&gt;], with a character range (such as [A–E]), represents a single character that must be within the specified range. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[A-E]%&#39;; empid lastname 8 Cameron 1 Davis 9 Doyle The square bracket wildcard [^&lt;character list or range&gt;], with a caret sign (^) followed by a character list or range (such as [^A–E]), represents a single character that is not in the specified character list or range. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[^A-E]%&#39;; empid lastname 2 Funk 7 King To search for a character that is also a wildcard, use an escape character before it in the LIKE pattern, and specify the escape character using the ESCAPE keyword. A character put in front of a wildcard character to indicate that the wildcard is interpreted as a regular character and not as a wildcard. escape_character is a character expression that has no default and must evaluate to only one character. -- specify character (!, @, $, or #) as the escape character col1 LIKE &#39;%!_%&#39; ESCAPE &#39;!&#39; col1 LIKE &#39;%@_%&#39; ESCAPE &#39;@&#39; col1 LIKE &#39;%$%_&#39; ESCAPE &#39;$&#39; col1 LIKE &#39;%#%_&#39; ESCAPE &#39;#&#39; A.2. Date and Time T-SQL supports six date and time data types: The legacy types DATETIME and SMALLDATETIME include date and time components that are inseparable. DATETIME &#39;YYYYMMDD hh:mm:ss.nnn&#39; &#39;20220212 12:30:15.123&#39; DATETIME &#39;YYYYMMDD&#39; &#39;20220212&#39; SMALLDATETIME &#39;YYYYMMDD hh:mm&#39; &#39;20220212 12:30&#39; SMALLDATETIME &#39;YYYYMMDD&#39; &#39;20220212&#39; The DATE and TIME data types provide a separation between the date and time components. DATE &#39;YYYYMMDD&#39; &#39;20220212&#39; TIME &#39;hh:mm:ss.nnnnnnn&#39; &#39;12:30:15.1234567&#39; The DATETIME2 data type has a bigger date range and better precision than the legacy types. DATETIME2 &#39;YYYYMMDD hh:mm:ss.nnnnnnn&#39; &#39;20220212 12:30:15.1234567&#39; The DATETIMEOFFSET data type is similar to DATETIME2, but it also includes the offset from UTC. DATETIMEOFFSET &#39;YYYYMMDD hh:mm:ss.nnnnnnn [+|-]hh:mm&#39; &#39;20220212 12:30:15.1234567 +02:00&#39; SELECT GETDATE() UNION ALL -- DATETIME current date and time SELECT CURRENT_TIMESTAMP UNION ALL -- DATETIME same as GETDATE but SQL-compliant SELECT GETUTCDATE() UNION ALL -- DATETIME current date and time in UTC SELECT SYSDATETIME() UNION ALL -- DATETIME2 current date and time SELECT SYSUTCDATETIME() UNION ALL -- DATETIME2 current date and time in UTC SELECT SYSDATETIMEOFFSET() -- DATETIME2 current date and time in UTC with Time Zone 2025-01-18 15:07:52.9766667 +00:00 2025-01-18 15:07:52.9766667 +00:00 2025-01-18 07:07:52.9766667 +00:00 2025-01-18 15:07:52.9755919 +00:00 2025-01-18 07:07:52.9755919 +00:00 2025-01-18 15:07:52.9755919 +08:00 T-SQL doesn’t provide the means to express a date and time literal; instead, a convertible literal of a different type can be specified—explicitly or implicitly—to a date and time data type. It is a best practice to use character strings with language-neutral formats to express date and time values. SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderdate = &#39;20220212&#39;; -- equivalent to: WHERE orderdate = CAST(&#39;20220212&#39; AS DATE); Each login has a default language, which affects how date and time literals are interpreted. SET LANGUAGE British; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-12-02 SET LANGUAGE us_english; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-02-12 The DATEFORMAT setting, expressed as a combination of the characters d, m, and y, determines how SQL Server interprets date and time literals from character strings (e.g., &#39;mdy&#39; for US English, &#39;dmy&#39; for British English). SET DATEFORMAT dmy; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-12-02 SET DATEFORMAT mdy; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-02-12 The LANGUAGE/DATEFORMAT setting affects only the way the values inputed are interpreted, and have no impact on the format used in the output for presentation purposes. SQL Server may not efficiently utilize indexes when functions like YEAR are applied to the column within the WHERE clause. SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE YEAR(orderdate) = 2021; -- better SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20210101&#39; AND orderdate &lt; &#39;20220101&#39;; References [1] Itzik Ben-Gan T-SQL Fundamentals. 3rd edition, Microsoft Press; August 3, 2016 [2] Itzik Ben-Gan, Adam Machanic, Dejan Sarka, Kevin Farlee T-SQL Querying. 1st Edition Microsoft Press; March 6, 2015 [3] https://learn.microsoft.com/en-us/sql/t-sql/language-reference" />
<link rel="canonical" href="https://blog.codefarm.me/2025/01/07/t-sql-learning-notes/" />
<meta property="og:url" content="https://blog.codefarm.me/2025/01/07/t-sql-learning-notes/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-07T03:12:33+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="T-SQL Learning Notes" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-01-07T03:12:33+08:00","datePublished":"2025-01-07T03:12:33+08:00","description":"SQL (pronounced /ˌɛsˌkjuˈɛl/ S-Q-L; or alternatively as /ˈsiːkwəl/ &quot;sequel&quot;) stands for Structured Query Language, which is both an ANSI and ISO standard language that was designed to query and manage data in relational database management systems (RDBMSs). An RDBMS is a database management system based on the relational model (a semantic model for representing data), which in turn is based on two mathematical branches: set theory and predicate logic. &quot;NULL marker&quot; or just &quot;NULL&quot; (/nʌl/) is not a NULL value but rather a marker for a missing value. SQL comprises several sub-languages for managing different aspects of a database: Data Definition Language (DDL) defines and manages the structure of database objects with statements such as CREATE, ALTER, and DROP. Data Manipulation Language (DML) retrieves and modifies data using statements like SELECT, INSERT, UPDATE, DELETE, and MERGE. Data Control Language (DCL) manages data access and user permissions through statements such as GRANT and REVOKE. Transaction Control Language (TCL) controls the lifecycle of transactions with statements like COMMIT and ROLLBACK. Microsoft provides T-SQL as a dialect of, or an extension to, SQL in SQL Server—its on-premises RDBMS flavor, and in Azure SQL and Azure Synapse Analytics—its cloud-based RDBMS flavors. T-SQL is based on standard SQL, but it also provides some nonstandard or proprietary extensions. Moreover, T-SQL does not implement all of standard SQL. To run T-SQL code against a database, a client application needs to connect to a SQL Server instance and be in the context of, or use, the relevant database. In both SQL Server and Azure SQL Managed Instance, the application can still access objects from other databases by adding the database name as a prefix. Azure SQL Database does not support cross-database/three-part name queries. SQL Server supports a feature called contained databases that breaks the connection between a database user and an instance-level login. The user (Windows or SQL authenticated) is fully contained within the specific database and is not tied to a login at the instance level. When connecting to SQL Server, the user needs to specify the database to connect, and the user cannot subsequently switch to other user databases. Unless specified otherwise, all T-SQL references to the name of a database object can be a four-part name in the following form: -- Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views server_name.[database_name].[schema_name].object_name | database_name.[schema_name].object_name | schema_name.object_name | object_name 1. Data Integrity 1.1. PRIMARY KEY 1.2. UNIQUE 1.3. FOREIGN KEY 1.4. CHECK 1.5. DEFAULT 2. Logical Query Processing 2.1. FROM 2.2. WHERE 2.3. GROUP BY 2.4. HAVING 2.5. SELECT 2.6. ORDER BY 2.7. TOP 2.8. OFFSET-FETCH 2.9. CASE 3. Predicates and Operators 3.1. Predicates: IN, BETWEEN, LIKE, EXISTS, and IS NULL 3.2. Three-Valued Logic (3VL) 3.3. Equality and Distinctness 3.4. Comparison Operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, and ALL, SOME, ANY 3.5. Logical Operators: OR, AND, and NOT 3.6. Arithmetic Operators: +, -, *, /, and % 4. Query Tuning 4.1. SQL Server Internals 4.1.1. Indexes 4.1.2. Execution Plans 4.1.3. Cardinality Estimates 4.1.4. Parallel Query Execution 4.2. Data Retrieval Strategies 4.2.1. Unordered Clustered Index Scan or Table Scan 4.2.2. Unordered Covering Nonclustered Index Scan 4.2.3. Ordered Clustered Index Scan 4.2.4. Ordered Covering Nonclustered Index Scan 4.2.5. Nonclustered Index Seek + Range Scan + Lookups 4.2.6. Unordered Nonclustered Index Scan + Lookups 4.2.7. Clustered Index Seek + Range Scan 4.2.8. Covering Nonclustered Index Seek + Range Scan 4.3. Tied Rows and Sorting 5. Joins 5.1. CROSS 5.2. INNER 5.3. OUTER 5.4. APPLY 6. Subqueries 6.1. Subqueries with IN or NOT IN 6.2. Subqueries with comparison operators 6.3. Subqueries with EXISTS or NOT EXISTS 7. Table Expressions 7.1. Derived Tables 7.2. CTEs 7.3. Views and TVFs 8. UNION, UNION ALL, INTERSECT, and EXCEPT 9. Data Analysis 9.1. Window Functions 9.1.1. Ranking 9.1.2. Offset 9.1.3. Aggregate 9.1.4. WINDOW 9.2. Pivoting 9.2.1. Grouped Query 9.2.2. PIVOT Operator 9.3. Unpivoting 9.3.1. APPLY Operator 9.3.2. UNPIVOT Operator 9.4. Grouping Sets 9.5. Time Series 10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE 10.1. INSERT 10.1.1. INSERT VALUES 10.1.2. INSERT SELECT 10.1.3. INSERT EXEC 10.1.4. SELECT INTO 10.1.5. BULK INSERT 10.2. DELETE and TRUNCATE 10.3. UPDATE 10.4. MERGE 11. System-Versioned Temporal Tables 12. Transactions and Concurrency 12.1. Locks and Blocking 12.1.1. Locks 12.1.1.1. Lock Modes and Compatibility 12.1.1.2. Lockable Resource Types 12.1.2. Blocking 12.2. Isolation Levels 12.2.1. READ UNCOMMITTED 12.2.2. READ COMMITTED 12.2.3. REPEATABLE READ 12.2.4. SERIALIZABLE 12.2.5. Multi-Version Concurrency Control 12.2.5.1. SNAPSHOT 12.2.5.2. Conflict Detection 12.2.5.3. READ COMMITTED SNAPSHOT 12.3. Deadlocks 13. Programmable Objects 13.1. Variables 13.2. Batchs 13.3. Flow Elements: IF and WHILE 13.4. Cursors 13.5. Temporary Tables 13.5.1. Local Temporary Tables 13.5.2. Global Temporary Tables 13.5.3. Table Variables 13.6. Dynamic SQL 13.7. Routines 13.7.1. User-defined Functions 13.7.2. Stored Procedures 13.7.3. Triggers 13.7.3.1. DML Triggers 13.7.3.2. DDL Triggers 13.8. Error Handling: TRY-CATCH 14. JSON 14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY 14.2. OPENJSON 14.3. FOR JSON 15. Vectors and embeddings 15.1. Embeddings 15.2. Vector search 15.2.1. Exact nearest neighbor (k-NN) search and vector distance 15.2.2. Approximate nearest neighbors (ANN) and vector index Appendix A: Data Types A.1. Character A.2. Date and Time References 1. Data Integrity SQL provides several mechanisms for enforcing data integrity: PRIMARY KEY constraint FOREIGN KEY constraint with actions like CASCADE, SET NULL, RESTRICT NOT NULL constraint CHECK constraint UNIQUE constraint DEFAULT constraint Triggers Stored procedures USE TSQLV6; DROP TABLE IF EXISTS dbo.Employees; CREATE TABLE dbo.Employees ( empid INT NOT NULL, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, hiredate DATE NOT NULL, mgrid INT NULL, ssn VARCHAR(20) NOT NULL, salary MONEY NOT NULL ); 1.1. PRIMARY KEY A primary key constraint enforces the uniqueness of rows and also disallows NULLs in the constraint attributes. Each unique combination of values in the constraint attributes can appear only once in the table—in other words, only in one row. An attempt to define a primary key constraint on a column that allows NULLs will be rejected by the RDBMS. Each table can have only one primary key. ALTER TABLE dbo.Employees ADD CONSTRAINT PK_Employees PRIMARY KEY (empid); To enforce the uniqueness of the logical primary key constraint, SQL Server will create a unique index behind the scenes. A unique index is a physical object used by SQL Server to enforce uniqueness. Indexes (not necessarily unique ones) are also used to speed up queries by avoiding sorting and unnecessary full table scans (similar to indexes in books). 1.2. UNIQUE A unique constraint enforces the uniqueness of rows, allowing to implement the concept of alternate keys from the relational model in a database. Unlike with primary keys, multiple unique constraints can be defined within the same table. Also, a unique constraint is not restricted to columns defined as NOT NULL. ALTER TABLE dbo.Employees ADD CONSTRAINT UNQ_Employees_ssn UNIQUE(ssn); For the purpose of enforcing a unique constraint, SQL Server handles NULLs just like non-NULL values. Consequently, for example, a single-column unique constraint allows only one NULL in the constrained column. However, the SQL standard defines NULL-handling by a unique constraint differently, like so: “A unique constraint on T is satisfied if and only if there do not exist two rows R1 and R2 of T such that R1 and R2 have the same non-NULL values in the unique columns.” In other words, only the non-NULL values are compared to determine whether duplicates exist. Consequently, a standard single-column unique constraint would allow multiple NULLs in the constrained column. 1.3. FOREIGN KEY A foreign key enforces referential integrity. It is defined on one or more attributes in what’s called the referencing table and points to candidate key (primary key or unique constraint) attributes in what’s called the referenced table. Note that the referencing and referenced tables can be one and the same. The foreign key’s purpose is to restrict the values allowed in the foreign key columns to those that exist in the referenced columns. DROP TABLE IF EXISTS dbo.Orders; CREATE TABLE dbo.Orders ( orderid INT NOT NULL, empid INT NOT NULL, custid VARCHAR(10) NOT NULL, orderts DATETIME2 NOT NULL, qty INT NOT NULL, CONSTRAINT PK_Orders PRIMARY KEY (orderid) ); -- enforce an integrity rule that restricts the values supported by the empid column in the Orders table to the values that exist in the empid column in the Employees table. ALTER TABLE dbo.Orders ADD CONSTRAINT FK_Orders_Employees FOREIGN KEY(empid) REFERENCES dbo.Employees(empid); -- restrict the values supported by the mgrid column in the Employees table to the values that exist in the empid column of the same table. ALTER TABLE dbo.Employees ADD CONSTRAINT FK_Employees_Employees FOREIGN KEY(mgrid) REFERENCES dbo.Employees(empid); Note that NULLs are allowed in the foreign key columns (mgrid in the last example) even if there are no NULLs in the referenced candidate key columns. 1.4. CHECK A check constraint is used to define a predicate that a row must meet to be entered into the table or to be modified. ALTER TABLE dbo.Employees ADD CONSTRAINT CHK_Employees_salary CHECK(salary &gt; 0.00); Note that a check constraint rejects an attempt to insert or update a row when the predicate evaluates to FALSE. The modification will be accepted when the predicate evaluates to either TRUE or UNKNOWN. 1.5. DEFAULT A default constraint is associated with a particular attribute. It’s an expression that is used as the default value when an explicit value is not specified for the attribute when inserting a row. ALTER TABLE dbo.Orders ADD CONSTRAINT DFT_Orders_orderts DEFAULT(SYSDATETIME()) FOR orderts; When done, run the following code for cleanup: DROP TABLE IF EXISTS dbo.Orders, dbo.Employees; 2. Logical Query Processing The logical query processing in standard SQL defines how a query should be processed and the final result achieved. Logical query-processing step numbers (5) SELECT (5-2) DISTINCT (7) TOP(&lt;top_specification&gt;) (5-1) &lt;select_list&gt; (1) FROM (1-J) &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; ON &lt;on_predicate&gt; | (1-A) &lt;left_table&gt; &lt;apply_type&gt; APPLY &lt;right_input_table&gt; AS &lt;alias&gt; | (1-P) &lt;left_table&gt; PIVOT(&lt;pivot_specification&gt;) AS &lt;alias&gt; | (1-U) &lt;left_table&gt; UNPIVOT(&lt;unpivot_specification&gt;) AS &lt;alias&gt; (2) WHERE &lt;where_predicate&gt; (3) GROUP BY &lt;group_by_specification&gt; (4) HAVING &lt;having_predicate&gt; (6) ORDER BY &lt;order_by_list&gt; (7) OFFSET &lt;offset_specification&gt; ROWS FETCH NEXT &lt;fetch_specification&gt; ROWS ONLY; The database engine is free to physically process a query differently by rearranging processing phases, as long as the final result would be the same as that dictated by logical query processing. The database engine’s query optimizer can—and in fact, often does—apply many transformation rules and shortcuts in the physical processing of a query as part of query optimization. USE TSQLV6; SELECT empid, YEAR (orderdate) AS orderyear, COUNT(*) AS numorder FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR (orderdate) HAVING COUNT(*) &gt; 1 ORDER BY empid, orderyear; If an identifier is irregular—for example, if it has embedded spaces or special characters, starts with a digit, or is a reserved keyword—it must be delimited. There are a couple of ways to delimit identifiers in T-SQL. One is the standard SQL form using double quotes—for example, &quot;Order Details&quot;. Another is the T-SQL- specific form using square brackets—for example, [Order Details]. In most programming languages, the lines of code are processed in the order that they are written. In SQL, things are different. Even though the SELECT clause appears first in the query, it is logically processed almost last. The clauses are logically processed in the following order: FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) HAVING COUNT(*) &gt; 1 SELECT empid, YEAR(orderdate) AS orderyear, COUNT(*) AS numorders ORDER BY empid, orderyear FROM &#8594; WHERE &#8594; GROUP BY &#8594; HAVING &#8594; SELECT &#8594; Expressions &#8594; DISTINCT &#8594; ORDER BY &#8594; TOP/OFFSET-FETCH 2.1. FROM The FROM clause is the very first query clause that is logically processed, which is used to specify the names of the tables to query and table operators that operate on those tables. FROM Sales.Orders 2.2. WHERE In the WHERE clause, a predicate, or logical expression is specified to filter the rows returned by the FROM phase. FROM Sales.Orders WHERE custid = 71 T-SQL uses three-valued predicate logic, where logical expressions can evaluate to TRUE, FALSE, or UNKNOWN. With three-valued logic, saying “returns TRUE” is not the same as saying “does not return FALSE.” The WHERE phase returns rows for which the logical expression evaluates to TRUE, and it doesn’t return rows for which the logical expression evaluates to FALSE or UNKNOWN. 2.3. GROUP BY The GROUP BY phase is used to arrange the rows returned by the previous logical query processing phase in groups determined by the elements, or expressions. FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) If the query is a grouped query, all phases subsequent to the GROUP BY phase— including HAVING, SELECT, and ORDER BY—operate on groups as opposed to operating on individual rows. Each group is ultimately represented by a single row in the final result of the query. All expressions specified in clauses that are processed in phases subsequent to the GROUP BY phase are required to guarantee returning a scalar (single value) per group. SELECT empid, YEAR(orderdate) AS orderyear, freight -- sum(freight) AS totalfreight FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate); Msg 8120, Level 16, State 1, Line 1 Column &#39;Sales.Orders.freight&#39; is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause. Total execution time: 00:00:00.016 Expressions based on elements that participate in the GROUP BY clause meet the requirement because, by definition, each such element represents a distinct value per group. Elements that do not participate in the GROUP BY clause are allowed only as inputs to an aggregate function such as COUNT, SUM, AVG, MIN, or MAX. Note that all aggregate functions that are applied to an input expression ignore NULLs. The COUNT(*) function isn’t applied to any input expression; it just counts rows irrespective of what those rows contain. For example, consider a group of five rows with the values 30, 10, NULL, 10, 10 in a column called qty. The expression COUNT(*) returns 5 because there are five rows in the group, whereas COUNT(qty) returns 4 because there are four known (non-NULL) values. To handle only distinct (unique) occurrences of known values, specify the DISTINCT keyword before the input expression to the aggregate function, like COUNT(DISTINCT qty), AVG(DISTINCT qty) and so on. 2.4. HAVING Whereas the WHERE clause is a row filter, the HAVING clause is a group filter. Only groups for which the HAVING predicate evaluates to TRUE are returned by the HAVING phase to the next logical query processing phase. Groups for which the predicate evaluates to FALSE or UNKNOWN are discarded. The HAVING clause is processed after the rows have been grouped, so aggregate functions can be referred to in the HAVING filter predicate. SELECT empid, YEAR(orderdate) AS orderyear, SUM(freight) AS totalfreight FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) -- filters only groups (employee and order year) with more than one row, and total freight with more than 500.0 HAVING COUNT(*) &gt; 1 AND SUM(freight) &gt; 500.0 ORDER BY empid, YEAR(orderdate) 1 2021 711.13 2 2022 672.16 4 2022 651.83 6 2021 628.31 7 2022 1231.56 2.5. SELECT The SELECT clause is where to specify the attributes (columns) to return in the result table of the query. SELECT empid, YEAR(orderdate) AS orderyear, COUNT(*) AS numorders FROM Sales.Orders WHERE custid = 71 GROUP BY empid, YEAR(orderdate) HAVING COUNT(*) &gt; 1 The SELECT clause is processed after the FROM, WHERE, GROUP BY, and HAVING clauses, which means that aliases assigned to expressions in the SELECT clause do not exist as far as clauses that are processed before the SELECT clause are concerned. It’s a typical mistake to try and refer to expression aliases in clauses that are processed before the SELECT clause, such as in the following example in which the attempt is made in the WHERE clause: SELECT orderid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE orderyear &gt; 2021; Msg 207, Level 16, State 1, Line 3 Invalid column name &#39;orderyear&#39;. One way around this problem is to repeat the expression YEAR(orderdate) in both the WHERE and SELECT clauses: SELECT orderid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE YEAR(orderdate) &gt; 2021; In addition to supporting the AS clause, T-SQL supports the form &lt;expression&gt; AS &lt;alias&gt;, and also supports the forms &lt;alias&gt; = &lt;expression&gt; (“alias equals expression”) and &lt;expression&gt; &lt;alias&gt; (“expression space alias”). In relational theory, a relational expression is applied to one or more input relations using operators from relational algebra, and returns a relation as output, that is, a relation in SQL is a table, and a relational expression in SQL is a table expression. Recall that a relation’s body is a set of tuples, and a set has no duplicates. Unlike relational theory, which is based on mathematical set theory, SQL is based on multiset theory. The mathematical term multiset, or bag, is similar in some aspects to a set, but it does allow duplicates. A table in SQL isn’t required to have a key. Without a key, the table can have duplicate rows and therefore isn’t relational. Even if the table does have a key, a SELECT query against the table can still return duplicate rows. SQL query results do not have keys. SQL provides the means to remove duplicates using the DISTINCT clause to return a relational result. SELECT DISTINCT empid, YEAR(orderdate) AS orderyear FROM Sales.Orders WHERE custid = 71; 2.6. ORDER BY In terms of logical query processing, ORDER BY comes after SELECT. With T-SQL, elements can also be specified in the ORDER BY clause that do not appear in the SELECT clause, meaning to sort by something that don’t necessarily want to be returned. SELECT empid, firstname, lastname, country FROM HR.Employees ORDER BY hiredate; SELECT empid, firstname, lastname, country FROM HR.Employees ORDER BY CASE country WHEN &#39;USA&#39; THEN 1 WHEN &#39;CHN&#39; THEN 2 WHEN &#39;JPN&#39; THEN 3 WHEN &#39;DEU&#39; THEN 4 WHEN &#39;CAN&#39; THEN 5 WHEN &#39;KOR&#39; THEN 6 ELSE 7 END, empid; -- tie-breaker However, when the DISTINCT clause is specified, the ORDER BY are restricted to list only elements that appear in the SELECT list. SELECT DISTINCT empid, firstname, lastname, country FROM HR.Employees ORDER BY hiredate; Msg 145, Level 15, State 1, Line 1 ORDER BY items must appear in the select list if SELECT DISTINCT is specified. ASC is the default sort order. NULL values are treated as the lowest possible values. One of the most important points to understand about SQL is that a table—be it an existing table in the database or a table result returned by a query—has no guaranteed order. That’s because a table is supposed to represent a set of rows (or multiset, if it has duplicates), and a set has no order. It means that when querying a table without specifying an ORDER BY clause, SQL Server is free to return the rows in the output in any order. The only way to guarantee the presentation order in the result is with an ORDER BY clause. However, realizing that if specifying an ORDER BY clause, the result can’t qualify as a table, because it is ordered. Standard SQL calls such a result a cursor. 2.7. TOP The TOP filter is a proprietary T-SQL feature that can be used to limit the number or percentage of rows queried returns. It relies on two elements as part of its specification: one is the number or percent of rows to return, and the other is the ordering. SELECT TOP (5) orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; Note that the TOP filter is handled after DISTINCT. The TOP can use option with the PERCENT keyword, in which case SQL Server calculates the number of rows to return based on a percentage of the number of qualifying rows, rounded up. SELECT TOP (1) PERCENT orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; The query returns nine rows because the Orders table has 830 rows, and 1 percent of 830, rounded up, is 9. 11074 2022-05-06 73 7 11075 2022-05-06 68 8 11076 2022-05-06 9 4 11077 2022-05-06 65 1 11070 2022-05-05 44 2 11071 2022-05-05 46 1 11072 2022-05-05 20 4 11073 2022-05-05 58 2 11067 2022-05-04 17 1 In the above query, notice that the ORDER BY list is not unique (because no primary key or unique constraint is defined on the orderdate column). In other words, the ordering is not strict total ordering. Multiple rows can have the same order date. In such a case, the ordering among rows with the same order date is undefined, which makes the query nondeterministic—more than one result can be considered correct. In case of ties, SQL Server filters rows based on optimization choices and physical access order. Note that when using the TOP filter in a query without an ORDER BY clause, the ordering is completely undefined—SQL Server returns whichever n rows it happens to physically access first, where n is the requested number of rows. To make the query be deterministic, a strict total ordering is needed; in other words, add a tie-breaker. SELECT TOP (5) orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC, orderid DESC; -- the row with the greater order ID value will be preferred. 11077 2022-05-06 65 1 11076 2022-05-06 9 4 11075 2022-05-06 68 8 11074 2022-05-06 73 7 11073 2022-05-05 58 2 Instead of adding a tie-breaker to the ORDER BY list, a request can be made to return all ties by adding the WITH TIES option. SELECT TOP (5) WITH TIES orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC; SQL Server first returned the TOP (5) rows based on orderdate DESC ordering, and it also returned all other rows from the table that had the same orderdate value as in the last of the five rows that were accessed. Using the WITH TIES option, the selection of rows is deterministic, but the presentation order among rows with the same order date isn’t. 11077 2022-05-06 65 1 11076 2022-05-06 9 4 11075 2022-05-06 68 8 11074 2022-05-06 73 7 11073 2022-05-05 58 2 11072 2022-05-05 20 4 11071 2022-05-05 46 1 11070 2022-05-05 44 2 The TOP filter is very useful, but it has two shortcomings—it’s not standard, and it doesn’t support a skipping capability. 2.8. OFFSET-FETCH T-SQL also supports a standard, TOP-like filter, called OFFSET-FETCH, which does support a skipping option, which makes it very useful for paging purposes. According to the SQL standard, the OFFSET-FETCH filter is considered an extension to the ORDER BY clause. With the OFFSET clause indicates how many rows to skip, and with the FETCH clause indicates how many rows to filter after the skipped rows. SELECT orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate, orderid OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY; -- OFFSET 50 ROWS; -- OFFSET 0 ROWS FETCH NEXT 25 ROWS ONLY; Note that a query that uses OFFSET-FETCH must have an ORDER BY clause. Also, contrary to the SQL standard, T-SQL doesn’t support the FETCH clause without the OFFSET clause. However, OFFSET without FETCH is allowed to skip the indicated number of rows and returns all remaining rows in the result. In the syntax for the OFFSET- FETCH filter, the singular and plural forms ROW and ROWS, and the forms FIRST and NEXT are interchangeable to phrase the filter in an intuitive, English-like manner. === OVER A window function is a function that, for each row in the underlying query, operates on a window (set) defined with an OVER clause of rows that is derived from the underlying query result, and computes a scalar (single) result value. SELECT orderid, custid, freight, ROW_NUMBER() OVER(PARTITION BY custid ORDER BY freight) AS rownum FROM Sales.Orders ORDER BY custid, freight; For each row in the underlying query, the OVER clause exposes to the function a subset of the rows from the underlying query’s result set. The OVER clause can restrict the rows in the window by using an optional window partition clause (PARTITION BY). It can define ordering for the calculation (if relevant) using a window order clause (ORDER BY)—not to be confused with the query’s presentation ORDER BY clause. Window functions are defined by the SQL standard, and T-SQL supports a subset of the features from the standard. 2.9. CASE A CASE expression, based on the SQL standard, is a scalar expression that returns a value based on conditional logic. Note that CASE is an (scalar) expression and not a statement; that is, it returns a value and it is allowed wherever scalar expressions are allowed, such as in the SELECT, WHERE, HAVING, and ORDER BY clauses and in CHECK constraints. There are two forms of CASE expressions: simple and searched. The simple CASE expression has a single test value or expression right after the CASE keyword that is compared with a list of possible values or expressions, in the WHEN clauses. If no value in the list is equal to the tested value, the CASE expression returns the value that appears in the ELSE clause (or NULL if an ELSE clause is not present). SELECT supplierid, COUNT(*) AS numproducts, CASE COUNT(*) % 2 WHEN 0 THEN &#39;Even&#39; WHEN 1 THEN &#39;Odd&#39; ELSE &#39;Unknown&#39; END AS countparity FROM Production.Products GROUP BY supplierid; The searched CASE expression returns the value in the THEN clause that is associated with the first WHEN predicate that evaluates to TRUE. If none of the WHEN predicates evaluates to TRUE, the CASE expression returns the value that appears in the ELSE clause (or NULL if an ELSE clause is not present). SELECT orderid, custid, freight, CASE WHEN freight &lt; 1000.00 THEN &#39;Less than 1000&#39; WHEN freight &lt;= 3000.00 THEN &#39;Between 1000 and 3000&#39; WHEN freight &gt; 3000.00 THEN &#39;More than 3000&#39; ELSE &#39;Unknown&#39; END AS valuecategory FROM Sales.Orders; 3. Predicates and Operators T-SQL has language elements in which predicates can be specified—for example, query filters such as WHERE and HAVING, the JOIN operator’s ON clause, CHECK constraints, and others. T-SQL uses three-valued predicate logic, where logical expressions can evaluate to TRUE, FALSE, or UNKNOWN. 3.1. Predicates: IN, BETWEEN, LIKE, EXISTS, and IS NULL The IN predicate is used to check whether a value, or scalar expression, is equal to at least one of the elements in a set. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderid IN(10248, 10249, 10250); The BETWEEN predicate is used to to check whether a value falls within a specified range, INCLUSIVE of the two delimiters of the range. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderid BETWEEN 10300 AND 10310; The LIKE predicate is used to check whether a character string value meets a specified pattern. SELECT empid, firstname, lastname FROM HR.Employees WHERE lastname LIKE N&#39;D%&#39;; Notice the use of the letter N to prefix the string &#39;D%&#39;; it stands for National and is used to denote that a character string is of a Unicode data type (NCHAR or NVARCHAR), as opposed to a regular character data type (CHAR or VARCHAR). The EXISTS or NOT EXISTS predicate is used to test for the presence or absence of rows in a subquery. SELECT custid, companyname FROM Sales.Customers AS C WHERE EXISTS (SELECT * FROM Sales.Orders AS O WHERE O.custid = C.custid); The IS NULL and its opposite IS NOT NULL predicates are used to test for NULL values. SELECT empid, firstname, lastname, mgrid FROM HR.Employees WHERE mgrid IS NULL; 3.2. Three-Valued Logic (3VL) SQL uses three-valued logic (3VL), where expressions can evaluate to one of three states: TRUE, FALSE, or NULL (also called UNKNOWN). It is critical to understand that WHERE and HAVING clauses only accept rows where the condition is TRUE, discarding rows that are FALSE or NULL. The logical operators AND, OR, and NOT behave as follows: NOT Operator: NOT TRUE results in FALSE. NOT FALSE results in TRUE. NOT NULL results in NULL. AND Operator (Pessimistic): It returns TRUE only if both sides are TRUE. It is pessimistic because if one side is FALSE, the result is FALSE, even if the other side is NULL. TRUE AND NULL results in NULL. FALSE AND NULL results in FALSE. NULL AND NULL results in NULL. OR Operator (Optimistic): It returns TRUE if either side is TRUE. It is optimistic because if one side is TRUE, the result is TRUE, even if the other side is NULL. TRUE OR NULL results in TRUE. FALSE OR NULL results in NULL. NULL OR NULL results in NULL. 3.3. Equality and Distinctness In SQL, the way NULL values are compared depends on the context, leading to two different types of comparison logic: Equality-based Comparison is the standard comparison used in predicates like WHERE and JOIN ON. It treats NULL as an unknown value. Because one unknown cannot be said to be equal to another, the expression NULL = NULL evaluates to UNKNOWN, not TRUE. Distinctness-based Comparison is used by operators that need to group rows or find duplicates, such as GROUP BY, UNION, INTERSECT, and EXCEPT. For these operations, two NULL values are treated as not distinct from each other (i.e., they are considered identical) which ensures that rows with NULL values in the same columns are correctly identified as duplicates. The formal SQL standard predicate for this logic is IS [NOT] DISTINCT FROM. It provides a way to compare values while treating two NULL values as equivalent. For example, NULL IS NOT DISTINCT FROM NULL evaluates to TRUE. It is important to note that T-SQL does not support this predicate, even though its set operators use the underlying distinctness logic. 3.4. Comparison Operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, and ALL, SOME, ANY T-SQL supports the comparison operators: =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, !&gt;, and !&lt;, of which the last three are not standard and should be avoided using. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20220101&#39;; The &lt;&gt; (not equal) operator is used to check whether a value is not equal to another value. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &lt;&gt; &#39;20220101&#39;; The ALL keyword is used with a comparison operator to compare a scalar value with every value in a list or result set returned by a subquery. The condition is TRUE if the comparison is TRUE for all values in the list. -- Example: Find products whose list price is greater than ALL list prices in the &#39;Road Bikes&#39; category. SELECT Name, ListPrice FROM Production.Product WHERE ListPrice &gt; ALL (SELECT ListPrice FROM Production.Product WHERE ProductSubcategoryID = 1); The SOME or ANY keyword (they are synonyms) is used with a comparison operator to compare a scalar value with any value in a list or result set returned by a subquery. The condition is TRUE if the comparison is TRUE for at least one value in the list. -- Example: Find products whose list price is greater than SOME list prices in the &#39;Mountain Bikes&#39; category. SELECT Name, ListPrice FROM Production.Product WHERE ListPrice &gt; SOME (SELECT ListPrice FROM Production.Product WHERE ProductSubcategoryID = 2); It&#8217;s important to distinguish between NOT IN and &lt;&gt; ANY: NOT IN means &quot;not equal to value A AND not equal to value B AND not equal to value C&#8230;&#8203;&quot; &lt;&gt; ANY means &quot;not equal to value A OR not equal to value B OR not equal to value C&#8230;&#8203;&quot; For example, if a subquery returns (1, 2, 3): value NOT IN (1, 2, 3) is true if value is not 1 AND not 2 AND not 3. value &lt;&gt; ANY (1, 2, 3) is true if value is not 1 OR not 2 OR not 3. 3.5. Logical Operators: OR, AND, and NOT The logical operators OR, AND, and NOT are used to combine logical expressions. SELECT orderid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20220101&#39; AND empid NOT IN(1, 3, 5); 3.6. Arithmetic Operators: +, -, *, /, and % T-SQL supports the four obvious arithmetic operators: +, -, *, and /, and also supports the % operator (modulo), which returns the remainder of integer division. SELECT orderid, productid, qty, unitprice, discount, qty * unitprice * (1 - discount) AS val FROM Sales.OrderDetails; Note that the data type of a scalar expression involving two operands is determined in T-SQL by the operand with the higher data-type precedence. If both operands are of the same data type, the result of the expression is of the same data type as well. If the two operands are of different types, the one with the lower precedence is promoted to the one that is higher. WITH Numbers AS ( SELECT 5 AS IntValue, 2 AS IntDivisor, 5.0 AS FloatValue ) SELECT IntValue / IntDivisor AS IntegerDivisionResult, -- Integer division CAST(IntValue AS NUMERIC(12, 2)) / CAST(IntDivisor AS NUMERIC(12, 2)) AS DecimalDivisionResult, -- Decimal division with casting FloatValue / IntDivisor AS DecimalDivisionFromFloatResult -- Division with a float FROM Numbers; The NUMERIC(12, 2) data type in T-SQL (SQL Server) defines a fixed-precision decimal number. 12 (Precision) → The total number of digits that can be stored (both before and after the decimal point). 2 (Scale) → The number of digits after the decimal point. 1234567890.12 -- Valid (12 digits total: 10 before the decimal, 2 after) | 999999999999.99 -- Valid (max possible value) | 100000000000.00 -- Invalid (13 digits, exceeds precision) | 12345.678 -- Invalid (more than 2 decimal places) | NUMERIC(p, s) and DECIMAL(p, s) are functionally identical in SQL Server. Both store exact numbers (unlike FLOAT or REAL, which are approximate). 4. Query Tuning To simulate a cold cache scenario for query performance measurement, run a manual checkpoint to write dirty buffers to disk and then drop all clean buffers from cache. CHECKPOINT; DBCC DROPCLEANBUFFERS; DBCC DROPCLEANBUFFERS should only be used isolated test environments as it can severely impact server performance. To see the estimated plan in SSMS/ADS by highlighting the query and clicking the Display Estimated Execution Plan (Ctrl+L) button on the SQL Editor toolbar. To see the actual plan by enabling the Include Actual Execution Plan (Ctrl+M) button and executing the query. Actual execution plans are generated after the T-SQL queries or batches execute that includes run-time information like the actual number of rows returned by, and the actual number of executions of, each operator. To enable measuring query performance with the session options STATISTICS IO (for I/O information) and STATISTICS TIME (for time information): SET STATISTICS IO, TIME ON; 4.1. SQL Server Internals A page is an 8-KB unit where SQL Server stores data. With disk-based tables, the page is the smallest I/O unit that SQL Server can read or write. An extent is a unit that contains eight contiguous pages. A table can be organized in one of two ways—either as a heap or as a B- tree (HOBT), technically as a B-tree when it has a clustered index defined on it and as a heap when it doesn’t. A heap is a table that has no clustered index, which means that the data is laid out as a bunch of pages and extents without any order. SQL Server maps the data that belongs to a heap using one or more bitmap pages called index allocation maps (IAMs). An allocation order scan is a heap scan that uses IAM pages to determine which pages and extents belong to the heap and reads them in physical file order, typically resulting in sequential reads when data is not cached. 4.1.1. Indexes All indexes in SQL Server on disk-based tables are structured as B-trees, which are a special case of balanced trees. An index on disk-based tables has a doubly linked list in their leaf level, so SQL Server can scan the rows in the leaf in forward and backward order. A clustered index is structured as a B-tree, and it maintains the entire table’s data, not a copy, in its leaf level. At the leaf level of the clustered index, the order in which data pages are stored on disk may not correspond to the sorted order of the index keys due to page splits. If page x points to next page y, and page y appears before page x in the file, page y is considered an out-of- order page. A nonclustered index is also structured as a B-tree, in contrast to a clustered index, a leaf row in a nonclustered index contains only the index key columns and a row locator value representing a particular data row. With the nonclustered index seek or range scan, it is more efficient because with fewer columns in the leaf row to fit more rows per leaf page. When using multiple predicates, the order of key columns in a nonclustered index is crucial for performance, as it determines whether qualifying rows are stored contiguously in the index leaf, maximizing seeks and minimizing scans. When have multiple equality predicates, place the columns from the predicates in any order in the index key list. When have at most one range predicate, place the columns from the equality predicates first in the key list and the column from the range predicate last. When have multiple range predicates, place the column from the most selective range predicate before the columns from the remaining range predicates. An index order scan is a scan performed on the leaf level of a B-tree index in the sorted order of the index key, using a doubly linked list for inter-page navigation and a row-offset array for intra-page order, supporting both full ordered scans and range scans. An index scan is necessary when the query filters on a non-leading column of the index key to scan a larger portion of the index (or even the entire index) to find the matching entries. An index seek is performed when SQL Server needs to find a certain key or range of keys at the leaf level of the index. An index seek is possible when the query filters on the leading column (or a prefix of the leading columns) of the index key to navigate the B-tree from the root node down to the specific leaf page(s) containing the matching values. In SQL Server, the direction of key columns can be indicated in an index definition (ascending by default). CREATE UNIQUE NONCLUSTERED INDEX [idx] ON [schema1].[Table1] ( [col1], -- same as [col1] ASC [col2] DESC ) The storage engine currently processes parallel scans only in the forward direction; backward scans are processed serially. If parallelism is a critical factor in the performance of the query, arrange a descending index. A filtered index is an index on a subset of rows from the underlying table defined based on a predicate. CREATE NONCLUSTERED INDEX idx_USA_orderdate ON Sales.Orders(orderdate) INCLUDE(orderid, custid, requireddate) WHERE shipcountry = N&#39;USA&#39;; A covering index is an index that contains all the columns required by the query, avoiding lookups to the base table. A clustered index is a covering index because the leaf row is the complete data row. A nonclustered index can be a covering index with an INCLUDE clause listing all non-key columns required by the query. CREATE INDEX idx_nc_cid_i_oid_eid_sid_od_flr ON dbo.Orders(custid) INCLUDE(orderid, empid, shipperid, orderdate, filler); A columnstore index stores data by columns rather than by rows, which leads to substantial performance advantages for analytical queries. A nonclustered columnstore index is a secondary index created on an existing table that is stored in the traditional rowstore format. CREATE NONCLUSTERED COLUMNSTORE INDEX idx_nc_cs ON dbo.Fact(key1, key2, key3, measure1, measure2, measure3, measure4); A clustered columnstore index is the primary storage for the table, with data physically stored in columnstore format. CREATE CLUSTERED COLUMNSTORE INDEX idx_cl_cs ON dbo.FactCS; 4.1.2. Execution Plans In SQL Server, the relational engine, like a brain including the optimizer, produces execution plans for queries, while the storage engine, like muscles, carries out these instructions, sometimes choosing the best of several options based on performance and consistency. When the plan shows a table scan operator, the storage engine has only one option: to use an allocation order scan. When the plan shows an ordered index scan operator (clustered or nonclustered), the storage engine can use only an index order scan. When the plan shows an unordered index scan operator, the storage engine has two options to scan the data: allocation order scan and index order scan. An allocation order scan can return multiple occurrences of rows and skip rows resulting from splits that take place during the scan. The storage engine opts for this option when the index size is greater than 64 pages and the request is running under the Read Uncommitted isolation level. When the query is running under the default Read Committed isolation level or higher, the storage engine will opt for an index order scan to prevent such phenomena from happening because of splits. An index order scan is safer in the sense that it won’t read multiple occurrences of the same row or skip rows because of splits. If an index key is modified after the row was read by an index order scan and the row is moved to a point in the leaf that the scan hasn’t reached yet, the scan will read the row a second time or never reach that row. It can happen in Read Uncommitted, Read Committed, and even Repeatable Read because the update was done to a row that was not yet read, but cannot happen under the isolation levels Serializable, Read Committed Snapshot, and Snapshot. 4.1.3. Cardinality Estimates A query optimizer, the main component in the relational engine (also known as the query processor), is responsible for generating physical execution plans for the queries. A cardinality estimator, that makes cardinality estimates of the number of rows returned by each operator, is employed by the optimizer to make decisions about access methods, join and aggregation algorithms, and memory allocation for sort and hash operations. It is not a simple task to make accurate cardinality estimations without actually running the query and without a time machine. Underestimations will tend to result in the following (not an exhaustive list): For filters, preferring an index seek and lookups to a scan. For aggregates, joins, and distinct, preferring order-based algorithms to hash-based ones. For sort and hash operations, there might be spills to tempdb as a result of an insufficient memory grant. Preferring a serial plan over a parallel one. Overestimations will tend to result in pretty much the inverse of underestimations (again, not an exhaustive list): For filters, preferring a scan to an index seek and lookups. For aggregates, joins, and distinct, preferring hash-based algorithms to order-based ones. For sort and hash operations, there won’t be spills, but very likely there will be a larger memory grant than needed, resulting in wasting memory. Preferring a parallel plan over a serial one. SQL Server relies on statistics about the data in its cardinality estimates. Whenever creating an index, SQL Server creates statistics using a full scan of the data. When additional statistics are needed, SQL Server might create them automatically using a sampled percentage of the data. SQL Server creates three main types of statistics: header, density vectors, and a histogram. CREATE INDEX idx_nc_cid_eid ON dbo.Orders(custid, empid); DBCC SHOW_STATISTICS(N&#39;dbo.Orders&#39;, N&#39;idx_nc_cid_eid&#39;); 4.1.4. Parallel Query Execution Parallel query execution (intraquery parallelism or parallelism) uses multiple processor cores to simultaneously process smaller chunks of data, leveraging modern hardware&#8217;s increased computing power for efficient large-data processing. Parallel processing, splitting work across multiple processor cores, can be implemented using two main models: a factory-line model (where each core performs a single action on data passed between cores) and a stream-based model (where each core processes a subset of data through all required operations). While the factory-line model might seem intuitively better for human tasks, database systems like SQL Server use stream-based models. Processors can efficiently switch between tasks as long as data is in local cache, and minimizing data movement between memory and storage is crucial for performance. Stream-based models can scale much better than factory-line models with large datasets, distributing rows across cores as evenly as possible using various algorithms for parallel execution of all operations on each subset of data. A query plan will be either entirely serial—processed using a single worker thread—or it will include one or more parallel branches, which are areas of the plan that are processed using multiple threads. The query processor can merge parallel streams into a single stream or create parallel streams from a single stream, resulting in plans with interleaved serial and parallel zones. All parallel zones in a plan use the same number of threads, known as the degree of parallelism (DOP), determined by server settings, hints, and runtime conditions. A given set of threads might be reused by multiple zones over the course of the plan. Parallel operators in the execution plan are marked with a circle icon with two arrows. Within a parallel zone, each thread processes a unique stream of rows before passing them to the next zone (serial or parallel). Parallel query plans rely on the Exchange (displayed as Parallelism) operator, which manages worker threads and data streams. Each SQL Server query plan operator has, internally, two logical interfaces: a consumer interface, which takes rows from upstream, and a producer interface, which passes rows downstream. While most operators handle their consumer and producer interfaces on the same thread and process single row streams, Exchange operators involve multiple threads and handle multiple streams, keeping other operators unaware of the parallelism. The number of threads on each side of the exchange depends on the type of exchange: A query plan can be read right-to-left (data flow) or left-to-right (operator logic). Gather Streams operators will have DOP threads on the consumer side and one thread on the producer side. From a data-flow perspective, it merges multiple parallel streams into a single serial stream, marking the end of a parallel zone. From an operator-logic perspective, it starts a parallel zone by invoking parallel worker threads. Distribute Streams operators will have one thread on the consumer side and DOP threads on the producer side. From a data-flow perspective, it splits a serial stream into multiple parallel streams, marking the start of a parallel zone. From an operator-logic perspective, it marks the end of a parallel zone. Repartition Streams operators will have DOP threads on each side of the exchange. From both data-flow and operator-logic perspectives, it redistributes rows from multiple parallel streams onto different threads based on a new scheme, effectively joining two adjacent parallel zones. Parallel query plans use five row distribution strategies across threads on the producer side of Distribute or Repartition exchanges: Hash: Assigns rows to threads based on a hash function, grouping rows with the same hashed value on the same thread (e.g., grouping by ProductID for aggregation). Round Robin: Distributes rows sequentially to each thread in a rotating fashion, often used outside Nested Loops where each row represents independent work. Broadcast: Sends all rows to all threads, used for small row counts when all threads need the complete dataset (e.g., building a hash table). Demand: Producer-side threads receive rows on request, currently used only with aligned partitioned tables. Range: Assigns unique, non-overlapping key ranges to each thread, used only for index building. 4.2. Data Retrieval Strategies SQL Server query optimizer uses various strategies to determine how the storage engine physically retrieves data from tables and indexes. Understanding these strategies, such as table scans, index seeks, and lookups, is crucial for diagnosing query performance and optimizing data access paths. 4.2.1. Unordered Clustered Index Scan or Table Scan A table scan or an unordered clustered index scan involves a scan of all data pages that belong to the table. Full table scans occur primarily in two cases: when all rows are required or when need only a subset of the rows but don’t have a good index to support the filter. When the underlying table is a heap, the plan will show an operator called Table Scan. SELECT * INTO dbo.Orders2 FROM dbo.Orders; ALTER TABLE dbo.Orders2 ADD CONSTRAINT PK_Orders2 PRIMARY KEY NONCLUSTERED (orderid); GO -- table scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orderss; When the underlying table is a B- tree, the plan will show an operator called Clustered Index Scan with an Ordered: False property. The fact that the Ordered property of the Clustered Index Scan operator indicates False means that as far as the relational engine is concerned, the data does not need to be returned from the operator in key order. It is up to the storage engine to determine to employ allocation order scan or index order scan. -- clustered index scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders; 4.2.2. Unordered Covering Nonclustered Index Scan An unordered covering nonclustered index scan is a query access method to retrieve all necessary data for a query solely from the leaf level of a nonclustered index, without accessing the base table&#8217;s data rows. An unordered covering nonclustered index scan is similar to an unordered clustered index scan. -- unordered covering nonclustered index scan SELECT orderid -- PRIMARY KEY NONCLUSTERED (orderid) FROM dbo.Orders; 4.2.3. Ordered Clustered Index Scan An ordered clustered index scan is a full scan of the leaf level of the clustered index that guarantees that the data will be returned to the next operator in index order. -- ordered clustered index scan SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders ORDER BY orderdate; -- CLUSTERED INDEX (orderdate) 4.2.4. Ordered Covering Nonclustered Index Scan An ordered covering nonclustered index scan is similar to an unordered covering nonclustered index scan, but retrieves data in the order of the index keys. -- ordered covering nonclustered index scan SELECT orderid, orderdate FROM dbo.Orders ORDER BY orderid; -- PRIMARY KEY NONCLUSTERED (orderid) 4.2.5. Nonclustered Index Seek + Range Scan + Lookups A nonclustered index seek + range scan + lookups access method is typically used for small-range queries or point queries using a nonclustered index that doesn’t cover the query. A point query uses equality conditions (=) to target specific values, potentially retrieving zero, one, or multiple rows, while a range query uses range operators (&lt;, &gt;, &lt;=, &gt;=, BETWEEN) to retrieve rows within a specified interval. While the index is capable of supporting the filter, lookups will be required to obtain the remaining columns from the respective data rows due to the index&#8217;s non-covering nature. If the target table is a heap, the lookups will be RID Lookups, each costing one page read. -- nonclustered index seek + range scan + lookups against a heap SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders2 -- heap WHERE orderid &lt;= 25; -- PRIMARY KEY NONCLUSTERED (orderid) If the underlying table is a B-tree, the lookups will be Key Lookups, each costing as many reads as the number of levels in the clustered index. -- nonclustered index seek + range scan + lookups against a B-tree SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders -- B-tree WHERE orderid &lt;= 25; -- PRIMARY KEY NONCLUSTERED (orderid) 4.2.6. Unordered Nonclustered Index Scan + Lookups An unordered nonclustered index scan + lookups access method is typically used by the optimizer when the following conditions are in place: The query has a selective filter. There’s a nonclustered index that contains the filtered column (or columns), but the index isn’t a covering one. The filtered columns are not leading columns in the index key list. -- unordered nonclustered index scan + lookups -- missing index SELECT orderid, custid, empid, shipperid, orderdate, filler FROM dbo.Orders WHERE custid = &#39;C0000000001&#39;; -- NONCLUSTERED INDEX (shipperid, orderdate, custid); It performs a full unordered scan of the leaf level of the index, followed by lookups for qualifying keys, a strategy that becomes less efficient than a full table scan for less selective queries due to the lookup overhead. 4.2.7. Clustered Index Seek + Range Scan A clustered index seek + range scan access method is typically used by the optimizer for range queries where the filter based on the first key column (or columns) of the clustered index. -- clustered index seek + range scan SELECT orderid, custid, empid, shipperid, orderdate FROM dbo.Orders WHERE orderdate = &#39;20140212&#39;; -- CLUSTERED INDEX (orderdate); 4.2.8. Covering Nonclustered Index Seek + Range Scan A covering nonclustered index seek + range scan access method is similar to the access method clustered index seek + range scan, only it uses a nonclustered covering index. -- nonclustered index seek + range scan SELECT orderid, shipperid, orderdate, custid FROM dbo.Orders WHERE shipperid = &#39;C&#39; AND orderdate &gt;= &#39;20140101&#39; AND orderdate &lt; &#39;20150101&#39;; -- NONCLUSTERED INDEX (shipperid, orderdate, custid); 4.3. Tied Rows and Sorting When an ORDER BY clause is used, SQL Server guarantees the result set is sorted according to the specified columns. However, this guarantee does not extend to rows with the same value in the ordering columns—known as tied rows. The order in which tied rows are returned is not guaranteed and can vary between query executions, leading to an unstable sort. This instability occurs because the execution plan only guarantees the explicitly requested order. For tied rows, the database returns them in whatever order is most convenient for that specific execution, which can lead to unexpected behavior, particularly in pagination scenarios. For instance, if a user is paging through a customer&#8217;s order history, an unstable sort could cause the same order to appear on multiple pages or for some orders to be skipped entirely, because the order of that customer&#8217;s orders shifted between page loads. To ensure a consistent and predictable sort, the ORDER BY clause must uniquely identify every row, which can be achieved by adding a tie-breaker—a column or set of columns guaranteed to be unique, such as the table&#8217;s primary key. For example, consider sorting orders by customer. A single customer can have multiple orders, creating tied rows. -- Unstable sort: Order of rows for the same `custid` is not guaranteed. SELECT custid, orderid, orderdate FROM Sales.Orders ORDER BY custid; By adding the unique orderid column as a tie-breaker, the sort becomes deterministic. A secondary sort by orderdate is also a good practice. -- Stable sort: orderdate and orderid act as tie-breakers. SELECT custid, orderid, orderdate FROM Sales.Orders ORDER BY custid, orderdate DESC, orderid DESC; This forces the optimizer to perform a secondary sort on orderdate and then orderid for any tied rows, resulting in a deterministic, or stable, sort that is consistent with every execution. 5. Joins T-SQL supports four table operators: JOIN, APPLY, PIVOT, and UNPIVOT. The JOIN operator is standard, while APPLY, PIVOT, and UNPIVOT are T-SQL extensions. Each table operator acts on input tables, applies a set of logical query processing phases, and returns a table result. A JOIN table operator operates on two input tables and has three fundamental types: A CROSS JOIN applies only one phase, the Cartesian Product. An INNER JOIN applies two phases, the Cartesian Product and the Filter. An OUTER JOIN applies three phases, the Cartesian Product, the Filter, and the Add Outer Rows. These phases describe the logical processing steps involved in different types of SQL joins: The Cartesian Product is the initial step where every row from the first table is combined with every row from the second table, resulting in a new table containing all possible combinations. A Filter is applied after the Cartesian Product, based on the ON clause of the join. Only the rows that satisfy the join condition are kept. Add Outer Rows is a specific phase for outer joins (LEFT, RIGHT, or FULL) that, after filtering, includes in the result set any rows from the outer table(s) that did not find a match in the other table. For a LEFT OUTER JOIN, the outer table is the left table. For a RIGHT OUTER JOIN, the outer table is the right table. For a FULL OUTER JOIN, both tables are considered outer tables. For these non-matching rows, columns from the table where no match was found will contain NULL values. The OUTER keyword is optional for LEFT, RIGHT, and FULL joins (e.g., LEFT JOIN is equivalent to LEFT OUTER JOIN). 5.1. CROSS The cross join is the simplest type of join that implements only one logical query processing phase—a Cartesian Product. It operates on the two tables provided as inputs and produces a Cartesian product of the two, that is, each row from one input is matched with all rows from the other. -- SQL-92 syntax SELECT C.custid, E.empid FROM Sales.Customers AS C CROSS JOIN HR.Employees AS E; -- SQL-89 syntax (not recommended) SELECT C.custid, E.empid FROM Sales.Customers AS C, HR.Employees AS E; -- Self cross joins SELECT E1.empid, E1.firstname, E1.lastname, E2.empid, E2.firstname, E2.lastname FROM HR.Employees AS E1 CROSS JOIN HR.Employees AS E2; DROP TABLE IF EXISTS dbo.Digits; CREATE TABLE dbo.Digits (digit INT NOT NULL PRIMARY KEY); INSERT INTO dbo.Digits(digit) VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9); -- Producing tables of numbers SELECT D3.digit * 100 + D2.digit * 10 + D1.digit + 1 AS n FROM dbo.Digits AS D1 CROSS JOIN dbo.Digits AS D2 CROSS JOIN dbo.Digits AS D3 ORDER BY n; 1 2 3 . . . 998 999 1000 5.2. INNER An inner join applies two logical query processing phases—it applies a Cartesian product between the two input tables like in a cross join, and then it filters rows based on a specified predicate in a designated clause called ON. -- SQL-92 syntax SELECT E.empid, E.firstname, E.lastname, O.orderid FROM HR.Employees AS E INNER JOIN Sales.Orders AS O ON E.empid = O.empid; -- Note that the SQL-89 syntax has no ON clause. SELECT E.empid, E.firstname, E.lastname, O.orderid FROM HR.Employees AS E, Sales.Orders AS O WHERE E.empid = O.empid; As with the WHERE and HAVING clauses, the ON clause also returns only rows for which the predicate evaluates to TRUE, and it does not return rows for which the predicate evaluates to FALSE or UNKNOWN. When a join condition involves only an equality operator, the join is said to be an equi join. When a join condition involves any operator besides equality, the join is said to be a non-equi join. SELECT E1.empid, E1.firstname, E1.lastname, E2.empid, E2.firstname, E2.lastname FROM HR.Employees AS E1 INNER JOIN HR.Employees AS E2 ON E1.empid &lt; E2.empid; Standard SQL supports a concept called natural join, which represents an inner join based on a match between columns with the same name in both sides. T-SQL doesn’t have an implementation of a natural join. For example, T1 NATURAL JOIN T2 joins the rows between T1 and T2 based on a match between the columns with the same names on both sides. A join that has an explicit join predicate like equi join and non-equi join that is based on a binary operator (equality or inequality) is known as a theta join. 5.3. OUTER Outer joins were introduced in SQL-92 and, unlike inner joins and cross joins, have only one standard syntax—the one in which the JOIN keyword is specified between the table names and the join condition is specified in the ON clause. Outer joins apply the two logical processing phases that inner joins apply (Cartesian Product and the ON filter), plus a third phase called Adding Outer Rows that is unique to this type of join. In an outer join, a table is marked as a preserved table by using the keywords LEFT OUTER JOIN, RIGHT OUTER JOIN, or FULL OUTER JOIN between the table names. The OUTER keyword is optional. The LEFT keyword means that the rows of the left table (the one to the left of the JOIN keyword) are preserved; the RIGHT keyword means that the rows in the right table are preserved; and the FULL keyword means that the rows in both the left and right tables are preserved. The third logical query processing phase of an outer join identifies the rows from the preserved table that did not find matches in the other table based on the ON predicate, which adds those rows to the result table produced by the first two phases of the join, and it uses NULLs as placeholders for the attributes from the nonpreserved side of the join in those outer rows. SELECT C.custid, C.companyname, O.orderid FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid; A FULL OUTER JOIN with the condition ON 1=1 is functionally equivalent to a CROSS JOIN. If the predicate in the WHERE clause refers to an attribute from the nonpreserved side of the join using an expression in the form &lt;attribute&gt; &lt;operator&gt; &lt;value&gt;, because attributes from the nonpreserved side of the join are NULLs in outer rows, and an expression in the form NULL &lt;operator&gt; &lt;value&gt; yields UNKNOWN (unless it’s the IS NULL operator explicitly looking for NULLs, or the distinct predicate IS [NOT] DISTINCT FROM), it’s usually an indication of a bug, SELECT C.custid, C.companyname, O.orderid, O.orderdate FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid WHERE O.orderdate &gt;= &#39;20220101&#39;; -- Effectively, the join becomes an inner join. If the predicate in the inner join’s ON clause compares an attribute from the nonpreserved side of the outer join and an attribute from the third table, all outer rows are discarded. Remember that outer rows have NULLs in the attributes from the nonpreserved side of the join, and comparing a NULL with anything yields UNKNOWN. UNKNOWN is filtered out by the ON filter. In other words, such a predicate nullifies the outer join, effectively turning it into an inner join. -- outer rows are dropped whenever any kind of outer join (left, right, or full) is -- followed by a subsequent inner join or right outer join. SELECT C.custid, O.orderid, OD.productid, OD.qty FROM Sales.Customers AS C LEFT OUTER JOIN Sales.Orders AS O ON C.custid = O.custid INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid; 5.4. APPLY The nonstandard APPLY operator, like a correlated join, instead of treaing its two inputs as a set, applies the right table (typically a derived table or a TVF) to each row from the left table (evaluated first) and produces a result table with the unified result sets. A CROSS APPLY operator is equavelent to a CROSS JOIN. SELECT S.shipperid, E.empid FROM Sales.Shippers AS S CROSS JOIN HR.Employees AS E; -- =&gt; SELECT S.shipperid, E.empid FROM Sales.Shippers AS S CROSS APPLY HR.Employees AS E; With APPLY, the left side is evaluated first, and the right side is evaluated per row from the left iteratively, and can have references to elements from the left. SELECT C.custid, A.orderid, A.orderdate FROM Sales.Customers AS C CROSS APPLY (SELECT TOP (3) orderid, empid, orderdate, requireddate FROM Sales.Orders AS O WHERE O.custid = C.custid ORDER BY orderdate DESC, orderid DESC) AS A; -- A is a correlated derived table Because the derived table is applied to each left row, the CROSS APPLY operator returns the three most recent orders for each customer. 1 11011 2022-04-09 1 10952 2022-03-16 1 10835 2022-01-15 2 10926 2022-03-04 2 10759 2021-11-28 2 10625 2021-08-08 3 10856 2022-01-28 3 10682 2021-09-25 3 10677 2021-09-22 . . . If the right table expression returns an empty set, the CROSS APPLY operator does not return the corresponding left row. To return rows from the left side even if there are no matches on the right side, use OUTER APPLY. SELECT C.custid, A.orderid, A.orderdate FROM Sales.Customers AS C OUTER APPLY (SELECT orderid, empid, orderdate, requireddate FROM Sales.Orders AS O WHERE O.custid = C.custid AND O.custid in (22, 57) ORDER BY orderdate DESC, orderid DESC OFFSET 0 ROWS FETCH FIRST 3 ROWS ONLY) AS A; 1 NULL NULL 2 NULL NULL 3 NULL NULL It&#8217;s more conventional to work with inline TVFs instead of derived tables. CREATE OR ALTER FUNCTION dbo.TopOrders (@custid AS INT, @n AS INT) RETURNS TABLE AS RETURN SELECT orderid, empid, orderdate, requireddate FROM Sales.Orders WHERE custid = @custid ORDER BY orderdate DESC, requireddate DESC OFFSET 0 ROWS FETCH NEXT @N ROWS ONLY; GO SELECT C.custid, C.companyname, A.orderid, A.empid, A.orderdate, A.requireddate FROM Sales.Customers AS C CROSS APPLY dbo.TopOrders(C.custid, 3) AS A; GO -- cleanup DROP FUNCTION if EXISTS dbo.TopOrders 6. Subqueries SQL supports writing queries within queries, or nesting queries. The outermost query is a query whose result set is returned to the caller and is known as the outer query. The inner query is a query whose result set is used by the outer query and is known as a subquery. A subquery can be either self-contained or correlated. A self-contained subquery has no dependency on tables from the outer query, whereas a correlated subquery does. A subquery can be single-valued, multivalued, or table-valued, that is, a subquery can return a single value, multiple values, or a whole table result. In queries that include a correlated subquery (a.k.a., a repeating subquery), the subquery depends on the outer query for its values, which means that the subquery is executed repeatedly, once for each row that might be selected by the outer query. SELECT custid, orderid, orderdate, empid FROM Sales.Orders AS O1 WHERE orderid = (SELECT MAX(O2.orderid) FROM Sales.Orders AS O2 WHERE O2.custid = O1.custid); A scalar subquery is a subquery that return a single value or NULL and can be anywhere in the outer query where a single-valued expression expected, such as WHERE or SELECT. DECLARE @maxid AS INT = (SELECT MAX(orderid) FROM Sales.Orders); SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE orderid = @maxid; -- substitute the above variable with a scalar self-contained subquery SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE orderid = (SELECT MAX(O.orderid) FROM Sales.Orders AS O); A multi-valued subquery is a subquery that returns multiple values as a single column, and such as the IN predicate, operate on a multi-valued subquery. SELECT orderid FROM Sales.Orders WHERE empid IN (SELECT E.empid FROM HR.Employees AS E WHERE E.lastname LIKE N&#39;D%&#39;); In some cases the database engine optimizes both the subquery and the the join the same way, sometimes joins perform better, and sometimes subqueries perform better. 6.1. Subqueries with IN or NOT IN A subquery introduced with IN or NOT IN provides a set of zero or more values for the outer query&#8217;s filtering. An empty set will cause the IN condition to always be FALSE, and the NOT IN condition to always be TRUE. 6.2. Subqueries with comparison operators Subqueries can be introduced with one of the comparison operators (=, &lt; &gt;, &gt;, &gt; =, &lt;, ! &gt;, ! &lt;, or &lt; =). A subquery introduced with an unmodified comparison operator (a comparison operator not followed by ANY, SOME or ALL) must return a single value rather than a list of values, like subqueries introduced with IN, otherwise SQL Server displays an error message. 6.3. Subqueries with EXISTS or NOT EXISTS A subquery introduced with EXISTS or NOT EXISTS functions as an existence test, returning TRUE or FALSE to the outer query&#8217;s WHERE clause based on the presence or absence of rows, without actually producing data. SELECT custid, companyname FROM Sales.Customers AS C WHERE country = N&#39;Spain&#39; AND EXISTS (SELECT * FROM Sales.Orders AS O WHERE O.custid = C.custid); 7. Table Expressions A table expression is an expression—typically a query—that conceptually returns a table result and as such can be nested as an operand of another table expression. Recall that a table in SQL is the counterpart to a relation in relational theory. A table expression is therefore SQL’s counterpart to a relational expression. A relational expression in relational theory is an expression that returns a relation and as such can be nested as an operand of another relational expression. A named table expression is then a table expression assigned with a name, and interacted with like doing with a base table. T-SQL supports four types of named table expressions: derived tables, common table expressions (CTEs), views, and inline table-valued functions (inline TVFs). 7.1. Derived Tables Derived tables are defined in the FROM clause of an outer query, which treated as if it were a regular table for the outer query, and also sometimes referred to as an inline view. SELECT * FROM (SELECT custid, companyname FROM Sales.Customers WHERE country = N&#39;USA&#39;) AS USACusts; SELECT orderyear, COUNT(DISTINCT custid) AS numcusts FROM (SELECT YEAR(orderdate) AS orderyear, custid FROM Sales.Orders) AS D GROUP BY orderyear; 7.2. CTEs A Common Table Expression (CTE) is a temporary, named result set created from a query, which can then be used within the scope of a single statement such as SELECT, INSERT, UPDATE, or DELETE. A CTE can also refer to itself in what is known as a recursive CTE. WITH &lt;CTE_Name&gt;[(&lt;target_column_list&gt;)] AS ( &lt;inner_query_defining_CTE&gt; ) &lt;outer_query_against_CTE&gt;; CTEs support two forms of column aliasing: inline, which uses the AS keyword to rename columns individually within the SELECT statement, and external, which defines all column names at once in a parenthesized list immediately following the CTE&#8217;s name. Inline aliasing is the most common and recommended method, where each new column name is defined individually inside the SELECT list, directly following the column or expression it refers to. WITH UserCTE AS ( SELECT user_id AS ID, user_name AS Name FROM users ) SELECT ID, Name FROM UserCTE; External aliasing is an alternative method where a complete list of new column names is provided in parentheses immediately after the CTE&#8217;s name, before the query definition begins. While less common, this method is required in certain scenarios, such as defining the column structure for recursive CTEs. WITH UserCTE (ID, Name) AS ( SELECT user_id, user_name FROM users ) SELECT ID, Name FROM UserCTE; A CTE must be immediately consumed by a single SELECT, INSERT, UPDATE, MERGE, or DELETE statement. It can also be used to define the query within a CREATE VIEW statement. CREATE VIEW RecentSalesHires AS -- 1. The CTE is defined first to simplify the logic. WITH SalesEmployees AS ( SELECT employee_id, employee_name, hire_date FROM employees WHERE department = &#39;Sales&#39; AND status = &#39;Active&#39; ) -- 2. The view&#39;s main SELECT statement then uses the CTE. SELECT employee_id, employee_name FROM SalesEmployees WHERE hire_date &gt;= DATE(&#39;now&#39;, &#39;-1 year&#39;); A single, nonrecursive CTE can be defined by the combined results of multiple SELECT queries that are connected by a set operator like UNION ALL, UNION, INTERSECT, or EXCEPT. -- This single CTE is defined by two SELECT statements -- combined with a set operator (UNION). WITH AllContacts AS ( -- The first SELECT query SELECT email_address FROM ActiveCustomers UNION -- The set operator that combines them -- The second SELECT query SELECT email FROM ProspectiveCustomers ) -- Now you can use the CTE, which contains the combined results. SELECT * FROM AllContacts; Each CTE can refer to all previously defined CTEs, and the outer query can refer to all CTEs. WITH -- CTE 1: Finds all employees in the &#39;North America&#39; region. RegionalEmployees AS ( SELECT employee_id, employee_name FROM employees WHERE region = &#39;North America&#39; ), -- CTE 2: Calculates sales totals by joining with the first CTE. -- Note it only passes on the ID and the aggregated total. EmployeeSales AS ( SELECT re.employee_id, SUM(s.sale_amount) AS total_sales FROM sales AS s JOIN RegionalEmployees AS re ON s.employee_id = re.employee_id GROUP BY re.employee_id ) -- The outer query now joins BOTH CTEs to get the required columns. SELECT re.employee_name, -- This column comes from the first CTE. es.total_sales -- This column comes from the second CTE. FROM RegionalEmployees AS re JOIN EmployeeSales AS es ON re.employee_id = es.employee_id WHERE es.total_sales &gt; 500000 ORDER BY es.total_sales DESC; Multiple references in CTEs in table operators like joins WITH YearlyCount AS ( SELECT YEAR(orderdate) AS orderyear, COUNT(DISTINCT custid) AS numcusts FROM Sales.Orders GROUP BY YEAR(orderdate) ) SELECT Cur.orderyear, Cur.numcusts AS curnumcusts, Prv.numcusts AS prvnumcusts, Cur.numcusts - Prv.numcusts AS growth FROM YearlyCount AS Cur LEFT OUTER JOIN YearlyCount AS Prv ON Cur.orderyear = Prv.orderyear + 1; CTEs are unique among table expressions in the sense that they support recursion. Recursive CTEs, like nonrecursive ones, are defined by the SQL standard. WITH &lt;CTE_Name&gt;[(&lt;target_column_list&gt;)] AS ( &lt;anchor_member&gt; UNION ALL &lt;recursive_member&gt; ) &lt;outer_query_against_CTE&gt;; A recursive CTE is defined by at least two queries (more are possible)—at least one query known as the anchor member and at least one query known as the recursive member. The anchor member is a query that returns a valid relational result table —like a query that is used to define a nonrecursive table expression. The anchor member query is invoked only once. The recursive member is a query that has a reference to the CTE name and is invoked repeatedly until it returns an empty set. The reference to the CTE name represents the previous result set. The first time that the recursive member is invoked, the previous result set represents whatever the anchor member returned. In each subsequent invocation of the recursive member, the reference to the CTE name represents the result set returned by the previous invocation of the recursive member. Both queries must be compatible in terms of the number of columns they return and the data types of the corresponding columns. The reference to the CTE name in the outer query represents the unified result sets of the invocation of the anchor member and all invocations of the recursive member. WITH EmpsCTE AS ( SELECT empid, mgrid, firstname, lastname FROM HR.Employees WHERE empid = 2 UNION ALL SELECT C.empid, C.mgrid, C.firstname, C.lastname FROM EmpsCTE AS P INNER JOIN HR.Employees AS C ON C.mgrid = P.empid ) SELECT empid, mgrid, firstname, lastname FROM EmpsCTE; 2 1 Don Funk 3 2 Judy Lew 5 2 Sven Mortensen 6 5 Paul Suurs 7 5 Russell King 9 5 Patricia Doyle 4 3 Yael Peled 8 3 Maria Cameron CTEs are not permitted to nest in SQL, but they can be chained sequentially in a single WITH clause, allowing each CTE to reference any of the ones defined before it to create a step-by-step logical flow. WITH -- 1. The first CTE identifies customers from a specific region. US_Customers AS ( SELECT customer_id, customer_name FROM customers WHERE country = &#39;USA&#39; ), -- 2. The second CTE is &quot;chained&quot; by using the first CTE as its source -- to find the recent orders for only those customers. Recent_US_Orders AS ( SELECT usc.customer_name, o.order_id, o.order_total FROM orders AS o JOIN US_Customers AS usc ON o.customer_id = usc.customer_id WHERE o.order_date &gt;= &#39;2025-01-01&#39; ) -- 3. The final query uses the last CTE in the chain to get the result. SELECT * FROM Recent_US_Orders; 7.3. Views and TVFs Derived tables and CTEs have a single-statement scope, which means they are not reusable. Views and inline table-valued functions (inline TVFs) are two types of table expressions whose definitions are stored as permanent objects in the database, making them reusable. CREATE OR ALTER VIEW Sales.USACusts AS SELECT custid, companyname, contactname, contacttitle, address, city, region, postalcode, country, phone, fax FROM Sales.Customers WHERE country = N&#39;USA&#39;; GO -- The GO command is used here to terminate what’s called a batch in T-SQL. SELECT custid, companyname FROM Sales.USACusts; Remember that a presentation ORDER BY clause is not allowed in the query defining a table expression because a relation isn’t ordered. CREATE OR ALTER VIEW Sales.USACusts AS SELECT custid, companyname, contactname, contacttitle, address, city, region, postalcode, country, phone, fax FROM Sales.Customers WHERE country = N&#39;USA&#39; ORDER BY region; GO Msg 1033, Level 15, State 1, Procedure USACusts, Line 8 The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified. Inline TVFs are reusable table expressions that support input parameters. In most respects, except for the support for input parameters, inline TVFs are similar to views, or parameterized views. T-SQL supports another type of table function called multi-statement TVF, which populates and returns a table variable. CREATE OR ALTER FUNCTION dbo.GetCustOrders (@cid AS INT) RETURNS TABLE AS RETURN SELECT orderid, custid, empid, orderdate, requireddate, shippeddate, shipperid, freight, shipname, shipaddress, shipcity, shipregion, shippostalcode, shipcountry FROM Sales.Orders WHERE custid = @cid; GO SELECT orderid, custid FROM dbo.GetCustOrders(1) AS O; GO SELECT O.orderid, O.custid, OD.productid, OD.qty FROM dbo.GetCustOrders(1) AS O INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid; GO DROP FUNCTION IF EXISTS dbo.GetCustOrders; 8. UNION, UNION ALL, INTERSECT, and EXCEPT Set operators combine rows from two query result sets (or multisets), with some operators removing duplicates to return a set, while others preserve duplicates to return a multiset. T-SQL supports the following operators: UNION, UNION ALL, INTERSECT, and EXCEPT. A set operator compares complete rows between the results of the two input queries involved. Input Query1 &lt;set_operator&gt; Input Query2 [ORDER BY ...]; Because a set operator expects multisets as inputs, the two queries involved cannot have ORDER BY clauses. Remember that a query with an ORDER BY clause does not return a multiset—it returns an ordered result. In terms of logical-query processing, each of the individual queries can have all logical-query processing phases except for a presentation ORDER BY. The operator is applied to the results of the two queries, and the outer ORDER BY clause (if one exists) is applied to the result of the operator. The two input queries must produce results with the same number of columns, and corresponding columns must have compatible data types. The names of the columns in the result are determined by the first query. Still, it’s considered a best practice to make sure that all columns have names in both queries, and that the names of the corresponding columns are the same. When a set operator compares rows between the two inputs, it doesn’t use an equality-based comparison; rather, it uses a distinctness-based comparison. The semantics of distinctness-based comparisons are the same as the ones used by a standard predicate called the distinct predicate that treats NULLs just like non-NULL values for comparison purposes to ensure that two rows with NULL values in the same columns are treated as duplicates, which is often the desired behavior. The SQL standard supports two &quot;flavors&quot; of each operator—DISTINCT (the default) and ALL. The DISTINCT flavor eliminates duplicates and returns a set. ALL doesn’t attempt to remove duplicates and therefore returns a multiset. All three operators in T-SQL support an implicit distinct version, but only the UNION operator supports the ALL version. In terms of syntax, T-SQL implicitly applies the DISTINCT clause unless the ALL keyword is explicitly used. SQL defines precedence among set operators: INTERSECT operator precedes UNION and EXCEPT, and UNION and EXCEPT are evaluated in order of appearance. -- the result is a multiset and not a set SELECT country, region, city FROM HR.Employees UNION ALL SELECT country, region, city FROM Sales.Customers; -- returns distinct locations SELECT country, region, city FROM HR.Employees UNION SELECT country, region, city FROM Sales.Customers; -- returns only distinct rows that appear in both input query results SELECT country, region, city FROM HR.Employees INTERSECT SELECT country, region, city FROM Sales.Customers; -- returns only distinct rows that appear in the first set but not the second SELECT country, region, city FROM HR.Employees EXCEPT SELECT country, region, city FROM Sales.Customers; SELECT country, region, city FROM Production.Suppliers EXCEPT SELECT country, region, city FROM HR.Employees INTERSECT -- evaluated first SELECT country, region, city FROM Sales.Customers; 9. Data Analysis T-SQL in SQL Server offers robust features for data analysis, including window Functions, pivoting, unpivoting, grouping sets, and time series data handling. 9.1. Window Functions A window function is a function that, for each row, computes a scalar result value based on a calculation against a subset as a window of the rows from the underlying query set. Window functions perform calculations on a per-row basis within a defined window of rows, preserving detail, whereas grouped queries lose detail by aggregation. Window functions operate directly on the underlying query result set, while subqueries often start with a fresh view of the data, potentially requiring duplication of query logic. Window functions can define the order of rows for calculations separately from the presentation order of the result set. Window functions are allowed only in the SELECT and ORDER BY clauses of a query. A window function is defined by using the OVER clause with up to three parts: window-partition, window-order, and window-frame. &lt;function&gt;( &lt;expression&gt; ) [ IGNORE NULLS | RESPECT NULLS ] OVER(...) An empty OVER() clause represents the entire underlying query’s result set. The window-partition clause (PARTITION BY) restricts the window to the subset of rows that have the same values in the partitioning columns as in the current row. The window-order clause (ORDER BY) defines ordering, but don’t confuse this with presentation ordering. In a window aggregate function, window ordering supports a frame specification. In a window ranking function, window ordering gives meaning to the rank. The window-frame filters a frame, or a subset, of rows from the window partition between the two specified delimiters, which is defined using the ROWS or RANGE clause. ROWS: Defines the frame based on the number of rows before and after the current row. ROWS BETWEEN &lt;top delimiter&gt; AND &lt;bottom delimiter&gt; UNBOUNDED PRECEDING: Includes all rows from the beginning of the partition up to the current row. n PRECEDING: Includes the current row and the n preceding rows. CURRENT ROW: Includes only the current row. n FOLLOWING: Includes the current row and the n following rows. UNBOUNDED FOLLOWING: Includes all rows from the current row to the end of the partition. RANGE: Defines the frame based on the values of the ORDER BY column. RANGE BETWEEN &lt;top delimiter&gt; AND &lt;bottom delimiter&gt; UNBOUNDED PRECEDING: Includes all rows from the beginning of the partition up to the current row. n PRECEDING: Includes rows where the ORDER BY column&#8217;s value is within n units of the current row&#8217;s value. CURRENT ROW: Includes only the current row. n FOLLOWING: Includes rows where the ORDER BY column&#8217;s value is within n units of the current row&#8217;s value. UNBOUNDED FOLLOWING: Includes all rows from the current row to the end of the partition. -- compute the running-total for each employee and month SELECT empid, ordermonth, val, SUM(val) OVER( PARTITION BY empid -- For an underlying row with employee ID `1`, the window exposed to the function filters only the rows where the employee ID is `1`. ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS runval FROM Sales.EmpOrders; 1 2020-07-01 1614.88 1614.88 1 2020-08-01 5555.90 7170.78 1 2020-09-01 6651.00 13821.78 . . . 9.1.1. Ranking T-SQL supports four ranking functions: ROW_NUMBER, RANK, DENSE_RANK, and NTILE to rank each row with respect to others in the window. SELECT orderid, custid, val, ROW_NUMBER() OVER(ORDER BY val) AS rownum, RANK() OVER(ORDER BY val) AS rank, DENSE_RANK() OVER(ORDER BY val) AS dense_rank, NTILE(10) OVER(ORDER BY val) AS ntile FROM Sales.OrderValues ORDER BY val; orderid custid val rownum rank dense_rank ntile 10782 12 12.50 1 1 1 1 10807 27 18.40 2 2 2 1 10586 66 23.80 3 3 3 1 10767 76 28.00 4 4 4 1 10898 54 30.00 5 5 5 1 10900 88 33.75 6 6 6 1 10883 48 36.00 7 7 7 1 11051 41 36.00 8 7 7 1 10815 71 40.00 9 9 8 1 10674 38 45.00 10 10 9 1 11057 53 45.00 11 10 9 1 10271 75 48.00 12 12 10 1 . . . 10496 81 190.00 83 83 78 1 10793 4 191.10 84 84 79 2 10428 66 192.00 85 85 80 2 . . . The ROW_NUMBER function assigns incremental sequential integers to the rows in the query result based on the mandatory window ordering. The RANK or DENSE_RANK function will produce same value when there are ties in the ordering values, and the difference between the two is that RANK reflects the count of rows that have a lower ordering value than the current row (plus 1), whereas DENSE_RANK reflects the count of distinct ordering values that are lower than the current row (plus 1). The NTILE function assigns a tile number to each row associated the rows in the result with tiles (equally sized groups of rows). If the number of rows can’t be evenly divided by the number of tiles, an extra row is added to each of the first tiles from the remainder. For example, if 102 rows and five tiles were requested, the first two tiles would have 21 rows instead of 20. Window functions are logically evaluated as part of the SELECT list, before the DISTINCT clause is evaluated. -- DISTINCT clause has no effect here, no duplicate rows to remove SELECT DISTINCT val, ROW_NUMBER() OVER(ORDER BY val) AS rownum FROM Sales.OrderValues; -- an alternative solution: GROUP BY phase is processed before the SELECT phase SELECT val, ROW_NUMBER() OVER(ORDER BY val) AS rownum FROM Sales.OrderValues GROUP BY val; 9.1.2. Offset T-SQL supports two pairs of offset functions: LAG and LEAD, and FIRST_VALUE and LAST_VALUE, to return an element from a row that is at a certain offset from the current row or at the beginning or end of a window frame. The LAG and LEAD functions look before and ahead respectively to obtain an element from a row that is at a certain offset from the current row within the partition, based on the indicated ordering. -- the LAG and LEAD functions support window partitions and window-order clauses. LAG(column_name, offset, default_value) OVER(...) LEAD(column_name, offset, default_value) OVER(...) column_name: the functions (which is mandatory) is the element to return. offset: (Optional) An integer specifying the number (1 if not specified) of rows to offset from the current row. default_value: (Optional) A value to be returned if there is no row at the requested offset (which is NULL if not specified otherwise). SELECT custid, orderid, val, LAG(val) OVER(PARTITION BY custid -- same as: LAG(val, 1, NULL) ORDER BY orderdate, orderid) AS prevval, LEAD(val) OVER(PARTITION BY custid -- same as: LEAD(val, 1, NULL) ORDER BY orderdate, orderid) AS nextval FROM Sales.OrderValues ORDER BY custid, orderdate, orderid; custid orderid val prevval nextval . . . 1 10952 471.20 845.80 933.50 1 11011 933.50 471.20 NULL 2 10308 88.80 NULL 479.75 2 10625 479.75 88.80 320.00 . . . The FIRST_VALUE and LAST_VALUE functions return an element from the first and last rows in the window frame, respectively. To obtain the element from the first row in the window partition, use FIRST_VALUE with the window-frame extent ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. To obtain the element from the last row in the window partition, use LAST_VALUE with the window-frame extent ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING. SELECT custid, orderid, val, FIRST_VALUE(val) OVER(PARTITION BY custid ORDER BY orderdate, orderid ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS firstval, LAST_VALUE(val) OVER(PARTITION BY custid ORDER BY orderdate, orderid ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS lastval FROM Sales.OrderValues ORDER BY custid, orderdate, orderid custid orderid val firstval lastval 1 10643 814.50 814.50 933.50 . . . 1 11011 933.50 814.50 933.50 2 10308 88.80 88.80 514.40 . . . 9.1.3. Aggregate The aggregate window functions aggregate the rows in the defined window, and support window-partition, window-order, and window-frame clauses. SELECT orderid, custid, val, 100. * val / SUM(val) OVER() AS pctall, -- percentage out of the grand total 100. * val / SUM(val) OVER(PARTITION BY custid) AS pctcust -- percentage out of the customer total FROM Sales.OrderValues; SELECT empid, ordermonth, val, SUM(val) OVER(PARTITION BY empid ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS runval FROM Sales.EmpOrders; 9.1.4. WINDOW The WINDOW clause defines and names reusable entire window specifications or part of them, improving code readability and maintainability by reducing redundancy in complex queries with multiple window functions. It is available in SQL Server 2022 and higher, as well as in Azure SQL Database, provided that the database compatibility level is set to 160 or higher. SELECT DATABASEPROPERTYEX(N&#39;TSQLV6&#39;, N&#39;CompatibilityLevel&#39;); -- 160 When considering all major query clauses (SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY), place the WINDOW clause between the HAVING and ORDER BY clauses of the query. SELECT empid, ordermonth, val, SUM(val) OVER W AS runsum, MIN(val) OVER W AS runmin, MAX(val) OVER W AS runmax, AVG(val) OVER W AS runavg FROM Sales.EmpOrders WINDOW W AS (PARTITION BY empid -- name an entire window specification ORDER BY ordermonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW); SELECT custid, orderid, val, FIRST_VALUE(val) OVER(PO ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS firstval, LAST_VALUE(val) OVER(PO ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS last FROM Sales.OrderValues WINDOW PO AS (PARTITION BY custid -- name part of a window specification ORDER BY orderdate, orderid) ORDER BY custid, orderdate, orderid; SELECT orderid, custid, orderdate, qty, val, ROW_NUMBER() OVER PO AS ordernum, MAX(orderdate) OVER P AS maxorderdate, SUM(qty) OVER POF AS runsumqty, SUM(val) OVER POF AS runsumval FROM Sales.OrderValues WINDOW P AS ( PARTITION BY custid ), -- recursively reuse one window name within another PO AS ( P ORDER BY orderdate, orderid ), POF AS ( PO ROWS UNBOUNDED PRECEDING ) ORDER BY custid, orderdate, orderid; 9.2. Pivoting Pivoting data involves rotating data from a state of rows to a state of columns, possibly aggregating values along the way, in many cases which is generally handled by the presentation layer for purposes such as reporting. -- create and populate the sample table dbo.Orders USE TSQLV6; DROP TABLE IF EXISTS dbo.Orders; CREATE TABLE dbo.Orders ( orderid INT NOT NULL CONSTRAINT PK_Orders PRIMARY KEY, orderdate DATE NOT NULL, empid INT NOT NULL, custid VARCHAR(5) NOT NULL, qty INT NOT NULL ); INSERT INTO dbo.Orders(orderid, orderdate, empid, custid, qty) VALUES (30001, &#39;20200802&#39;, 3, &#39;A&#39;, 10), (10001, &#39;20201224&#39;, 2, &#39;A&#39;, 12), (10005, &#39;20201224&#39;, 1, &#39;B&#39;, 20), (40001, &#39;20210109&#39;, 2, &#39;A&#39;, 40), (10006, &#39;20210118&#39;, 1, &#39;C&#39;, 14), (20001, &#39;20210212&#39;, 2, &#39;B&#39;, 12), (40005, &#39;20220212&#39;, 3, &#39;A&#39;, 10), (20002, &#39;20220216&#39;, 1, &#39;C&#39;, 20), (30003, &#39;20220418&#39;, 2, &#39;B&#39;, 15), (30004, &#39;20200418&#39;, 3, &#39;C&#39;, 22), (30007, &#39;20220907&#39;, 3, &#39;D&#39;, 30); -- query and return the total order quantity for each employee and customer SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid; empid custid sumqty 2 A 52 3 A 20 1 B 20 2 B 27 1 C 34 3 C 22 3 D 30 Pivoted view of total quantity per employee (on rows) and customer (on columns) empid A B C D 1 NULL 20 34 NULL 2 52 27 NULL NULL 3 20 NULL 22 30 Every pivoting request involves three logical processing phases, each with associated elements: A grouping phase with an associated grouping or on rows element A spreading phase with an associated spreading or on cols element An aggregation phase with an associated aggregation element and aggregate function 9.2.1. Grouped Query SELECT empid, SUM( (3) CASE WHEN custid = &#39;A&#39; THEN qty END (2) ) AS A, SUM(CASE WHEN custid = &#39;B&#39; THEN qty END) AS B, SUM(CASE WHEN custid = &#39;C&#39; THEN qty END) AS C, SUM(CASE WHEN custid = &#39;D&#39; THEN qty END) AS D FROM dbo.Orders GROUP BY empid; (1) 1 The grouping phase is achieved with a GROUP BY clause—in this case, GROUP BY empid. 2 The spreading phase is achieved in the SELECT clause with a CASE expression for each target column. -- returns the quantity from the current row only when -- the current row represents an order for customer A; -- otherwise, the expression returns a NULL. CASE WHEN custid = &#39;A&#39; THEN qty END 3 Finally, the aggregation phase is achieved by applying the relevant aggregate function to the result of each CASE expression. -- produces the result column for customer A SUM(CASE WHEN custid = &#39;A&#39; THEN qty END) AS A 9.2.2. PIVOT Operator T- SQL also supports a proprietary table operator called PIVOT on a source table or table expression provided to it as its left input, pivots the data, and returns a result table. SELECT ... FROM &lt;input_table&gt; PIVOT(&lt;agg_function&gt;(&lt;aggregation_element&gt;) FOR &lt;spreading_element&gt; IN (&lt;list_of_target_columns&gt;)) WHERE ...; The PIVOT operator figures out the grouping elements implicitly by elimination, that are all attributes from the source table that were not specified as either the spreading element or the aggregation element. -- custid is the spreading element -- qty is the aggregation element -- the left empid is the implied grouping element SELECT empid, A, B, C, D FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; As a best practice with the PIVOT operator, always work with a table expression and not query the underlying table directly. -- the dbo.Orders table contains the attributes orderid, orderdate, empid, custid, and qty. -- the remaining attributes (orderid, orderdate, and empid) are all considered the grouping elements SELECT empid, A, B, C, D FROM dbo.Orders PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; The items in the list of the target columns must be referred to as identifiers in the IN clause, and be delimited using square brackets when they are irregular (contain spaces, special characters, or are reserved keywords). SELECT custid, [1], [2], [3], [4] FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR empid IN ([1], [2], [3], [4])) AS P; 9.3. Unpivoting Unpivoting is a technique that rotates data from a state of columns to a state of rows. -- create and populate the sample table dbo.EmpCustOrders USE TSQLV6; DROP TABLE IF EXISTS dbo.EmpCustOrders; CREATE TABLE dbo.EmpCustOrders ( empid INT NOT NULL CONSTRAINT PK_EmpCustOrders PRIMARY KEY, A VARCHAR(5) NULL, B VARCHAR(5) NULL, C VARCHAR(5) NULL, D VARCHAR(5) NULL ); INSERT INTO dbo.EmpCustOrders(empid, A, B, C, D) SELECT empid, A, B, C, D FROM (SELECT empid, custid, qty FROM dbo.Orders) AS D PIVOT(SUM(qty) FOR custid IN(A, B, C, D)) AS P; SELECT * FROM dbo.EmpCustOrders; empid A B C D 1 NULL 20 34 NULL 2 52 27 NULL NULL 3 20 NULL 22 30 Unpivoted data returns a row for each employee and customer, along with the order quantity empid custid qty 1 B 20 1 C 34 2 A 52 2 B 27 3 A 20 3 C 22 3 D 30 9.3.1. APPLY Operator -- 1. Producing copies SELECT * FROM dbo.EmpCustOrders CROSS JOIN (VALUES(&#39;A&#39;),(&#39;B&#39;),(&#39;C&#39;),(&#39;D&#39;)) AS C(custid); -- empid A B C D custid -- 1 NULL 20 34 NULL A -- 1 NULL 20 34 NULL B -- 1 NULL 20 34 NULL C -- . . . -- 2. Extracting values SELECT empid, custid, qty FROM dbo.EmpCustOrders -- a join treats its two inputs as a set; -- use the CROSS APPLY operator instead of the CROSS JOIN operator -- to refer to the columns A, B, C, and D from the left side of the join (EmpCustOrders) CROSS APPLY (VALUES(&#39;A&#39;, A),(&#39;B&#39;, B),(&#39;C&#39;, C),(&#39;D&#39;, D)) AS C(custid, qty) -- empid custid qty -- 1 A NULL -- 1 B 20 -- 1 C 34 -- . . . -- 3. Eliminating irrelevant rows SELECT empid, custid, qty FROM dbo.EmpCustOrders CROSS APPLY (VALUES(&#39;A&#39;, A),(&#39;B&#39;, B),(&#39;C&#39;, C),(&#39;D&#39;, D)) AS C(custid, qty) WHERE qty IS NOT NULL; -- discard rows with a NULL in the qty column -- empid custid qty -- 1 B 20 -- 1 C 34 -- 2 A 52 -- . . . 9.3.2. UNPIVOT Operator T- SQL, like the PIVOT operator, also supports the UNPIVOT operator to unpivot data involved producing two result columns from any number of source columns—one to hold the source column names as strings and another to hold the source column values. SELECT ... FROM &lt;input_table&gt; UNPIVOT(&lt;values_column&gt; FOR &lt;names_column&gt; IN(&lt;source_columns&gt;) WHERE ...; SELECT empid, custid, qty FROM dbo.EmpCustOrders UNPIVOT(qty FOR custid IN(A, B, C, D)) AS U; 9.4. Grouping Sets A grouping set is a set of expressions to group the data by in a grouped query (a query with a GROUP BY clause). Traditionally in SQL, a single grouped query defines a single grouping set. -- set(empid, custid) SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid; -- set(empid) SELECT empid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid; -- set(custid) SELECT custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY custid; -- set() SELECT SUM(qty) AS sumqty FROM dbo.Orders; Use UNION ALL with NULL placeholders to combine multiple queries into a single result set for reporting, but potentially lead to two main problems—the length of the code and performance due to multiple scans for separated query. SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid, custid UNION ALL SELECT empid, NULL, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY empid UNION ALL SELECT NULL, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY custid UNION ALL SELECT NULL, NULL, SUM(qty) AS sumqty FROM dbo.Orders; T-SQL supports the standard GROUPING SETS, CUBE, and ROLLUP subclauses of the GROUP BY clause, and the GROUPING and GROUPING_ID functions to define multiple grouping sets in the same query for reporting and data analysis. The GROUPING SETS subclause is a powerful enhancement to the GROUP BY clause to define multiple grouping sets in the same query. The grouping sets are listed, separated by commas within the parentheses of the GROUPING SETS subclause, and for each grouping set list the members, separated by commas, within parentheses. SQL Server typically needs fewer scans of the data than the number of grouping sets because it can roll up aggregates internally. SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY GROUPING SETS ( (empid, custid), (empid), (custid), () ); The CUBE subclause of the GROUP BY clause provides an abbreviated way to define multiple grouping sets. In the parentheses of the CUBE subclause, provide a set of members separated by commas, and get all possible grouping sets that can be defined based on the input members. In set theory, the set of all subsets of elements that can be produced from a particular set is called the power set. For example, CUBE(a, b, c) is equivalent to GROUPING SETS( (a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), () ). SELECT empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); The ROLLUP subclause of the GROUP BY clause also provides an abbreviated way to define multiple grouping sets. Unlike CUBE, which produces all possible grouping sets, ROLLUP assumes a hierarchy among input members and produces only grouping sets that form leading combinations of those members. For example, whereas CUBE(a, b, c) produces all eight possible grouping sets, ROLLUP(a, b, c) produces only four based on the hierarchy a&gt;b&gt;c that is the equivalent of specifying GROUPING SETS( (a, b, c), (a, b), (a), () ) rolling up the aggregations from the most granular level (a, b, c) to higher levels like (a, b) and finally to the total (). -- ROLLUP(YEAR(orderdate), MONTH(orderdate), DAY(orderdate)) -- =&gt; -- GROUPING SETS( -- (YEAR(orderdate), MONTH(orderdate), DAY(orderdate)), -- (YEAR(orderdate), MONTH(orderdate)), -- (YEAR(orderdate)), -- () ) SELECT YEAR(orderdate) AS orderyear, MONTH(orderdate) AS ordermonth, DAY(orderdate) AS orderday, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY ROLLUP(YEAR(orderdate), MONTH(orderdate), DAY(orderdate)) The GROUPING and GROUPING_ID functions are used to identify which columns in a GROUP BY clause are included in a group set or or are represented by a NULL placeholder in the aggregated result set. GROUPING: returns 1 when the element isn’t part of the grouping set and 0 otherwise. SELECT GROUPING(empid) AS grpemp, GROUPING(custid) AS grpcust, empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); grpemp grpcust empid custid sumqty 0 0 2 A 52 0 0 3 A 20 1 0 NULL A 72 . . . GROUPING_ID: returns an integer bitmap in which each bit represents a different input element—the rightmost element represented by the rightmost bit. SELECT GROUPING_ID(empid, custid) AS groupingset, empid, custid, SUM(qty) AS sumqty FROM dbo.Orders GROUP BY CUBE(empid, custid); groupingset empid custid sumqty 0 2 A 52 -- 00 0 3 A 20 -- 00 2 NULL A 72 -- 10 . . . 9.5. Time Series Time series data is data representing a series of events, or measurements, typically taken at regular time intervals. Time series data analysis usually involves organizing the data in groups, also known as buckets, and then aggregating some measures per bucket. 10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE SQL has a set of statements known as Data Manipulation Language (DML) that includes the statements SELECT, INSERT, UPDATE, DELETE, TRUNCATE, and MERGE. 10.1. INSERT T-SQL provides several statements for inserting data into tables: INSERT VALUES, INSERT SELECT, INSERT EXEC, SELECT INTO, and BULK INSERT. 10.1.1. INSERT VALUES The standard INSERT VALUES statement is used to insert rows into a table based on specified values. INSERT INTO dbo.Orders(orderid, orderdate, empid, custid) VALUES(10001, &#39;20220212&#39;, 3, &#39;A&#39;); Specifying the target column names right after the table name is optional, but by doing so, it can control the value-column associations instead of relying on the order of the columns in the CREATE TABLE statement. In T-SQL, specifying the INTO clause is optional. If a value for a column is NOT specified, Microsoft SQL Server will use a default value if one was defined for the column. If a default value isn’t defined and the column allows NULLs, a NULL will be used. If no default is defined and the column does not allow NULLs and does not somehow get its value automatically, the INSERT statement will fail. T-SQL supports an enhanced standard VALUES clause that can be used to specify multiple rows separated by commas. The enhanced standard VALUES statement is processed as a transaction, meaning that if any row fails to enter the table, none of the rows in the statement enters the table. INSERT INTO dbo.Orders (orderid, orderdate, empid, custid) VALUES (10003, &#39;20220213&#39;, 4, &#39;B&#39;), (10004, &#39;20220214&#39;, 1, &#39;A&#39;), (10005, &#39;20220213&#39;, 1, &#39;C&#39;), (10006, &#39;20220215&#39;, 3, &#39;C&#39;); The enhanced VALUES clause can be used as a table-value constructor to construct a derived table. SELECT * FROM ( VALUES (10003, &#39;20220213&#39;, 4, &#39;B&#39;), (10004, &#39;20220214&#39;, 1, &#39;A&#39;), (10005, &#39;20220213&#39;, 1, &#39;C&#39;), (10006, &#39;20220215&#39;, 3, &#39;C&#39;) ) AS O(orderid, orderdate, empid, custid); -- alias(es) to the table, and the target columns 10.1.2. INSERT SELECT The standard INSERT SELECT statement inserts a set of rows returned by a SELECT query into a target table. The INSERT SELECT statement is performed as a transaction, so if any row fails to enter the target table, none of the rows enters the table. INSERT INTO dbo.Orders(orderid, orderdate, empid, custid) SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE shipcountry = N&#39;UK&#39;; If a system function such as SYSDATETIME is included in the inserted query, the function gets invoked only once for the entire query and not once per row. The exception to this rule is if globally unique identifiers (GUIDs) is generated using the NEWID function, which gets invoked per row. 10.1.3. INSERT EXEC The INSERT EXEC statement is used to insert a result set returned from a stored procedure or a dynamic SQL batch into a target table. CREATE OR ALTER PROC Sales.GetOrders @country AS NVARCHAR(40) AS SELECT orderid, orderdate, empid, custid FROM Sales.Orders WHERE shipcountry = @country; GO INSERT INTO dbo.Orders (orderid, orderdate, empid, custid) EXEC Sales.GetOrders @country = N&#39;France&#39;; 10.1.4. SELECT INTO The SELECT INTO statement is a nonstandard (not part of the ISO and ANSI SQL) T-SQL statement that CREATEs a target table and populates it with the result set of a query. DROP TABLE IF EXISTS dbo.Orders; SELECT orderid, orderdate, empid, custid INTO dbo.Orders FROM Sales.Orders; -- SELECT INTO statement with set operations DROP TABLE IF EXISTS dbo.Locations; SELECT country, region, city INTO dbo.Locations FROM Sales.Customers EXCEPT SELECT country, region, city FROM HR.Employees; The target table’s structure and data are based on the source table. The SELECT INTO statement copies from the source the base structure (such as column names, types, nullability, and identity property) and the data, but does not copy from the source constraints, indexes, triggers, column properties, and permissions. 10.1.5. BULK INSERT The BULK INSERT statement is a server-side T-SQL command for high-speed data loading that requires the data file to reside on a local or network path accessible to the SQL Server service account, as the path is resolved by the server, not the client. BULK INSERT dbo.Orders FROM &#39;\\ServerName\\Share\\orders.txt&#39; -- Path must be accessible by the SQL Server service WITH ( DATAFILETYPE = &#39;char&#39;, FIELDTERMINATOR = &#39;,&#39;, ROWTERMINATOR = &#39;\\n&#39;, BATCHSIZE = 10000, TABLOCK ); While BULK INSERT on an on-premises SQL Server requires a local or UNC path, it can natively access files in Azure Blob Storage when used with Azure SQL Database or Azure SQL Managed Instance. -- Example for Azure SQL -- 1. Define the external data source (once) CREATE EXTERNAL DATA SOURCE MyBlobStorage WITH ( TYPE = BLOB_STORAGE, LOCATION = &#39;https://myaccount.blob.core.windows.net/mycontainer&#39; -- Plus credential setup ); -- 2. Use it in BULK INSERT BULK INSERT dbo.Orders FROM &#39;data/orders.csv&#39; -- Path is relative to the container WITH (DATA_SOURCE = &#39;MyBlobStorage&#39;); bcp and SqlBulkCopy bcp (Bulk Copy Program) is a client-side command-line utility for script-automated data transfer, streaming filesystem-based files from a client machine to SQL Server. # Import data from a local client file to the Orders table bcp MyDatabase.dbo.Orders in C:\\Data\\orders.csv -c -T -S MyServerName SqlBulkCopy is an ADO.NET class offering maximum ETL flexibility by enabling applications to programmatically stream data directly into SQL Server from in-memory sources like a DataTable or any IDataReader implementation. This example demonstrates a robust and highly performant pattern for upserting (inserting or updating) data in SQL Server. It uses SqlBulkCopy to quickly upload a batch of data into a temporary staging table and then uses a MERGE statement to apply those changes to a final destination table. The destination table is configured as a system-versioned temporal table, which automatically keeps a full history of all data changes. -- Create the main table to store product data CREATE TABLE dbo.Products ( Id INT PRIMARY KEY, Name NVARCHAR(255) NOT NULL, Category NVARCHAR(100) NOT NULL, Price DECIMAL(18, 2) NOT NULL, LastModified DATETIME2 NOT NULL, -- Columns for system-versioning ValidFrom DATETIME2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL, ValidTo DATETIME2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL, PERIOD FOR SYSTEM_TIME (ValidFrom, ValidTo) ) WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.ProductsHistory)); /// &lt;summary&gt; /// Represents a product entity. /// &lt;/summary&gt; public class Product { public int Id { get; set; } public string Name { get; set; } public string Category { get; set; } public decimal Price { get; set; } public DateTime LastModified { get; set; } } /// &lt;summary&gt; /// Performs a high-performance bulk &quot;upsert&quot; operation for a list of products. /// It stages the data in a temporary table and then merges it into the final destination table. /// &lt;/summary&gt; /// &lt;param name=&quot;connection&quot;&gt;An open SqlConnection to use.&lt;/param&gt; /// &lt;param name=&quot;products&quot;&gt;An enumerable of Product objects to upsert.&lt;/param&gt; public async Task UpsertProductsAsync(SqlConnection connection, IEnumerable&lt;Product&gt; products) { // Create an in-memory DataTable to hold the data var productData = new DataTable(); productData.Columns.Add(&quot;Id&quot;, typeof(int)); productData.Columns.Add(&quot;Name&quot;, typeof(string)); productData.Columns.Add(&quot;Category&quot;, typeof(string)); productData.Columns.Add(&quot;Price&quot;, typeof(decimal)); productData.Columns.Add(&quot;LastModified&quot;, typeof(DateTime)); foreach (var p in products) { productData.Rows.Add(p.Id, p.Name, p.Category, p.Price, p.LastModified); } await using var transaction = (SqlTransaction)await connection.BeginTransactionAsync(); try { // 1. Create a temporary table to stage the data var createTempTableCmd = connection.CreateCommand(); createTempTableCmd.Transaction = transaction; createTempTableCmd.CommandText = @&quot; CREATE TABLE #ProductStaging ( Id INT PRIMARY KEY, Name NVARCHAR(255) NOT NULL, Category NVARCHAR(100) NOT NULL, Price DECIMAL(18, 2) NOT NULL, LastModified DATETIME2 NOT NULL );&quot;; await createTempTableCmd.ExecuteNonQueryAsync(); // 2. Bulk load the data from the DataTable into the staging table await using (var bulkCopy = new SqlBulkCopy(connection, SqlBulkCopyOptions.Default, transaction)) { bulkCopy.DestinationTableName = &quot;#ProductStaging&quot;; bulkCopy.BatchSize = 5000; // Add column mappings to ensure data goes into the correct columns bulkCopy.ColumnMappings.Add(&quot;Id&quot;, &quot;Id&quot;); bulkCopy.ColumnMappings.Add(&quot;Name&quot;, &quot;Name&quot;); bulkCopy.ColumnMappings.Add(&quot;Category&quot;, &quot;Category&quot;); bulkCopy.ColumnMappings.Add(&quot;Price&quot;, &quot;Price&quot;); bulkCopy.ColumnMappings.Add(&quot;LastModified&quot;, &quot;LastModified&quot;); await bulkCopy.WriteToServerAsync(productData); } // 3. Merge the staged data into the final Products table var mergeCmd = connection.CreateCommand(); mergeCmd.Transaction = transaction; mergeCmd.CommandText = @&quot; MERGE dbo.Products AS target USING #ProductStaging AS source ON target.Id = source.Id WHEN MATCHED THEN UPDATE SET target.Name = source.Name, target.Category = source.Category, target.Price = source.Price, target.LastModified = source.LastModified WHEN NOT MATCHED BY TARGET THEN INSERT (Id, Name, Category, Price, LastModified) VALUES (source.Id, source.Name, source.Category, source.Price, source.LastModified);&quot;; await mergeCmd.ExecuteNonQueryAsync(); // If all operations were successful, commit the transaction await transaction.CommitAsync(); } catch (Exception) { // If any operation fails, roll back the entire transaction await transaction.RollbackAsync(); throw; } } 10.2. DELETE and TRUNCATE T-SQL provides two statements for deleting rows from a table: DELETE and TRUNCATE. The DELETE statement is a standard statement used to delete data from a table based on an optional filter predicate. DELETE FROM dbo.Orders WHERE orderdate &lt; &#39;20210101&#39;; The DELETE statement tends to be expensive when deleting a large number of rows, mainly because it’s a fully logged operation. The standard TRUNCATE statement deletes all rows from a table without filter. TRUNCATE TABLE dbo.T1; The advantage that TRUNCATE has over DELETE is that the former is minimally logged, whereas the latter is fully logged, resulting in significant performance differences. TRUNCATE resets the identity value back to the original seed, but DELETE doesn’t—even when used without a filter. The TRUNCATE statement is not allowed when the target table is referenced by a foreign-key constraint, even if the referencing table is empty and even if the foreign key is disabled. The TRUNCATE statement can be used to truncate individual partitions in a partitioned table. TRUNCATE TABLE dbo.T1 WITH ( PARTITIONS(1, 3, 5, 7 TO 10) ); T-SQL supports a nonstandard DELETE syntax based on joins to delete rows from one table based on a filter against attributes in related rows from another table. DELETE FROM O FROM dbo.Orders AS O INNER JOIN dbo.Customers AS C ON O.custid = C.custid WHERE C.country = N&#39;USA&#39;; 10.3. UPDATE T-SQL supports a standard UPDATE statement to update rows in a table, and also supports nonstandard forms of the UPDATE statement with joins and with variables. The UPDATE statement is a standard statement to update a subset of rows in a table. To identify the subset of rows to update, specify a predicate in a WHERE clause. Specify the assignment of values to columns in a SET clause, separated by commas. UPDATE dbo.OrderDetails SET discount = discount + 0.05 WHERE productid = 51; T-SQL supports compound assignment operators: += (plus equal), −= (minus equal), *= (multiplication equal), /= (division equal), %= (modulo equal), and others. UPDATE dbo.OrderDetails SET discount += 0.05 WHERE productid = 51; All-at-once operations: all expressions that appear in the same logical phase are evaluated as a set, logically at the same point in time. -- the assignments take place all at once, meaning that both assignments use the same value of col1—the value before the update. UPDATE dbo.T1 SET col1 = col1 + 10, col2 = col1 + 10; -- swap the values in the columns col1 and col2 UPDATE dbo.T1 SET col1 = col2, col2 = col1; The UPDATE statement also supports a nonstandard form based on joins that serves a filtering purpose. UPDATE OD SET discount += 0.05 FROM dbo.OrderDetails AS OD INNER JOIN dbo.Orders AS O ON OD.orderid = O.orderid WHERE O.custid = 1; -- same task by using standard code (recommended) UPDATE dbo.OrderDetails SET discount += 0.05 WHERE EXISTS (SELECT * FROM dbo.Orders AS O WHERE O.orderid = OrderDetails.orderid AND O.custid = 1); T-SQL supports a proprietary UPDATE syntax that both updates data in a table and assigns values to variables at the same time. DECLARE @nextval AS INT; UPDATE dbo.MySequences SET @nextval = val += 1 WHERE id = &#39;SEQ1&#39;; SELECT @nextval; 10.4. MERGE T-SQL supports a statement called MERGE to merge data from a source into a target, applying different actions (INSERT, UPDATE, and DELETE) based on conditional logic. A task achieved by a single MERGE statement typically translates to a combination of several other DML statements (INSERT, UPDATE, and DELETE) without MERGE. MERGE INTO dbo.Customers AS TGT USING dbo.CustomersStage AS SRC ON TGT.custid = SRC.custid WHEN MATCHED THEN UPDATE SET TGT.companyname = SRC.companyname, TGT.phone = SRC.phone, TGT.address = SRC.address WHEN NOT MATCHED THEN INSERT (custid, companyname, phone, address) VALUES (SRC.custid, SRC.companyname, SRC.phone, SRC.address); 11. System-Versioned Temporal Tables Temporal tables provide a powerful mechanism for tracking changes to data over time to easily capture and query historical versions of data, which is crucial for various scenarios such as auditing, data analysis, and data recovery. Track Data Changes: Capture all modifications (insertions, updates, deletions) to the data over time. Audit Data Modifications: Track who made changes, when they were made, and the previous state of the data for auditing and compliance purposes. Perform Point-in-Time Analysis: Analyze data as it existed at any point in the past. Data Recovery: Easily restore previous versions of data in case of accidental deletions or updates. Support Slowly Changing Dimensions: Efficiently manage slowly changing dimensions (SCDs) in data warehousing. The SQL standard supports three types of temporal tables: System-versioned temporal tables rely on the system transaction time to define the validity period of a row. Application-time period tables rely on the application’s definition of the validity period of a row. Bitemporal combines the two types just mentioned (transaction and valid time). SQL Server 2022 supports only system-versioned temporal tables. A system-versioned temporal table has two columns representing the validity period of the row, plus a linked history table with a mirrored schema holding older states of modified rows. To create a system-versioned temporal table, make sure the table definition has all the following elements: CREATE TABLE dbo.Employees ( empid INT NOT NULL CONSTRAINT PK_Employees PRIMARY KEY, (1) empname VARCHAR(25) NOT NULL, department VARCHAR(50) NOT NULL, salary NUMERIC(10, 2) NOT NULL, validfrom DATETIME2(0) GENERATED ALWAYS AS ROW START HIDDEN NOT NULL, (2) validto DATETIME2(0) GENERATED ALWAYS AS ROW END HIDDEN NOT NULL, (2) PERIOD FOR SYSTEM_TIME (validfrom, validto) (3) ) WITH ( SYSTEM_VERSIONING = ON (4) ( HISTORY_TABLE = dbo.EmployeesHistory, (5) HISTORY_RETENTION_PERIOD = 5 YEARS (6) ) ); 1 A primary key 2 Two columns defined as DATETIME2 with any precision, which are non-nullable and represent the start and end of the row’s validity period in the UTC time zone A start column that should be marked with the option GENERATED ALWAYS AS ROW START An end column that should be marked with the option GENERATED ALWAYS AS ROW END Optionally, the period columns can be marked as hidden so that when querying the table with SELECT * they won’t be returned and when inserting data they’ll be ignored. The modification times that SQL Server records in the period columns reflect the transaction start time. If a long-running transaction that started at point in time T1 and ended at T2, SQL Server will record T1 as the modification time for all statements. 3 A designation of the period columns with the option PERIOD FOR SYSTEM_TIME (&lt;startcol&gt;, &lt;endcol&gt;) 4 The table option SYSTEM_VERSIONING, which should be set to ON 5 A linked history table (which SQL Server can create automatically) to hold the past states of modified rows If do not specify a name for the table, SQL Server assigns one using the form MSSQL_TemporalHistoryFor_&lt;object_id&gt;, where object_id is the object ID of the current table. 6 Optionally, define a history retention policy using the HISTORY_RETENTION_PERIOD subclause of the SYSTEM_VERSIONING clause. To drop a system-versioned table, first disable system versioning with an ALTER TABLE command, and then manually drop the current and history tables. IF OBJECT_ID(N&#39;dbo.Employees&#39;, N&#39;U&#39;) IS NOT NULL BEGIN ALTER TABLE dbo.Employees SET ( SYSTEM_VERSIONING = OFF ); DROP TABLE IF EXISTS dbo.EmployeesHistory; DROP TABLE IF EXISTS dbo.Employees; END; When modifying data, interact with the current table, issuing normal data-modification statements. SQL Server automatically updates the period columns and moves older versions of rows to the history table. INSERT INTO dbo.Employees (empid, empname, department, salary) VALUES(1, &#39;Sara&#39;, &#39;IT&#39; , 50000.00), (2, &#39;Don&#39; , &#39;HR&#39; , 45000.00), (3, &#39;Judy&#39;, &#39;Sales&#39; , 55000.00), (4, &#39;Yael&#39;, &#39;Marketing&#39;, 55000.00), (5, &#39;Sven&#39;, &#39;IT&#39; , 45000.00), (6, &#39;Paul&#39;, &#39;Sales&#39; , 40000.00); -- current table has the six new rows SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees; -- history table is empty at this point SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory; -- SQL Server moves the deleted row to the history table, setting its validto value to the deletion time. DELETE FROM dbo.Employees WHERE empid = 6; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory; -- 6 Paul Sales 40000.00 2025-01-15 03:42:15 2025-01-15 03:44:53 -- An update of a row is treated as a delete plus an insert. UPDATE dbo.Employees SET salary *= 1.05 WHERE department = &#39;IT&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees WHERE department = &#39;IT&#39;; -- 1 Sara IT 52500.00 2025-01-15 03:47:42 9999-12-31 23:59:59 -- 5 Sven IT 47250.00 2025-01-15 03:47:42 9999-12-31 23:59:59 SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory WHERE department = &#39;IT&#39;; -- 1 Sara IT 50000.00 2025-01-15 03:42:15 2025-01-15 03:47:42 -- 5 Sven IT 45000.00 2025-01-15 03:42:15 2025-01-15 03:47:42 When querying data, for the current state, simply query the current table as usual, and to see a past state, correct to a certain point or period of time, query the current table followed by the FOR SYSTEM_TIME clause, plus a subclause that indicates more specifics. SQL Server will retrieve the data from both the current and history tables as needed. Table 1. Qualifying rows for FOR SYSTEM_TIME subclauses [&lt;datetime2 value&gt;] Subclause Qualifying rows AS OF @datetime validfrom &lt;= @datetime AND validto &gt; @datetime FROM @start TO @end validfrom &lt; @end AND validto &gt; @start BETWEEN @start AND @end validfrom &lt;= @end AND validto &gt; @start CONTAINED IN(@start, @end) validfrom &gt;= @start AND validto &lt;= @end ALL All rows from both tables (T-SQL*) DECLARE @datetime AS DATETIME2 = &#39;2025-01-15 03:45:00&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees FOR SYSTEM_TIME AS OF @datetime; -- same as DECLARE @datetime AS DATETIME2 = &#39;2025-01-15 03:45:00&#39;; SELECT empid, empname, department, salary, validfrom, validto FROM dbo.Employees WHERE validfrom &lt;= @datetime AND validto &gt; @datetime UNION ALL SELECT empid, empname, department, salary, validfrom, validto FROM dbo.EmployeesHistory WHERE validfrom &lt;= @datetime AND validto &gt; @datetime 12. Transactions and Concurrency A transaction is a unit of work that might include multiple activities that query and modify data and that can also change the data definition. Transaction boundaries can be defined either explicitly or implicitly. A transaction explicitly is defined beginning with a BEGIN TRAN (or BEGIN TRANSACTION) statement, and end explicitly with a COMMIT TRAN statement to commit it and with a ROLLBACK TRAN (or ROLLBACK TRANSACTION) statement to undo its changes. BEGIN TRAN; INSERT INTO dbo.T1(keycol, col1, col2) VALUES(4, 101, &#39;C&#39;); INSERT INTO dbo.T2(keycol, col1, col2) VALUES(4, 201, &#39;X&#39;); COMMIT TRAN; If the boundaries of a transaction isn&#8217;t marked explicitly, by default, SQL Server treats each individual statement as a transaction, which is known as an auto-commit mode. Transactions have four properties—atomicity, consistency, isolation, and durability— abbreviated with the acronym ACID: Atomicity: A transaction is an atomic unit of work. Either all changes in the transaction take place or none do. If the system fails before a transaction is completed (before the commit instruction is recorded in the transaction log), upon restart, SQL Server undoes the changes that took place. Also, if errors are encountered during the transaction and the error is considered severe enough, such as the target filegroup being full when trying to insert data, SQL Server automatically rolls back the transaction. Consistency: The term consistency refers to the state of the data that the relational database management system (RDBMS) as concurrent transactions modify and query it, which is a subjective term, and depends on an application’s needs. Isolation: Isolation ensures that transactions access only consistent data through a mechanism called isolation levels. With disk-based tables, SQL Server supports two different models to handle isolation: one based purely on locking, and another based on a combination of locking and row versioning. The model based on locking is the default in a box product. In this model, readers require shared locks. If the current state of the data is inconsistent, readers are blocked until the state of the data becomes consistent. The model based on locking and row versioning is the default in Azure SQL Database. In this model, readers don’t take shared locks and don’t need to wait. If the current state of the data is inconsistent, the reader gets an older consistent state. Durability: The durability property means that once a commit instruction is acknowledged by the database engine, the transaction’s changes are guaranteed to be durable—or in other words, persist—in the database. A commit is acknowledged by getting control back to the application and running the next line of code. Data changes are always written to the database’s transaction log on disk before they are written to the data portion of the database on disk. After the commit instruction is recorded in the transaction log on disk, the transaction is considered durable even if the change hasn’t yet made it to the data portion on disk. When the system starts, either normally or after a system failure, SQL Server runs a recovery process in each database that involves analyzing the log, then applying a redo phase, and then applying an undo phase. The redo phase involves rolling forward (replaying) all the changes from any transaction whose commit instruction is written to the log but whose changes haven’t yet made it to the data portion. The undo phase involves rolling back (undoing) the changes from any transaction whose commit instruction was not recorded in the log. -- Start a new transaction BEGIN TRAN; -- Declare a variable DECLARE @neworderid AS INT; -- Insert a new order into the Sales.Orders table INSERT INTO Sales.Orders (custid, empid, orderdate, requireddate, shippeddate, shipperid, freight, shipname, shipaddress, shipcity, shippostalcode, shipcountry) VALUES (85, 5, &#39;20220212&#39;, &#39;20220301&#39;, &#39;20220216&#39;, 3, 32.38, N&#39;Ship to 85-B&#39;, N&#39;6789 rue de l&#39;&#39;Abbaye&#39;, N&#39;Reims&#39;, N&#39;10345&#39;, N&#39;France&#39;); -- Save the new order ID in a variable SET @neworderid = SCOPE_IDENTITY(); -- Return the new order ID SELECT @neworderid AS neworderid; -- Insert order lines for the new order into Sales.OrderDetails INSERT INTO Sales.OrderDetails (orderid, productid, unitprice, qty, discount) VALUES(@neworderid, 11, 14.00, 12, 0.000), (@neworderid, 42, 9.80, 10, 0.000), (@neworderid, 72, 34.80, 5, 0.000); -- Commit the transaction COMMIT TRAN; 12.1. Locks and Blocking By default, a SQL Server box product uses a pure locking model to enforce the isolation property of transactions, whereas Azure SQL Database uses the row-versioning model by default. -- turn off the database property READ_COMMITTED_SNAPSHOT to switch to the locking model as the default ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT OFF; 12.1.1. Locks Locks are control resources obtained by a transaction to guard data resources, preventing conflicting or incompatible access by other transactions. 12.1.1.1. Lock Modes and Compatibility When trying to modify data, a transaction requests an exclusive lock on the data resource, regardless of the isolation level. If granted, the exclusive lock is held until the end of the transaction. For single- statement transactions, this means that the lock is held until the statement completes. For multistatement transactions, this means that the lock is held until all statements complete and the transaction is ended by a COMMIT TRAN or ROLLBACK TRAN command. As for reading data, the defaults are different for a SQL Server box product and Azure SQL Database. In SQL Server, the default isolation level is called READ COMMITTED. In this isolation, when trying to read data, by default a transaction requests a shared lock on the data resource and releases the lock as soon as the read statement is done with that resource. In Azure SQL Database, the default isolation level is called READ COMMITTED SNAPSHOT. Instead of relying only on locking, this isolation level relies on a combination of locking and row versioning. Under this isolation level, readers do not require shared locks, and therefore they never wait; they rely on the row-versioning technology to provide the expected isolation. Under the READ COMMITTED isolation level, if a transaction modifies rows, until the transaction completes, another transaction can’t read the same rows. This approach to concurrency control is known as the pessimistic concurrency approach. Under the READ COMMITTED SNAPSHOT isolation level, if a transaction modifies rows, another transaction trying to read the data will get the last committed state of the rows that was available when the statement started. This approach to concurrency control is known as the optimistic concurrency approach. READ COMMITTED SNAPSHOT is an MVCC-based implementation of the READ COMMITTED isolation level in SQL Server. Table 2. Lock compatibility of exclusive and shared locks Requested mode Granted Exclusive (X) Granted Shared (S) Exclusive No No Shared No Yes A “No” in the intersection means that the locks are incompatible and the requested mode is denied; the requester must wait. A “Yes” in the intersection means that the locks are compatible and the requested mode is accepted. 12.1.1.2. Lockable Resource Types SQL Server can lock different types of resources that include rows (RID in a heap, key in an index), pages, objects (for example, tables), databases, and others. Rows reside within pages, and pages are the physical data blocks that contain table or index data. To obtain a lock on a certain resource type, a transaction must first obtain intent locks of the same mode on higher levels of granularity to efficiently detect incompatible lock requests on higher levels of granularity and prevent the granting of those. SQL Server determines dynamically which resource types to lock. Naturally, for ideal concurrency, it’s best to lock only what needs to be locked—namely, only the affected rows. However, locks require memory resources and internal management overhead. So SQL Server considers both concurrency and system resources when it’s choosing which resource types to lock. When SQL Server estimates that a transaction will interact with a small number of rows, it tends to use row locks. With larger numbers of rows, SQL Server tends to use page locks. SQL Server might first acquire fine-grained locks (such as row or page locks) and, in certain circumstances, try to escalate the fine-grained locks to a table lock to preserve memory. 12.1.2. Blocking When one transaction holds a lock on a data resource and another transaction requests an incompatible lock on the same resource, the request is blocked and the requester enters a wait state. By default, the blocked request keeps waiting until the blocker releases the interfering lock. To restrict the amount of time the session waits for a lock, set a session option called LOCK_TIMEOUT. Specify a value in milliseconds—such as 5000 for 5 seconds, 0 for an immediate timeout, and –1 for no timeout (which is the default). SET LOCK_TIMEOUT 5000; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Msg 1222, Level 16, State 51, Line 3 Lock request time out period exceeded. To remove the lock timeout value, set it back to the default (no timeout), and issue the query again. SET LOCK_TIMEOUT -1; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; The dynamic management view (DMV) sys.dm_tran_locks can be used to get lock information, including both locks granted to sessions and locks sessions waiting for. -- Connection 1: hold exclusive lock to write BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; -- no COMMIT TRAN or ROLLBACK TRAN, the transaction remains open, and the lock is still held -- Connection 2: needs a shared lock to read, but be blocked and has to wait SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 3 SELECT -- use * to explore other available attributes request_session_id AS sid, resource_type AS restype, resource_database_id AS dbid, DB_NAME(resource_database_id) AS dbname, resource_description AS res, resource_associated_entity_id AS resid, request_mode AS mode, request_status AS status FROM sys.dm_tran_locks; sid restype dbid dbname res resid mode status 52 DATABASE 6 TSQLV6 0 S GRANT 56 DATABASE 6 TSQLV6 0 S GRANT 59 DATABASE 6 TSQLV6 0 S GRANT 52 PAGE 6 TSQLV6 1:456 72057594046251008 IS GRANT 56 PAGE 6 TSQLV6 1:456 72057594046251008 IX GRANT 52 OBJECT 6 TSQLV6 1029578706 IS GRANT 56 OBJECT 6 TSQLV6 1029578706 IX GRANT 56 KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 X GRANT 52 KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 S WAIT Each session is identified by a unique session ID. A session’s ID can be determined by querying the function @@SPID. If working with SQL Server Management Studio, the session ID could be found in parentheses to the right of the login name in the status bar at the bottom of the query window that has the focus, and also in the caption of the connected query window. By observing that both sessions lock a row with the same res and resid values, session 52 is waiting for a shared lock on a row in the sample database TSQLV6 that is being held as an exclusive lock by session 56. The involved table can be figured out by moving upward in the lock hierarchy for either session 52 or 56 and inspecting the intent locks on the object (table) where the row resides. The OBJECT_NAME function can be used to translate the object ID (1029578706, in this example) that appears under the resid attribute in the object lock, that is Production.Products. SELECT OBJECT_NAME(1029578706); -- Products The sys.dm_tran_locks view gives the information about the IDs of the sessions involved in the blocking chain, that is, two or more sessions that are involved in the blocking situation, such as session x blocking session y, session y blocking session z, and so on—hence the use of the term chain. The DMV sys.dm_exec_connections can be used to get information about the connections associated with those session IDs and filter only the session IDs that are involved: SELECT -- use * to explore session_id AS sid, connect_time, last_read, last_write, most_recent_sql_handle FROM sys.dm_exec_connections WHERE session_id IN(52, 56); 52 2025-01-13 14:50:57.367 2025-01-13 14:54:07.930 2025-01-13 14:54:07.923 0x0200000063FC7D052E09844778CDD615CFE7A2D1FB4118020000000000000000000000000000000000000000 56 2025-01-13 14:53:33.587 2025-01-13 14:53:52.560 2025-01-13 14:53:52.560 0x020000008FAC322CF2FC73472F8E93B0DF1994A69639ED090000000000000000000000000000000000000000 A binary value holding a handle to the most recent SQL batch run by the connection. The handle can be provided as an input parameter to a table function called sys.dm_exec_sql_text, and the function returns the batch of code represented by the handle. SELECT session_id, text FROM sys.dm_exec_connections CROSS APPLY sys.dm_exec_sql_text(most_recent_sql_handle) AS ST WHERE session_id IN(52, 56); 52 (@1 tinyint)SELECT [productid],[unitprice] FROM [Production].[Products] WHERE [productid]=@1 56 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; Starting with SQL Server 2016, the function sys.dm_exec_input_buffer instead of sys.dm_exec_sql_text can be used to get the code that the sessions of interest submitted last. SELECT session_id, event_info FROM sys.dm_exec_connections CROSS APPLY sys.dm_exec_input_buffer(session_id, NULL) AS IB WHERE session_id IN(52, 56); The DMV sys.dm_exec_sessions can be used to find a lot of useful information about the sessions involved in a blocking situation. SELECT -- use * to explore session_id AS sid, login_time, host_name, program_name, login_name, nt_user_name, last_request_start_time, last_request_end_time FROM sys.dm_exec_sessions WHERE session_id IN(52, 56); Another DMV sys.dm_exec_requests can probably be used to find useful for troubleshooting blocking situations. SELECT -- use * to explore session_id AS sid, blocking_session_id, command, sql_handle, database_id, wait_type, wait_time, wait_resource FROM sys.dm_exec_requests WHERE blocking_session_id &gt; 0; To terminate the blocker—for example, if realizing that as a result of a bug in the application the transaction remained open and nothing in the application can close it—do so by using the KILL &lt;session_id&gt; command. KILL 56; 12.2. Isolation Levels Isolation levels determine the level of consistency when interacting with data. In the default isolation level in a box product, a reader uses shared locks on the target resources and a writer uses exclusive locks. SQL Server supports four isolation levels that are based on the pure locking model: READ UNCOMMITTED, READ COMMITTED (the default in a SQL Server box product), REPEATABLE READ, and SERIALIZABLE. SQL Server also supports two isolation levels that are based on a combination of locking and row versioning: SNAPSHOT and READ COMMITTED SNAPSHOT (the default in Azure SQL Database). SNAPSHOT and READ COMMITTED SNAPSHOT are in a sense the row-versioning counterparts of READ COMMITTED and SERIALIZABLE, respectively. The isolation level of the whole session can be set by using the following command: SET TRANSACTION ISOLATION LEVEL &lt;isolationname&gt;; The isolation level of a query can be set by using a table hint: SELECT ... FROM &lt;table&gt; WITH (&lt;isolationname&gt;); With the first four isolation levels, the higher the isolation level, the stricter the locks are that readers request and the longer their duration is; therefore, the higher the isolation level is, the higher the consistency is and the lower the concurrency is. With the two row-versioning-based isolation levels, SQL Server is able to store previous committed versions of rows in a version store. Readers do not request shared locks; instead, if the current version of the rows is not what they are supposed to see, SQL Server provides them with an older version. Table 3. Isolation level properties Isolation level Allows uncommitted reads? Allows nonrepeatable reads? Allows lost updates? Allows phantom reads? Detects update conflicts? Uses row versioning? READ UNCOMMITTED Yes Yes Yes Yes No No READ COMMITTED No Yes Yes Yes No No REPEATABLE READ No No No Yes No No SERIALIZABLE No No No No No No SNAPSHOT No No No No Yes Yes READ COMMITTED SNAPSHOT No Yes Yes Yes No Yes 12.2.1. READ UNCOMMITTED READ UNCOMMITTED is the lowest available isolation level, that is, a reader doesn’t ask for a shared lock. A reader that doesn’t ask for a shared lock can never be in conflict with a writer that is holding an exclusive lock, so that the reader can read uncommitted changes (also known as dirty reads). It also means the reader won’t interfere with a writer that asks for an exclusive lock, that is, a writer can change data while a reader that is running under the READ UNCOMMITTED isolation level reads data. Open a transaction, update the unit price of product 2 by adding 1.00 to its current price (19.00), and then query the product’s row -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 Set the isolation level to READ UNCOMMITTED and query the row for product 2. The query returned the state of the row after the change, even though the change was not committed -- Connection 2 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 Keep in mind that Connection 1 might apply further changes to the row later in the transaction or even roll back at some point. -- Connection 1 ROLLBACK TRAN; The above rollback undoes the update of product 2, changing its price back to 19.00. The value 20.00 that the reader got was never committed which is called dirty read. 12.2.2. READ COMMITTED The lowest isolation level that prevents dirty reads is READ COMMITTED, which is also the default isolation level in SQL Server (the box product), to prevent uncommitted reads by requiring a reader to obtain a shared lock. -- Connection 1 -- open a transaction, update the price of product 2, and query the row to show the new price BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 2 -- Keep in mind that this isolation level is the default, so unless previously changed the session’s isolation level, it isn&#39;t needed to set it explicitly. -- The SELECT statement is currently blocked because it needs a shared lock to be able to read the row, and this shared lock request is in conflict with the exclusive lock held by the writer in Connection 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; -- Connection 1 -- commit the transaction COMMIT TRAN; -- Connection 2 2 20.00 -- restore the unitprice of the product 2 UPDATE Production.Products SET unitprice -= 1.00 -- 19.00 WHERE productid = 2; In terms of the duration of locks, in the READ COMMITTED isolation level, a reader holds the shared lock only until it’s done with the resource. It doesn’t keep the lock until the end of the transaction; in fact, it doesn’t even keep the lock until the end of the statement, that means that in between two reads of the same data resource in the same transaction, no lock is held on the resource. Therefore, another transaction can modify the resource in between those two reads, and the reader might get different values in each read, which is called nonrepeatable reads or inconsistent analysis. 12.2.3. REPEATABLE READ The isolation level REPEATABLE READ can be used to get repeatable reads, or consistent analysis to ensure that no one can change values in between reads that take place in the same transaction, that is, not only does a reader need a shared lock to be able to read, but it also holds the lock until the end of the transaction. The REPEATABLE READ but not by lower isolation levels can also prevent another phenomenon called a lost update that happens when two transactions read a value, make calculations based on what they read, and then update the value. In isolation levels lower than REPEATABLE READ no lock is held on the resource after the read, both transactions can update the value, and whichever transaction updates the value last “wins,” overwriting the other transaction’s update. In REPEATABLE READ, both sides keep their shared locks after the first read, so neither can acquire an exclusive lock later in order to update, which results in a deadlock, and the update conflict is prevented. -- Connection 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- keep holding a shared lock on the row for product 2 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 -- Connection 2 -- blocked the modifier’s request for an exclusive lock in conflict with the reader’s granted shared lock. UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; -- Connection 1 -- the second read got the same unit price for product 2 as the first read SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; -- commit the transaction and release the shared lock -- Connection 2 -- obtain the exclusive lock it was waiting for and update the row 12.2.4. SERIALIZABLE Under the REPEATABLE READ isolation level, readers keep shared locks until the end of the transaction that locks only resources (e.g., rows) that the query found the first time it ran, not rows that weren’t there when the query ran, so that a second read in the same transaction might return new rows as well, which happens if, in between the reads, another transaction inserts new rows that satisfy the reader’s query filter, which are called phantoms, and such reads are called phantom reads. The SERIALIZABLE isolation level can be used to prevent phantom reads, that requires a reader to obtain a shared lock on the whole range of keys that qualify for the query’s filter to be able to read, and it keeps the lock until the end of the transaction. -- Connection 1 -- set the transaction isolation level to SERIALIZABLE, open a transaction, and query all products with category 1 SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; BEGIN TRAN SELECT productid, productname, categoryid, unitprice FROM Production.Products WHERE categoryid = 1; -- Connection 2 -- In all isolation levels that are lower than SERIALIZABLE, such an attempt would be successful. -- In the SERIALIZABLE isolation level, the attempt is blocked. INSERT INTO Production.Products (productname, supplierid, categoryid, unitprice, discontinued) VALUES(&#39;Product ABCDE&#39;, 1, 1, 20.00, 0); sid restype dbid dbname res resid mode status 55 (Connection 1) KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 RangeS-S GRANT 64 (Connection 2) KEY 6 TSQLV6 (61a06abd401c) 72057594046251008 X WAIT -- Connection 1 -- get the same output as before, with no phantoms SELECT productid, productname, categoryid, unitprice FROM Production.Products WHERE categoryid = 1; COMMIT TRAN; -- transaction is committed and the shared key-range lock is released 12.2.5. Multi-Version Concurrency Control With the row-versioning technology, SQL Server can store previous versions of committed rows in a version store. If the Accelerated Database Recovery (ADR) feature is not enabled in the database, the version store resides in the tempdb database. If ADR is enabled, the version store resides in the user database in question. SQL Server supports two isolation levels, called SNAPSHOT and READ COMMITTED SNAPSHOT, that are based on this row-versioning technology. The SNAPSHOT isolation level is logically similar to the SERIALIZABLE isolation level in terms of the types of consistency problems that can or cannot happen. The READ COMMITTED SNAPSHOT isolation level is similar to the READ COMMITTED isolation level. Readers using isolation levels based on row versioning do not acquire shared locks, so they don’t wait when the requested data is exclusively locked. In other words, readers don’t block writers and writers don’t block readers. Readers still get levels of consistency similar to SERIALIZABLE and READ COMMITTED. SQL Server provides readers with an older version of the row if the current version is not the one they are supposed to see. Note that if enabling any of the row-versioning-based isolation levels (which are enabled in Azure SQL Database by default), the DELETE and UPDATE statements need to copy the version of the row before the change to the version store (Copy-on-Write); INSERT statements don’t need to write anything to the version store, because no earlier version of the row exists. But it’s important to be aware that enabling any of the isolation levels that are based on row versioning might have a negative impact on the performance of updates and deletes. The performance of readers usually improves, sometimes dramatically, because they do not acquire shared locks and don’t need to wait when data is exclusively locked or its version is not the expected one. 12.2.5.1. SNAPSHOT The SNAPSHOT isolation level, relies on row versioning instead of using shared locks, guarantees the reader to get the last committed version of the row that was available when the transaction started to get committed reads and repeatable reads, and not phantom reads. To work with the SNAPSHOT isolation level in a SQL Server box product instance (enabled by default in Azure SQL Database), first enable the option at the database level by running the following code in any open query window: ALTER DATABASE TSQLV6 SET ALLOW_SNAPSHOT_ISOLATION ON; Open a transaction, update the price of product 2 by adding 1.00 to its current price of 19.00, and show the new price. -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 If someone begins a transaction using the SNAPSHOT isolation level, that session can request the version before the update. -- Connection 2 SET TRANSACTION ISOLATION LEVEL SNAPSHOT; BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 If a transaction were under the SERIALIZABLE isolation level, the query would be blocked. -- Connection 3 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; -- by default in SQL Server SET LOCK_TIMEOUT 5000; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Msg 1222, Level 16, State 51, Line 5 Lock request time out period exceeded. Go back to Connection 1, and commit the transaction. -- at this point, the current version of the row with the price of 20.00 is a committed version. COMMIT TRAN; Go back to Connection 2, and run the following code. -- still get the last committed version of the row that was available when the transaction started (with a price of 19.00). SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; 2 19.00 12.2.5.2. Conflict Detection The SNAPSHOT isolation level prevents update conflicts, but unlike the REPEATABLE READ and SERIALIZABLE isolation levels that do so by generating a deadlock, the SNAPSHOT isolation level generates a more specific error, indicating that an update conflict was detected by examining the version store to figure out whether another transaction modified the data between a read and a write that took place in a transaction. Set the transaction isolation level to SNAPSHOT, open a transaction, and read the row for product 2. -- Connection 1 SET TRANSACTION ISOLATION LEVEL SNAPSHOT; BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 Update the price of the product queried previously to 20.00, and commit the transaction. -- Connection 1 UPDATE Production.Products SET unitprice = 20.00 WHERE productid = 2; COMMIT TRAN; No other transaction modified the row between the read, calculation, and write; therefore, there was no update conflict and SQL Server allowed the update to take place. Restore the price of product 2 back to 19.00: UPDATE Production.Products SET unitprice = 19.00 WHERE productid = 2; Next, run the following code in Connection 1, again, to open a transaction, and read the row for product 2: -- Connection 1 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; Next, run the following code in Connection 2 to update the price of product 2 to 25.00: -- Connection 2 UPDATE Production.Products SET unitprice = 25.00 WHERE productid = 2; Go back to Connection 1, and try to update the price of the product to 20.00: UPDATE Production.Products SET unitprice = 20.00 WHERE productid = 2; SQL Server detected that this time another transaction modified the data between the read and write; therefore, it fails the transaction with the following error: Msg 3960, Level 16, State 2, Line 1 Snapshot isolation transaction aborted due to update conflict. You cannot use snapshot isolation to access table &#39;Production.Products&#39; directly or indirectly in database &#39;TSQLV6&#39; to update, delete, or insert the row that has been modified or deleted by another transaction. Retry the transaction or change the isolation level for the update/delete statement. 12.2.5.3. READ COMMITTED SNAPSHOT The READ COMMITTED SNAPSHOT isolation level is also based on row versioning, but differs from the SNAPSHOT isolation level in that instead of providing a reader with a transaction-level consistent view of the data, it provides the reader with a statement-level consistent view of the data, and also does not detect update conflicts. To make a reader to acquire a shared lock under READ COMMITTED SNAPSHOT, add a table hint called READCOMMITTEDLOCK to the SELECT statements, as in SELECT * FROM dbo.T1 WITH (READCOMMITTEDLOCK). To enable the use of the READ COMMITTED SNAPSHOT isolation level in a SQL Server box product (enabled by default in Azure SQL Database), turn on a database option called READ_COMMITTED_SNAPSHOT. ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT ON; Unlike the SNAPSHOT isolation level, this flag changes the meaning, or semantics, of the READ COMMITTED isolation level to READ COMMITTED SNAPSHOT, which means that when this database flag is turned on, unless explicitly changing the session’s isolation level, READ COMMITTED SNAPSHOT is the default. Run the following code in Connection 1 to open a transaction, update the row for product 2, and read the row, leaving the transaction open: -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 20.00 In Connection 2, open a transaction and read the row for product 2, leaving the transaction open: -- Connection 2 BEGIN TRAN; SELECT productid, unitprice FROM Production.Products WHERE productid = 2; 2 19.00 Run the following code in Connection 1 to commit the transaction: -- Connection 1 COMMIT TRAN; Now run the code in Connection 2 to read the row for product 2 again, and commit the transaction: -- Connection 2 -- get the last committed version of the row that was available when the statement started (20.00) and not when the transaction started (19.00) SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; 2 19.00 Close all connections. Open a new connection, and run the following code to disable the isolation levels that are based on row versioning in the TSQLV6 database: ALTER DATABASE TSQLV6 SET ALLOW_SNAPSHOT_ISOLATION OFF; ALTER DATABASE TSQLV6 SET READ_COMMITTED_SNAPSHOT OFF; 12.3. Deadlocks A deadlock is a situation in which two or more sessions block each other. An example of a two- session deadlock is when session A blocks session B and session B blocks session A. An example of a deadlock involving more than two sessions is when session A blocks session B, session B blocks session C, and session C blocks session A. In any of these cases, SQL Server detects the deadlock and intervenes by terminating one of the transactions. If SQL Server did not intervene, the sessions involved would remain deadlocked forever. Unless otherwise specified (DEADLOCK_PRIORITY), SQL Server chooses to terminate the transaction that did the least work (based on the activity written to the transaction log), because rolling that transaction’s work back is the cheapest option. Run the following code in Connection 1 to open a new transaction, update a row in the Production.Products table for product 2, and leave the transaction open: -- Connection 1 BEGIN TRAN; UPDATE Production.Products SET unitprice += 1.00 WHERE productid = 2; Run the following code in Connection 2 to open a new transaction, update a row in the Sales.OrderDetails table for product 2, and leave the transaction open: -- Connection 2 BEGIN TRAN; UPDATE Sales.OrderDetails SET unitprice += 1.00 WHERE productid = 2; Run the following code in Connection 1 to attempt to query the rows for product 2 in the Sales.OrderDetails table, and commit the transaction: -- Connection 1 -- needs a shared lock to be able to perform its read, but blocked by Connection 2 SELECT orderid, productid, unitprice FROM Sales.OrderDetails WHERE productid = 2; COMMIT TRAN; Next, run the following code in Connection 2 to attempt to query the row for product 2 in the Production.Products table and commit the transaction: -- Connection 2 -- needs a shared lock to be able to perform its read, but blocked by Connection 1 SELECT productid, unitprice FROM Production.Products WHERE productid = 2; COMMIT TRAN; At this point, each of the sessions blocks the other —results a deadlock. SQL Server identifies the deadlock (typically within a few seconds), chooses one of the sessions involved as the deadlock victim, and terminates its transaction with the following error: Msg 1205, Level 13, State 51, Line 3 Transaction (Process ID 57) was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction. Deadlocks are expensive because they involve undoing work that has already been done and then, usually with some error-handling logic, redoing the work. Obviously, the longer the transactions are, the longer locks are kept, increasing the probability of deadlocks. Keep transactions as short as possible, taking activities out of the transaction that aren’t logically supposed to be part of the same unit of work. For example, don’t use transactions that require user input to finish! One typical deadlock, also called a deadly embrace deadlock (e.g., the above example), happens when transactions access resources in inverse order. By swapping the order in one of the transactions, you can prevent this type of deadlock from happening—assuming that it makes no logical difference to your application. Deadlocks often also happen when there is no real logical conflict (for example, trying to access the same rows), because of a lack of good indexing to support query filters. For example, suppose both statements in the transaction in Connection 2 filtered product 5. Now that the statements in Connection 1 handle product 2 and the statements in Connection 2 handle product 5, there shouldn’t be any conflict. However, if indexes aren&#8217;t defined on the productid column in the tables to support the filter, SQL Server has to scan (and lock) all rows in the table, that is, of course, can lead to a deadlock. While scanning the entire table, both connections might attempt to acquire locks on the same or overlapping table pages, leading to a deadlock situation even though they are working with different product data. In short, good index design can help mitigate the occurrences of deadlocks that have no real logical conflict. Another option to consider to mitigate deadlock occurrences is the choice of isolation level. The SELECT statements in the example needed shared locks because they ran under the READ COMMITTED isolation level. If using the READ COMMITTED SNAPSHOT isolation level, readers will not need shared locks, and deadlocks that evolve because of the involvement of shared locks can be eliminated. 13. Programmable Objects Programmable objects in SQL Server are reusable code blocks that extend the capabilities of the database beyond basic data storage and retrieval. 13.1. Variables A variable is used to temporarily store data values for later use in the same batch in which they were declared, and a batch is one or more T-SQL statements sent to Microsoft SQL Server for execution as a single unit. Use a DECLARE statement to declare one or more variables, and use a SET statement to assign a value to a single variable. -- declares two variables called @i and @j of INT data type and assigns it the value 10 and 20 DECLARE @i AS INT, @j AS INT; -- SET statement can operate on only one variable at a time SET @i = 10; SEt @j = 20; Alternatively, a variable can be declared and initialized in the same statement, like this: DECLARE @i AS INT = 10, @j AS INT = 20; When assign a value to a scalar variable, the value must be the result of a scalar expression. DECLARE @empname AS NVARCHAR(61); -- a scalar subquery SET @empname = (SELECT firstname + N&#39; &#39; + lastname FROM HR.Employees WHERE empid = 3); -- a scalar subquery fails at run time if it returns more than one value DECLARE @empname AS NVARCHAR(61); SET @empname = (SELECT firstname + N&#39; &#39; + lastname FROM HR.Employees WHERE mgrid = 2); Msg 512, Level 16, State 1, Line 2 Subquery returned more than 1 value. This is not permitted when the subquery follows =, !=, &lt;, &lt;= , &gt;, &gt;= or when the subquery is used as an expression. T-SQL also supports a nonstandard assignment SELECT statement to query data and assign multiple values obtained from the same row to multiple variables by using a single statement. DECLARE @firstname AS NVARCHAR(20), @lastname AS NVARCHAR(40); -- if the query has more than one qualifying row, the values in the variables are those from the last row that SQL Server happened to access. SELECT @firstname = firstname, @lastname = lastname FROM HR.Employees WHERE empid = 3; SELECT @firstname AS firstname, @lastname AS lastname; 13.2. Batchs A batch is one or more T-SQL statements sent by a client application to SQL Server for execution as a single unit. A transaction is an atomic unit of work. A batch can have multiple transactions, and a transaction can be submitted in parts as multiple batches. Client application programming interfaces (APIs) such as ADO.NET provide methods for submitting a batch of code to SQL Server for execution. SQL Server utilities such as SQL Server Management Studio (SSMS), Azure Data Studio (ADS), SQLCMD, and OSQL provide a client tool command called GO that signals the end of a batch. Note that the GO command is a client tool command and not a T-SQL server command, and do not terminate the GO command with a semicolon. A batch is a set of commands that are parsed and executed as a unit. If the parsing is successful, SQL Server then attempts to execute the batch. In the event of a syntax error in the batch, the whole batch is not submitted to SQL Server for execution. -- Valid batch PRINT &#39;First batch&#39;; USE TSQLV6; GO -- Invalid batch PRINT &#39;Second batch&#39;; SELECT custid FROM Sales.Customers; SELECT orderid FOM Sales.Orders; GO -- Valid batch PRINT &#39;Third batch&#39;; SELECT empid FROM HR.Employees; First batch Msg 102, Level 15, State 1, Line 8 Incorrect syntax near &#39;Sales&#39;. Third batch A variable is local to the batch in which it’s defined, that is, it can’t be referred to in another batch. DECLARE @i AS INT = 10; -- Succeeds PRINT @i; GO -- Fails PRINT @i; 10 Msg 137, Level 15, State 2, Line 6 Must declare the scalar variable &quot;@i&quot;. The CREATE statements cannot be combined with other statements in the same batch. -- CREATE DEFAULT, CREATE FUNCTION, CREATE PROCEDURE, CREATE RULE, CREATE SCHEMA, CREATE TRIGGER, and CREATE VIEW DROP VIEW IF EXISTS Sales.MyView; -- GO -- To get around the problem, add a GO command here CREATE VIEW Sales.MyView AS SELECT YEAR(orderdate) AS orderyear, COUNT (*) AS numorders FROM Sales.Orders GROUP BY YEAR(orderdate); GO Msg 111, Level 15, State 1, Line 3 &#39;CREATE VIEW&#39; must be the first statement in a query batch. A batch is a unit of resolution (also known as binding), that means that checking the existence of objects and columns happens at the batch level. When applying schema changes to an object and try to manipulate the object data in the same batch, SQL Server might not be aware of the schema changes yet and fail the data-manipulation statement with a resolution error. DROP TABLE IF EXISTS dbo.T1; CREATE TABLE dbo.T1(col1 INT); GO ALTER TABLE dbo.T1 ADD col2 INT; -- GO -- To get around the problem, add a GO command here SELECT col1, col2 FROM dbo.T1; -- Invalid column name &#39;col2&#39;. GO DROP TABLE IF EXISTS dbo.T1; The GO command is not really a T-SQL command; it’s actually a command used by SQL Server’s client tools, such as SSMS, to denote the end of a batch. It also supports an argument indicating how many times you want to execute the batch. DROP TABLE IF EXISTS dbo.T1; CREATE TABLE dbo.T1(col1 INT IDENTITY); GO SET NOCOUNT ON; INSERT INTO dbo.T1 DEFAULT VALUES; GO 100 SELECT SUM(col1) FROM dbo.T1; -- (1 + 100) * 100 / 2 = 5050 GO DROP TABLE IF EXISTS dbo.T1; 13.3. Flow Elements: IF and WHILE T-SQL provides basic forms of control with flow elements to control the flow of the code, including the IF . . . ELSE element and the WHILE element. The IF . . . ELSE element is used to control the flow of a code based on the result of a predicate. IF YEAR(SYSDATETIME()) &lt;&gt; YEAR(DATEADD(day, 1, SYSDATETIME())) -- a statement or statement block that is executed if the predicate is TRUE PRINT &#39;Today is the last day of the year.&#39;; -- optionally a statement or statement block that is executed if the predicate is FALSE or UNKNOWN. ELSE BEGIN -- mark the boundaries of a statement block with the BEGIN and END keywords IF MONTH(SYSDATETIME()) &lt;&gt; MONTH(DATEADD(day, 1, SYSDATETIME())) PRINT &#39;Today is the last day of the month but not the last day of the year.&#39;; ELSE PRINT &#39;Today is not the last day of the month.&#39;; END DECLARE @score AS INT = CAST(RAND() * 100 AS INT); IF @score &gt; 90 PRINT &#39;A&#39;; ELSE IF @score &gt; 80 PRINT &#39;B&#39;; ELSE IF @score &gt; 70 PRINT &#39;C&#39;; ELSE IF @score &gt; 60 PRINT &#39;D&#39;; ELSE PRINT &#39;F&#39;; -- CASE is expression, instead of statement DECLARE @score AS INT = CAST(RAND() * 100 AS INT); SELECT CASE WHEN @score &gt;= 90 THEN &#39;A&#39; WHEN @score &gt;= 80 THEN &#39;B&#39; WHEN @score &gt;= 70 THEN &#39;C&#39; WHEN @score &gt;= 60 THEN &#39;D&#39; ELSE &#39;F&#39; END AS Grade; The WHILE element executes a statement or statement block repeatedly while the predicate specified after the WHILE keyword is TRUE, otherwise, the loop terminates when the predicate is FALSE or UNKNOWN. DECLARE @i AS INT = 0; WHILE @i &lt;= 10 BEGIN SET @i = @i + 1; IF @i = 3 CONTINUE; -- skip the rest of the activity in the current iteration and evaluate the loop’s predicate again PRINT @i; IF @i = 7 BREAK; -- break out of the current loop and proceed to execute the statement that appears after the loop’s body END; 13.4. Cursors SQL and T-SQL also support an object called cursor to process rows from a result of a query one at a time and in a requested order. Primarily, the use of cursors contradicts the fundamental principles of the relational model, which is grounded in set theory. Cursors, due to their record-by-record processing, incur significant overhead compared to set-based operations, resulting in significantly slower execution times even for similar underlying physical processing. Cursor solutions, being imperative, tend to be longer, less readable, and harder to maintain than the declarative set solutions. Working with a cursor generally involves the following steps: Declare the cursor based on a query. Open the cursor. Fetch attribute values from the first cursor record into variables. While not reaching the end of the cursor (the value of a function called @@FETCH_STATUS is 0), loop through the cursor records. In each iteration of the loop, perform the processing needed for the current row, and then fetch the attribute values from the next row into the variables. Close the cursor. Deallocate the cursor. DROP VIEW IF EXISTS Sales.CustOrders; GO CREATE VIEW Sales.CustOrders AS SELECT DISTINCT O.custid, O.orderdate AS ordermonth, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid GROUP BY o.custid, O.orderdate GO -- Suppress messages indicating how many rows were affected SET NOCOUNT ON; -- Declare table variable to hold the final result DECLARE @Result AS TABLE ( custid INT, ordermonth DATE, qty INT, runqty INT, PRIMARY KEY(custid, ordermonth) ); -- Declare local variables that are used to store intermediate variables DECLARE @custid AS INT, @prvcustid AS INT, @ordermonth AS DATE, @qty AS INT, @runqty AS INT; -- Step 1: Declare the cursor based on a query DECLARE C CURSOR FAST_FORWARD /* read only, forward only */ FOR SELECT custid, ordermonth, qty FROM Sales.CustOrders ORDER BY custid, ordermonth; -- Step 2: Open the cursor OPEN C; -- Step 3: Fetch attribute values from the first cursor record into variables FETCH NEXT FROM C INTO @custid, @ordermonth, @qty; -- Initialize variables SELECT @prvcustid = @custid, @runqty = 0; -- Step 4: Loop through the cursor records while last fetch was -- In each iteration: -- Reset variables if customer ID changes -- Compute current running total and insert into table -- Fetch next cursor record WHILE @@FETCH_STATUS = 0 BEGIN IF @custid &lt;&gt; @prvcustid SELECT @prvcustid = @custid, @runqty = 0; SET @runqty = @runqty + @qty; INSERT INTO @Result VALUES(@custid, @ordermonth, @qty, @runqty); FETCH NEXT FROM C INTO @custid, @ordermonth, @qty; END; -- Step 5: Close the cursor CLOSE C; -- Step 6: Deallocate the cursor DEALLOCATE C; -- Enable showing messages indicating how many rows were affected SET NOCOUNT OFF; -- Query the table variable to return the final result SELECT custid, CONVERT(VARCHAR(7), ordermonth, 121) AS ordermonth, qty, runqty FROM @Result ORDER BY custid, ordermonth; -- address the same task with a window function SELECT custid, ordermonth, qty, SUM(qty) OVER(PARTITION BY custid ORDER BY ordermonth ROWS UNBOUNDED PRECEDING) AS runqty FROM Sales.CustOrders ORDER BY custid, ordermonth; 13.5. Temporary Tables Temporary tables are temporary storage structures within a SQL Server database. Unlike permanent tables, they are designed for short-term data storage and have limited lifespans. SQL Server supports three kinds of temporary tables to be more conveniental to work with than permanent tables in such cases: local temporary tables, global temporary tables, and table variables. All three kinds of temporary tables are created in the tempdb database. It&#8217;s crucial to distinguish temporary tables (local, global, table variables) from system-versioned temporal tables. Temporary Tables: Primarily used for temporary storage within a specific session or batch, often for intermediate results or data manipulation. System-Versioned Temporal Tables: Specifically designed to track the history of data changes over time. 13.5.1. Local Temporary Tables A local temporary table is created by naming it with a single number sign (#) as a prefix, such as #T1. A local temporary table is visible only to the session that created it, in the creating level and all inner levels in the call stack (inner procedures, triggers, and dynamic batches). A local temporary table is destroyed automatically by SQL Server when the creating level in the call stack goes out of scope. A suffix is added to the table name by SQL Server internally that makes it unique in tempdb. DROP TABLE IF EXISTS #MyOrderTotalsByYear; GO CREATE TABLE #MyOrderTotalsByYear ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); INSERT INTO #MyOrderTotalsByYear(orderyear, qty) SELECT YEAR(O.orderdate) AS orderyear, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON OD.orderid = O.orderid GROUP BY YEAR(orderdate); SELECT Cur.orderyear, Cur.qty AS curyearqty, Prv.qty AS prvyearq FROM #MyOrderTotalsByYear AS Cur LEFT OUTER JOIN #MyOrderTotalsByYear AS Prv ON Cur.orderyear = Prv.orderyear + 1; -- clean up resources as soon as possible DROP TABLE IF EXISTS #MyOrderTotalsByYear; 13.5.2. Global Temporary Tables A global temporary table is created by naming it with a double number sign (##) as a prefix, such as ##T1. A global temporary table is visible to all other sessions. A global temporary table is destroyed automatically by SQL Server when the creating session disconnects and there are no active references to the table. -- creates a global temporary table called ##Globals with columns called id and val CREATE TABLE ##Globals ( id sysname NOT NULL PRIMARY KEY, val SQL_VARIANT NOT NULL ); -- anyone can insert rows into the table. INSERT INTO ##Globals(id, val) VALUES(N&#39;I&#39;, CAST(10 AS INT)); -- anyone can modify and retrieve data from the table. SELECT val FROM ##Globals WHERE id = N&#39;I&#39;; -- explicitly destroy the global temporary table DROP TABLE IF EXISTS ##Globals; 13.5.3. Table Variables A table variable is a local, temporary table-like data structure declared within a single batch. As with local temporary tables, table variables have a physical presence as a table in the tempdb database. Like local temporary tables, table variables are visible only to the creating session, but because they are variables they have a more limited scope: only the current batch. If an explicit transaction is rolled back, changes made to temporary tables in that transaction are rolled back as well; however, changes made to table variables by statements that completed in the transaction aren’t rolled back. In terms of performance, usually it makes more sense to use table variables with small volumes of data (only a few rows) and to use local temporary tables otherwise. DECLARE @MyOrderTotalsByYear TABLE ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); INSERT INTO @MyOrderTotalsByYear(orderyear, qty) SELECT YEAR(O.orderdate) AS orderyear, SUM(OD.qty) AS qty FROM Sales.Orders AS O INNER JOIN Sales.OrderDetails AS OD ON OD.orderid = O.orderid GROUP BY YEAR(orderdate); SELECT Cur.orderyear, Cur.qty AS curyearqty, Prv.qty AS prvyearqty FROM @MyOrderTotalsByYear AS Cur LEFT OUTER JOIN @MyOrderTotalsByYear AS Prv ON Cur.orderyear = Prv.orderyear + 1; A table type is a user-defined data structure that defines the schema (columns, data types) of a table to be reused as the table definition of table variables and input parameters of stored procedures and user-defined functions. -- create a table type called dbo.OrderTotalsByYear DROP TYPE IF EXISTS dbo.OrderTotalsByYear; CREATE TYPE dbo.OrderTotalsByYear AS TABLE ( orderyear INT NOT NULL PRIMARY KEY, qty INT NOT NULL ); -- simply specify dbo.OrderTotalsByYear as the variable’s type DECLARE @MyOrderTotalsByYear AS dbo.OrderTotalsByYear; 13.6. Dynamic SQL A dynamic SQL in SQL Server is a batch of T-SQL code as a character string that can be executed by using the EXEC command and the sp_executesql stored procedure. The EXEC (short for EXECUTE) command accepts a regular or Unicode character string in parentheses as input and executes the batch of code within the character string. DECLARE @sql AS VARCHAR(100); SET @sql = &#39;PRINT &#39;&#39;This message was printed by a dynamic SQL batch&#39;&#39;&#39; EXEC(@sql); The sp_executesql stored procedure is an alternative tool to the EXEC command for executing dynamic SQL code. It’s more secure and more flexible in the sense that it has an interface; that is, it supports input and output parameters. In terms of security, parameters that appear in the code cannot be considered part of the code—they can only be considered operands in expressions. Note that unlike EXEC, sp_executesql supports only Unicode character strings as the input batch of code. The sp_executesql stored procedure can perform better than EXEC because its parameterization aids in reusing cached execution plans, which incur cost when SQL Server needs to create them anew. An execution plan is the physical processing plan SQL Server produces for a query, with the set of instructions describing which objects to access, in what order, which indexes to use, how to access them, which join algorithms to use, and so on. One of the requirements for reusing a previously cached plan is that the query string be the same as the one for which the cached plan was created. DECLARE @sql AS NVARCHAR(100); SET @sql = N&#39;SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderid = @orderid;&#39;; EXEC sp_executesql @stmt = @sql, -- a Unicode character string holding the batch of code @params = N&#39;@orderid AS INT&#39;, -- a Unicode character string holding the declarations of input and output parameters @orderid = 10248; -- an input parameter called @orderid 13.7. Routines Routines are programmable objects that encapsulate code to calculate a result or to execute activity. SQL Server supports three types of routines: user-defined functions, stored procedures, and triggers. 13.7.1. User-defined Functions A user-defined function (UDF) is used to encapsulate logic that calculates something, possibly based on input parameters, and return a result. SQL Server supports scalar and table-valued UDFs. Scalar UDFs return a single value; table-valued UDFs return a table. Scalar UDFs can appear anywhere in the query where an expression that returns a single value can appear (for example, in the SELECT list). Table UDFs can appear in the FROM clause of a query. UDFs are not allowed to have any side effects, that means UDFs are not allowed to apply any schema or data changes in the database. CREATE OR ALTER FUNCTION dbo.GetNewID() RETURNS UNIQUEIDENTIFIER AS BEGIN RETURN NEWID(); -- Invalid use of a side-effecting operator &#39;newid&#39; within a function. END; -- create a UDF called dbo.GetAge that returns the age of a person DROP FUNCTION IF EXISTS dbo.GetAge; GO CREATE OR ALTER FUNCTION dbo.GetAge ( @birthdate AS DATE, -- a specified birth date (@birthdate argument) @eventdate AS DATE -- a specified event date (@eventdate argument) ) RETURNS INT AS BEGIN RETURN -- a RETURN clause that returns a value DATEDIFF(year, @birthdate, @eventdate) - CASE WHEN 100 * MONTH(@eventdate) + DAY(@eventdate) &lt; 100 * MONTH(@birthdate) + DAY(@birthdate) THEN 1 ELSE 0 END; END; GO -- use a UDF in a query SELECT empid, firstname, lastname, birthdate, dbo.GetAge(birthdate, SYSDATETIME()) AS age FROM HR.Employees; 13.7.2. Stored Procedures Stored procedures are routines that encapsulate logic with input and output parameters, return result sets of queries, and can have side effects. Stored procedures encapsulate logic, allowing for centralized modification and ensuring all users utilize the updated implementation. Stored procedures give better control of security. A user permissions can be granted to execute the procedure without granting the user direct permissions to perform the underlying activities to ensure that all the required validations and auditing always take place. Stored procedures with parameters can help prevent SQL injection. All error-handling code can be incorporated within a procedure, silently taking corrective action where relevant. Stored procedures give performance benefits. Parameterized queries within stored procedures enhance performance by leveraging cached execution plans. Stored procedures reduce network traffic by minimizing data exchange between the client and server. -- create a stored procedure called Sales.GetCustomerOrders CREATE OR ALTER PROC Sales.GetCustomerOrders -- a customer ID (@custid) and a date range (@fromdate and @todate) as inputs @custid AS INT, @fromdate AS DATETIME = &#39;19000101&#39;, -- default 19000101 @todate AS DATETIME = &#39;99991231&#39;, -- default 99991231 @numrows AS INT OUTPUT -- the number of affected rows (@numrows) as an output AS SET NOCOUNT ON; -- suppress messages indicating affected rows by DML SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE custid = @custid AND orderdate &gt;= @fromdate AND orderdate &lt; @todate; SET @numrows = @@rowcount; -- execute the procedure, and absorb the value of the output parameter @numrows in the variable @rc DECLARE @rc AS INT; EXEC Sales.GetCustomerOrders @custid = 1, @fromdate = &#39;20210101&#39;, @todate = &#39;20220101&#39;, @numrows = @rc OUTPUT; SELECT @rc AS numrows; 13.7.3. Triggers A trigger is a special kind of stored procedure attached to an event—one that cannot be executed explicitly. SQL Server supports the association of triggers with two kinds of events: data manipulation events (DML triggers) such as INSERT, and data definition events (DDL triggers) such as CREATE TABLE. A trigger is considered part of the transaction that includes the event that caused the trigger to fire. Triggers in SQL Server fire per statement and not per modified row. 13.7.3.1. DML Triggers SQL Server supports two kinds of DML triggers: after and instead of. An after trigger fires after the event it’s associated with finishes and can be defined only on permanent tables. An instead of trigger fires instead of the event it’s associated with and can be defined on permanent tables and views. In the trigger’s code, pseudo tables called inserted and deleted that contain the rows that were affected by the modification that caused the trigger to fire can be accessed. The inserted table holds the new image of the affected rows in the case of INSERT and UPDATE actions. The deleted table holds the old image of the affected rows in the case of DELETE and UPDATE actions. In the case of instead of triggers, the inserted and deleted tables contain the rows that were supposed to be affected by the modification that caused the trigger to fire. -- create a table called dbo.T1, and a table called dbo.T1_Audit DROP TABLE IF EXISTS dbo.T1_Audit, dbo.T1; CREATE TABLE dbo.T1 ( keycol INT NOT NULL PRIMARY KEY, datacol VARCHAR(10) NOT NULL ); CREATE TABLE dbo.T1_Audit ( audit_lsn INT NOT NULL IDENTITY PRIMARY KEY, -- audit log serial number dt DATETIME2(3) NOT NULL DEFAULT(SYSDATETIME()), login_name sysname NOT NULL DEFAULT(ORIGINAL_LOGIN()), keycol INT NOT NULL, datacol VARCHAR(10) NOT NULL ); GO -- create the AFTER INSERT trigger trg_T1_insert_audit on the T1 table to audit insertions CREATE OR ALTER TRIGGER trg_T1_insert_audit ON dbo.T1 AFTER INSERT AS SET NOCOUNT ON; INSERT INTO dbo.T1_Audit(keycol, datacol) SELECT keycol, datacol FROM inserted; GO -- trigger fires after each statement INSERT INTO dbo.T1(keycol, datacol) VALUES(10, &#39;a&#39;); INSERT INTO dbo.T1(keycol, datacol) VALUES(30, &#39;x&#39;); INSERT INTO dbo.T1(keycol, datacol) VALUES(20, &#39;g&#39;); GO SELECT audit_lsn, dt, login_name, keycol, datacol FROM dbo.T1_Audit; -- 1 2025-01-15 16:03:50.997 sa 10 a -- 2 2025-01-15 16:03:51.004 sa 30 x -- 3 2025-01-15 16:03:51.008 sa 20 g GO -- cleanup DROP TABLE dbo.T1_Audit, dbo.T1; 13.7.3.2. DDL Triggers SQL Server supports DDL triggers, which can be used for purposes such as auditing, policy enforcement, and change management. SQL Server box product supports the creation of DDL triggers at two scopes, the database scope and the server scope, depending on the scope of the event. Azure SQL Database currently supports only database triggers. SQL Server supports only after DDL triggers; it doesn’t support instead of DDL triggers. Within the trigger, information about the event that caused the trigger to fire can be obtained by querying a function called EVENTDATA, which returns the event information as an XML instance. -- creates the dbo.AuditDDLEvents table to hold the audit information DROP TABLE IF EXISTS dbo.AuditDDLEvents; CREATE TABLE dbo.AuditDDLEvents ( audit_lsn INT NOT NULL IDENTITY, posttime DATETIME2(3) NOT NULL, eventtype sysname NOT NULL, loginname sysname NOT NULL, schemaname sysname NOT NULL, objectname sysname NOT NULL, targetobjectname sysname NULL, eventdata XML NOT NULL, CONSTRAINT PK_AuditDDLEvents PRIMARY KEY(audit_lsn) ); GO -- create the trg_audit_ddl_events audit trigger on the database by using the event group DDL_DATABASE_LEVEL_EVENTS CREATE OR ALTER TRIGGER trg_audit_ddl_events ON DATABASE FOR DDL_DATABASE_LEVEL_EVENTS AS SET NOCOUNT ON; DECLARE @eventdata AS XML = eventdata(); INSERT INTO dbo.AuditDDLEvents( posttime, eventtype, loginname, schemaname, objectname, targetobjectname, eventdata) VALUES( @eventdata.value(&#39;(/EVENT_INSTANCE/PostTime)[1]&#39;, &#39;VARCHAR(23)&#39;), -- XQuery expressions @eventdata.value(&#39;(/EVENT_INSTANCE/EventType)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/LoginName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/SchemaName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/ObjectName)[1]&#39;, &#39;sysname&#39;), @eventdata.value(&#39;(/EVENT_INSTANCE/TargetObjectName)[1]&#39;, &#39;sysname&#39;), @eventdata); GO -- test the trigger CREATE TABLE dbo.T1(col1 INT NOT NULL PRIMARY KEY); ALTER TABLE dbo.T1 ADD col2 INT NULL; ALTER TABLE dbo.T1 ALTER COLUMN col2 INT NOT NULL; CREATE NONCLUSTERED INDEX idx1 ON dbo.T1(col2); GO SELECT * FROM dbo.AuditDDLEvents; GO -- cleanup DROP TRIGGER IF EXISTS trg_audit_ddl_events ON DATABASE; DROP TABLE IF EXISTS dbo.AuditDDLEvents, dbo.T1; 13.8. Error Handling: TRY-CATCH The TRY. . .CATCH construct in SQL Server handles errors by placing the usual T-SQL code in a TRY block and placing all the error-handling code in the adjacent CATCH block. If the TRY block has no error, the CATCH block is simply skipped. If the TRY block has an error, control is passed to the corresponding CATCH block. BEGIN TRY -- TRY block (between the BEGIN TRY and END TRY keywords) PRINT 10/0; PRINT &#39;No error&#39;; END TRY BEGIN CATCH -- CATCH block (between the BEGIN CATCH and END CATCH keywords) PRINT &#39; Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39; Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); END CATCH; SQL Server also provides a set of functions to get information about the error. The ERROR_NUMBER function returns an integer with the number of the error. The ERROR_MESSAGE function returns error-message text. To get the list of error numbers and messages, query the sys.messages catalog view. The ERROR_SEVERITY and ERROR_STATE functions return the error severity and state. The ERROR_LINE function returns the line number in the code where the error happened. The ERROR_PROCEDURE function returns the name of the procedure in which the error happened and returns NULL if the error did not happen within a procedure. -- create a table called dbo.Employees DROP TABLE IF EXISTS dbo.Employees; CREATE TABLE dbo.Employees ( empid INT NOT NULL, empname VARCHAR(25) NOT NULL, mgrid INT NULL, CONSTRAINT PK_Employees PRIMARY KEY(empid), CONSTRAINT CHK_Employees_empid CHECK(empid &gt; 0), CONSTRAINT FK_Employees_Employees FOREIGN KEY(mgrid) REFERENCES dbo.Employees(empid) ); BEGIN TRY INSERT INTO dbo.Employees(empid, empname, mgrid) VALUES(1, &#39;Emp1&#39;, NULL); -- Also try with empid = 0, &#39;A&#39;, NULL END TRY BEGIN CATCH IF ERROR_NUMBER() = 2627 BEGIN PRINT &#39; Handling PK violation...&#39;; END; ELSE IF ERROR_NUMBER() = 547 BEGIN PRINT &#39; Handling CHECK/FK constraint violation...&#39;; END; ELSE IF ERROR_NUMBER() = 515 BEGIN PRINT &#39; Handling NULL violation...&#39;; END; ELSE IF ERROR_NUMBER() = 245 BEGIN PRINT &#39; Handling conversion error...&#39;; END; ELSE BEGIN PRINT &#39;Re-throwing error...&#39;; THROW; -- re-throws the error END; PRINT &#39; Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39; Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39; Error Severity: &#39; + CAST(ERROR_SEVERITY() AS VARCHAR(10)); PRINT &#39; Error State : &#39; + CAST(ERROR_STATE() AS VARCHAR(10)); PRINT &#39; Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); PRINT &#39; Error Proc : &#39; + COALESCE(ERROR_PROCEDURE(), &#39;Not within a procedure&#39;); END CATCH; -- a stored procedure that encapsulates reusable error-handling code CREATE OR ALTER PROC dbo.ErrInsertHandler AS SET NOCOUNT ON; IF ERROR_NUMBER() = 2627 BEGIN PRINT &#39;Handling PK violation...&#39;; END; ELSE IF ERROR_NUMBER() = 547 BEGIN PRINT &#39;Handling CHECK/FK constraint violation...&#39;; END; ELSE IF ERROR_NUMBER() = 515 BEGIN PRINT &#39;Handling NULL violation...&#39;; END; ELSE IF ERROR_NUMBER() = 245 BEGIN PRINT &#39;Handling conversion error...&#39;; END; PRINT &#39;Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39;Error Number : &#39; + CAST(ERROR_NUMBER() AS VARCHAR(10)); PRINT &#39;Error Message : &#39; + ERROR_MESSAGE(); PRINT &#39;Error Severity: &#39; + CAST(ERROR_SEVERITY() AS VARCHAR(10)); PRINT &#39;Error State : &#39; + CAST(ERROR_STATE() AS VARCHAR(10)); PRINT &#39;Error Line : &#39; + CAST(ERROR_LINE() AS VARCHAR(10)); PRINT &#39;Error Proc : &#39; + COALESCE(ERROR_PROCEDURE(), &#39;Not within a procedure&#39;); GO BEGIN TRY INSERT INTO dbo.Employees(empid, empname, mgrid) VALUES(1, &#39;Emp1&#39;, NULL); END TRY BEGIN CATCH IF ERROR_NUMBER() IN (2627, 547, 515, 245) EXEC dbo.ErrInsertHandler; ELSE THROW; END CATCH; GO -- clean up DROP TABLE IF EXISTS dbo.Employees; DROP PROC IF EXISTS dbo.ErrInsertHandler; 14. JSON JSON is a widely-used text format for data exchange in modern applications and for storing unstructured data. SQL Server 2016 and later versions provide built-in functions that integrate JSON with relational data, enabling the storage and querying of JSON documents within the database and the formatting of relational query results as JSON text. A native JSON data type, available in Azure SQL and in preview for SQL Server 2025, stores JSON in an optimized binary format, which provides more efficient reads, writes, and storage compared to traditional string types, while maintaining compatibility with existing query functions. 14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY ISJSON() checks if a string contains valid JSON. JSON_VALUE() extracts a single scalar value (like a string or number). JSON_QUERY() extracts a JSON object or an array. JSON_MODIFY() updates a property within a JSON string and returns the new string. These functions use a JavaScript-like path syntax to reference nested elements, and the extracted values can be used in any part of a T-SQL query, such as WHERE or ORDER BY clauses. The path expressions for JSON_VALUE, JSON_QUERY, and JSON_MODIFY can be prefixed with lax (the default) or strict. lax mode returns NULL (or an empty result for JSON_QUERY) if the path is not found, whereas strict mode will raise an error. If the input JSON expression is NULL, all JSON functions will return NULL. However, if the input is not NULL but is an invalid JSON text, the functions will raise an error. It is a best practice to use ISJSON() to validate the input before applying other JSON functions. -- Declare a variable to hold JSON data DECLARE @person NVARCHAR(MAX) = &#39;{ &quot;name&quot;: &quot;Jane Doe&quot;, &quot;status&quot;: &quot;Active&quot;, &quot;location&quot;: { &quot;city&quot;: &quot;Belgrade&quot;, &quot;country&quot;: &quot;Serbia&quot; }, &quot;skills&quot;: [ &quot;T-SQL&quot;, &quot;Power BI&quot; ] }&#39;; -- Check if the JSON is valid before querying IF ISJSON(@person) &gt; 0 BEGIN -- Extract values and use them in a SELECT statement -- This uses the default &#39;lax&#39; mode. A non-existent path would return NULL. SELECT JSON_VALUE(@person, &#39;$.name&#39;) AS Name, JSON_VALUE(@person, &#39;$.location.city&#39;) AS City, JSON_QUERY(@person, &#39;$.skills&#39;) AS Skills, JSON_VALUE(@person, &#39;$.info.age&#39;) AS Age; -- This path doesn&#39;t exist, will return NULL -- Using &#39;strict&#39; mode will cause an error if the path is not found. -- SELECT JSON_VALUE(@person, &#39;strict $.info.age&#39;); -- This would raise an error. -- Modify the city from &quot;Belgrade&quot; to &quot;London&quot; SET @person = JSON_MODIFY(@person, &#39;$.location.city&#39;, &#39;London&#39;); -- Display the updated JSON SELECT @person AS UpdatedPersonJSON; END The ISJSON function returns 1 for valid JSON, 0 for invalid, and NULL for a NULL input, and the conditions ISJSON(col) &gt; 0 and ISJSON(col) = 1 are functionally identical for validation and result in the same execution plan. 14.2. OPENJSON The OPENJSON rowset function transforms JSON text into a structured rowset to enable standard T-SQL querying, requiring database compatibility level 130 or higher. By default, the function returns first-level key/value pairs from a JSON object or all elements with their indexes from a JSON array. It operates in two primary modes: Default Schema (without a WITH clause) returns a key-value table with key, value, and type columns, which is useful for inspecting a document&#8217;s structure. DECLARE @json NVARCHAR(MAX) = &#39;{ &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 45, &quot;isStudent&quot;: false, &quot;skills&quot;: [ &quot;SQL&quot;, &quot;C#&quot; ] }&#39;; -- Use the default schema to return a key-value table SELECT * FROM OPENJSON(@json); Result Set key value type --- name John Doe 1 age 45 2 isStudent false 0 skills [&quot;SQL&quot;,&quot;C#&quot;] 4 Explicit Schema (with a WITH clause) shreds a JSON array into a relational format by mapping user-defined columns, data types, and JSON paths in an explicit schema definition. DECLARE @json NVARCHAR(MAX) = N&#39;[ { &quot;OrderNumber&quot;: &quot;SO43659&quot;, &quot;OrderDate&quot;: &quot;2024-05-31&quot;, &quot;Customer&quot;: &quot;AW29825&quot;, &quot;Quantity&quot;: 1 }, { &quot;OrderNumber&quot;: &quot;SO43661&quot;, &quot;OrderDate&quot;: &quot;2024-06-01&quot;, &quot;Customer&quot;: &quot;AW73565&quot;, &quot;Quantity&quot;: 3 } ]&#39;; -- Use an explicit schema to define the output table structure SELECT * FROM OPENJSON(@json) WITH ( Number VARCHAR(200) &#39;$.OrderNumber&#39;, [Date] DATETIME &#39;$.OrderDate&#39;, CustomerAcct VARCHAR(200) &#39;$.Customer&#39;, Qty INT &#39;$.Quantity&#39; ); Result Set Number Date CustomerAcct Qty --- SO43659 2024-05-31 00:00:00.000 AW29825 1 SO43661 2024-06-01 00:00:00.000 AW73565 3 JSON documents might have sub-elements and hierarchical data that can&#8217;t be directly mapped into the standard relational columns. To flatten hierarchical JSON, a primary OPENJSON call extracts a nested array as a JSON text fragment using the AS JSON option, which is then unnested by a second OPENJSON call via an APPLY operator. DECLARE @json NVARCHAR(MAX) = N&#39;[ {&quot;id&quot;: 2, &quot;info&quot;: {&quot;name&quot;: &quot;John&quot;, &quot;surname&quot;: &quot;Smith&quot;}, &quot;age&quot;: 25}, {&quot;id&quot;: 5, &quot;info&quot;: {&quot;name&quot;: &quot;Jane&quot;, &quot;surname&quot;: &quot;Smith&quot;, &quot;skills&quot;: [&quot;SQL&quot;, &quot;C#&quot;, &quot;Azure&quot;]}, &quot;dob&quot;: &quot;2005-11-04T12:00:00&quot;} ]&#39;; SELECT id, firstName, lastName, age, dateOfBirth, skill FROM OPENJSON(@json) WITH ( id INT &#39;strict $.id&#39;, firstName NVARCHAR(50) &#39;$.info.name&#39;, lastName NVARCHAR(50) &#39;$.info.surname&#39;, age INT, dateOfBirth DATETIME2 &#39;$.dob&#39;, skills NVARCHAR(MAX) &#39;$.info.skills&#39; AS JSON ) OUTER APPLY OPENJSON(skills) WITH (skill NVARCHAR(8) &#39;$&#39;); Result Set id firstName lastName age dateOfBirth skill --- 2 John Smith 25 NULL NULL 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 SQL 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 C# 5 Jane Smith NULL 2005-11-04 12:00:00.0000000 Azure 14.3. FOR JSON The FOR JSON clause in a SELECT statement formats query results into JSON text, delegating the formatting task from the client application to the database. It operates in two primary modes: FOR JSON AUTO automatically creates a nested JSON structure based on the tables used in the SELECT statement and their join relationships. FOR JSON PATH provides explicit control over the output format, allowing for the creation of custom nested objects and arrays using dot notation (i.e., &#39;Order.Details.ProductID&#39;) in column aliases. Further customization is available through options like ROOT to add a top-level element, INCLUDE_NULL_VALUES to retain properties with null values, and WITHOUT_ARRAY_WRAPPER to remove the default surrounding array brackets, which is useful for generating a single JSON object from a single-row result. Example SELECT TOP 2 SalesOrderID AS &#39;Order.ID&#39;, OrderDate AS &#39;Order.Date&#39;, AccountNumber AS &#39;Customer.Account&#39; FROM Sales.SalesOrderHeader FOR JSON PATH, ROOT(&#39;Orders&#39;); Result Set { &quot;Orders&quot;: [ { &quot;Order&quot;: { &quot;ID&quot;: 43659, &quot;Date&quot;: &quot;2011-05-31T00:00:00&quot;, &quot;Customer&quot;: { &quot;Account&quot;: &quot;10-4020-000676&quot; } } }, { &quot;Order&quot;: { &quot;ID&quot;: 43660, &quot;Date&quot;: &quot;2011-05-31T00:00:00&quot;, &quot;Customer&quot;: { &quot;Account&quot;: &quot;10-4020-000117&quot; } } } ] } 15. Vectors and embeddings The SQL Database Engine supports storing and querying structured and unstructured data, including performing vector search, which is beneficial for unified data search without external services. Vectors are ordered arrays of numbers (typically floats) representing data (e.g., pixel values, text ASCII values). Vectorization is the process of converting data into vectors, which are efficiently stored using the SQL Server VECTOR data type. Vector features are available in SQL Server 2025 (17.x) Preview, Azure SQL Database, and Azure SQL Managed Instance (configured with the Always-up-to-date update policy). 15.1. Embeddings Embeddings are a specialized type of vector that capture important features of data, often generated by deep learning models, with the ability of representing semantic similarity between various data entities, such as words or images. Azure OpenAI provides models for creating text embeddings, which can be stored in SQL Server alongside their data to enable vector search for similar data points. Storing generated embeddings in a SQL Server database allows for co-location with the represented data and facilitates vector search queries to find similar data points. 15.2. Vector search Vector search refers to the process of finding vectors in a dataset that are similar to a specific query vector. Similarity is measured using distance metrics like cosine distance; closer vectors indicate higher similarity. SQL Server provides built-in support for vectors via the VECTOR data type, storing data in an optimized binary format yet is exposed as JSON arrays for convenience. Vectors, typically managed as arrays of floats, can be created by casting JSON arrays to the VECTOR data type. For example: SELECT CAST(&#39;[1.0, -0.2, 30]&#39; AS VECTOR(3)) AS v1, CAST(JSON_ARRAY(1.0, -0.2, 30) AS VECTOR(3)) AS v2; DECLARE @v1 VECTOR(3) = &#39;[1.0, -0.2, 30]&#39;; DECLARE @v2 VECTOR(3) = JSON_ARRAY(1.0, -0.2, 30); SELECT @v1 as v1, @v2 as v2; DECLARE @v VECTOR(3) = &#39;[1.0, -0.2, 30]&#39;; SELECT CAST(@v AS NVARCHAR(MAX)) AS s, CAST(@v AS JSON) AS j 15.2.1. Exact nearest neighbor (k-NN) search and vector distance Exact search, also known as k-nearest neighbor (k-NN) search, involves calculating the distance between a given vector and all other vectors in a dataset, sorting the results, and selecting the closest neighbors based on a specified distance metric. k-nearest neighbor (k-NN) search guarantees precise nearest neighbor retrieval by performing an exhaustive distance calculation across all indexed vectors, making it computationally intensive but suitable for smaller datasets or when accuracy is paramount. Vector distance functions, such as Euclidean distance, cosine similarity, and dot product, measure vector closeness and are essential for accurate k-NN searches. In the SQL Database Engine, k-NN searches utilize the VECTOR_DISTANCE function for efficient distance calculation and nearest neighbor retrieval. The terms &quot;exact search,&quot; &quot;k-nearest neighbor (k-NN) search,&quot; and &quot;exact nearest neighbor (ENN) vector search&quot; are used interchangeably to refer to this precise, exhaustive search method. The following example shows how to do k-NN to return the top 10 most similar vectors stored in the content_vector table to the given query vector @qv. DECLARE @qv VECTOR(1536) = AI_GENERATE_EMBEDDINGS(N&#39;Pink Floyd music style&#39; USE MODEL Ada2Embeddings); SELECT TOP (10) id, VECTOR_DISTANCE(&#39;cosine&#39;, @qv, [content_vector]) AS distance, title FROM [dbo].[wikipedia_articles_embeddings] ORDER BY distance Exact search is recommended for datasets with fewer than 50,000 vectors. Larger tables can use exact search if search predicates effectively reduce the number of vectors for neighbor search to 50,000 or fewer. 15.2.2. Approximate nearest neighbors (ANN) and vector index Approximate vector index and vector search are in preview and currently only available in SQL Server 2025 (17.x) Preview. Approximate Nearest Neighbors (ANN) offers a high-performance alternative to the slow and resource-intensive exact k-nearest neighbors (k-NN) search. While k-NN requires comparing a query vector against every vector in a database, ANN trades a small degree of accuracy (recall) for a massive gain in search speed, making it a practical solution for large-scale vector search. Recall is a metric that measures the proportion of relevant items successfully retrieved out of all truly relevant items. In vector search, recall specifically quantifies how many of the exact nearest neighbors found by an exhaustive search are successfully identified by an Approximate Nearest Neighbors (ANN) algorithm. It serves as a crucial measure of the approximation&#8217;s quality, with a perfect recall of 1 indicating that the ANN algorithm found all the exact nearest neighbors. For AI applications, the inherent approximation of vector embeddings makes ANN a highly advantageous trade-off over exact k-NN, offering significant performance and resource benefits well-suited for operational databases. A vector index is a data structure optimized for efficiently finding approximate nearest neighbors in high-dimensional vector spaces, thereby returning approximate results for ANN searches, unlike traditional relational database indexes (e.g., B-trees, LSM-trees) designed for exact lookups and range queries on scalar values. In the SQL Database engine, vector indexes are based on the DiskANN algorithm. DiskANN is a graph-based system that indexes and searches large vector datasets by creating a navigable graph to quickly find the closest match to a given vector. DiskANN efficiently uses SSDs and minimal memory to handle significantly more data than in-memory indices, while maintaining high queries per second (QPS) and low latency, ensuring a balance between memory, CPU and I/O usage and search performance. An approximate nearest neighbors algorithm search can be done first creating a vector index using the CREATE VECTOR INDEX T-SQL command and then using VECTOR_SEARCH T-SQL function to run the approximate search. DECLARE @qv VECTOR(1536) = AI_GENERATE_EMBEDDINGS(N&#39;Pink Floyd music style&#39; USE MODEL Ada2Embeddings); SELECT t.id, s.distance, t.title FROM VECTOR_SEARCH( TABLE = [dbo].[wikipedia_articles_embeddings] AS t, COLUMN = [content_vector], SIMILAR_TO = @qv, METRIC = &#39;cosine&#39;, TOP_N = 10 ) AS s ORDER BY s.distance Appendix A: Data Types A data type is an attribute that specifies the type of data that the object can hold: integer data, character data, monetary data, date and time data, binary strings, and so on. [3] Data types can be converted either implicitly or explicitly. Implicit conversions are not visible to the user. SQL Server automatically converts the data from one data type to another. Explicit conversions use the CAST or CONVERT functions. Use CAST instead of CONVERT to write Transact-SQL program code to comply with ISO. Use CONVERT instead of CAST to take advantage of the style functionality in CONVERT. CAST ( expression AS data_type [ ( length ) ] ) CONVERT ( data_type [ ( length ) ] , expression [ , style ] ) SELECT CAST(123 AS VARCHAR(10)), CONVERT(VARCHAR(10), 123) -- same result: integer to string SELECT CONVERT(VARCHAR(10), GETDATE(), 101) -- date to string in MM/dd/yyyy format A.1. Character SQL Server supports two kinds of character data type pairs: regular kind (CHAR and VARCHAR) and N-kind (NCHAR and NVARCHAR). Each of the type pairs can support different character encoding systems, and can result in different encoded byte lengths and on-disk storage sizes, based on the effective collation of the data and the character code range in use. The regular types, with UTF-8 collation, use the UTF-8 encoding system and support full range of Unicode characters. The N-kind types, with supplementary character collation (SC), use the UTF-16 encoding system and support the full range of Unicode characters. Otherwise, they support only the subset of characters from the UCS-2 character encoding system. The VARCHAR(size) defines the maximum size in bytes, while the NVARCHAR(size) defines the size in byte pairs. The literals of regular type character are enclosed in single quotes, while N-kind type require a preceding &#39;N&#39;. Any data type without the VAR element (CHAR, NCHAR) in its name has a fixed length, that is, SQL Server preserves the maximum space in the row based on the column’s defined size and not on the actual user data that is stored. A data type with the VAR element (VARCHAR, NVARCHAR) in its name has a variable length, that is, SQL Server uses as much storage space in the row as required to store the actual character string, plus two extra bytes for offset data. Updates of variable-length data types can be less efficient than those of fixed-length types due to potential row expansion and data movement. Variable-length data types can use the MAX specifier, allowing for up to 2GB per value. Any value with a size up to a certain threshold (8,000 bytes by default) can be stored inline in the row. Any value with a size above the threshold is stored external to the row as a large object (LOB). The collation is a property of character data that encapsulates several aspects: language support, sort order, case sensitivity, accent sensitivity, and more. -- get the set of supported collations and their descriptions SELECT name, description FROM sys.fn_helpcollations(); In an on-premises SQL Server implementation and Azure SQL Managed Instance, collation can be defined at four different levels: instance, database, column, and expression. The lowest level is the effective one that is used. SELECT DATABASEPROPERTYEX(DB_NAME(), &#39;Collation&#39;); -- SQL_Latin1_General_CP1_CI_AS In Azure SQL Database, collation can be defined at the database, column, and expression levels. T-SQL provides the plus-sign (+) operator and the CONCAT and CONCAT_WS functions to concatenate strings. SELECT empid, firstname + N&#39; &#39; + lastname AS fullname FROM HR.Employees; Standard SQL dictates that a concatenation with a NULL should yield a NULL. SELECT custid, country, region, city, country + N&#39;,&#39; + region + N&#39;,&#39; + city AS location FROM Sales.Customers; custid country region city location 9 France NULL Marseille NULL 10 Canada BC Tsawassen Canada,BC,Tsawassen To treat a NULL as an empty string—or more accurately, to substitute a NULL with an empty string—use the COALESCE function that accepts a list of input values and returns the first that is not NULL. SELECT custid, country, region, city, country + COALESCE(N&#39;,&#39; + region, N&#39;&#39;) + N&#39;,&#39; + city AS location FROM Sales.Customers; custid country region city location 8 Spain NULL Madrid Spain,Madrid 9 France NULL Marseille France,Marseille T-SQL supports a function called CONCAT, which accepts a list of inputs for concatenation and automatically substitutes NULLs with empty strings. SELECT custid, country, region, city, CONCAT(country, N&#39;,&#39; + region, N&#39;,&#39; + city) AS location FROM Sales.Customers; T-SQL also supports a function called CONCAT_WS, which accepts the separator as the first parameter, specifying it only once, and then the list of inputs for concatenation. SELECT custid, country, region, city, CONCAT_WS(N&#39;,&#39;, country, region, city) AS location FROM Sales.Customers; The PATINDEX function returns the position of the first occurrence of a pattern, similar to the patterns used by the LIKE predicate in T-SQL, within a string. PATINDEX(pattern, string) SELECT PATINDEX(&#39;%[0-9]%&#39;, &#39;abcd123efgh&#39;); -- 5 T-SQL provides a predicate called LIKE to check whether a character string matches a specified pattern. The % (percent sign) wildcard represents a string of any size, including an empty string. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;D%&#39;; empid lastname 1 Davis 9 Doyle The _ (underscore) wildcard represents a single character. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;_e%&#39;; empid lastname 3 Lew 4 Peled The square bracket wildcard [&lt;list of characters&gt;], with a list of characters (such as [ABC]), represents a single character that must be one of the characters specified in the list. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[ABC]%&#39;; empid lastname 8 Cameron The square bracket wildcard [&lt;character&gt;-&lt;character&gt;], with a character range (such as [A–E]), represents a single character that must be within the specified range. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[A-E]%&#39;; empid lastname 8 Cameron 1 Davis 9 Doyle The square bracket wildcard [^&lt;character list or range&gt;], with a caret sign (^) followed by a character list or range (such as [^A–E]), represents a single character that is not in the specified character list or range. SELECT empid, lastname FROM HR.Employees WHERE lastname LIKE N&#39;[^A-E]%&#39;; empid lastname 2 Funk 7 King To search for a character that is also a wildcard, use an escape character before it in the LIKE pattern, and specify the escape character using the ESCAPE keyword. A character put in front of a wildcard character to indicate that the wildcard is interpreted as a regular character and not as a wildcard. escape_character is a character expression that has no default and must evaluate to only one character. -- specify character (!, @, $, or #) as the escape character col1 LIKE &#39;%!_%&#39; ESCAPE &#39;!&#39; col1 LIKE &#39;%@_%&#39; ESCAPE &#39;@&#39; col1 LIKE &#39;%$%_&#39; ESCAPE &#39;$&#39; col1 LIKE &#39;%#%_&#39; ESCAPE &#39;#&#39; A.2. Date and Time T-SQL supports six date and time data types: The legacy types DATETIME and SMALLDATETIME include date and time components that are inseparable. DATETIME &#39;YYYYMMDD hh:mm:ss.nnn&#39; &#39;20220212 12:30:15.123&#39; DATETIME &#39;YYYYMMDD&#39; &#39;20220212&#39; SMALLDATETIME &#39;YYYYMMDD hh:mm&#39; &#39;20220212 12:30&#39; SMALLDATETIME &#39;YYYYMMDD&#39; &#39;20220212&#39; The DATE and TIME data types provide a separation between the date and time components. DATE &#39;YYYYMMDD&#39; &#39;20220212&#39; TIME &#39;hh:mm:ss.nnnnnnn&#39; &#39;12:30:15.1234567&#39; The DATETIME2 data type has a bigger date range and better precision than the legacy types. DATETIME2 &#39;YYYYMMDD hh:mm:ss.nnnnnnn&#39; &#39;20220212 12:30:15.1234567&#39; The DATETIMEOFFSET data type is similar to DATETIME2, but it also includes the offset from UTC. DATETIMEOFFSET &#39;YYYYMMDD hh:mm:ss.nnnnnnn [+|-]hh:mm&#39; &#39;20220212 12:30:15.1234567 +02:00&#39; SELECT GETDATE() UNION ALL -- DATETIME current date and time SELECT CURRENT_TIMESTAMP UNION ALL -- DATETIME same as GETDATE but SQL-compliant SELECT GETUTCDATE() UNION ALL -- DATETIME current date and time in UTC SELECT SYSDATETIME() UNION ALL -- DATETIME2 current date and time SELECT SYSUTCDATETIME() UNION ALL -- DATETIME2 current date and time in UTC SELECT SYSDATETIMEOFFSET() -- DATETIME2 current date and time in UTC with Time Zone 2025-01-18 15:07:52.9766667 +00:00 2025-01-18 15:07:52.9766667 +00:00 2025-01-18 07:07:52.9766667 +00:00 2025-01-18 15:07:52.9755919 +00:00 2025-01-18 07:07:52.9755919 +00:00 2025-01-18 15:07:52.9755919 +08:00 T-SQL doesn’t provide the means to express a date and time literal; instead, a convertible literal of a different type can be specified—explicitly or implicitly—to a date and time data type. It is a best practice to use character strings with language-neutral formats to express date and time values. SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderdate = &#39;20220212&#39;; -- equivalent to: WHERE orderdate = CAST(&#39;20220212&#39; AS DATE); Each login has a default language, which affects how date and time literals are interpreted. SET LANGUAGE British; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-12-02 SET LANGUAGE us_english; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-02-12 The DATEFORMAT setting, expressed as a combination of the characters d, m, and y, determines how SQL Server interprets date and time literals from character strings (e.g., &#39;mdy&#39; for US English, &#39;dmy&#39; for British English). SET DATEFORMAT dmy; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-12-02 SET DATEFORMAT mdy; SELECT CAST(&#39;02/12/2022&#39; AS DATE); -- 2022-02-12 The LANGUAGE/DATEFORMAT setting affects only the way the values inputed are interpreted, and have no impact on the format used in the output for presentation purposes. SQL Server may not efficiently utilize indexes when functions like YEAR are applied to the column within the WHERE clause. SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE YEAR(orderdate) = 2021; -- better SELECT orderid, custid, empid, orderdate FROM Sales.Orders WHERE orderdate &gt;= &#39;20210101&#39; AND orderdate &lt; &#39;20220101&#39;; References [1] Itzik Ben-Gan T-SQL Fundamentals. 3rd edition, Microsoft Press; August 3, 2016 [2] Itzik Ben-Gan, Adam Machanic, Dejan Sarka, Kevin Farlee T-SQL Querying. 1st Edition Microsoft Press; March 6, 2015 [3] https://learn.microsoft.com/en-us/sql/t-sql/language-reference","headline":"T-SQL Learning Notes","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2025/01/07/t-sql-learning-notes/"},"url":"https://blog.codefarm.me/2025/01/07/t-sql-learning-notes/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">T-SQL Learning Notes</h1><p class="c-post-meta">21 Jan 2025</p>
  </header>

  <div class="c-post-content">
    <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>SQL (pronounced /ˌɛsˌkjuˈɛl/ S-Q-L; or alternatively as /ˈsiːkwəl/ "sequel") stands for <strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage, which is both an ANSI and ISO standard language that was designed to query and manage data in relational database management systems (RDBMSs).</p>
</div>
<div class="paragraph">
<p>An RDBMS is a database management system based on the relational model (a semantic model for representing data), which in turn is based on two mathematical branches: <em>set theory</em> and <em>predicate logic</em>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
"NULL marker" or just "NULL" (/nʌl/) is not a NULL value but rather a marker for a missing value.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>SQL comprises several sub-languages for managing different aspects of a database:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Data Definition Language (DDL) defines and manages the structure of database objects with statements such as <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code>.</p>
</li>
<li>
<p>Data Manipulation Language (DML) retrieves and modifies data using statements like <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>MERGE</code>.</p>
</li>
<li>
<p>Data Control Language (DCL) manages data access and user permissions through statements such as <code>GRANT</code> and <code>REVOKE</code>.</p>
</li>
<li>
<p>Transaction Control Language (TCL) controls the lifecycle of transactions with statements like <code>COMMIT</code> and <code>ROLLBACK</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Microsoft provides T-SQL as a dialect of, or an extension to, SQL in SQL Server—its on-premises RDBMS flavor, and in Azure SQL and Azure Synapse Analytics—its cloud-based RDBMS flavors.</p>
</div>
<div class="paragraph">
<p>T-SQL is based on standard SQL, but it also provides some nonstandard or proprietary extensions. Moreover, T-SQL does not implement all of standard SQL.</p>
</div>
<div class="paragraph">
<p>To run T-SQL code against a database, a client application needs to connect to a SQL Server instance and be in the context of, or use, the relevant database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In both SQL Server and Azure SQL Managed Instance, the application can still access objects from other databases by adding the database name as a prefix.</p>
</li>
<li>
<p>Azure SQL Database does not support cross-database/three-part name queries.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SQL Server supports a feature called <em>contained databases</em> that breaks the connection between a database user and an instance-level login.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The user (Windows or SQL authenticated) is fully contained within the specific database and is not tied to a login at the instance level.</p>
</li>
<li>
<p>When connecting to SQL Server, the user needs to specify the database to connect, and the user cannot subsequently switch to other user databases.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unless specified otherwise, all T-SQL references to the name of a database object can be a four-part name in the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">-- Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views

server_name.[database_name].[schema_name].object_name

| database_name.[schema_name].object_name

| schema_name.object_name

| object_name</code></pre>
</div>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#data-integrity">1. Data Integrity</a>
<ul class="sectlevel2">
<li><a href="#primary-key">1.1. PRIMARY KEY</a></li>
<li><a href="#unique">1.2. UNIQUE</a></li>
<li><a href="#foreign-key">1.3. FOREIGN KEY</a></li>
<li><a href="#check">1.4. CHECK</a></li>
<li><a href="#default">1.5. DEFAULT</a></li>
</ul>
</li>
<li><a href="#logical-query-processing">2. Logical Query Processing</a>
<ul class="sectlevel2">
<li><a href="#from">2.1. FROM</a></li>
<li><a href="#where">2.2. WHERE</a></li>
<li><a href="#group-by">2.3. GROUP BY</a></li>
<li><a href="#having">2.4. HAVING</a></li>
<li><a href="#select">2.5. SELECT</a></li>
<li><a href="#order-by">2.6. ORDER BY</a></li>
<li><a href="#top">2.7. TOP</a></li>
<li><a href="#offset-fetch">2.8. OFFSET-FETCH</a></li>
<li><a href="#case">2.9. CASE</a></li>
</ul>
</li>
<li><a href="#predicates-and-operators">3. Predicates and Operators</a>
<ul class="sectlevel2">
<li><a href="#predicates-in-between-like-exists-and-is-null">3.1. Predicates: <code>IN</code>, <code>BETWEEN</code>, <code>LIKE</code>, <code>EXISTS</code>, and <code>IS NULL</code></a></li>
<li><a href="#three-valued-logic-3vl">3.2. Three-Valued Logic (3VL)</a></li>
<li><a href="#equality-and-distinctness">3.3. Equality and Distinctness</a></li>
<li><a href="#comparison-operators-and-all-some-any">3.4. Comparison Operators: <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code><=</code>, <code>&lt;&gt;</code>, and <code>ALL</code>, <code>SOME</code>, <code>ANY</code></a></li>
<li><a href="#logical-operators-or-and-and-not">3.5. Logical Operators: <code>OR</code>, <code>AND</code>, and <code>NOT</code></a></li>
<li><a href="#arithmetic-operators-and">3.6. Arithmetic Operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code></a></li>
</ul>
</li>
<li><a href="#query-tuning">4. Query Tuning</a>
<ul class="sectlevel2">
<li><a href="#sql-server-internals">4.1. SQL Server Internals</a>
<ul class="sectlevel3">
<li><a href="#indexes">4.1.1. Indexes</a></li>
<li><a href="#execution-plans">4.1.2. Execution Plans</a></li>
<li><a href="#cardinality-estimates">4.1.3. Cardinality Estimates</a></li>
<li><a href="#parallel-query-execution">4.1.4. Parallel Query Execution</a></li>
</ul>
</li>
<li><a href="#data-retrieval-strategies">4.2. Data Retrieval Strategies</a>
<ul class="sectlevel3">
<li><a href="#unordered-clustered-index-scan-or-table-scan">4.2.1. Unordered Clustered Index Scan or Table Scan</a></li>
<li><a href="#unordered-covering-nonclustered-index-scan">4.2.2. Unordered Covering Nonclustered Index Scan</a></li>
<li><a href="#ordered-clustered-index-scan">4.2.3. Ordered Clustered Index Scan</a></li>
<li><a href="#ordered-covering-nonclustered-index-scan">4.2.4. Ordered Covering Nonclustered Index Scan</a></li>
<li><a href="#nonclustered-index-seek-range-scan-lookups">4.2.5. Nonclustered Index Seek + Range Scan + Lookups</a></li>
<li><a href="#unordered-nonclustered-index-scan-lookups">4.2.6. Unordered Nonclustered Index Scan + Lookups</a></li>
<li><a href="#clustered-index-seek-range-scan">4.2.7. Clustered Index Seek + Range Scan</a></li>
<li><a href="#covering-nonclustered-index-seek-range-scan">4.2.8. Covering Nonclustered Index Seek + Range Scan</a></li>
</ul>
</li>
<li><a href="#tied-rows-and-sorting">4.3. Tied Rows and Sorting</a></li>
</ul>
</li>
<li><a href="#joins">5. Joins</a>
<ul class="sectlevel2">
<li><a href="#cross">5.1. CROSS</a></li>
<li><a href="#inner">5.2. INNER</a></li>
<li><a href="#outer">5.3. OUTER</a></li>
<li><a href="#apply">5.4. APPLY</a></li>
</ul>
</li>
<li><a href="#subqueries">6. Subqueries</a>
<ul class="sectlevel2">
<li><a href="#subqueries-with-in-or-not-in">6.1. Subqueries with IN or NOT IN</a></li>
<li><a href="#subqueries-with-comparison-operators">6.2. Subqueries with comparison operators</a></li>
<li><a href="#subqueries-with-exists-or-not-exists">6.3. Subqueries with EXISTS or NOT EXISTS</a></li>
</ul>
</li>
<li><a href="#table-expressions">7. Table Expressions</a>
<ul class="sectlevel2">
<li><a href="#derived-tables">7.1. Derived Tables</a></li>
<li><a href="#ctes">7.2. CTEs</a></li>
<li><a href="#views-and-tvfs">7.3. Views and TVFs</a></li>
</ul>
</li>
<li><a href="#union-union-all-intersect-and-except">8. UNION, UNION ALL, INTERSECT, and EXCEPT</a></li>
<li><a href="#data-analysis">9. Data Analysis</a>
<ul class="sectlevel2">
<li><a href="#window-functions">9.1. Window Functions</a>
<ul class="sectlevel3">
<li><a href="#ranking">9.1.1. Ranking</a></li>
<li><a href="#offset">9.1.2. Offset</a></li>
<li><a href="#aggregate">9.1.3. Aggregate</a></li>
<li><a href="#window">9.1.4. WINDOW</a></li>
</ul>
</li>
<li><a href="#pivoting">9.2. Pivoting</a>
<ul class="sectlevel3">
<li><a href="#grouped-query">9.2.1. Grouped Query</a></li>
<li><a href="#pivot-operator">9.2.2. PIVOT Operator</a></li>
</ul>
</li>
<li><a href="#unpivoting">9.3. Unpivoting</a>
<ul class="sectlevel3">
<li><a href="#apply-operator">9.3.1. APPLY Operator</a></li>
<li><a href="#unpivot-operator">9.3.2. UNPIVOT Operator</a></li>
</ul>
</li>
<li><a href="#grouping-sets">9.4. Grouping Sets</a></li>
<li><a href="#time-series">9.5. Time Series</a></li>
</ul>
</li>
<li><a href="#insert-delete-truncate-update-and-merge">10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE</a>
<ul class="sectlevel2">
<li><a href="#insert">10.1. INSERT</a>
<ul class="sectlevel3">
<li><a href="#insert-values">10.1.1. INSERT VALUES</a></li>
<li><a href="#insert-select">10.1.2. INSERT SELECT</a></li>
<li><a href="#insert-exec">10.1.3. INSERT EXEC</a></li>
<li><a href="#select-into">10.1.4. SELECT INTO</a></li>
<li><a href="#bulk-insert">10.1.5. BULK INSERT</a></li>
</ul>
</li>
<li><a href="#delete-and-truncate">10.2. DELETE and TRUNCATE</a></li>
<li><a href="#update">10.3. UPDATE</a></li>
<li><a href="#merge">10.4. MERGE</a></li>
</ul>
</li>
<li><a href="#system-versioned-temporal-tables">11. System-Versioned Temporal Tables</a></li>
<li><a href="#transactions-and-concurrency">12. Transactions and Concurrency</a>
<ul class="sectlevel2">
<li><a href="#locks-and-blocking">12.1. Locks and Blocking</a>
<ul class="sectlevel3">
<li><a href="#locks">12.1.1. Locks</a>
<ul class="sectlevel4">
<li><a href="#lock-modes-and-compatibility">12.1.1.1. Lock Modes and Compatibility</a></li>
<li><a href="#lockable-resource-types">12.1.1.2. Lockable Resource Types</a></li>
</ul>
</li>
<li><a href="#blocking">12.1.2. Blocking</a></li>
</ul>
</li>
<li><a href="#isolation-levels">12.2. Isolation Levels</a>
<ul class="sectlevel3">
<li><a href="#read-uncommitted">12.2.1. READ UNCOMMITTED</a></li>
<li><a href="#read-committed">12.2.2. READ COMMITTED</a></li>
<li><a href="#repeatable-read">12.2.3. REPEATABLE READ</a></li>
<li><a href="#serializable">12.2.4. SERIALIZABLE</a></li>
<li><a href="#multi-version-concurrency-control">12.2.5. Multi-Version Concurrency Control</a>
<ul class="sectlevel4">
<li><a href="#snapshot">12.2.5.1. SNAPSHOT</a></li>
<li><a href="#conflict-detection">12.2.5.2. Conflict Detection</a></li>
<li><a href="#read-committed-snapshot">12.2.5.3. READ COMMITTED SNAPSHOT</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#deadlocks">12.3. Deadlocks</a></li>
</ul>
</li>
<li><a href="#programmable-objects">13. Programmable Objects</a>
<ul class="sectlevel2">
<li><a href="#variables">13.1. Variables</a></li>
<li><a href="#batchs">13.2. Batchs</a></li>
<li><a href="#flow-elements-if-and-while">13.3. Flow Elements: IF and WHILE</a></li>
<li><a href="#cursors">13.4. Cursors</a></li>
<li><a href="#temporary-tables">13.5. Temporary Tables</a>
<ul class="sectlevel3">
<li><a href="#local-temporary-tables">13.5.1. Local Temporary Tables</a></li>
<li><a href="#global-temporary-tables">13.5.2. Global Temporary Tables</a></li>
<li><a href="#table-variables">13.5.3. Table Variables</a></li>
</ul>
</li>
<li><a href="#dynamic-sql">13.6. Dynamic SQL</a></li>
<li><a href="#routines">13.7. Routines</a>
<ul class="sectlevel3">
<li><a href="#user-defined-functions">13.7.1. User-defined Functions</a></li>
<li><a href="#stored-procedures">13.7.2. Stored Procedures</a></li>
<li><a href="#triggers">13.7.3. Triggers</a>
<ul class="sectlevel4">
<li><a href="#dml-triggers">13.7.3.1. DML Triggers</a></li>
<li><a href="#ddl-triggers">13.7.3.2. DDL Triggers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#error-handling-try-catch">13.8. Error Handling: TRY-CATCH</a></li>
</ul>
</li>
<li><a href="#json">14. JSON</a>
<ul class="sectlevel2">
<li><a href="#isjson-json_value-json_query-and-json_modify">14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY</a></li>
<li><a href="#openjson">14.2. OPENJSON</a></li>
<li><a href="#for-json">14.3. FOR JSON</a></li>
</ul>
</li>
<li><a href="#vectors-and-embeddings">15. Vectors and embeddings</a>
<ul class="sectlevel2">
<li><a href="#embeddings">15.1. Embeddings</a></li>
<li><a href="#vector-search">15.2. Vector search</a>
<ul class="sectlevel3">
<li><a href="#exact-nearest-neighbor-k-nn-search-and-vector-distance">15.2.1. Exact nearest neighbor (k-NN) search and vector distance</a></li>
<li><a href="#approximate-nearest-neighbors-ann-and-vector-index">15.2.2. Approximate nearest neighbors (ANN) and vector index</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#data-types">Appendix A: Data Types</a>
<ul class="sectlevel2">
<li><a href="#character">A.1. Character</a></li>
<li><a href="#date-and-time">A.2. Date and Time</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="data-integrity">1. Data Integrity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SQL provides several mechanisms for enforcing data integrity:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PRIMARY KEY</code> constraint</p>
</li>
<li>
<p><code>FOREIGN KEY</code> constraint with actions like <code>CASCADE</code>, <code>SET NULL</code>, <code>RESTRICT</code></p>
</li>
<li>
<p><code>NOT NULL</code> constraint</p>
</li>
<li>
<p><code>CHECK</code> constraint</p>
</li>
<li>
<p><code>UNIQUE</code> constraint</p>
</li>
<li>
<p><code>DEFAULT</code> constraint</p>
</li>
<li>
<p>Triggers</p>
</li>
<li>
<p>Stored procedures</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">TSQLV6</span><span class="p">;</span>

<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span> <span class="p">(</span>
    <span class="n">empid</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">firstname</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">lastname</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">hiredate</span> <span class="nb">DATE</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">mgrid</span> <span class="nb">INT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">ssn</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">salary</span> <span class="n">MONEY</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="primary-key">1.1. PRIMARY KEY</h3>
<div class="paragraph">
<p>A <em>primary key constraint</em> enforces the uniqueness of rows and also disallows NULLs in the constraint attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each unique combination of values in the constraint attributes can appear only once in the table—in other words, only in one row.</p>
</li>
<li>
<p>An attempt to define a primary key constraint on a column that allows NULLs will be rejected by the RDBMS.</p>
</li>
<li>
<p>Each table can have only one primary key.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
  <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">PK_Employees</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">empid</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To enforce the uniqueness of the logical primary key constraint, SQL Server will create a <em>unique index</em> behind the scenes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A unique index is a physical object used by SQL Server to enforce uniqueness.</p>
</li>
<li>
<p>Indexes (not necessarily unique ones) are also used to speed up queries by avoiding sorting and unnecessary full table scans (similar to indexes in books).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="unique">1.2. UNIQUE</h3>
<div class="paragraph">
<p>A <em>unique constraint</em> enforces the uniqueness of rows, allowing to implement the concept of <em>alternate keys</em> from the relational model in a  database.</p>
</div>
<div class="paragraph">
<p>Unlike with primary keys, multiple unique constraints can be defined within the same table.</p>
</div>
<div class="paragraph">
<p>Also, a unique constraint is not restricted to columns defined as NOT NULL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sq">ALTER TABLE dbo.Employees
  ADD CONSTRAINT UNQ_Employees_ssn
  UNIQUE(ssn);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the purpose of enforcing a unique constraint, SQL Server handles NULLs just like non-NULL values.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consequently, for example, a single-column unique constraint allows only one NULL in the constrained column.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, the SQL standard defines NULL-handling by a unique constraint differently, like so: “A unique constraint on T is satisfied if and only if there do not exist two rows R1 and R2 of T such that R1 and R2 have the same non-NULL values in the unique columns.”</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In other words, only the non-NULL values are compared to determine whether duplicates exist.</p>
</li>
<li>
<p>Consequently, a standard single-column unique constraint would allow multiple NULLs in the constrained column.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="foreign-key">1.3. FOREIGN KEY</h3>
<div class="paragraph">
<p>A <em>foreign key</em> enforces referential integrity.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is defined on one or more attributes in what’s called the <em>referencing table</em> and points to <em>candidate key</em> (primary key or unique constraint) attributes in what’s called the <em>referenced table</em>.</p>
</li>
<li>
<p>Note that the referencing and referenced tables can be one and the same.</p>
</li>
<li>
<p>The foreign key’s purpose is to restrict the values allowed in the foreign key columns to those that exist in the referenced columns.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span> <span class="p">(</span>
    <span class="n">orderid</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">empid</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">custid</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">orderts</span> <span class="n">DATETIME2</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">qty</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="n">PK_Orders</span>
      <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">orderid</span><span class="p">)</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- enforce an integrity rule that restricts the values supported by the empid column in the Orders table to the values that exist in the empid column in the Employees table.</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
  <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">FK_Orders_Employees</span>
  <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="n">empid</span><span class="p">)</span>
  <span class="k">REFERENCES</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">(</span><span class="n">empid</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- restrict the values supported by the mgrid column in the Employees table to the values that exist in the empid column of the same table.</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
  <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">FK_Employees_Employees</span>
  <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="n">mgrid</span><span class="p">)</span>
  <span class="k">REFERENCES</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">(</span><span class="n">empid</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that NULLs are allowed in the foreign key columns (mgrid in the last example) even if there are no NULLs in the referenced candidate key columns.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="check">1.4. CHECK</h3>
<div class="paragraph">
<p>A <em>check constraint</em> is used to define a predicate that a row must meet to be entered into the table or to be modified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
  <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">CHK_Employees_salary</span>
  <span class="k">CHECK</span><span class="p">(</span><span class="n">salary</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that a check constraint rejects an attempt to insert or update a row when the predicate evaluates to FALSE. The modification will be accepted when the predicate evaluates to either <em>TRUE</em> or <em>UNKNOWN</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="default">1.5. DEFAULT</h3>
<div class="paragraph">
<p>A <em>default constraint</em> is associated with a particular attribute.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It’s <em>an expression</em> that is used as the <em>default value</em> when an explicit value is not specified for the attribute when inserting a row.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
  <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">DFT_Orders_orderts</span>
  <span class="k">DEFAULT</span><span class="p">(</span><span class="n">SYSDATETIME</span><span class="p">())</span> <span class="k">FOR</span> <span class="n">orderts</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When done, run the following code for cleanup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">,</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logical-query-processing">2. Logical Query Processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <em>logical query processing</em> in standard SQL defines how a query should be processed and the final result achieved.</p>
</div>
<div class="listingblock">
<div class="title"><em>Logical query-processing step numbers</em></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">(5) SELECT (5-2) DISTINCT (7) TOP(&lt;top_specification&gt;) (5-1) &lt;select_list&gt;
(1) FROM (1-J) &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; ON &lt;on_predicate&gt;
| (1-A) &lt;left_table&gt; &lt;apply_type&gt; APPLY &lt;right_input_table&gt; AS &lt;alias&gt;
| (1-P) &lt;left_table&gt; PIVOT(&lt;pivot_specification&gt;) AS &lt;alias&gt;
| (1-U) &lt;left_table&gt; UNPIVOT(&lt;unpivot_specification&gt;) AS &lt;alias&gt;
(2) WHERE &lt;where_predicate&gt;
(3) GROUP BY &lt;group_by_specification&gt;
(4) HAVING &lt;having_predicate&gt;
(6) ORDER BY &lt;order_by_list&gt;
(7) OFFSET &lt;offset_specification&gt; ROWS FETCH NEXT &lt;fetch_specification&gt; ROWS ONLY;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The database engine is free to physically process a query differently by rearranging processing phases, as long as the final result would be the same as that dictated by logical query processing.</p>
</li>
<li>
<p>The database engine’s <em>query optimizer</em> can—and in fact, often does—apply many transformation rules and shortcuts in the physical processing of a query as part of query optimization.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">TSQLV6</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span> <span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">numorder</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span> <span class="p">(</span><span class="n">orderdate</span><span class="p">)</span>
<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderyear</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If an identifier is irregular—for example, if it has embedded spaces or special characters, starts with a digit, or is a reserved keyword—it must be delimited. There are a couple of ways to delimit identifiers in T-SQL. One is the standard SQL form using double quotes—for example, <code>"Order Details"</code>. Another is the T-SQL- specific form using square brackets—for example, <code>[Order Details]</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In most programming languages, the lines of code are processed in the order that they are written. In SQL, things are different. Even though the <code>SELECT</code> clause appears first in the query, it is logically processed almost last. The clauses are logically processed in the following order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span>
<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">numorders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderyear</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>FROM</code> &#8594; <code>WHERE</code> &#8594; <code>GROUP BY</code> &#8594; <code>HAVING</code> &#8594; <code>SELECT</code> &#8594; <code>Expressions</code> &#8594; <code>DISTINCT</code> &#8594; <code>ORDER BY</code> &#8594; <code>TOP/OFFSET-FETCH</code>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="from">2.1. FROM</h3>
<div class="paragraph">
<p>The <code>FROM</code> clause is the very first query clause that is logically processed, which is used to specify the names of the <em>tables</em> to query and <em>table operators</em> that operate on those tables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="where">2.2. WHERE</h3>
<div class="paragraph">
<p>In the <code>WHERE</code> clause, a predicate, or logical expression is specified to filter the rows returned by the <code>FROM</code> phase.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
T-SQL uses three-valued predicate logic, where logical expressions can evaluate to <code>TRUE</code>, <code>FALSE</code>, or <code>UNKNOWN</code>. With three-valued logic, saying “returns TRUE” is not the same as saying “does not return FALSE.” The <code>WHERE</code> phase returns rows for which the logical expression evaluates to <code>TRUE</code>, and it doesn’t return rows for which the logical expression evaluates to <code>FALSE</code> or <code>UNKNOWN</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="group-by">2.3. GROUP BY</h3>
<div class="paragraph">
<p>The <code>GROUP BY</code> phase is used to arrange the rows returned by the previous logical query processing phase in groups determined by the <em>elements</em>, or <em>expressions</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>If the query is a grouped query, all phases subsequent to the <code>GROUP BY</code> phase— including <code>HAVING</code>, <code>SELECT</code>, and <code>ORDER BY</code>—operate on groups as opposed to operating on individual rows.</p>
</li>
<li>
<p>Each group is ultimately represented by a single row in the final result of the query.</p>
</li>
<li>
<p>All expressions specified in clauses that are processed in phases subsequent to the <code>GROUP BY</code> phase are required to guarantee returning a scalar (single value) per group.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span> <span class="n">freight</span> <span class="c1">-- sum(freight) AS totalfreight</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 8120, Level 16, State 1, Line 1
Column 'Sales.Orders.freight' is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause.
Total execution time: 00:00:00.016</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Expressions based on elements that participate in the <code>GROUP BY</code> clause meet the requirement because, by definition, each such element represents a distinct value per group.</p>
</li>
<li>
<p>Elements that do not participate in the <code>GROUP BY</code> clause are allowed only as inputs to an aggregate function such as <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, or <code>MAX</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Note that all aggregate functions that are applied to an input expression ignore NULLs.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>COUNT(*)</code> function isn’t applied to any input expression; it just counts rows irrespective of what those rows contain.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For example, consider a group of five rows with the values <code>30, 10, NULL, 10, 10</code> in a column called <code>qty</code>.</p>
</li>
<li>
<p>The expression <code>COUNT(*)</code> returns <code>5</code> because there are five rows in the group, whereas <code>COUNT(qty)</code> returns <code>4</code> because there are four known (non-NULL) values.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>To handle only distinct (unique) occurrences of known values, specify the <code>DISTINCT</code> keyword before the input expression to the aggregate function, like <code>COUNT(DISTINCT qty)</code>, <code>AVG(DISTINCT qty)</code> and so on.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="having">2.4. HAVING</h3>
<div class="paragraph">
<p>Whereas the <code>WHERE</code> clause is a row filter, the <code>HAVING</code> clause is a group filter.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only groups for which the <code>HAVING</code> predicate evaluates to <code>TRUE</code> are returned by the <code>HAVING</code> phase to the next logical query processing phase.</p>
</li>
<li>
<p>Groups for which the predicate evaluates to <code>FALSE</code> or <code>UNKNOWN</code> are discarded.</p>
</li>
<li>
<p>The <code>HAVING</code> clause is processed after the rows have been grouped, so aggregate functions can be referred to in the <code>HAVING</code> filter predicate.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">freight</span><span class="p">)</span> <span class="k">AS</span> <span class="n">totalfreight</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span>
<span class="c1">-- filters only groups (employee and order year) with more than one row, and total freight with more than 500.0</span>
<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">AND</span> <span class="k">SUM</span><span class="p">(</span><span class="n">freight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">.</span><span class="mi">0</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">1	2021	711.13
2	2022	672.16
4	2022	651.83
6	2021	628.31
7	2022	1231.56</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="select">2.5. SELECT</h3>
<div class="paragraph">
<p>The <code>SELECT</code> clause is where to specify the attributes (columns) to return in the result table of the query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">numorders</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span>
<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>SELECT</code> clause is processed after the <code>FROM</code>, <code>WHERE</code>, <code>GROUP BY</code>, and <code>HAVING</code> clauses, which means that aliases assigned to expressions in the <code>SELECT</code> clause do not exist as far as clauses that are processed before the <code>SELECT</code> clause are concerned.</p>
<div class="paragraph">
<p>It’s a typical mistake to try and refer to expression aliases in clauses that are processed before the SELECT clause, such as in the following example in which the attempt is made in the WHERE clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderyear</span> <span class="o">&gt;</span> <span class="mi">2021</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 207, Level 16, State 1, Line 3
Invalid column name 'orderyear'.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One way around this problem is to repeat the expression <code>YEAR(orderdate)</code> in both the <code>WHERE</code> and <code>SELECT</code> clauses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2021</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In addition to supporting the AS clause, T-SQL supports the form <code>&lt;expression&gt; AS &lt;alias&gt;</code>, and also supports the forms <code>&lt;alias&gt; = &lt;expression&gt;</code> (“alias equals expression”) and <code>&lt;expression&gt; &lt;alias&gt;</code> (“expression space alias”).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In relational theory, a relational expression is applied to one or more input relations using operators from relational algebra, and returns a relation as output, that is, a relation in SQL is a table, and a relational expression in SQL is a <em>table expression</em>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Recall that a relation’s body is a set of tuples, and a set has no duplicates. Unlike relational theory, which is based on mathematical set theory, SQL is based on <em>multiset</em> theory.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The mathematical term <code>multiset</code>, or <code>bag</code>, is similar in some aspects to a set, but it does allow duplicates.</p>
</li>
<li>
<p>A table in SQL isn’t required to have a key.</p>
<div class="ulist">
<ul>
<li>
<p>Without a key, the table can have duplicate rows and therefore isn’t relational.</p>
</li>
<li>
<p>Even if the table does have a key, a SELECT query against the table can still return duplicate rows. SQL query results do not have keys.</p>
</li>
</ul>
</div>
</li>
<li>
<p>SQL provides the means to remove duplicates using the <code>DISTINCT</code> clause to return a relational result.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">empid</span><span class="p">,</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="mi">71</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="order-by">2.6. ORDER BY</h3>
<div class="paragraph">
<p>In terms of logical query processing, <code>ORDER BY</code> comes after <code>SELECT</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With T-SQL, elements can also be specified in the <code>ORDER BY</code> clause that do not appear in the <code>SELECT</code> clause, meaning to sort by something that don’t necessarily want to be returned.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span><span class="p">,</span> <span class="n">country</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">hiredate</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span><span class="p">,</span> <span class="n">country</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">ORDER</span> <span class="k">BY</span>
    <span class="k">CASE</span> <span class="n">country</span>
        <span class="k">WHEN</span> <span class="s1">'USA'</span> <span class="k">THEN</span> <span class="mi">1</span>
        <span class="k">WHEN</span> <span class="s1">'CHN'</span> <span class="k">THEN</span> <span class="mi">2</span>
        <span class="k">WHEN</span> <span class="s1">'JPN'</span> <span class="k">THEN</span> <span class="mi">3</span>
        <span class="k">WHEN</span> <span class="s1">'DEU'</span> <span class="k">THEN</span> <span class="mi">4</span>
        <span class="k">WHEN</span> <span class="s1">'CAN'</span> <span class="k">THEN</span> <span class="mi">5</span>
        <span class="k">WHEN</span> <span class="s1">'KOR'</span> <span class="k">THEN</span> <span class="mi">6</span>
        <span class="k">ELSE</span> <span class="mi">7</span>
    <span class="k">END</span><span class="p">,</span>
    <span class="n">empid</span><span class="p">;</span> <span class="c1">-- tie-breaker</span></code></pre>
</div>
</div>
</li>
<li>
<p>However, when the <code>DISTINCT</code> clause is specified, the <code>ORDER BY</code> are restricted to list only elements that appear in the <code>SELECT</code> list.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span><span class="p">,</span> <span class="n">country</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">hiredate</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 145, Level 15, State 1, Line 1
ORDER BY items must appear in the select list if SELECT DISTINCT is specified.</span></code></pre>
</div>
</div>
</li>
<li>
<p><code>ASC</code> is the default sort order. <code>NULL</code> values are treated as the lowest possible values.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One of the most important points to understand about SQL is that a table—be it an existing table in the database or a table result returned by a query—has no guaranteed order. That’s because a table is supposed to represent a set of rows (or multiset, if it has duplicates), and a set has no order.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It means that when querying a table without specifying an <code>ORDER BY</code> clause, SQL Server is free to return the rows in the output in any order.</p>
</li>
<li>
<p>The only way to guarantee the presentation order in the result is with an <code>ORDER BY</code> clause.</p>
</li>
<li>
<p>However, realizing that if specifying an <code>ORDER BY</code> clause, the result can’t qualify as a <em>table</em>, because it is ordered. Standard SQL calls such a result a <em>cursor</em>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="top">2.7. TOP</h3>
<div class="paragraph">
<p>The <code>TOP</code> filter is a proprietary T-SQL feature that can be used to limit the number or percentage of rows queried returns. It relies on two elements as part of its specification: one is the number or percent of rows to return, and the other is the ordering.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">TOP</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that the <code>TOP</code> filter is handled after <code>DISTINCT</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>TOP</code> can use option with the <code>PERCENT</code> keyword, in which case SQL Server calculates the number of rows to return based on a percentage of the number of qualifying rows, rounded up.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">TOP</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">PERCENT</span>
  <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The query returns nine rows because the <code>Orders</code> table has 830 rows, and 1 percent of 830, rounded up, is 9.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">11074	2022-05-06	73	7
11075	2022-05-06	68	8
11076	2022-05-06	9	4
11077	2022-05-06	65	1
11070	2022-05-05	44	2
11071	2022-05-05	46	1
11072	2022-05-05	20	4
11073	2022-05-05	58	2
11067	2022-05-04	17	1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above query, notice that the <code>ORDER BY</code> list is not unique (because no primary key or unique constraint is defined on the orderdate column).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In other words, the ordering is not strict total ordering. Multiple rows can have the same order date.</p>
</li>
<li>
<p>In such a case, the ordering among rows with the same order date is undefined, which makes the query nondeterministic—more than one result can be considered correct.</p>
</li>
<li>
<p>In case of ties, SQL Server filters rows based on optimization choices and physical access order.</p>
</li>
<li>
<p>Note that when using the TOP filter in a query without an <code>ORDER BY</code> clause, the ordering is completely undefined—SQL Server returns whichever <code>n</code> rows it happens to physically access first, where <code>n</code> is the requested number of rows.</p>
</li>
<li>
<p>To make the query be deterministic, a strict total ordering is needed; in other words, add a tie-breaker.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">TOP</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">orderid</span> <span class="k">DESC</span><span class="p">;</span> <span class="c1">-- the row with the greater order ID value will be preferred.</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">11077	2022-05-06	65	1
11076	2022-05-06	9	4
11075	2022-05-06	68	8
11074	2022-05-06	73	7
11073	2022-05-05	58	2</span></code></pre>
</div>
</div>
</li>
<li>
<p>Instead of adding a tie-breaker to the <code>ORDER BY</code> list, a request can be made to return all ties by adding the <code>WITH TIES</code> option.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">TOP</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">WITH</span> <span class="n">TIES</span>
  <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>SQL Server first returned the <code>TOP (5)</code> rows based on <code>orderdate</code> <code>DESC</code> ordering, and it also returned all other rows from the table that had the same orderdate value as in the last of the five rows that were accessed.</p>
</li>
<li>
<p>Using the <code>WITH TIES</code> option, the selection of rows is deterministic, but the presentation order among rows with the same order date isn’t.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">11077	2022-05-06	65	1
11076	2022-05-06	9	4
11075	2022-05-06	68	8
11074	2022-05-06	73	7
11073	2022-05-05	58	2
11072	2022-05-05	20	4
11071	2022-05-05	46	1
11070	2022-05-05	44	2</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>TOP</code> filter is very useful, but it has two shortcomings—it’s not standard, and it doesn’t support a skipping capability.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="offset-fetch">2.8. OFFSET-FETCH</h3>
<div class="paragraph">
<p>T-SQL also supports a standard, TOP-like filter, called OFFSET-FETCH, which does support a skipping option, which makes it very useful for paging purposes.</p>
</div>
<div class="paragraph">
<p>According to the SQL standard, the OFFSET-FETCH filter is considered an extension to the <code>ORDER BY</code> clause. With the <code>OFFSET</code> clause indicates how many rows to skip, and with the <code>FETCH</code> clause indicates how many rows to filter after the skipped rows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span>
  <span class="k">OFFSET</span> <span class="mi">50</span> <span class="k">ROWS</span> <span class="k">FETCH</span> <span class="k">NEXT</span> <span class="mi">25</span> <span class="k">ROWS</span> <span class="k">ONLY</span><span class="p">;</span>
  <span class="c1">-- OFFSET 50 ROWS;</span>
  <span class="c1">-- OFFSET 0 ROWS FETCH NEXT 25 ROWS ONLY;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that a query that uses OFFSET-FETCH must have an <code>ORDER BY</code> clause. Also, contrary to the SQL standard, T-SQL doesn’t support the <code>FETCH</code> clause without the <code>OFFSET</code> clause. However, <code>OFFSET</code> without <code>FETCH</code> is allowed to skip the indicated number of rows and returns all remaining rows in the result.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the syntax for the OFFSET- FETCH filter, the singular and plural forms <code>ROW</code> and <code>ROWS</code>, and the forms <code>FIRST</code> and <code>NEXT</code> are interchangeable to phrase the filter in an intuitive, English-like manner.
=== OVER
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A window function is a function that, for each row in the underlying query, operates on a window (set) defined with an <code>OVER</code> clause of rows that is derived from the underlying query result, and computes a scalar (single) result value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">freight</span><span class="p">,</span>
  <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span>
                     <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">freight</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rownum</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">freight</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>For each row in the underlying query, the <code>OVER</code> clause exposes to the function a subset of the rows from the underlying query’s result set.</p>
</li>
<li>
<p>The <code>OVER</code> clause can restrict the rows in the window by using an optional window partition clause (<code>PARTITION BY</code>).</p>
</li>
<li>
<p>It can define ordering for the calculation (if relevant) using a window order clause (<code>ORDER BY</code>)—not to be confused with the query’s presentation <code>ORDER BY</code> clause.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Window functions are defined by the SQL standard, and T-SQL supports a subset of the features from the standard.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="case">2.9. CASE</h3>
<div class="paragraph">
<p>A <code>CASE</code> expression, based on the SQL standard, is a scalar expression that returns a value based on conditional logic.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that <code>CASE</code> is an (scalar) expression and not a statement; that is, it returns a value and it is allowed wherever scalar expressions are allowed, such as in the <code>SELECT</code>, <code>WHERE</code>, <code>HAVING</code>, and <code>ORDER BY</code> clauses and in <code>CHECK</code> constraints.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two forms of CASE expressions: <em>simple</em> and <em>searched</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>simple CASE expression</em> has a single test value or expression right after the <code>CASE</code> keyword that is compared with a list of possible values or expressions, in the <code>WHEN</code> clauses.</p>
<div class="ulist">
<ul>
<li>
<p>If no value in the list is equal to the tested value, the <code>CASE</code> expression returns the value that appears in the <code>ELSE</code> clause (or <code>NULL</code> if an <code>ELSE</code> clause is not present).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">supplierid</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">numproducts</span><span class="p">,</span>
  <span class="k">CASE</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
     <span class="k">WHEN</span> <span class="mi">0</span> <span class="k">THEN</span> <span class="s1">'Even'</span>
     <span class="k">WHEN</span> <span class="mi">1</span> <span class="k">THEN</span> <span class="s1">'Odd'</span>
     <span class="k">ELSE</span> <span class="s1">'Unknown'</span>
   <span class="k">END</span> <span class="k">AS</span> <span class="n">countparity</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">supplierid</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <em>searched CASE expression</em> returns the value in the <code>THEN</code> clause that is associated with the first <code>WHEN</code> predicate that evaluates to <code>TRUE</code>.</p>
<div class="ulist">
<ul>
<li>
<p>If none of the <code>WHEN</code> predicates evaluates to <code>TRUE</code>, the <code>CASE</code> expression returns the value that appears in the <code>ELSE</code> clause (or <code>NULL</code> if an <code>ELSE</code> clause is not present).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">freight</span><span class="p">,</span>
  <span class="k">CASE</span>
     <span class="k">WHEN</span> <span class="n">freight</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">.</span><span class="mi">00</span>  <span class="k">THEN</span> <span class="s1">'Less than 1000'</span>
     <span class="k">WHEN</span> <span class="n">freight</span> <span class="o">&lt;=</span> <span class="mi">3000</span><span class="p">.</span><span class="mi">00</span> <span class="k">THEN</span> <span class="s1">'Between 1000 and 3000'</span>
     <span class="k">WHEN</span> <span class="n">freight</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">.</span><span class="mi">00</span>  <span class="k">THEN</span> <span class="s1">'More than 3000'</span>
     <span class="k">ELSE</span> <span class="s1">'Unknown'</span>
   <span class="k">END</span> <span class="k">AS</span> <span class="n">valuecategory</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="predicates-and-operators">3. Predicates and Operators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>T-SQL has language elements in which predicates can be specified—for example, query filters such as <code>WHERE</code> and <code>HAVING</code>, the <code>JOIN</code> operator’s <code>ON</code> clause, <code>CHECK</code> constraints, and others.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
T-SQL uses three-valued predicate logic, where logical expressions can evaluate to <code>TRUE</code>, <code>FALSE</code>, or <code>UNKNOWN</code>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="predicates-in-between-like-exists-and-is-null">3.1. Predicates: <code>IN</code>, <code>BETWEEN</code>, <code>LIKE</code>, <code>EXISTS</code>, and <code>IS NULL</code></h3>
<div class="ulist">
<ul>
<li>
<p>The <code>IN</code> predicate is used to check whether a value, or scalar expression, is equal to at least one of the elements in a set.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderid</span> <span class="k">IN</span><span class="p">(</span><span class="mi">10248</span><span class="p">,</span> <span class="mi">10249</span><span class="p">,</span> <span class="mi">10250</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>BETWEEN</code> predicate is used to to check whether a value falls within a specified range, INCLUSIVE of the two delimiters of the range.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderid</span> <span class="k">BETWEEN</span> <span class="mi">10300</span> <span class="k">AND</span> <span class="mi">10310</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>LIKE</code> predicate is used to check whether a character string value meets a specified pattern.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">lastname</span> <span class="k">LIKE</span> <span class="n">N</span><span class="s1">'D%'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Notice the use of the letter <code>N</code> to prefix the string <code>'D%';</code> it stands for National and is used to denote that a character string is of a Unicode data type (<code>NCHAR</code> or <code>NVARCHAR</code>), as opposed to a regular character data type (<code>CHAR</code> or <code>VARCHAR</code>).
</td>
</tr>
</table>
</div>
</li>
<li>
<p>The <code>EXISTS</code> or <code>NOT EXISTS</code> predicate is used to test for the presence or absence of rows in a subquery.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">companyname</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
<span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span> <span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>IS NULL</code> and its opposite <code>IS NOT NULL</code> predicates are used to test for <code>NULL</code> values.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span><span class="p">,</span> <span class="n">mgrid</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">mgrid</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="three-valued-logic-3vl">3.2. Three-Valued Logic (3VL)</h3>
<div class="paragraph">
<p>SQL uses <strong>three-valued logic (3VL)</strong>, where expressions can evaluate to one of three states: <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code> (also called <code>UNKNOWN</code>). It is critical to understand that <code>WHERE</code> and <code>HAVING</code> clauses only accept rows where the condition is <code>TRUE</code>, discarding rows that are <code>FALSE</code> or <code>NULL</code>.</p>
</div>
<div class="paragraph">
<p>The logical operators <code>AND</code>, <code>OR</code>, and <code>NOT</code> behave as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NOT</code> Operator:</p>
<div class="ulist">
<ul>
<li>
<p><code>NOT TRUE</code> results in <code>FALSE</code>.</p>
</li>
<li>
<p><code>NOT FALSE</code> results in <code>TRUE</code>.</p>
</li>
<li>
<p><code>NOT NULL</code> results in <code>NULL</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>AND</code> Operator (Pessimistic): It returns <code>TRUE</code> only if both sides are <code>TRUE</code>. It is pessimistic because if one side is <code>FALSE</code>, the result is <code>FALSE</code>, even if the other side is <code>NULL</code>.</p>
<div class="ulist">
<ul>
<li>
<p><code>TRUE AND NULL</code> results in <code>NULL</code>.</p>
</li>
<li>
<p><code>FALSE AND NULL</code> results in <code>FALSE</code>.</p>
</li>
<li>
<p><code>NULL AND NULL</code> results in <code>NULL</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>OR</code> Operator (Optimistic): It returns <code>TRUE</code> if either side is <code>TRUE</code>. It is optimistic because if one side is <code>TRUE</code>, the result is <code>TRUE</code>, even if the other side is <code>NULL</code>.</p>
<div class="ulist">
<ul>
<li>
<p><code>TRUE OR NULL</code> results in <code>TRUE</code>.</p>
</li>
<li>
<p><code>FALSE OR NULL</code> results in <code>NULL</code>.</p>
</li>
<li>
<p><code>NULL OR NULL</code> results in <code>NULL</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="equality-and-distinctness">3.3. Equality and Distinctness</h3>
<div class="paragraph">
<p>In SQL, the way <code>NULL</code> values are compared depends on the context, leading to two different types of comparison logic:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Equality-based Comparison</strong> is the standard comparison used in predicates like <code>WHERE</code> and <code>JOIN ON</code>. It treats <code>NULL</code> as an <em>unknown</em> value. Because one unknown cannot be said to be equal to another, the expression <code>NULL = NULL</code> evaluates to <code>UNKNOWN</code>, not <code>TRUE</code>.</p>
</li>
<li>
<p><strong>Distinctness-based Comparison</strong> is used by operators that need to group rows or find duplicates, such as <code>GROUP BY</code>, <code>UNION</code>, <code>INTERSECT</code>, and <code>EXCEPT</code>. For these operations, two <code>NULL</code> values are treated as <strong>not distinct</strong> from each other (i.e., they are considered identical) which ensures that rows with <code>NULL</code> values in the same columns are correctly identified as duplicates.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The formal SQL standard predicate for this logic is <code>IS [NOT] DISTINCT FROM</code>. It provides a way to compare values while treating two <code>NULL</code> values as equivalent. For example, <code>NULL IS NOT DISTINCT FROM NULL</code> evaluates to <code>TRUE</code>. It is important to note that <strong>T-SQL does not support this predicate</strong>, even though its set operators use the underlying distinctness logic.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="comparison-operators-and-all-some-any">3.4. Comparison Operators: <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code><=</code>, <code>&lt;&gt;</code>, and <code>ALL</code>, <code>SOME</code>, <code>ANY</code></h3>
<div class="ulist">
<ul>
<li>
<p>T-SQL supports the comparison operators: <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code><=</code>, <code>&lt;&gt;</code>, <code>!=</code>, <code>!&gt;</code>, and <code>!&lt;</code>, of which the last three are not standard and should be avoided using.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderdate</span> <span class="o">&gt;=</span> <span class="s1">'20220101'</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>&lt;&gt;</code> (not equal) operator is used to check whether a value is not equal to another value.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderdate</span> <span class="o">&lt;&gt;</span> <span class="s1">'20220101'</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>ALL</code> keyword is used with a comparison operator to compare a scalar value with every value in a list or result set returned by a subquery. The condition is <code>TRUE</code> if the comparison is <code>TRUE</code> for all values in the list.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Example: Find products whose list price is greater than ALL list prices in the 'Road Bikes' category.</span>
<span class="k">SELECT</span> <span class="n">Name</span><span class="p">,</span> <span class="n">ListPrice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Product</span>
<span class="k">WHERE</span> <span class="n">ListPrice</span> <span class="o">&gt;</span> <span class="k">ALL</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">ListPrice</span> <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Product</span> <span class="k">WHERE</span> <span class="n">ProductSubcategoryID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>SOME</code> or <code>ANY</code> keyword (they are synonyms) is used with a comparison operator to compare a scalar value with any value in a list or result set returned by a subquery. The condition is <code>TRUE</code> if the comparison is <code>TRUE</code> for at least one value in the list.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Example: Find products whose list price is greater than SOME list prices in the 'Mountain Bikes' category.</span>
<span class="k">SELECT</span> <span class="n">Name</span><span class="p">,</span> <span class="n">ListPrice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Product</span>
<span class="k">WHERE</span> <span class="n">ListPrice</span> <span class="o">&gt;</span> <span class="k">SOME</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">ListPrice</span> <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Product</span> <span class="k">WHERE</span> <span class="n">ProductSubcategoryID</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It&#8217;s important to distinguish between <code>NOT IN</code> and <code>&lt;&gt; ANY</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NOT IN</code> means "not equal to value A AND not equal to value B AND not equal to value C&#8230;&#8203;"</p>
</li>
<li>
<p><code>&lt;&gt; ANY</code> means "not equal to value A OR not equal to value B OR not equal to value C&#8230;&#8203;"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, if a subquery returns <code>(1, 2, 3)</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value NOT IN (1, 2, 3)</code> is true if <code>value</code> is not 1 AND not 2 AND not 3.</p>
</li>
<li>
<p><code>value &lt;&gt; ANY (1, 2, 3)</code> is true if <code>value</code> is not 1 OR not 2 OR not 3.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="logical-operators-or-and-and-not">3.5. Logical Operators: <code>OR</code>, <code>AND</code>, and <code>NOT</code></h3>
<div class="ulist">
<ul>
<li>
<p>The logical operators <code>OR</code>, <code>AND</code>, and <code>NOT</code> are used to combine logical expressions.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderdate</span> <span class="o">&gt;=</span> <span class="s1">'20220101'</span>
  <span class="k">AND</span> <span class="n">empid</span> <span class="k">NOT</span> <span class="k">IN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="arithmetic-operators-and">3.6. Arithmetic Operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code></h3>
<div class="ulist">
<ul>
<li>
<p>T-SQL supports the four obvious arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and also supports the <code>%</code> operator (modulo), which returns the remainder of integer division.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">productid</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">unitprice</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span>
  <span class="n">qty</span> <span class="o">*</span> <span class="n">unitprice</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">discount</span><span class="p">)</span> <span class="k">AS</span> <span class="n">val</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that the data type of a scalar expression involving two operands is determined in T-SQL by the operand with the higher data-type precedence.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If both operands are of the same data type, the result of the expression is of the same data type as well.</p>
</li>
<li>
<p>If the two operands are of different types, the one with the lower precedence is promoted to the one that is higher.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span> <span class="n">Numbers</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="mi">5</span> <span class="k">AS</span> <span class="n">IntValue</span><span class="p">,</span> <span class="mi">2</span> <span class="k">AS</span> <span class="n">IntDivisor</span><span class="p">,</span> <span class="mi">5</span><span class="p">.</span><span class="mi">0</span> <span class="k">AS</span> <span class="n">FloatValue</span>
<span class="p">)</span>
<span class="k">SELECT</span>
  <span class="n">IntValue</span> <span class="o">/</span> <span class="n">IntDivisor</span> <span class="k">AS</span> <span class="n">IntegerDivisionResult</span><span class="p">,</span> <span class="c1">-- Integer division</span>
  <span class="k">CAST</span><span class="p">(</span><span class="n">IntValue</span> <span class="k">AS</span> <span class="nb">NUMERIC</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="k">CAST</span><span class="p">(</span><span class="n">IntDivisor</span> <span class="k">AS</span> <span class="nb">NUMERIC</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">AS</span> <span class="n">DecimalDivisionResult</span><span class="p">,</span> <span class="c1">-- Decimal division with casting</span>
  <span class="n">FloatValue</span> <span class="o">/</span> <span class="n">IntDivisor</span> <span class="k">AS</span> <span class="n">DecimalDivisionFromFloatResult</span> <span class="c1">-- Division with a float</span>
<span class="k">FROM</span> <span class="n">Numbers</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>NUMERIC(12, 2)</code> data type in T-SQL (SQL Server) defines a <em>fixed-precision decimal number</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>12</code> (Precision) → The total number of <strong>digits</strong> that can be stored (both before and after the decimal point).</p>
</li>
<li>
<p><code>2</code> (Scale) → The number of <strong>digits after the decimal point</strong>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="mi">1234567890</span><span class="p">.</span><span class="mi">12</span>   <span class="c1">-- Valid    (12 digits total: 10 before the decimal, 2 after) |</span>
<span class="mi">999999999999</span><span class="p">.</span><span class="mi">99</span> <span class="c1">-- Valid    (max possible value) |</span>
<span class="mi">100000000000</span><span class="p">.</span><span class="mi">00</span> <span class="c1">-- Invalid  (13 digits, exceeds precision) |</span>
<span class="mi">12345</span><span class="p">.</span><span class="mi">678</span>       <span class="c1">-- Invalid  (more than 2 decimal places) |</span></code></pre>
</div>
</div>
</li>
<li>
<p><code>NUMERIC(p, s)</code> and <code>DECIMAL(p, s)</code> are functionally <strong>identical</strong> in SQL Server.</p>
</li>
<li>
<p>Both store <em>exact</em> numbers (unlike <code>FLOAT</code> or <code>REAL</code>, which are approximate).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query-tuning">4. Query Tuning</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>To simulate a cold cache scenario for query performance measurement, run a manual checkpoint to write dirty buffers to disk and then drop all clean buffers from cache.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CHECKPOINT</span><span class="p">;</span>
<span class="n">DBCC</span> <span class="n">DROPCLEANBUFFERS</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>DBCC DROPCLEANBUFFERS</code> should only be used isolated test environments as it can severely impact server performance.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>To see the estimated plan in SSMS/ADS by highlighting the query and clicking the Display Estimated Execution Plan (Ctrl+L) button on the SQL Editor toolbar.</p>
<div class="ulist">
<ul>
<li>
<p>To see the actual plan by enabling the Include Actual Execution Plan (Ctrl+M) button and executing the query.</p>
</li>
<li>
<p>Actual execution plans are generated after the T-SQL queries or batches execute that includes run-time information like the actual number of rows returned by, and the actual number of executions of, each operator.</p>
</li>
</ul>
</div>
</li>
<li>
<p>To enable measuring query performance with the session options STATISTICS IO (for I/O information) and STATISTICS TIME (for time information):</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SET</span> <span class="k">STATISTICS</span> <span class="n">IO</span><span class="p">,</span> <span class="nb">TIME</span> <span class="k">ON</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="sql-server-internals">4.1. SQL Server Internals</h3>
<div class="paragraph">
<p>A <em>page</em> is an 8-KB unit where SQL Server stores data. With disk-based tables, the page is the smallest I/O unit that SQL Server can read or write. An <em>extent</em> is a unit that contains eight contiguous pages.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>table</em> can be organized in one of two ways—either as a <em>heap</em> or as a <em>B- tree</em> (HOBT), technically as a B-tree when it has a clustered index defined on it and as a heap when it doesn’t.</p>
</li>
<li>
<p>A <em>heap</em> is a table that has no clustered index, which means that the data is laid out as a bunch of pages and extents without any order.</p>
<div class="ulist">
<ul>
<li>
<p>SQL Server maps the data that belongs to a heap using one or more bitmap pages called <em>index allocation maps (IAMs)</em>.</p>
</li>
<li>
<p>An <em>allocation order scan</em> is a heap scan that uses IAM pages to determine which pages and extents belong to the heap and reads them in physical file order, typically resulting in sequential reads when data is not cached.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="indexes">4.1.1. Indexes</h4>
<div class="ulist">
<ul>
<li>
<p>All indexes in SQL Server on disk-based tables are structured as <em>B-trees</em>, which are a special case of balanced trees.</p>
<div class="ulist">
<ul>
<li>
<p>An index on disk-based tables has a doubly linked list in their leaf level, so SQL Server can scan the rows in the leaf in forward and backward order.</p>
</li>
<li>
<p>A <em>clustered index</em> is structured as a B-tree, and it maintains the entire table’s data, not a copy, in its leaf level.</p>
<div class="ulist">
<ul>
<li>
<p>At the leaf level of the clustered index, the order in which data pages are stored on disk may not correspond to the sorted order of the index keys due to page splits.</p>
</li>
<li>
<p>If page <code>x</code> points to next page <code>y</code>, and page <code>y</code> appears before page <code>x</code> in the file, page <code>y</code> is considered an out-of- order page.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A <em>nonclustered index</em> is also structured as a B-tree, in contrast to a clustered index, a leaf row in a nonclustered index contains only the index key columns and a row locator value representing a particular data row.</p>
<div class="ulist">
<ul>
<li>
<p>With the nonclustered index seek or range scan, it is more efficient because with fewer columns in the leaf row to fit more rows per leaf page.</p>
</li>
<li>
<p>When using multiple predicates, the order of key columns in a nonclustered index is crucial for performance, as it determines whether qualifying rows are stored contiguously in the index leaf, maximizing seeks and minimizing scans.</p>
<div class="ulist">
<ul>
<li>
<p>When have multiple equality predicates, place the columns from the predicates in any order in the index key list.</p>
</li>
<li>
<p>When have at most one range predicate, place the columns from the equality predicates first in the key list and the column from the range predicate last.</p>
</li>
<li>
<p>When have multiple range predicates, place the column from the most selective range predicate before the columns from the remaining range predicates.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>An <em>index order scan</em> is a scan performed on the leaf level of a B-tree index in the sorted order of the index key, using a doubly linked list for inter-page navigation and a row-offset array for intra-page order, supporting both full ordered scans and range scans.</p>
<div class="ulist">
<ul>
<li>
<p>An index scan is necessary when the query filters on a non-leading column of the index key to scan a larger portion of the index (or even the entire index) to find the matching entries.</p>
</li>
</ul>
</div>
</li>
<li>
<p>An <em>index seek</em> is performed when SQL Server needs to find a certain key or range of keys at the leaf level of the index.</p>
<div class="ulist">
<ul>
<li>
<p>An index seek is possible when the query filters on the leading column (or a prefix of the leading columns) of the index key to navigate the B-tree from the root node down to the specific leaf page(s) containing the matching values.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In SQL Server, the direction of key columns can be indicated in an index definition (ascending by default).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">UNIQUE</span> <span class="n">NONCLUSTERED</span> <span class="k">INDEX</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">ON</span> <span class="p">[</span><span class="n">schema1</span><span class="p">].[</span><span class="n">Table1</span><span class="p">]</span>
<span class="p">(</span>
  <span class="p">[</span><span class="n">col1</span><span class="p">],</span> <span class="c1">-- same as [col1] ASC</span>
  <span class="p">[</span><span class="n">col2</span><span class="p">]</span> <span class="k">DESC</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The storage engine currently processes parallel scans only in the forward direction; backward scans are processed serially.</p>
</li>
<li>
<p>If parallelism is a critical factor in the performance of the query, arrange a descending index.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A <em>filtered index</em> is an index on a subset of rows from the underlying table defined based on a predicate.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="n">NONCLUSTERED</span> <span class="k">INDEX</span> <span class="n">idx_USA_orderdate</span>
  <span class="k">ON</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span>
  <span class="n">INCLUDE</span><span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">requireddate</span><span class="p">)</span>
  <span class="k">WHERE</span> <span class="n">shipcountry</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'USA'</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>A <em>covering index</em> is an index that contains all the columns required by the query, avoiding lookups to the base table.</p>
<div class="ulist">
<ul>
<li>
<p>A clustered index is a covering index because the leaf row is the complete data row.</p>
</li>
<li>
<p>A nonclustered index can be a covering index with an <code>INCLUDE</code> clause listing all non-key columns required by the query.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_nc_cid_i_oid_eid_sid_od_flr</span>
  <span class="k">ON</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">(</span><span class="n">custid</span><span class="p">)</span>
  <span class="n">INCLUDE</span><span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">filler</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A <em>columnstore index</em> stores data by columns rather than by rows, which leads to substantial performance advantages for analytical queries.</p>
<div class="ulist">
<ul>
<li>
<p>A nonclustered columnstore index is a secondary index created on an existing table that is stored in the traditional rowstore format.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="n">NONCLUSTERED</span> <span class="n">COLUMNSTORE</span> <span class="k">INDEX</span> <span class="n">idx_nc_cs</span>
    <span class="k">ON</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Fact</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">key3</span><span class="p">,</span> <span class="n">measure1</span><span class="p">,</span> <span class="n">measure2</span><span class="p">,</span> <span class="n">measure3</span><span class="p">,</span> <span class="n">measure4</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>A clustered columnstore index is the primary storage for the table, with data physically stored in columnstore format.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="n">CLUSTERED</span> <span class="n">COLUMNSTORE</span> <span class="k">INDEX</span> <span class="n">idx_cl_cs</span> <span class="k">ON</span> <span class="n">dbo</span><span class="p">.</span><span class="n">FactCS</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="execution-plans">4.1.2. Execution Plans</h4>
<div class="paragraph">
<p>In SQL Server, the <em>relational engine</em>, like a brain including the optimizer, produces execution plans for queries, while the <em>storage engine</em>, like muscles, carries out these instructions, sometimes choosing the best of several options based on performance and consistency.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the plan shows a table scan operator, the storage engine has only one option: to use an allocation order scan.</p>
</li>
<li>
<p>When the plan shows an ordered index scan operator (clustered or nonclustered), the storage engine can use only an index order scan.</p>
</li>
<li>
<p>When the plan shows an unordered index scan operator, the storage engine has two options to scan the data: allocation order scan and index order scan.</p>
<div class="ulist">
<ul>
<li>
<p>An allocation order scan can return multiple occurrences of rows and skip rows resulting from splits that take place during the scan.</p>
<div class="ulist">
<ul>
<li>
<p>The storage engine opts for this option when the index size is greater than 64 pages and the request is running under the Read Uncommitted isolation level.</p>
</li>
<li>
<p>When the query is running under the default Read Committed isolation level or higher, the storage engine will opt for an index order scan to prevent such phenomena from happening because of splits.</p>
</li>
</ul>
</div>
</li>
<li>
<p>An index order scan is safer in the sense that it won’t read multiple occurrences of the same row or skip rows because of splits.</p>
<div class="ulist">
<ul>
<li>
<p>If an index key is modified after the row was read by an index order scan and the row is moved to a point in the leaf that the scan hasn’t reached yet, the scan will read the row a second time or never reach that row.</p>
</li>
<li>
<p>It can happen in Read Uncommitted, Read Committed, and even Repeatable Read because the update was done to a row that was not yet read, but cannot happen under the isolation levels Serializable, Read Committed Snapshot, and Snapshot.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="cardinality-estimates">4.1.3. Cardinality Estimates</h4>
<div class="paragraph">
<p>A <em>query optimizer</em>, the main component in the <em>relational engine</em> (also known as the <em>query processor</em>), is responsible for generating physical execution plans for the queries.</p>
</div>
<div class="paragraph">
<p>A <em>cardinality estimator</em>, that makes cardinality estimates of the number of rows returned by each operator, is employed by the optimizer to make decisions about access methods, join and aggregation algorithms, and memory allocation for sort and hash operations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is not a simple task to make accurate cardinality estimations without actually running the query and without a time machine.</p>
<div class="ulist">
<ul>
<li>
<p>Underestimations will tend to result in the following (not an exhaustive list):</p>
<div class="ulist">
<ul>
<li>
<p>For filters, preferring an index seek and lookups to a scan.</p>
</li>
<li>
<p>For aggregates, joins, and distinct, preferring order-based algorithms to hash-based ones.</p>
</li>
<li>
<p>For sort and hash operations, there might be spills to tempdb as a result of an insufficient memory grant.</p>
</li>
<li>
<p>Preferring a serial plan over a parallel one.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Overestimations will tend to result in pretty much the inverse of underestimations (again, not an exhaustive list):</p>
<div class="ulist">
<ul>
<li>
<p>For filters, preferring a scan to an index seek and lookups.</p>
</li>
<li>
<p>For aggregates, joins, and distinct, preferring hash-based algorithms to order-based ones.</p>
</li>
<li>
<p>For sort and hash operations, there won’t be spills, but very likely there will be a larger memory grant than needed, resulting in wasting memory.</p>
</li>
<li>
<p>Preferring a parallel plan over a serial one.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>SQL Server relies on statistics about the data in its cardinality estimates.</p>
<div class="ulist">
<ul>
<li>
<p>Whenever creating an index, SQL Server creates statistics using a full scan of the data.</p>
</li>
<li>
<p>When additional statistics are needed, SQL Server might create them automatically using a sampled percentage of the data.</p>
</li>
<li>
<p>SQL Server creates three main types of statistics: header, density vectors, and a histogram.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_nc_cid_eid</span> <span class="k">ON</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">(</span><span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">);</span>
<span class="n">DBCC</span> <span class="n">SHOW_STATISTICS</span><span class="p">(</span><span class="n">N</span><span class="s1">'dbo.Orders'</span><span class="p">,</span> <span class="n">N</span><span class="s1">'idx_nc_cid_eid'</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="parallel-query-execution">4.1.4. Parallel Query Execution</h4>
<div class="paragraph">
<p><em>Parallel query execution</em> (<em>intraquery parallelism</em> or <em>parallelism</em>) uses multiple processor cores to simultaneously process smaller chunks of data, leveraging modern hardware&#8217;s increased computing power for efficient large-data processing.</p>
</div>
<div class="paragraph">
<p>Parallel processing, splitting work across multiple processor cores, can be implemented using two main models:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a factory-line model (where each core performs a single action on data passed between cores) and</p>
</li>
<li>
<p>a stream-based model (where each core processes a subset of data through all required operations).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While the factory-line model might seem intuitively better for human tasks, database systems like SQL Server use stream-based models.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Processors can efficiently switch between tasks as long as data is in local cache, and minimizing data movement between memory and storage is crucial for performance.</p>
</li>
<li>
<p>Stream-based models can scale much better than factory-line models with large datasets, distributing rows across cores as evenly as possible using various algorithms for parallel execution of all operations on each subset of data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A query plan will be either entirely serial—processed using a single worker thread—or it will include one or more parallel branches, which are areas of the plan that are processed using multiple threads.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The query processor can merge parallel streams into a single stream or create parallel streams from a single stream, resulting in plans with interleaved serial and parallel zones.</p>
</li>
<li>
<p>All parallel zones in a plan use the same number of threads, known as the <em>degree of parallelism</em> (DOP), determined by server settings, hints, and runtime conditions.</p>
</li>
<li>
<p>A given set of threads might be reused by multiple zones over the course of the plan.</p>
</li>
<li>
<p>Parallel operators in the execution plan are marked with a circle icon with two arrows.</p>
</li>
<li>
<p>Within a parallel zone, each thread processes a unique stream of rows before passing them to the next zone (serial or parallel).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Parallel query plans rely on the <em>Exchange</em> (displayed as <em>Parallelism</em>) operator, which manages worker threads and data streams.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each SQL Server query plan operator has, internally, two logical interfaces: a consumer interface, which takes rows from upstream, and a producer interface, which passes rows downstream.</p>
</li>
<li>
<p>While most operators handle their consumer and producer interfaces on the same thread and process single row streams, Exchange operators involve multiple threads and handle multiple streams, keeping other operators unaware of the parallelism.</p>
</li>
<li>
<p>The number of threads on each side of the exchange depends on the type of exchange:</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A query plan can be read right-to-left (data flow) or left-to-right (operator logic).
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Gather Streams operators will have DOP threads on the consumer side and one thread on the producer side.</p>
<div class="ulist">
<ul>
<li>
<p>From a data-flow perspective, it merges multiple parallel streams into a single serial stream, marking the end of a parallel zone.</p>
</li>
<li>
<p>From an operator-logic perspective, it starts a parallel zone by invoking parallel worker threads.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Distribute Streams operators will have one thread on the consumer side and DOP threads on the producer side.</p>
<div class="ulist">
<ul>
<li>
<p>From a data-flow perspective, it splits a serial stream into multiple parallel streams, marking the start of a parallel zone.</p>
</li>
<li>
<p>From an operator-logic perspective, it marks the end of a parallel zone.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Repartition Streams operators will have DOP threads on each side of the exchange.</p>
<div class="ulist">
<ul>
<li>
<p>From both data-flow and operator-logic perspectives, it redistributes rows from multiple parallel streams onto different threads based on a new scheme, effectively joining two adjacent parallel zones.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Parallel query plans use five row distribution strategies across threads on the producer side of Distribute or Repartition exchanges:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hash: Assigns rows to threads based on a hash function, grouping rows with the same hashed value on the same thread (e.g., grouping by ProductID for aggregation).</p>
</li>
<li>
<p>Round Robin: Distributes rows sequentially to each thread in a rotating fashion, often used outside Nested Loops where each row represents independent work.</p>
</li>
<li>
<p>Broadcast: Sends all rows to all threads, used for small row counts when all threads need the complete dataset (e.g., building a hash table).</p>
</li>
<li>
<p>Demand: Producer-side threads receive rows on request, currently used only with aligned partitioned tables.</p>
</li>
<li>
<p>Range: Assigns unique, non-overlapping key ranges to each thread, used only for index building.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data-retrieval-strategies">4.2. Data Retrieval Strategies</h3>
<div class="paragraph">
<p>SQL Server query optimizer uses various strategies to determine how the storage engine physically retrieves data from tables and indexes. Understanding these strategies, such as table scans, index seeks, and lookups, is crucial for diagnosing query performance and optimizing data access paths.</p>
</div>
<div class="sect3">
<h4 id="unordered-clustered-index-scan-or-table-scan">4.2.1. Unordered Clustered Index Scan or Table Scan</h4>
<div class="paragraph">
<p>A <em>table scan</em> or an <em>unordered clustered index scan</em> involves a scan of all data pages that belong to the table.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Full table scans occur primarily in two cases: when all rows are required or when need only a subset of the rows but don’t have a good index to support the filter.</p>
</li>
<li>
<p>When the underlying table is a heap, the plan will show an operator called <em>Table Scan</em>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders2</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders2</span> <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">PK_Orders2</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="n">NONCLUSTERED</span> <span class="p">(</span><span class="n">orderid</span><span class="p">);</span>
<span class="k">GO</span>

<span class="c1">-- table scan</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">filler</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orderss</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>When the underlying table is a B- tree, the plan will show an operator called <em>Clustered Index Scan</em> with an <em>Ordered: False</em> property.</p>
<div class="ulist">
<ul>
<li>
<p>The fact that the <code>Ordered</code> property of the Clustered Index Scan operator indicates <code>False</code> means that as far as the relational engine is concerned, the data does not need to be returned from the operator in key order.</p>
</li>
<li>
<p>It is up to the storage engine to determine to employ allocation order scan or index order scan.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- clustered index scan</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">filler</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="unordered-covering-nonclustered-index-scan">4.2.2. Unordered Covering Nonclustered Index Scan</h4>
<div class="paragraph">
<p>An <em>unordered covering nonclustered index scan</em> is a query access method to retrieve all necessary data for a query solely from the leaf level of a nonclustered index, without accessing the base table&#8217;s data rows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <em>unordered covering nonclustered index scan</em> is similar to an unordered clustered index scan.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- unordered covering nonclustered index scan</span>
<span class="k">SELECT</span> <span class="n">orderid</span> <span class="c1">-- PRIMARY KEY NONCLUSTERED (orderid)</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="ordered-clustered-index-scan">4.2.3. Ordered Clustered Index Scan</h4>
<div class="paragraph">
<p>An <em>ordered clustered index scan</em> is a full scan of the leaf level of the clustered index that guarantees that the data will be returned to the next operator in index order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- ordered clustered index scan</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">filler</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">;</span> <span class="c1">-- CLUSTERED INDEX (orderdate)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ordered-covering-nonclustered-index-scan">4.2.4. Ordered Covering Nonclustered Index Scan</h4>
<div class="paragraph">
<p>An <em>ordered covering nonclustered index scan</em> is similar to an unordered covering nonclustered index scan, but retrieves data in the order of the index keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- ordered covering nonclustered index scan</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderid</span><span class="p">;</span> <span class="c1">-- PRIMARY KEY NONCLUSTERED (orderid)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nonclustered-index-seek-range-scan-lookups">4.2.5. Nonclustered Index Seek + Range Scan + Lookups</h4>
<div class="paragraph">
<p>A <em>nonclustered index seek + range scan + lookups</em> access method is typically used for small-range queries or point queries using a nonclustered index that doesn’t cover the query.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>point query</em> uses equality conditions (<code>=</code>) to target specific values, potentially retrieving zero, one, or multiple rows, while a <em>range query</em> uses range operators (<code>&lt;</code>, <code>&gt;</code>, <code><=</code>, <code>&gt;=</code>, <code>BETWEEN</code>) to retrieve rows within a specified interval.</p>
</li>
<li>
<p>While the index is capable of supporting the filter, lookups will be required to obtain the remaining columns from the respective data rows due to the index&#8217;s non-covering nature.</p>
<div class="ulist">
<ul>
<li>
<p>If the target table is a heap, the lookups will be RID Lookups, each costing one page read.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- nonclustered index seek + range scan + lookups against a heap</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">filler</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders2</span> <span class="c1">-- heap</span>
<span class="k">WHERE</span> <span class="n">orderid</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span> <span class="c1">-- PRIMARY KEY NONCLUSTERED (orderid)</span></code></pre>
</div>
</div>
</li>
<li>
<p>If the underlying table is a B-tree, the lookups will be Key Lookups, each costing as many reads as the number of levels in the clustered index.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- nonclustered index seek + range scan + lookups against a B-tree</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">filler</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span> <span class="c1">-- B-tree</span>
<span class="k">WHERE</span> <span class="n">orderid</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span> <span class="c1">-- PRIMARY KEY NONCLUSTERED (orderid)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="unordered-nonclustered-index-scan-lookups">4.2.6. Unordered Nonclustered Index Scan + Lookups</h4>
<div class="paragraph">
<p>An <em>unordered nonclustered index scan + lookups</em> access method is typically used by the optimizer when the following conditions are in place:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The query has a selective filter.</p>
</li>
<li>
<p>There’s a nonclustered index that contains the filtered column (or columns), but the index isn’t a covering one.</p>
</li>
<li>
<p>The filtered columns are not leading columns in the index key list.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- unordered nonclustered index scan + lookups</span>
<span class="c1">-- missing index</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">filler</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="s1">'C0000000001'</span><span class="p">;</span> <span class="c1">-- NONCLUSTERED INDEX (shipperid, orderdate, custid);</span></code></pre>
</div>
</div>
</li>
<li>
<p>It performs a full unordered scan of the leaf level of the index, followed by lookups for qualifying keys, a strategy that becomes less efficient than a full table scan for less selective queries due to the lookup overhead.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="clustered-index-seek-range-scan">4.2.7. Clustered Index Seek + Range Scan</h4>
<div class="paragraph">
<p>A <em>clustered index seek + range scan</em> access method is typically used by the optimizer for range queries where the filter based on the first key column (or columns) of the clustered index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- clustered index seek + range scan</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderdate</span> <span class="o">=</span> <span class="s1">'20140212'</span><span class="p">;</span> <span class="c1">-- CLUSTERED INDEX (orderdate);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="covering-nonclustered-index-seek-range-scan">4.2.8. Covering Nonclustered Index Seek + Range Scan</h4>
<div class="paragraph">
<p>A <em>covering nonclustered index seek + range scan</em> access method is similar to the access method <em>clustered index seek + range scan</em>, only it uses a nonclustered covering index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- nonclustered index seek + range scan</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">custid</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">shipperid</span> <span class="o">=</span> <span class="s1">'C'</span>
  <span class="k">AND</span> <span class="n">orderdate</span> <span class="o">&gt;=</span> <span class="s1">'20140101'</span>
  <span class="k">AND</span> <span class="n">orderdate</span> <span class="o">&lt;</span> <span class="s1">'20150101'</span><span class="p">;</span> <span class="c1">-- NONCLUSTERED INDEX (shipperid, orderdate, custid);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tied-rows-and-sorting">4.3. Tied Rows and Sorting</h3>
<div class="paragraph">
<p>When an <code>ORDER BY</code> clause is used, SQL Server guarantees the result set is sorted according to the specified columns. However, this guarantee does not extend to rows with the same value in the ordering columns—known as <strong>tied rows</strong>. The order in which tied rows are returned is not guaranteed and can vary between query executions, leading to an <strong>unstable sort</strong>.</p>
</div>
<div class="paragraph">
<p>This instability occurs because the execution plan only guarantees the explicitly requested order. For tied rows, the database returns them in whatever order is most convenient for that specific execution, which can lead to unexpected behavior, particularly in pagination scenarios.</p>
</div>
<div class="paragraph">
<p>For instance, if a user is paging through a customer&#8217;s order history, an unstable sort could cause the same order to appear on multiple pages or for some orders to be skipped entirely, because the order of that customer&#8217;s orders shifted between page loads.</p>
</div>
<div class="paragraph">
<p>To ensure a consistent and predictable sort, the <code>ORDER BY</code> clause must uniquely identify every row, which can be achieved by adding a <strong>tie-breaker</strong>—a column or set of columns guaranteed to be unique, such as the table&#8217;s primary key.</p>
</div>
<div class="paragraph">
<p>For example, consider sorting orders by customer. A single customer can have multiple orders, creating tied rows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Unstable sort: Order of rows for the same `custid` is not guaranteed.</span>
<span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By adding the unique <code>orderid</code> column as a tie-breaker, the sort becomes deterministic. A secondary sort by <code>orderdate</code> is also a good practice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Stable sort: orderdate and orderid act as tie-breakers.</span>
<span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">orderid</span> <span class="k">DESC</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This forces the optimizer to perform a secondary sort on <code>orderdate</code> and then <code>orderid</code> for any tied rows, resulting in a deterministic, or stable, sort that is consistent with every execution.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="joins">5. Joins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>T-SQL supports four table operators: <code>JOIN</code>, <code>APPLY</code>, <code>PIVOT</code>, and <code>UNPIVOT</code>. The <code>JOIN</code> operator is standard, while <code>APPLY</code>, <code>PIVOT</code>, and <code>UNPIVOT</code> are T-SQL extensions. Each table operator acts on input tables, applies a set of logical query processing phases, and returns a table result.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>JOIN</code> table operator operates on two input tables and has three fundamental types:</p>
<div class="ulist">
<ul>
<li>
<p>A <code>CROSS JOIN</code> applies only one phase, the Cartesian Product.</p>
</li>
<li>
<p>An <code>INNER JOIN</code> applies two phases, the Cartesian Product and the Filter.</p>
</li>
<li>
<p>An <code>OUTER JOIN</code> applies three phases, the Cartesian Product, the Filter, and the Add Outer Rows.</p>
</li>
</ul>
</div>
</li>
<li>
<p>These phases describe the logical processing steps involved in different types of SQL joins:</p>
<div class="ulist">
<ul>
<li>
<p>The <code>Cartesian Product</code> is the initial step where every row from the first table is combined with every row from the second table, resulting in a new table containing all possible combinations.</p>
</li>
<li>
<p>A <code>Filter</code> is applied after the Cartesian Product, based on the <code>ON</code> clause of the join. Only the rows that satisfy the join condition are kept.</p>
</li>
<li>
<p><code>Add Outer Rows</code> is a specific phase for outer joins (<code>LEFT</code>, <code>RIGHT</code>, or <code>FULL</code>) that, after filtering, includes in the result set any rows from the outer table(s) that did not find a match in the other table.</p>
<div class="ulist">
<ul>
<li>
<p>For a <code>LEFT OUTER JOIN</code>, the outer table is the left table.</p>
</li>
<li>
<p>For a <code>RIGHT OUTER JOIN</code>, the outer table is the right table.</p>
</li>
<li>
<p>For a <code>FULL OUTER JOIN</code>, both tables are considered outer tables.</p>
<div class="paragraph">
<p>For these non-matching rows, columns from the table where no match was found will contain <code>NULL</code> values.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>OUTER</code> keyword is optional for <code>LEFT</code>, <code>RIGHT</code>, and <code>FULL</code> joins (e.g., <code>LEFT JOIN</code> is equivalent to <code>LEFT OUTER JOIN</code>).
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="cross">5.1. CROSS</h3>
<div class="paragraph">
<p>The <em>cross join</em> is the simplest type of join that implements only one logical query processing phase—a Cartesian Product.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It operates on the two tables provided as inputs and produces a Cartesian product of the two, that is, each row from one input is matched with all rows from the other.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- SQL-92 syntax</span>
<span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
   <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E</span><span class="p">;</span>

<span class="c1">-- SQL-89 syntax (not recommended)</span>
<span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span><span class="p">,</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E</span><span class="p">;</span>

<span class="c1">-- Self cross joins</span>
<span class="k">SELECT</span>
  <span class="n">E1</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="n">E1</span><span class="p">.</span><span class="n">firstname</span><span class="p">,</span> <span class="n">E1</span><span class="p">.</span><span class="n">lastname</span><span class="p">,</span>
  <span class="n">E2</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="n">E2</span><span class="p">.</span><span class="n">firstname</span><span class="p">,</span> <span class="n">E2</span><span class="p">.</span><span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E1</span>
   <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Digits</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Digits</span> <span class="p">(</span><span class="n">digit</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Digits</span><span class="p">(</span><span class="n">digit</span><span class="p">)</span>
  <span class="k">VALUES</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">);</span>
<span class="c1">-- Producing tables of numbers</span>
<span class="k">SELECT</span> <span class="n">D3</span><span class="p">.</span><span class="n">digit</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">D2</span><span class="p">.</span><span class="n">digit</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">D1</span><span class="p">.</span><span class="n">digit</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">AS</span> <span class="n">n</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Digits</span> <span class="k">AS</span> <span class="n">D1</span>
   <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Digits</span> <span class="k">AS</span> <span class="n">D2</span>
   <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Digits</span> <span class="k">AS</span> <span class="n">D3</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">n</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">1
2
3
. . .
998
999
1000</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="inner">5.2. INNER</h3>
<div class="paragraph">
<p>An <em>inner join</em> applies two logical query processing phases—it applies a Cartesian product between the two input tables like in a cross join, and then it filters rows based on a  specified predicate in a designated clause called <code>ON</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- SQL-92 syntax</span>
<span class="k">SELECT</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">firstname</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">lastname</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">ON</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">empid</span><span class="p">;</span>

<span class="c1">-- Note that the SQL-89 syntax has no ON clause.</span>
<span class="k">SELECT</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">firstname</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">lastname</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E</span><span class="p">,</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
<span class="k">WHERE</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">empid</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with the <code>WHERE</code> and <code>HAVING</code> clauses, the <code>ON</code> clause also returns only rows for which the predicate evaluates to <code>TRUE</code>, and it does not return rows for which the predicate evaluates to <code>FALSE</code> or <code>UNKNOWN</code>.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>When a join condition involves only an equality operator, the join is said to be an <em>equi join</em>.</p>
</li>
<li>
<p>When a join condition involves any operator besides equality, the join is said to be a <em>non-equi join</em>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span>
  <span class="n">E1</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="n">E1</span><span class="p">.</span><span class="n">firstname</span><span class="p">,</span> <span class="n">E1</span><span class="p">.</span><span class="n">lastname</span><span class="p">,</span>
  <span class="n">E2</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="n">E2</span><span class="p">.</span><span class="n">firstname</span><span class="p">,</span> <span class="n">E2</span><span class="p">.</span><span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E1</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E2</span>
  <span class="k">ON</span> <span class="n">E1</span><span class="p">.</span><span class="n">empid</span> <span class="o">&lt;</span> <span class="n">E2</span><span class="p">.</span><span class="n">empid</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Standard SQL supports a concept called <em>natural join</em>, which represents an inner join based on a match between columns with the same name in both sides. T-SQL doesn’t have an implementation of a natural join.</p>
</div>
<div class="paragraph">
<p>For example, <code>T1 NATURAL JOIN T2</code> joins the rows between <code>T1</code> and <code>T2</code> based on a match between the columns with the same names on both sides.</p>
</div>
<div class="paragraph">
<p>A join that has an explicit join predicate like <em>equi join</em> and <em>non-equi join</em>  that is based on a binary operator (equality or inequality) is known as a <em>theta join</em>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="outer">5.3. OUTER</h3>
<div class="paragraph">
<p><em>Outer joins</em> were introduced in SQL-92 and, unlike inner joins and cross joins, have only one standard syntax—the one in which the <code>JOIN</code> keyword is specified between the table names and the join condition is specified in the <code>ON</code> clause.</p>
</div>
<div class="paragraph">
<p>Outer joins apply the two logical processing phases that inner joins apply (Cartesian Product and the <code>ON</code> filter), plus a third phase called Adding Outer Rows that is unique to this type of join.</p>
</div>
<div class="paragraph">
<p>In an outer join, a table is marked as a preserved table by using the keywords <code>LEFT OUTER JOIN</code>, <code>RIGHT OUTER JOIN</code>, or <code>FULL OUTER JOIN</code> between the table names.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>OUTER</code> keyword is optional.</p>
</li>
<li>
<p>The <code>LEFT</code> keyword means that the rows of the left table (the one to the left of the <code>JOIN</code> keyword) are preserved; the <code>RIGHT</code> keyword means that the rows in the right table are preserved; and the <code>FULL</code> keyword means that the rows in both the left and right tables are preserved.</p>
</li>
<li>
<p>The third logical query processing phase of an outer join identifies the rows from the preserved table that did not find matches in the other table based on the <code>ON</code> predicate, which adds those rows to the result table produced by the first two phases of the join, and it uses NULLs as placeholders for the attributes from the nonpreserved side of the join in those outer rows.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="k">C</span><span class="p">.</span><span class="n">companyname</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">ON</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A <code>FULL OUTER JOIN</code> with the condition <code>ON 1=1</code> is functionally equivalent to a <code>CROSS JOIN</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the predicate in the <code>WHERE</code> clause refers to an attribute from the nonpreserved side of the join using an expression in the form <code>&lt;attribute&gt; &lt;operator&gt; &lt;value&gt;</code>, because attributes from the nonpreserved side of the join are NULLs in outer rows, and an expression in the form <code>NULL &lt;operator&gt; &lt;value&gt;</code> yields <code>UNKNOWN</code> (unless it’s the <code>IS NULL</code> operator explicitly looking for NULLs, or the distinct predicate <code>IS [NOT] DISTINCT FROM</code>), it’s usually an indication of a bug,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="k">C</span><span class="p">.</span><span class="n">companyname</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">ON</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span>
<span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">orderdate</span> <span class="o">&gt;=</span> <span class="s1">'20220101'</span><span class="p">;</span> <span class="c1">-- Effectively, the join becomes an inner join.</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the predicate in the inner join’s <code>ON</code> clause compares an attribute from the nonpreserved side of the outer join and an attribute from the third table, all outer rows are discarded.</p>
</div>
<div class="paragraph">
<p>Remember that outer rows have NULLs in the attributes from the nonpreserved side of the join, and comparing a NULL with anything yields <code>UNKNOWN</code>. <code>UNKNOWN</code> is filtered out by the <code>ON</code> filter. In other words, such a predicate nullifies the outer join, effectively turning it into an inner join.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- outer rows are dropped whenever any kind of outer join (left, right, or full) is</span>
<span class="c1">-- followed by a subsequent inner join or right outer join.</span>
<span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span><span class="p">,</span> <span class="n">OD</span><span class="p">.</span><span class="n">productid</span><span class="p">,</span> <span class="n">OD</span><span class="p">.</span><span class="n">qty</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">ON</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span> <span class="k">AS</span> <span class="n">OD</span>
  <span class="k">ON</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span> <span class="o">=</span> <span class="n">OD</span><span class="p">.</span><span class="n">orderid</span><span class="p">;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="apply">5.4. APPLY</h3>
<div class="paragraph">
<p>The nonstandard <code>APPLY</code> operator, like a correlated join, instead of treaing its two inputs as a set, applies the right table (typically a derived table or a TVF) to each row from the left table (evaluated first) and produces a result table with the unified result sets.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>CROSS APPLY</code> operator is equavelent to a <code>CROSS JOIN</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">S</span><span class="p">.</span><span class="n">shipperid</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Shippers</span> <span class="k">AS</span> <span class="n">S</span>
  <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E</span><span class="p">;</span>
<span class="c1">-- =&gt;</span>
<span class="k">SELECT</span> <span class="n">S</span><span class="p">.</span><span class="n">shipperid</span><span class="p">,</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Shippers</span> <span class="k">AS</span> <span class="n">S</span>
  <span class="k">CROSS</span> <span class="n">APPLY</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>With <code>APPLY</code>, the left side is evaluated first, and the right side is evaluated per row from the left iteratively, and can have references to elements from the left.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">orderid</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
  <span class="k">CROSS</span> <span class="n">APPLY</span>
    <span class="p">(</span><span class="k">SELECT</span> <span class="n">TOP</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">requireddate</span>
     <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
     <span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span>
     <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">orderid</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">AS</span> <span class="n">A</span><span class="p">;</span> <span class="c1">-- A is a correlated derived table</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Because the derived table is applied to each left row, the CROSS APPLY operator returns the three most recent orders for each customer.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">1	11011	2022-04-09
1	10952	2022-03-16
1	10835	2022-01-15
2	10926	2022-03-04
2	10759	2021-11-28
2	10625	2021-08-08
3	10856	2022-01-28
3	10682	2021-09-25
3	10677	2021-09-22
. . .</span></code></pre>
</div>
</div>
</li>
<li>
<p>If the right table expression returns an empty set, the <code>CROSS APPLY</code> operator does not return the corresponding left row.  To return rows from the left side even if there are no matches on the right side, use <code>OUTER APPLY</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">orderid</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
  <span class="k">OUTER</span> <span class="n">APPLY</span>
    <span class="p">(</span><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">requireddate</span>
     <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
     <span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span> <span class="k">AND</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="k">in</span> <span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="mi">57</span><span class="p">)</span>
     <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">orderid</span> <span class="k">DESC</span>
     <span class="k">OFFSET</span> <span class="mi">0</span> <span class="k">ROWS</span> <span class="k">FETCH</span> <span class="k">FIRST</span> <span class="mi">3</span> <span class="k">ROWS</span> <span class="k">ONLY</span><span class="p">)</span> <span class="k">AS</span> <span class="n">A</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">1	NULL	NULL
2	NULL	NULL
3	NULL	NULL</span></code></pre>
</div>
</div>
</li>
<li>
<p>It&#8217;s more conventional to work with inline TVFs instead of derived tables.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">FUNCTION</span> <span class="n">dbo</span><span class="p">.</span><span class="n">TopOrders</span>
  <span class="p">(</span><span class="o">@</span><span class="n">custid</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">,</span> <span class="o">@</span><span class="n">n</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">)</span>
  <span class="k">RETURNS</span> <span class="k">TABLE</span>
<span class="k">AS</span>
<span class="k">RETURN</span>
  <span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">requireddate</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
  <span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="o">@</span><span class="n">custid</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">requireddate</span> <span class="k">DESC</span>
  <span class="k">OFFSET</span> <span class="mi">0</span> <span class="k">ROWS</span> <span class="k">FETCH</span> <span class="k">NEXT</span> <span class="o">@</span><span class="n">N</span> <span class="k">ROWS</span> <span class="k">ONLY</span><span class="p">;</span>
<span class="k">GO</span>

<span class="k">SELECT</span>
  <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="k">C</span><span class="p">.</span><span class="n">companyname</span><span class="p">,</span>
  <span class="n">A</span><span class="p">.</span><span class="n">orderid</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">orderdate</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">requireddate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
  <span class="k">CROSS</span> <span class="n">APPLY</span> <span class="n">dbo</span><span class="p">.</span><span class="n">TopOrders</span><span class="p">(</span><span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">AS</span> <span class="n">A</span><span class="p">;</span>
<span class="k">GO</span>

<span class="c1">-- cleanup</span>
<span class="k">DROP</span> <span class="k">FUNCTION</span> <span class="n">if</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">TopOrders</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="subqueries">6. Subqueries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SQL supports writing queries within queries, or <em>nesting</em> queries.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The outermost query is a query whose result set is returned to the caller and is known as the <em>outer query</em>.</p>
</li>
<li>
<p>The inner query is a query whose result set is used by the outer query and is known as a <em>subquery</em>.</p>
</li>
<li>
<p>A subquery can be either <em>self-contained</em> or <em>correlated</em>.</p>
<div class="ulist">
<ul>
<li>
<p>A self-contained subquery has no dependency on tables from the outer query, whereas a correlated subquery does.</p>
</li>
<li>
<p>A subquery can be single-valued, multivalued, or table-valued, that is, a subquery can return a single value, multiple values, or a whole table result.</p>
</li>
<li>
<p>In queries that include a <em>correlated subquery</em> (a.k.a., a <em>repeating subquery</em>), the subquery depends on the outer query for its values, which means that the subquery is executed repeatedly, once for each row that might be selected by the outer query.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O1</span>
<span class="k">WHERE</span> <span class="n">orderid</span> <span class="o">=</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">O2</span><span class="p">.</span><span class="n">orderid</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O2</span>
<span class="k">WHERE</span> <span class="n">O2</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="n">O1</span><span class="p">.</span><span class="n">custid</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A scalar subquery is a subquery that return a single value or <code>NULL</code> and can be anywhere in the outer query where a single-valued expression expected, such as <code>WHERE</code> or <code>SELECT</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">maxid</span> <span class="k">AS</span> <span class="nb">INT</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">orderid</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderid</span> <span class="o">=</span> <span class="o">@</span><span class="n">maxid</span><span class="p">;</span>
<span class="c1">-- substitute the above variable with a scalar self-contained subquery</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderid</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">O</span><span class="p">.</span><span class="n">orderid</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>A multi-valued subquery is a subquery that returns multiple values as a single column, and such as the <code>IN</code> predicate, operate on a multi-valued subquery.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">empid</span> <span class="k">IN</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="n">E</span><span class="p">.</span><span class="n">empid</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="n">E</span>
<span class="k">WHERE</span> <span class="n">E</span><span class="p">.</span><span class="n">lastname</span> <span class="k">LIKE</span> <span class="n">N</span><span class="s1">'D%'</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In some cases the database engine optimizes both the subquery and the the join the same way, sometimes joins perform better, and sometimes subqueries perform better.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="subqueries-with-in-or-not-in">6.1. Subqueries with IN or NOT IN</h3>
<div class="ulist">
<ul>
<li>
<p>A subquery introduced with <code>IN</code> or <code>NOT IN</code> provides a set of zero or more values for the outer query&#8217;s filtering.</p>
</li>
<li>
<p>An empty set will cause the <code>IN</code> condition to always be <code>FALSE</code>, and the <code>NOT IN</code> condition to always be <code>TRUE</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="subqueries-with-comparison-operators">6.2. Subqueries with comparison operators</h3>
<div class="ulist">
<ul>
<li>
<p>Subqueries can be introduced with one of the comparison operators (<code>=</code>, <code>&lt; &gt;</code>, <code>&gt;</code>, <code>&gt; =</code>, <code>&lt;</code>, <code>! &gt;</code>, <code>! &lt;</code>, or <code>&lt; =</code>).</p>
</li>
<li>
<p>A subquery introduced with an unmodified comparison operator (a comparison operator not followed by <code>ANY</code>, <code>SOME</code> or <code>ALL</code>) must return a single value rather than a list of values, like subqueries introduced with <code>IN</code>, otherwise SQL Server displays an error message.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="subqueries-with-exists-or-not-exists">6.3. Subqueries with EXISTS or NOT EXISTS</h3>
<div class="ulist">
<ul>
<li>
<p>A subquery introduced with <code>EXISTS</code> or <code>NOT EXISTS</code> functions as an existence test, returning <code>TRUE</code> or <code>FALSE</code> to the outer query&#8217;s <code>WHERE</code> clause based on the presence or absence of rows, without actually producing data.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">companyname</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
<span class="k">WHERE</span> <span class="n">country</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'Spain'</span>
  <span class="k">AND</span> <span class="k">EXISTS</span>
     <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="table-expressions">7. Table Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>table expression</em> is an expression—typically a query—that conceptually returns a table result and as such can be nested as an operand of another table expression.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Recall that a table in SQL is the counterpart to a relation in relational theory.</p>
</li>
<li>
<p>A table expression is therefore SQL’s counterpart to a relational expression.</p>
</li>
<li>
<p>A relational expression in relational theory is an expression that returns a relation and as such can be nested as an operand of another relational expression.</p>
</li>
<li>
<p>A <em>named table expression</em> is then a table expression assigned with a name, and interacted with like doing with a base table.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>T-SQL supports four types of named table expressions: <em>derived tables</em>, <em>common table expressions</em> (CTEs), <em>views</em>, and <em>inline table-valued functions</em> (inline TVFs).</p>
</div>
<div class="sect2">
<h3 id="derived-tables">7.1. Derived Tables</h3>
<div class="paragraph">
<p>Derived tables are defined in the <code>FROM</code> clause of an outer query, which treated as if it were a regular table for the outer query, and also sometimes referred to as an inline view.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">companyname</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span>
  <span class="k">WHERE</span> <span class="n">country</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'USA'</span><span class="p">)</span> <span class="k">AS</span> <span class="n">USACusts</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderyear</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">custid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">numcusts</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span> <span class="n">custid</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span><span class="p">)</span> <span class="k">AS</span> <span class="n">D</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">orderyear</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ctes">7.2. CTEs</h3>
<div class="paragraph">
<p>A Common Table Expression (CTE) is a temporary, named result set created from a query, which can then be used within the scope of a single statement such as <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>. A CTE can also refer to itself in what is known as a recursive CTE.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span> <span class="o">&lt;</span><span class="n">CTE_Name</span><span class="o">&gt;</span><span class="p">[(</span><span class="o">&lt;</span><span class="n">target_column_list</span><span class="o">&gt;</span><span class="p">)]</span>
<span class="k">AS</span>
<span class="p">(</span>
  <span class="o">&lt;</span><span class="n">inner_query_defining_CTE</span><span class="o">&gt;</span>
<span class="p">)</span>
<span class="o">&lt;</span><span class="n">outer_query_against_CTE</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>CTEs support two forms of column aliasing: <strong>inline</strong>, which uses the <code>AS</code> keyword to rename columns individually within the <code>SELECT</code> statement, and <strong>external</strong>, which defines all column names at once in a parenthesized list immediately following the CTE&#8217;s name.</p>
<div class="ulist">
<ul>
<li>
<p>Inline aliasing is the most common and recommended method, where each new column name is defined individually inside the <code>SELECT</code> list, directly following the column or expression it refers to.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span> <span class="n">UserCTE</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span>
    <span class="n">user_id</span> <span class="k">AS</span> <span class="n">ID</span><span class="p">,</span>
    <span class="n">user_name</span> <span class="k">AS</span> <span class="n">Name</span>
  <span class="k">FROM</span> <span class="n">users</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="n">ID</span><span class="p">,</span> <span class="n">Name</span> <span class="k">FROM</span> <span class="n">UserCTE</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>External aliasing is an alternative method where a complete list of new column names is provided in parentheses immediately after the CTE&#8217;s name, before the query definition begins.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
While less common, this method is required in certain scenarios, such as defining the column structure for recursive CTEs.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span> <span class="n">UserCTE</span> <span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">Name</span><span class="p">)</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span>
    <span class="n">user_id</span><span class="p">,</span>
    <span class="n">user_name</span>
  <span class="k">FROM</span> <span class="n">users</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="n">ID</span><span class="p">,</span> <span class="n">Name</span> <span class="k">FROM</span> <span class="n">UserCTE</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A CTE must be immediately consumed by a single <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>MERGE</code>, or <code>DELETE</code> statement. It can also be used to define the query within a <code>CREATE VIEW</code> statement.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">RecentSalesHires</span> <span class="k">AS</span>

<span class="c1">-- 1. The CTE is defined first to simplify the logic.</span>
<span class="k">WITH</span> <span class="n">SalesEmployees</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span>
    <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">employee_name</span><span class="p">,</span>
    <span class="n">hire_date</span>
  <span class="k">FROM</span> <span class="n">employees</span>
  <span class="k">WHERE</span> <span class="n">department</span> <span class="o">=</span> <span class="s1">'Sales'</span> <span class="k">AND</span> <span class="n">status</span> <span class="o">=</span> <span class="s1">'Active'</span>
<span class="p">)</span>

<span class="c1">-- 2. The view's main SELECT statement then uses the CTE.</span>
<span class="k">SELECT</span>
  <span class="n">employee_id</span><span class="p">,</span>
  <span class="n">employee_name</span>
<span class="k">FROM</span> <span class="n">SalesEmployees</span>
<span class="k">WHERE</span> <span class="n">hire_date</span> <span class="o">&gt;=</span> <span class="nb">DATE</span><span class="p">(</span><span class="s1">'now'</span><span class="p">,</span> <span class="s1">'-1 year'</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>A single, nonrecursive CTE can be defined by the combined results of multiple <code>SELECT</code> queries that are connected by a set operator like <code>UNION ALL</code>, <code>UNION</code>, <code>INTERSECT</code>, or <code>EXCEPT</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- This single CTE is defined by two SELECT statements</span>
<span class="c1">-- combined with a set operator (UNION).</span>

<span class="k">WITH</span> <span class="n">AllContacts</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="c1">-- The first SELECT query</span>
  <span class="k">SELECT</span> <span class="n">email_address</span>
  <span class="k">FROM</span> <span class="n">ActiveCustomers</span>

  <span class="k">UNION</span>  <span class="c1">-- The set operator that combines them</span>

  <span class="c1">-- The second SELECT query</span>
  <span class="k">SELECT</span> <span class="n">email</span>
  <span class="k">FROM</span> <span class="n">ProspectiveCustomers</span>
<span class="p">)</span>

<span class="c1">-- Now you can use the CTE, which contains the combined results.</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">AllContacts</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Each CTE can refer to all previously defined CTEs, and the outer query can refer to all CTEs.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span>
  <span class="c1">-- CTE 1: Finds all employees in the 'North America' region.</span>
  <span class="n">RegionalEmployees</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">employee_name</span>
    <span class="k">FROM</span> <span class="n">employees</span>
    <span class="k">WHERE</span> <span class="n">region</span> <span class="o">=</span> <span class="s1">'North America'</span>
  <span class="p">),</span>

  <span class="c1">-- CTE 2: Calculates sales totals by joining with the first CTE.</span>
  <span class="c1">-- Note it only passes on the ID and the aggregated total.</span>
  <span class="n">EmployeeSales</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
      <span class="n">re</span><span class="p">.</span><span class="n">employee_id</span><span class="p">,</span>
      <span class="k">SUM</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">sale_amount</span><span class="p">)</span> <span class="k">AS</span> <span class="n">total_sales</span>
    <span class="k">FROM</span> <span class="n">sales</span> <span class="k">AS</span> <span class="n">s</span>
    <span class="k">JOIN</span> <span class="n">RegionalEmployees</span> <span class="k">AS</span> <span class="n">re</span> <span class="k">ON</span> <span class="n">s</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">employee_id</span>
    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">re</span><span class="p">.</span><span class="n">employee_id</span>
  <span class="p">)</span>

<span class="c1">-- The outer query now joins BOTH CTEs to get the required columns.</span>
<span class="k">SELECT</span>
  <span class="n">re</span><span class="p">.</span><span class="n">employee_name</span><span class="p">,</span>  <span class="c1">-- This column comes from the first CTE.</span>
  <span class="n">es</span><span class="p">.</span><span class="n">total_sales</span>     <span class="c1">-- This column comes from the second CTE.</span>
<span class="k">FROM</span>
  <span class="n">RegionalEmployees</span> <span class="k">AS</span> <span class="n">re</span>
<span class="k">JOIN</span>
  <span class="n">EmployeeSales</span> <span class="k">AS</span> <span class="n">es</span> <span class="k">ON</span> <span class="n">re</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">es</span><span class="p">.</span><span class="n">employee_id</span>
<span class="k">WHERE</span>
  <span class="n">es</span><span class="p">.</span><span class="n">total_sales</span> <span class="o">&gt;</span> <span class="mi">500000</span>
<span class="k">ORDER</span> <span class="k">BY</span>
  <span class="n">es</span><span class="p">.</span><span class="n">total_sales</span> <span class="k">DESC</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Multiple references in CTEs in table operators like joins</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span> <span class="n">YearlyCount</span> <span class="k">AS</span>
<span class="p">(</span>
  <span class="k">SELECT</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span>
    <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">custid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">numcusts</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="n">Cur</span><span class="p">.</span><span class="n">orderyear</span><span class="p">,</span>
  <span class="n">Cur</span><span class="p">.</span><span class="n">numcusts</span> <span class="k">AS</span> <span class="n">curnumcusts</span><span class="p">,</span> <span class="n">Prv</span><span class="p">.</span><span class="n">numcusts</span> <span class="k">AS</span> <span class="n">prvnumcusts</span><span class="p">,</span>
  <span class="n">Cur</span><span class="p">.</span><span class="n">numcusts</span> <span class="o">-</span> <span class="n">Prv</span><span class="p">.</span><span class="n">numcusts</span> <span class="k">AS</span> <span class="n">growth</span>
<span class="k">FROM</span> <span class="n">YearlyCount</span> <span class="k">AS</span> <span class="n">Cur</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">YearlyCount</span> <span class="k">AS</span> <span class="n">Prv</span>
  <span class="k">ON</span> <span class="n">Cur</span><span class="p">.</span><span class="n">orderyear</span> <span class="o">=</span> <span class="n">Prv</span><span class="p">.</span><span class="n">orderyear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>CTEs are unique among table expressions in the sense that they support recursion.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Recursive CTEs, like nonrecursive ones, are defined by the SQL standard.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span> <span class="o">&lt;</span><span class="n">CTE_Name</span><span class="o">&gt;</span><span class="p">[(</span><span class="o">&lt;</span><span class="n">target_column_list</span><span class="o">&gt;</span><span class="p">)]</span>
<span class="k">AS</span>
<span class="p">(</span>
  <span class="o">&lt;</span><span class="n">anchor_member</span><span class="o">&gt;</span>
  <span class="k">UNION</span> <span class="k">ALL</span>
  <span class="o">&lt;</span><span class="n">recursive_member</span><span class="o">&gt;</span>
<span class="p">)</span>
<span class="o">&lt;</span><span class="n">outer_query_against_CTE</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A recursive CTE is defined by at least two queries (more are possible)—at least one query known as the <em>anchor member</em> and at least one query known as the <em>recursive member</em>.</p>
</li>
<li>
<p>The <em>anchor member</em> is a query that returns a valid relational result table —like a query that is used to define a nonrecursive table expression. The anchor member query is invoked only once.</p>
</li>
<li>
<p>The <em>recursive member</em> is a query that has a reference to the CTE name and is invoked repeatedly until it returns an empty set. The reference to the CTE name represents the previous result set.</p>
</li>
<li>
<p>The first time that the recursive member is invoked, the previous result set represents whatever the anchor member returned.</p>
</li>
<li>
<p>In each subsequent invocation of the recursive member, the reference to the CTE name represents the result set returned by the previous invocation of the recursive member.</p>
</li>
<li>
<p>Both queries must be compatible in terms of the number of columns they return and the data types of the corresponding columns.</p>
</li>
<li>
<p>The reference to the CTE name in the outer query represents the unified result sets of the invocation of the anchor member and all invocations of the recursive member.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span> <span class="n">EmpsCTE</span> <span class="k">AS</span>
<span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span>
  <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
  <span class="k">WHERE</span> <span class="n">empid</span> <span class="o">=</span> <span class="mi">2</span>

  <span class="k">UNION</span> <span class="k">ALL</span>

  <span class="k">SELECT</span> <span class="k">C</span><span class="p">.</span><span class="n">empid</span><span class="p">,</span> <span class="k">C</span><span class="p">.</span><span class="n">mgrid</span><span class="p">,</span> <span class="k">C</span><span class="p">.</span><span class="n">firstname</span><span class="p">,</span> <span class="k">C</span><span class="p">.</span><span class="n">lastname</span>
  <span class="k">FROM</span> <span class="n">EmpsCTE</span> <span class="k">AS</span> <span class="n">P</span>
    <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span> <span class="k">AS</span> <span class="k">C</span>
      <span class="k">ON</span> <span class="k">C</span><span class="p">.</span><span class="n">mgrid</span> <span class="o">=</span> <span class="n">P</span><span class="p">.</span><span class="n">empid</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">EmpsCTE</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	1	Don	Funk
3	2	Judy	Lew
5	2	Sven	Mortensen
6	5	Paul	Suurs
7	5	Russell	King
9	5	Patricia	Doyle
4	3	Yael	Peled
8	3	Maria	Cameron</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>CTEs are not permitted to nest in SQL, but they can be chained sequentially in a single <code>WITH</code> clause, allowing each CTE to reference any of the ones defined before it to create a step-by-step logical flow.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">WITH</span>
  <span class="c1">-- 1. The first CTE identifies customers from a specific region.</span>
  <span class="n">US_Customers</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">customer_name</span>
    <span class="k">FROM</span> <span class="n">customers</span>
    <span class="k">WHERE</span> <span class="n">country</span> <span class="o">=</span> <span class="s1">'USA'</span>
  <span class="p">),</span>

  <span class="c1">-- 2. The second CTE is "chained" by using the first CTE as its source</span>
  <span class="c1">--    to find the recent orders for only those customers.</span>
  <span class="n">Recent_US_Orders</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
      <span class="n">usc</span><span class="p">.</span><span class="n">customer_name</span><span class="p">,</span>
      <span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="p">,</span>
      <span class="n">o</span><span class="p">.</span><span class="n">order_total</span>
    <span class="k">FROM</span> <span class="n">orders</span> <span class="k">AS</span> <span class="n">o</span>
    <span class="k">JOIN</span> <span class="n">US_Customers</span> <span class="k">AS</span> <span class="n">usc</span> <span class="k">ON</span> <span class="n">o</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">usc</span><span class="p">.</span><span class="n">customer_id</span>
    <span class="k">WHERE</span> <span class="n">o</span><span class="p">.</span><span class="n">order_date</span> <span class="o">&gt;=</span> <span class="s1">'2025-01-01'</span>
  <span class="p">)</span>

<span class="c1">-- 3. The final query uses the last CTE in the chain to get the result.</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Recent_US_Orders</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="views-and-tvfs">7.3. Views and TVFs</h3>
<div class="paragraph">
<p>Derived tables and CTEs have a single-statement scope, which means they are not reusable. <em>Views</em> and <em>inline table-valued functions</em> (inline TVFs) are two types of table expressions whose definitions are stored as permanent objects in the database, making them reusable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">VIEW</span> <span class="n">Sales</span><span class="p">.</span><span class="n">USACusts</span>
<span class="k">AS</span>
  <span class="k">SELECT</span>
    <span class="n">custid</span><span class="p">,</span> <span class="n">companyname</span><span class="p">,</span> <span class="n">contactname</span><span class="p">,</span> <span class="n">contacttitle</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
    <span class="n">city</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">postalcode</span><span class="p">,</span> <span class="n">country</span><span class="p">,</span> <span class="n">phone</span><span class="p">,</span> <span class="n">fax</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span>
  <span class="k">WHERE</span> <span class="n">country</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'USA'</span><span class="p">;</span>
<span class="k">GO</span> <span class="c1">-- The GO command is used here to terminate what’s called a batch in T-SQL.</span>

<span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">companyname</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">USACusts</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Remember that a presentation <code>ORDER BY</code> clause is not allowed in the query defining a table expression because a relation isn’t ordered.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">VIEW</span> <span class="n">Sales</span><span class="p">.</span><span class="n">USACusts</span>
<span class="k">AS</span>
  <span class="k">SELECT</span>
    <span class="n">custid</span><span class="p">,</span> <span class="n">companyname</span><span class="p">,</span> <span class="n">contactname</span><span class="p">,</span> <span class="n">contacttitle</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
    <span class="n">city</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">postalcode</span><span class="p">,</span> <span class="n">country</span><span class="p">,</span> <span class="n">phone</span><span class="p">,</span> <span class="n">fax</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span>
  <span class="k">WHERE</span> <span class="n">country</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'USA'</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">region</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 1033, Level 15, State 1, Procedure USACusts, Line 8
The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified.</span></code></pre>
</div>
</div>
</li>
<li>
<p>Inline TVFs are reusable table expressions that support input parameters.</p>
<div class="ulist">
<ul>
<li>
<p>In most respects, except for the support for input parameters, inline TVFs are similar to views, or parameterized views.</p>
</li>
<li>
<p>T-SQL supports another type of table function called multi-statement TVF, which populates and returns a table variable.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">FUNCTION</span> <span class="n">dbo</span><span class="p">.</span><span class="n">GetCustOrders</span>
   <span class="p">(</span><span class="o">@</span><span class="n">cid</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">)</span> <span class="k">RETURNS</span> <span class="k">TABLE</span>
 <span class="k">AS</span>
 <span class="k">RETURN</span>
   <span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">requireddate</span><span class="p">,</span>
     <span class="n">shippeddate</span><span class="p">,</span> <span class="n">shipperid</span><span class="p">,</span> <span class="n">freight</span><span class="p">,</span> <span class="n">shipname</span><span class="p">,</span> <span class="n">shipaddress</span><span class="p">,</span> <span class="n">shipcity</span><span class="p">,</span>
     <span class="n">shipregion</span><span class="p">,</span> <span class="n">shippostalcode</span><span class="p">,</span> <span class="n">shipcountry</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="o">@</span><span class="n">cid</span><span class="p">;</span>
<span class="k">GO</span>

<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">GetCustOrders</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">O</span><span class="p">;</span>
<span class="k">GO</span>

<span class="k">SELECT</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">OD</span><span class="p">.</span><span class="n">productid</span><span class="p">,</span> <span class="n">OD</span><span class="p">.</span><span class="n">qty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">GetCustOrders</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span> <span class="k">AS</span> <span class="n">OD</span>
  <span class="k">ON</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span> <span class="o">=</span> <span class="n">OD</span><span class="p">.</span><span class="n">orderid</span><span class="p">;</span>
<span class="k">GO</span>

<span class="k">DROP</span> <span class="k">FUNCTION</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">GetCustOrders</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="union-union-all-intersect-and-except">8. UNION, UNION ALL, INTERSECT, and EXCEPT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set operators combine rows from two query result sets (or multisets), with some operators removing duplicates to return a set, while others preserve duplicates to return a multiset.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>T-SQL supports the following operators: <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, and <code>EXCEPT</code>.</p>
</li>
<li>
<p>A set operator compares complete rows between the results of the two input queries involved.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">Input</span> <span class="n">Query1</span>
<span class="o">&lt;</span><span class="n">set_operator</span><span class="o">&gt;</span>
<span class="k">Input</span> <span class="n">Query2</span>
<span class="p">[</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="p">...];</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Because a set operator expects multisets as inputs, the two queries involved cannot have <code>ORDER BY</code> clauses.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that a query with an ORDER BY clause does not return a multiset—it returns an ordered result.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>In terms of logical-query processing, each of the individual queries can have all logical-query processing phases except for a presentation <code>ORDER BY</code>.</p>
</li>
<li>
<p>The operator is applied to the results of the two queries, and the outer <code>ORDER BY</code> clause (if one exists) is applied to the result of the operator.</p>
</li>
<li>
<p>The two input queries must produce results with the same number of columns, and corresponding columns must have compatible data types.</p>
</li>
<li>
<p>The names of the columns in the result are determined by the first query. Still, it’s considered a best practice to make sure that all columns have names in both queries, and that the names of the corresponding columns are the same.</p>
</li>
<li>
<p>When a set operator compares rows between the two inputs, it doesn’t use an equality-based comparison; rather, it uses a distinctness-based comparison.</p>
<div class="paragraph">
<p>The semantics of distinctness-based comparisons are the same as the ones used by a standard predicate called the <em>distinct predicate</em>  that treats NULLs just like non-NULL values for comparison purposes to ensure that two rows with NULL values in the same columns are treated as duplicates, which is often the desired behavior.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The SQL standard supports two "flavors" of each operator—<code>DISTINCT</code> (the default) and <code>ALL</code>.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>DISTINCT</code> flavor eliminates duplicates and returns a set.</p>
</li>
<li>
<p><code>ALL</code> doesn’t attempt to remove duplicates and therefore returns a multiset.</p>
</li>
<li>
<p>All three operators in T-SQL support an implicit distinct version, but only the <code>UNION</code> operator supports the <code>ALL</code> version.</p>
</li>
<li>
<p>In terms of syntax, T-SQL implicitly applies the <code>DISTINCT</code> clause unless the <code>ALL</code> keyword is explicitly used.</p>
</li>
</ul>
</div>
</li>
<li>
<p>SQL defines precedence among set operators: <code>INTERSECT</code> operator precedes <code>UNION</code> and <code>EXCEPT</code>, and <code>UNION</code> and <code>EXCEPT</code> are evaluated in order of appearance.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- the result is a multiset and not a set</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- returns distinct locations</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- returns only distinct rows that appear in both input query results</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">INTERSECT</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- returns only distinct rows that appear in the first set but not the second</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">EXCEPT</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Suppliers</span>
<span class="k">EXCEPT</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">INTERSECT</span> <span class="c1">-- evaluated first</span>
<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-analysis">9. Data Analysis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>T-SQL in SQL Server offers robust features for data analysis, including window Functions, pivoting, unpivoting, grouping sets, and time series data handling.</p>
</div>
<div class="sect2">
<h3 id="window-functions">9.1. Window Functions</h3>
<div class="paragraph">
<p>A <em>window function</em> is a function that, for each row, computes a scalar result value based on a calculation against a subset as a window of the rows from the underlying query set.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Window functions perform calculations on a per-row basis within a defined window of rows, preserving detail, whereas grouped queries lose detail by aggregation.</p>
</li>
<li>
<p>Window functions operate directly on the underlying query result set, while subqueries often start with a fresh view of the data, potentially requiring duplication of query logic.</p>
</li>
<li>
<p>Window functions can define the order of rows for calculations separately from the presentation order of the result set.</p>
</li>
<li>
<p>Window functions are allowed only in the <code>SELECT</code> and <code>ORDER BY</code> clauses of a query.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A window function is defined by using the <code>OVER</code> clause with up to three parts: window-partition, window-order, and window-frame.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="o">&lt;</span><span class="k">function</span><span class="o">&gt;</span><span class="p">(</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">[</span> <span class="k">IGNORE</span> <span class="n">NULLS</span> <span class="o">|</span> <span class="n">RESPECT</span> <span class="n">NULLS</span> <span class="p">]</span> <span class="n">OVER</span><span class="p">(...)</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>An empty <code>OVER()</code> clause represents the entire underlying query’s result set.</p>
</li>
<li>
<p>The <em>window-partition</em> clause (<code>PARTITION BY</code>) restricts the window to the subset of rows that have the same values in the partitioning columns as in the current row.</p>
</li>
<li>
<p>The <em>window-order</em> clause (<code>ORDER BY</code>) defines ordering, but don’t confuse this with presentation ordering.</p>
<div class="ulist">
<ul>
<li>
<p>In a window aggregate function, window ordering supports a frame specification.</p>
</li>
<li>
<p>In a window ranking function, window ordering gives meaning to the rank.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <em>window-frame</em> filters a frame, or a subset, of rows from the window partition between the two specified delimiters, which is defined using the <code>ROWS</code> or <code>RANGE</code> clause.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>ROWS</code>: Defines the frame based on the number of rows before and after the current row.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="o">&lt;</span><span class="n">top</span> <span class="k">delimiter</span><span class="o">&gt;</span> <span class="k">AND</span> <span class="o">&lt;</span><span class="n">bottom</span> <span class="k">delimiter</span><span class="o">&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UNBOUNDED PRECEDING</code>: Includes all rows from the beginning of the partition up to the current row.</p>
</li>
<li>
<p><code>n PRECEDING</code>: Includes the current row and the <code>n</code> preceding rows.</p>
</li>
<li>
<p><code>CURRENT ROW</code>: Includes only the current row.</p>
</li>
<li>
<p><code>n FOLLOWING</code>: Includes the current row and the <code>n</code> following rows.</p>
</li>
<li>
<p><code>UNBOUNDED FOLLOWING</code>: Includes all rows from the current row to the end of the partition.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>RANGE</code>: Defines the frame based on the values of the <code>ORDER BY</code> column.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">RANGE</span> <span class="k">BETWEEN</span> <span class="o">&lt;</span><span class="n">top</span> <span class="k">delimiter</span><span class="o">&gt;</span> <span class="k">AND</span> <span class="o">&lt;</span><span class="n">bottom</span> <span class="k">delimiter</span><span class="o">&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UNBOUNDED PRECEDING</code>: Includes all rows from the beginning of the partition up to the current row.</p>
</li>
<li>
<p><code>n PRECEDING</code>: Includes rows where the <code>ORDER BY</code> column&#8217;s value is within <code>n</code> units of the current row&#8217;s value.</p>
</li>
<li>
<p><code>CURRENT ROW</code>: Includes only the current row.</p>
</li>
<li>
<p><code>n FOLLOWING</code>: Includes rows where the <code>ORDER BY</code> column&#8217;s value is within <code>n</code> units of the current row&#8217;s value.</p>
</li>
<li>
<p><code>UNBOUNDED FOLLOWING</code>: Includes all rows from the current row to the end of the partition.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- compute the running-total for each employee and month</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span>
                <span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">empid</span> <span class="c1">-- For an underlying row with employee ID `1`, the window exposed to the function filters only the rows where the employee ID is `1`.</span>
                <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ordermonth</span>
                <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span> <span class="k">AND</span> <span class="k">CURRENT</span> <span class="k">ROW</span>
               <span class="p">)</span> <span class="k">AS</span> <span class="n">runval</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">EmpOrders</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">1	2020-07-01	1614.88	1614.88
1	2020-08-01	5555.90	7170.78
1	2020-09-01	6651.00	13821.78
. . .</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="ranking">9.1.1. Ranking</h4>
<div class="paragraph">
<p>T-SQL supports four ranking functions: <code>ROW_NUMBER</code>, <code>RANK</code>, <code>DENSE_RANK</code>, and <code>NTILE</code> to rank each row with respect to others in the window.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">val</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rownum</span><span class="p">,</span>
  <span class="n">RANK</span><span class="p">()</span>       <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">val</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rank</span><span class="p">,</span>
  <span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">val</span><span class="p">)</span> <span class="k">AS</span> <span class="n">dense_rank</span><span class="p">,</span>
  <span class="n">NTILE</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>    <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">val</span><span class="p">)</span> <span class="k">AS</span> <span class="n">ntile</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">val</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">orderid	custid	val	rownum	rank	dense_rank	ntile</span>
<span class="go">10782	12	12.50	1	1	1	1</span>
<span class="go">10807	27	18.40	2	2	2	1</span>
<span class="go">10586	66	23.80	3	3	3	1</span>
<span class="go">10767	76	28.00	4	4	4	1</span>
<span class="go">10898	54	30.00	5	5	5	1</span>
<span class="go">10900	88	33.75	6	6	6	1</span>
<span class="hll"><span class="go">10883	48	36.00	7	7	7	1</span>
</span><span class="hll"><span class="go">11051	41	36.00	8	7	7	1</span>
</span><span class="go">10815	71	40.00	9	9	8	1</span>
<span class="go">10674	38	45.00	10	10	9	1</span>
<span class="hll"><span class="go">11057	53	45.00	11	10	9	1</span>
</span><span class="hll"><span class="go">10271	75	48.00	12	12	10	1</span>
</span><span class="go">. . .</span>
<span class="go">10496	81	190.00	83	83	78	1</span>
<span class="hll"><span class="go">10793	4	191.10	84	84	79	2</span>
</span><span class="go">10428	66	192.00	85	85	80	2</span>
<span class="go">. . .</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>ROW_NUMBER</code> function assigns incremental sequential integers to the rows in the query result based on the mandatory window ordering.</p>
</li>
<li>
<p>The <code>RANK</code> or <code>DENSE_RANK</code> function will produce same value when there are ties in the ordering values, and the difference between the two is that <code>RANK</code> reflects the count of rows that have a lower ordering value than the current row (plus 1), whereas <code>DENSE_RANK</code> reflects the count of distinct ordering values that are lower than the current row (plus 1).</p>
</li>
<li>
<p>The <code>NTILE</code> function assigns a tile number to each row associated the rows in the result with tiles (equally sized groups of rows).</p>
<div class="paragraph">
<p>If the number of rows can’t be evenly divided by the number of tiles, an extra row is added to each of the first tiles from the remainder. For example, if 102 rows and five tiles were requested, the first two tiles would have 21 rows instead of 20.</p>
</div>
</li>
<li>
<p>Window functions are logically evaluated as part of the <code>SELECT</code> list, before the <code>DISTINCT</code> clause is evaluated.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- DISTINCT clause has no effect here, no duplicate rows to remove</span>
<span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">val</span><span class="p">,</span> <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">val</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rownum</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- an alternative solution: GROUP BY phase is processed before the SELECT phase</span>
<span class="k">SELECT</span> <span class="n">val</span><span class="p">,</span> <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">val</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rownum</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">val</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="offset">9.1.2. Offset</h4>
<div class="paragraph">
<p>T-SQL supports two pairs of offset functions: <code>LAG</code> and <code>LEAD</code>, and <code>FIRST_VALUE</code> and <code>LAST_VALUE</code>, to return an element from a row that is at a certain offset from the current row or at the beginning or end of a window frame.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>LAG</code> and <code>LEAD</code> functions look before and ahead respectively to obtain an element from a row that is at a certain offset from the current row within the partition, based on the indicated ordering.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- the LAG and LEAD functions support window partitions and window-order clauses.</span>
<span class="n">LAG</span><span class="p">(</span><span class="k">column_name</span><span class="p">,</span> <span class="k">offset</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>  <span class="n">OVER</span><span class="p">(...)</span>
<span class="n">LEAD</span><span class="p">(</span><span class="k">column_name</span><span class="p">,</span> <span class="k">offset</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(...)</span></code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>column_name</code>: the functions (which is mandatory) is the element to return.</p>
</li>
<li>
<p><code>offset</code>: (Optional) An integer specifying the number (<code>1</code> if not specified) of rows to offset from the current row.</p>
</li>
<li>
<p><code>default_value</code>: (Optional) A value to be returned if there is no row at the requested offset (which is <code>NULL</code> if not specified otherwise).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="n">LAG</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>  <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span> <span class="c1">-- same as: LAG(val, 1, NULL)</span>
                 <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">prevval</span><span class="p">,</span>
  <span class="n">LEAD</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span> <span class="c1">-- same as: LEAD(val, 1, NULL)</span>
                 <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">nextval</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">custid	orderid	val	prevval	nextval
. . .
1	10952	471.20	845.80	933.50
1	11011	933.50	471.20	NULL
2	10308	88.80	NULL	479.75
2	10625	479.75	88.80	320.00
. . .</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>FIRST_VALUE</code> and <code>LAST_VALUE</code> functions return an element from the first and last rows in the window frame, respectively.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>To obtain the element from the first row in the window partition, use <code>FIRST_VALUE</code> with the window-frame extent <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>.</p>
</li>
<li>
<p>To obtain the element from the last row in the window partition, use <code>LAST_VALUE</code> with the window-frame extent <code>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="n">FIRST_VALUE</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span>
                        <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span>
                        <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span>
                                 <span class="k">AND</span> <span class="k">CURRENT</span> <span class="k">ROW</span><span class="p">)</span> <span class="k">AS</span> <span class="n">firstval</span><span class="p">,</span>
  <span class="n">LAST_VALUE</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span>
                        <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span>
                        <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="k">CURRENT</span> <span class="k">ROW</span>
                                 <span class="k">AND</span> <span class="n">UNBOUNDED</span> <span class="k">FOLLOWING</span><span class="p">)</span> <span class="k">AS</span> <span class="n">lastval</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">custid	orderid	val	firstval	lastval
1	10643	814.50	814.50	933.50
. . .
1	11011	933.50	814.50	933.50
2	10308	88.80	88.80	514.40
. . .</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aggregate">9.1.3. Aggregate</h4>
<div class="paragraph">
<p>The aggregate window functions aggregate the rows in the defined window, and support window-partition, window-order, and window-frame clauses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="mi">100</span><span class="p">.</span> <span class="o">*</span> <span class="n">val</span> <span class="o">/</span> <span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">()</span> <span class="k">AS</span> <span class="n">pctall</span><span class="p">,</span> <span class="c1">-- percentage out of the grand total</span>
  <span class="mi">100</span><span class="p">.</span> <span class="o">*</span> <span class="n">val</span> <span class="o">/</span> <span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">pctcust</span> <span class="c1">-- percentage out of the customer total</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">empid</span>
                <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ordermonth</span>
                <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span>
                         <span class="k">AND</span> <span class="k">CURRENT</span> <span class="k">ROW</span><span class="p">)</span> <span class="k">AS</span> <span class="n">runval</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">EmpOrders</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="window">9.1.4. WINDOW</h4>
<div class="paragraph">
<p>The WINDOW clause defines and names reusable entire window specifications or part of them, improving code readability and maintainability by reducing redundancy in complex queries with multiple window functions. It is available in SQL Server 2022 and higher, as well as in Azure SQL Database, provided that the database compatibility level is set to 160 or higher.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">DATABASEPROPERTYEX</span><span class="p">(</span><span class="n">N</span><span class="s1">'TSQLV6'</span><span class="p">,</span> <span class="n">N</span><span class="s1">'CompatibilityLevel'</span><span class="p">);</span> <span class="c1">-- 160</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When considering all major query clauses (<code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>, <code>GROUP BY</code>, <code>HAVING</code>, <code>ORDER BY</code>), place the <code>WINDOW</code> clause between the <code>HAVING</code> and <code>ORDER BY</code> clauses of the query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span> <span class="n">W</span> <span class="k">AS</span> <span class="n">runsum</span><span class="p">,</span>
  <span class="k">MIN</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span> <span class="n">W</span> <span class="k">AS</span> <span class="n">runmin</span><span class="p">,</span>
  <span class="k">MAX</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span> <span class="n">W</span> <span class="k">AS</span> <span class="n">runmax</span><span class="p">,</span>
  <span class="k">AVG</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span> <span class="n">W</span> <span class="k">AS</span> <span class="n">runavg</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">EmpOrders</span>
<span class="k">WINDOW</span> <span class="n">W</span> <span class="k">AS</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">empid</span> <span class="c1">-- name an entire window specification</span>
             <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ordermonth</span>
             <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span>
                      <span class="k">AND</span> <span class="k">CURRENT</span> <span class="k">ROW</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="n">FIRST_VALUE</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="n">PO</span>
                        <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span>
                                 <span class="k">AND</span> <span class="k">CURRENT</span> <span class="k">ROW</span><span class="p">)</span> <span class="k">AS</span> <span class="n">firstval</span><span class="p">,</span>
  <span class="n">LAST_VALUE</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>  <span class="n">OVER</span><span class="p">(</span><span class="n">PO</span>
                        <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="k">CURRENT</span> <span class="k">ROW</span>
                                 <span class="k">AND</span> <span class="n">UNBOUNDED</span> <span class="k">FOLLOWING</span><span class="p">)</span> <span class="k">AS</span> <span class="k">last</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span>
<span class="k">WINDOW</span> <span class="n">PO</span> <span class="k">AS</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span> <span class="c1">-- name part of a window specification</span>
              <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
  <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span> <span class="n">PO</span> <span class="k">AS</span> <span class="n">ordernum</span><span class="p">,</span>
  <span class="k">MAX</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="n">OVER</span> <span class="n">P</span> <span class="k">AS</span> <span class="n">maxorderdate</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="n">OVER</span> <span class="n">POF</span> <span class="k">AS</span> <span class="n">runsumqty</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">OVER</span> <span class="n">POF</span> <span class="k">AS</span> <span class="n">runsumval</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderValues</span>
<span class="k">WINDOW</span> <span class="n">P</span> <span class="k">AS</span> <span class="p">(</span> <span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span> <span class="p">),</span> <span class="c1">-- recursively reuse one window name within another</span>
       <span class="n">PO</span> <span class="k">AS</span> <span class="p">(</span> <span class="n">P</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span> <span class="p">),</span>
       <span class="n">POF</span> <span class="k">AS</span> <span class="p">(</span> <span class="n">PO</span> <span class="k">ROWS</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span> <span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">orderid</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pivoting">9.2. Pivoting</h3>
<div class="paragraph">
<p>Pivoting data involves rotating data from a state of rows to a state of columns, possibly aggregating values along the way, in many cases which is generally handled by the presentation layer for purposes such as reporting.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- create and populate the sample table dbo.Orders</span>
<span class="n">USE</span> <span class="n">TSQLV6</span><span class="p">;</span>

<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="p">(</span>
  <span class="n">orderid</span>   <span class="nb">INT</span>        <span class="k">NOT</span> <span class="k">NULL</span>
    <span class="k">CONSTRAINT</span> <span class="n">PK_Orders</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">orderdate</span> <span class="nb">DATE</span>       <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">empid</span>     <span class="nb">INT</span>        <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">custid</span>    <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">qty</span>       <span class="nb">INT</span>        <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">qty</span><span class="p">)</span>
<span class="k">VALUES</span>
  <span class="p">(</span><span class="mi">30001</span><span class="p">,</span> <span class="s1">'20200802'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">10001</span><span class="p">,</span> <span class="s1">'20201224'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">10005</span><span class="p">,</span> <span class="s1">'20201224'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">40001</span><span class="p">,</span> <span class="s1">'20210109'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">10006</span><span class="p">,</span> <span class="s1">'20210118'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">20001</span><span class="p">,</span> <span class="s1">'20210212'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">40005</span><span class="p">,</span> <span class="s1">'20220212'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">20002</span><span class="p">,</span> <span class="s1">'20220216'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">30003</span><span class="p">,</span> <span class="s1">'20220418'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">30004</span><span class="p">,</span> <span class="s1">'20200418'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">30007</span><span class="p">,</span> <span class="s1">'20220907'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- query and return the total order quantity for each employee and customer</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">empid	custid	sumqty
2	A	52
3	A	20
1	B	20
2	B	27
1	C	34
3	C	22
3	D	30</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Pivoted view of total quantity per employee (on rows) and customer (on columns)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">empid	A	B	C	D
1	NULL	20	34	NULL
2	52	27	NULL	NULL
3	20	NULL	22	30</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Every pivoting request involves three logical processing phases, each with associated elements:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <em>grouping phase</em> with an associated grouping or on rows element</p>
</li>
<li>
<p>A <em>spreading phase</em> with an associated spreading or on cols element</p>
</li>
<li>
<p>An <em>aggregation phase</em> with an associated aggregation element and aggregate function</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="grouped-query">9.2.1. Grouped Query</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
      <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">custid</span> <span class="o">=</span> <span class="s1">'A'</span> <span class="k">THEN</span> <span class="n">qty</span> <span class="k">END</span> <i class="conum" data-value="2"></i><b>(2)</b>
     <span class="p">)</span> <span class="k">AS</span> <span class="n">A</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">custid</span> <span class="o">=</span> <span class="s1">'B'</span> <span class="k">THEN</span> <span class="n">qty</span> <span class="k">END</span><span class="p">)</span> <span class="k">AS</span> <span class="n">B</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">custid</span> <span class="o">=</span> <span class="s1">'C'</span> <span class="k">THEN</span> <span class="n">qty</span> <span class="k">END</span><span class="p">)</span> <span class="k">AS</span> <span class="k">C</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">custid</span> <span class="o">=</span> <span class="s1">'D'</span> <span class="k">THEN</span> <span class="n">qty</span> <span class="k">END</span><span class="p">)</span> <span class="k">AS</span> <span class="n">D</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The grouping phase is achieved with a <code>GROUP BY</code> clause—in this case, <code>GROUP BY empid</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The spreading phase is achieved in the <code>SELECT</code> clause with a <code>CASE</code> expression for each target column.
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- returns the quantity from the current row only when</span>
<span class="c1">-- the current row represents an order for customer A;</span>
<span class="c1">--  otherwise, the expression returns a NULL.</span>
<span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">custid</span> <span class="o">=</span> <span class="s1">'A'</span> <span class="k">THEN</span> <span class="n">qty</span> <span class="k">END</span></code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finally, the aggregation phase is achieved by applying the relevant aggregate function to the result of each <code>CASE</code> expression.
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- produces the result column for customer A</span>
<span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">custid</span> <span class="o">=</span> <span class="s1">'A'</span> <span class="k">THEN</span> <span class="n">qty</span> <span class="k">END</span><span class="p">)</span> <span class="k">AS</span> <span class="n">A</span></code></pre>
</div>
</div></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pivot-operator">9.2.2. PIVOT Operator</h4>
<div class="paragraph">
<p>T- SQL also supports a proprietary table operator called <code>PIVOT</code> on a source table or table expression provided to it as its left input, pivots the data, and returns a result table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="p">...</span>
<span class="k">FROM</span> <span class="o">&lt;</span><span class="n">input_table</span><span class="o">&gt;</span>
  <span class="n">PIVOT</span><span class="p">(</span><span class="o">&lt;</span><span class="n">agg_function</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">aggregation_element</span><span class="o">&gt;</span><span class="p">)</span>
          <span class="k">FOR</span> <span class="o">&lt;</span><span class="n">spreading_element</span><span class="o">&gt;</span> <span class="k">IN</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">list_of_target_columns</span><span class="o">&gt;</span><span class="p">))</span>
<span class="k">WHERE</span> <span class="p">...;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>PIVOT</code> operator figures out the grouping elements implicitly by elimination, that are all attributes from the source table that were not specified as either the spreading element or the aggregation element.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- custid is the spreading element</span>
<span class="c1">-- qty is the aggregation element</span>
<span class="c1">-- the left empid is the implied grouping element</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">qty</span>
      <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">)</span> <span class="k">AS</span> <span class="n">D</span>
  <span class="n">PIVOT</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">FOR</span> <span class="n">custid</span> <span class="k">IN</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span> <span class="k">AS</span> <span class="n">P</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>As a best practice with the <code>PIVOT</code> operator, always work with a table expression and not query the underlying table directly.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- the dbo.Orders table contains the attributes orderid, orderdate, empid, custid, and qty.</span>
<span class="c1">-- the remaining attributes (orderid, orderdate, and empid) are all considered the grouping elements</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
  <span class="n">PIVOT</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">FOR</span> <span class="n">custid</span> <span class="k">IN</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span> <span class="k">AS</span> <span class="n">P</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The items in the list of the target columns must be referred to as identifiers in the <code>IN</code> clause, and be delimited using square brackets when they are irregular (contain spaces, special characters, or are reserved keywords).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">qty</span>
      <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">)</span> <span class="k">AS</span> <span class="n">D</span>
  <span class="n">PIVOT</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">FOR</span> <span class="n">empid</span> <span class="k">IN</span> <span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]))</span> <span class="k">AS</span> <span class="n">P</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unpivoting">9.3. Unpivoting</h3>
<div class="paragraph">
<p>Unpivoting is a technique that rotates data from a state of columns to a state of rows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- create and populate the sample table dbo.EmpCustOrders</span>
<span class="n">USE</span> <span class="n">TSQLV6</span><span class="p">;</span>

<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span>
<span class="p">(</span>
  <span class="n">empid</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span>
    <span class="k">CONSTRAINT</span> <span class="n">PK_EmpCustOrders</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">A</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">B</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">C</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">D</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span><span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span>
  <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">qty</span>
        <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">)</span> <span class="k">AS</span> <span class="n">D</span>
    <span class="n">PIVOT</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">FOR</span> <span class="n">custid</span> <span class="k">IN</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span> <span class="k">AS</span> <span class="n">P</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">empid	A	B	C	D
1	NULL	20	34	NULL
2	52	27	NULL	NULL
3	20	NULL	22	30</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Unpivoted data returns a row for each employee and customer, along with the order quantity</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">empid	custid	qty
1	B	20
1	C	34
2	A	52
2	B	27
3	A	20
3	C	22
3	D	30</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="apply-operator">9.3.1. APPLY Operator</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- 1. Producing copies</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span>
  <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="p">(</span><span class="k">VALUES</span><span class="p">(</span><span class="s1">'A'</span><span class="p">),(</span><span class="s1">'B'</span><span class="p">),(</span><span class="s1">'C'</span><span class="p">),(</span><span class="s1">'D'</span><span class="p">))</span> <span class="k">AS</span> <span class="k">C</span><span class="p">(</span><span class="n">custid</span><span class="p">);</span>

<span class="c1">--	empid	A	B	C	D	custid</span>
<span class="c1">--	1	NULL	20	34	NULL	A</span>
<span class="c1">--	1	NULL	20	34	NULL	B</span>
<span class="c1">--	1	NULL	20	34	NULL	C</span>
<span class="c1">--	. . .</span>

<span class="c1">-- 2. Extracting values</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">qty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span>
  <span class="c1">--  a join treats its two inputs as a set;</span>
  <span class="c1">-- use the CROSS APPLY operator instead of the CROSS JOIN operator</span>
  <span class="c1">-- to refer to the columns A, B, C, and D from the left side of the join (EmpCustOrders)</span>
  <span class="k">CROSS</span> <span class="n">APPLY</span> <span class="p">(</span><span class="k">VALUES</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span> <span class="n">A</span><span class="p">),(</span><span class="s1">'B'</span><span class="p">,</span> <span class="n">B</span><span class="p">),(</span><span class="s1">'C'</span><span class="p">,</span> <span class="k">C</span><span class="p">),(</span><span class="s1">'D'</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span> <span class="k">AS</span> <span class="k">C</span><span class="p">(</span><span class="n">custid</span><span class="p">,</span> <span class="n">qty</span><span class="p">)</span>

<span class="c1">--	empid	custid	qty</span>
<span class="c1">--	1	A	NULL</span>
<span class="c1">--	1	B	20</span>
<span class="c1">--	1	C	34</span>
<span class="c1">--	. . .</span>

<span class="c1">-- 3. Eliminating irrelevant rows</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">qty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span>
  <span class="k">CROSS</span> <span class="n">APPLY</span> <span class="p">(</span><span class="k">VALUES</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span> <span class="n">A</span><span class="p">),(</span><span class="s1">'B'</span><span class="p">,</span> <span class="n">B</span><span class="p">),(</span><span class="s1">'C'</span><span class="p">,</span> <span class="k">C</span><span class="p">),(</span><span class="s1">'D'</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span> <span class="k">AS</span> <span class="k">C</span><span class="p">(</span><span class="n">custid</span><span class="p">,</span> <span class="n">qty</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="n">qty</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span> <span class="c1">-- discard rows with a NULL in the qty column</span>

<span class="c1">--	empid	custid	qty</span>
<span class="c1">--	1	B	20</span>
<span class="c1">--	1	C	34</span>
<span class="c1">--	2	A	52</span>
<span class="c1">--	. . .</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unpivot-operator">9.3.2. UNPIVOT Operator</h4>
<div class="paragraph">
<p>T- SQL, like the <code>PIVOT</code> operator, also supports the <code>UNPIVOT</code> operator to unpivot data involved producing two result columns from any number of source columns—one to hold the source column names as strings and another to hold the source column values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="p">...</span>
<span class="k">FROM</span> <span class="o">&lt;</span><span class="n">input_table</span><span class="o">&gt;</span>
  <span class="n">UNPIVOT</span><span class="p">(</span><span class="o">&lt;</span><span class="n">values_column</span><span class="o">&gt;</span> <span class="k">FOR</span> <span class="o">&lt;</span><span class="n">names_column</span><span class="o">&gt;</span> <span class="k">IN</span><span class="p">(</span><span class="o">&lt;</span><span class="n">source_columns</span><span class="o">&gt;</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="p">...;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">qty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmpCustOrders</span>
  <span class="n">UNPIVOT</span><span class="p">(</span><span class="n">qty</span> <span class="k">FOR</span> <span class="n">custid</span> <span class="k">IN</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="k">C</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span> <span class="k">AS</span> <span class="n">U</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="grouping-sets">9.4. Grouping Sets</h3>
<div class="paragraph">
<p>A grouping set is a set of expressions to group the data by in a grouped query (a query with a <code>GROUP BY</code> clause).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Traditionally in SQL, a single grouped query defines a single grouping set.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- set(empid, custid)</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">;</span>

<span class="c1">-- set(empid)</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">;</span>

<span class="c1">-- set(custid)</span>
<span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">;</span>

<span class="c1">-- set()</span>
<span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use <code>UNION ALL</code> with <code>NULL</code> placeholders to combine multiple queries into a single result set for reporting, but potentially lead to two main problems—the length of the code and performance due to multiple scans for separated query.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span>

<span class="k">UNION</span> <span class="k">ALL</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">empid</span>

<span class="k">UNION</span> <span class="k">ALL</span>

<span class="k">SELECT</span> <span class="k">NULL</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">custid</span>

<span class="k">UNION</span> <span class="k">ALL</span>

<span class="k">SELECT</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>T-SQL supports the standard <code>GROUPING SETS</code>, <code>CUBE</code>, and <code>ROLLUP</code> subclauses of the <code>GROUP BY</code> clause, and the <code>GROUPING</code> and <code>GROUPING_ID</code> functions to define multiple grouping sets in the same query for reporting and data analysis.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>GROUPING SETS</code> subclause is a powerful enhancement to the <code>GROUP BY</code> clause to define multiple grouping sets in the same query.</p>
<div class="ulist">
<ul>
<li>
<p>The grouping sets are listed, separated by commas within the parentheses of the <code>GROUPING SETS</code> subclause, and for each grouping set list the members, separated by commas, within parentheses.</p>
</li>
<li>
<p>SQL Server typically needs fewer scans of the data than the number of grouping sets because it can roll up aggregates internally.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="k">GROUPING</span> <span class="k">SETS</span>
  <span class="p">(</span>
    <span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">),</span>
    <span class="p">(</span><span class="n">empid</span><span class="p">),</span>
    <span class="p">(</span><span class="n">custid</span><span class="p">),</span>
    <span class="p">()</span>
<span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>CUBE</code> subclause of the <code>GROUP BY</code> clause provides an abbreviated way to define multiple grouping sets.</p>
<div class="ulist">
<ul>
<li>
<p>In the parentheses of the <code>CUBE</code> subclause, provide a set of members separated by commas, and get all possible grouping sets that can be defined based on the input members.</p>
</li>
<li>
<p>In set theory, the set of all subsets of elements that can be produced from a particular set is called the <em>power set</em>.</p>
<div class="paragraph">
<p>For example, <code>CUBE(a, b, c)</code> is equivalent to <code>GROUPING SETS( (a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), () )</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">CUBE</span><span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>ROLLUP</code> subclause of the <code>GROUP BY</code> clause also provides an abbreviated way to define multiple grouping sets.</p>
<div class="ulist">
<ul>
<li>
<p>Unlike <code>CUBE</code>, which produces all possible grouping sets, <code>ROLLUP</code> assumes a hierarchy among input members and produces only grouping sets that form leading combinations of those members.</p>
<div class="paragraph">
<p>For example, whereas <code>CUBE(a, b, c)</code> produces all eight possible grouping sets, <code>ROLLUP(a, b, c)</code> produces only four based on the hierarchy <code>a&gt;b&gt;c</code> that is the equivalent of specifying <code>GROUPING SETS( (a, b, c), (a, b), (a), () )</code> rolling up the aggregations from the most granular level <code>(a, b, c)</code> to higher levels like <code>(a, b)</code> and finally to the total <code>()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- ROLLUP(YEAR(orderdate), MONTH(orderdate), DAY(orderdate))</span>
<span class="c1">-- =&gt;</span>
<span class="c1">-- GROUPING SETS(</span>
<span class="c1">--   (YEAR(orderdate), MONTH(orderdate), DAY(orderdate)),</span>
<span class="c1">--   (YEAR(orderdate), MONTH(orderdate)),</span>
<span class="c1">--   (YEAR(orderdate)),</span>
<span class="c1">--   () )</span>
<span class="k">SELECT</span>
  <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span>
  <span class="k">MONTH</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">ordermonth</span><span class="p">,</span>
  <span class="k">DAY</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderday</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">ROLLUP</span><span class="p">(</span><span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">),</span> <span class="k">MONTH</span><span class="p">(</span><span class="n">orderdate</span><span class="p">),</span> <span class="k">DAY</span><span class="p">(</span><span class="n">orderdate</span><span class="p">))</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>GROUPING</code> and <code>GROUPING_ID</code> functions are used to identify which columns in a <code>GROUP BY</code> clause are included in a group set or or are represented by a <code>NULL</code> placeholder in the aggregated result set.</p>
<div class="ulist">
<ul>
<li>
<p><code>GROUPING</code>: returns <code>1</code> when the element isn’t part of the grouping set and <code>0</code> otherwise.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span>
  <span class="k">GROUPING</span><span class="p">(</span><span class="n">empid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">grpemp</span><span class="p">,</span>
  <span class="k">GROUPING</span><span class="p">(</span><span class="n">custid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">grpcust</span><span class="p">,</span>
  <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">CUBE</span><span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">grpemp	grpcust	empid	custid	sumqty
0	0	2	A	52
0	0	3	A	20
1	0	NULL	A	72
. . .</span></code></pre>
</div>
</div>
</li>
<li>
<p><code>GROUPING_ID</code>: returns an integer bitmap in which each bit represents a different input element—the rightmost element represented by the rightmost bit.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span>
  <span class="n">GROUPING_ID</span><span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">)</span> <span class="k">AS</span> <span class="n">groupingset</span><span class="p">,</span>
  <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumqty</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">CUBE</span><span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">groupingset	empid	custid	sumqty
0          	2    	A     	52  -- 00
0          	3    	A     	20  -- 00
2          	NULL 	A     	72  -- 10
. . .</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="time-series">9.5. Time Series</h3>
<div class="paragraph">
<p>Time series data is data representing a series of events, or measurements, typically taken at regular time intervals. Time series data analysis usually involves organizing the data in <em>groups</em>, also known as <em>buckets</em>, and then aggregating some measures per bucket.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="insert-delete-truncate-update-and-merge">10. INSERT, DELETE, TRUNCATE, UPDATE, and MERGE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SQL has a set of statements known as Data Manipulation Language (DML) that includes the statements <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>TRUNCATE</code>, and <code>MERGE</code>.</p>
</div>
<div class="sect2">
<h3 id="insert">10.1. INSERT</h3>
<div class="paragraph">
<p>T-SQL provides several statements for inserting data into tables: <code>INSERT VALUES</code>, <code>INSERT SELECT</code>, <code>INSERT EXEC</code>, <code>SELECT INTO</code>, and <code>BULK INSERT</code>.</p>
</div>
<div class="sect3">
<h4 id="insert-values">10.1.1. INSERT VALUES</h4>
<div class="paragraph">
<p>The standard <code>INSERT VALUES</code> statement is used to insert rows into a table based on specified values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">)</span>
   <span class="k">VALUES</span><span class="p">(</span><span class="mi">10001</span><span class="p">,</span> <span class="s1">'20220212'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Specifying the target column names right after the table name is optional, but by doing so, it can control the value-column associations instead of relying on the order of the columns in the <code>CREATE TABLE</code> statement.</p>
</li>
<li>
<p>In T-SQL, specifying the <code>INTO</code> clause is optional.</p>
</li>
<li>
<p>If a value for a column is NOT specified, Microsoft SQL Server will use a default value if one was defined for the column.</p>
</li>
<li>
<p>If a default value isn’t defined and the column allows NULLs, a <code>NULL</code> will be used.</p>
</li>
<li>
<p>If no default is defined and the column does not allow NULLs and does not somehow get its value automatically, the <code>INSERT</code> statement will fail.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>T-SQL supports an enhanced standard <code>VALUES</code> clause that can be used to specify multiple rows separated by commas.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The enhanced standard <code>VALUES</code> statement is processed as a transaction, meaning that  if any row fails to enter the table, none of the rows in the statement enters the table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
  <span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">)</span>
<span class="k">VALUES</span>
  <span class="p">(</span><span class="mi">10003</span><span class="p">,</span> <span class="s1">'20220213'</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">10004</span><span class="p">,</span> <span class="s1">'20220214'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">10005</span><span class="p">,</span> <span class="s1">'20220213'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">10006</span><span class="p">,</span> <span class="s1">'20220215'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>The enhanced <code>VALUES</code> clause can be used as a table-value constructor to construct a derived table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="p">(</span> <span class="k">VALUES</span>
         <span class="p">(</span><span class="mi">10003</span><span class="p">,</span> <span class="s1">'20220213'</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">),</span>
         <span class="p">(</span><span class="mi">10004</span><span class="p">,</span> <span class="s1">'20220214'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">),</span>
         <span class="p">(</span><span class="mi">10005</span><span class="p">,</span> <span class="s1">'20220213'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">),</span>
         <span class="p">(</span><span class="mi">10006</span><span class="p">,</span> <span class="s1">'20220215'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">)</span> <span class="p">)</span>
     <span class="k">AS</span> <span class="n">O</span><span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">);</span> <span class="c1">-- alias(es) to the table, and the target columns</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="insert-select">10.1.2. INSERT SELECT</h4>
<div class="paragraph">
<p>The standard <code>INSERT SELECT</code> statement inserts a set of rows returned by a <code>SELECT</code> query into a target table.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>INSERT SELECT</code> statement is performed as a transaction, so if any row fails to enter the target table, none of the rows enters the table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
  <span class="k">WHERE</span> <span class="n">shipcountry</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'UK'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a system function such as <code>SYSDATETIME</code> is included in the inserted query, the function gets invoked only once for the entire query and not once per row. The exception to this rule is if globally unique identifiers (GUIDs) is generated using the <code>NEWID</code> function, which gets invoked per row.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="insert-exec">10.1.3. INSERT EXEC</h4>
<div class="paragraph">
<p>The <code>INSERT EXEC</code> statement is used to insert a result set returned from a stored procedure or a dynamic SQL batch into a target table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="n">PROC</span> <span class="n">Sales</span><span class="p">.</span><span class="n">GetOrders</span>
  <span class="o">@</span><span class="n">country</span> <span class="k">AS</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="k">AS</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">shipcountry</span> <span class="o">=</span> <span class="o">@</span><span class="n">country</span><span class="p">;</span>
<span class="k">GO</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span> <span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span><span class="p">)</span>
<span class="k">EXEC</span> <span class="n">Sales</span><span class="p">.</span><span class="n">GetOrders</span> <span class="o">@</span><span class="n">country</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'France'</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="select-into">10.1.4. SELECT INTO</h4>
<div class="paragraph">
<p>The <code>SELECT INTO</code> statement is a nonstandard (not part of the ISO and ANSI SQL) T-SQL statement that CREATEs a target table and populates it with the result set of a query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">custid</span>
<span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- SELECT INTO statement with set operations</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Locations</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span>
<span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Locations</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span>

<span class="k">EXCEPT</span>

<span class="k">SELECT</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The target table’s structure and data are based on the source table.</p>
</li>
<li>
<p>The <code>SELECT INTO</code> statement copies from the source the base structure (such as column names, types, nullability, and identity property) and the data, but does not copy from the source constraints, indexes, triggers, column properties, and permissions.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="bulk-insert">10.1.5. BULK INSERT</h4>
<div class="paragraph">
<p>The <code>BULK INSERT</code> statement is a server-side T-SQL command for high-speed data loading that requires the data file to reside on a local or network path accessible to the SQL Server service account, as the path is resolved by the server, not the client.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">BULK</span> <span class="k">INSERT</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">FROM</span> <span class="s1">'</span><span class="se">\S</span><span class="s1">erverName</span><span class="se">\S</span><span class="s1">hare</span><span class="se">\o</span><span class="s1">rders.txt'</span> <span class="c1">-- Path must be accessible by the SQL Server service</span>
<span class="k">WITH</span> <span class="p">(</span>
    <span class="n">DATAFILETYPE</span> <span class="o">=</span> <span class="s1">'char'</span><span class="p">,</span>
    <span class="n">FIELDTERMINATOR</span> <span class="o">=</span> <span class="s1">','</span><span class="p">,</span>
    <span class="n">ROWTERMINATOR</span> <span class="o">=</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">,</span>
    <span class="n">BATCHSIZE</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">TABLOCK</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While <code>BULK INSERT</code> on an on-premises SQL Server requires a local or UNC path, it can natively access files in <strong>Azure Blob Storage</strong> when used with Azure SQL Database or Azure SQL Managed Instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Example for Azure SQL</span>
<span class="c1">-- 1. Define the external data source (once)</span>
<span class="k">CREATE</span> <span class="k">EXTERNAL</span> <span class="k">DATA</span> <span class="k">SOURCE</span> <span class="n">MyBlobStorage</span>
<span class="k">WITH</span> <span class="p">(</span>
    <span class="k">TYPE</span> <span class="o">=</span> <span class="n">BLOB_STORAGE</span><span class="p">,</span>
    <span class="k">LOCATION</span> <span class="o">=</span> <span class="s1">'https://myaccount.blob.core.windows.net/mycontainer'</span>
    <span class="c1">-- Plus credential setup</span>
<span class="p">);</span>

<span class="c1">-- 2. Use it in BULK INSERT</span>
<span class="n">BULK</span> <span class="k">INSERT</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">FROM</span> <span class="s1">'data/orders.csv'</span> <span class="c1">-- Path is relative to the container</span>
<span class="k">WITH</span> <span class="p">(</span><span class="n">DATA_SOURCE</span> <span class="o">=</span> <span class="s1">'MyBlobStorage'</span><span class="p">);</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title"><code>bcp</code> and <code>SqlBulkCopy</code></div>
<div class="ulist">
<ul>
<li>
<p><code>bcp</code> (Bulk Copy Program) is a client-side command-line utility for script-automated data transfer, streaming filesystem-based files from a client machine to SQL Server.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Import data from a local client file to the Orders table</span>
bcp MyDatabase.dbo.Orders <span class="k">in </span>C:<span class="se">\D</span>ata<span class="se">\o</span>rders.csv <span class="nt">-c</span> <span class="nt">-T</span> <span class="nt">-S</span> MyServerName</code></pre>
</div>
</div>
</li>
<li>
<p><code>SqlBulkCopy</code> is an ADO.NET class offering maximum ETL flexibility by enabling applications to programmatically stream data directly into SQL Server from in-memory sources like a <code>DataTable</code> or any <code>IDataReader</code> implementation.</p>
<div class="paragraph">
<p>This example demonstrates a robust and highly performant pattern for upserting (inserting or updating) data in SQL Server. It uses <code>SqlBulkCopy</code> to quickly upload a batch of data into a temporary staging table and then uses a <code>MERGE</code> statement to apply those changes to a final destination table. The destination table is configured as a <strong>system-versioned temporal table</strong>, which automatically keeps a full history of all data changes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Create the main table to store product data</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
<span class="p">(</span>
    <span class="n">Id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">Name</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">Category</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">Price</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">LastModified</span> <span class="n">DATETIME2</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>

    <span class="c1">-- Columns for system-versioning</span>
    <span class="n">ValidFrom</span> <span class="n">DATETIME2</span> <span class="k">GENERATED</span> <span class="n">ALWAYS</span> <span class="k">AS</span> <span class="k">ROW</span> <span class="k">START</span> <span class="n">HIDDEN</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">ValidTo</span> <span class="n">DATETIME2</span> <span class="k">GENERATED</span> <span class="n">ALWAYS</span> <span class="k">AS</span> <span class="k">ROW</span> <span class="k">END</span> <span class="n">HIDDEN</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">PERIOD</span> <span class="k">FOR</span> <span class="n">SYSTEM_TIME</span> <span class="p">(</span><span class="n">ValidFrom</span><span class="p">,</span> <span class="n">ValidTo</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">WITH</span> <span class="p">(</span><span class="n">SYSTEM_VERSIONING</span> <span class="o">=</span> <span class="k">ON</span> <span class="p">(</span><span class="n">HISTORY_TABLE</span> <span class="o">=</span> <span class="n">dbo</span><span class="p">.</span><span class="n">ProductsHistory</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="csharp"><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Represents a product entity.</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Category</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Price</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">LastModified</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Performs a high-performance bulk "upsert" operation for a list of products.</span>
<span class="c1">/// It stages the data in a temporary table and then merges it into the final destination table.</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;param name="connection"&gt;An open SqlConnection to use.&lt;/param&gt;</span>
<span class="c1">/// &lt;param name="products"&gt;An enumerable of Product objects to upsert.&lt;/param&gt;</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">UpsertProductsAsync</span><span class="p">(</span><span class="n">SqlConnection</span> <span class="n">connection</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Product</span><span class="p">&gt;</span> <span class="n">products</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Create an in-memory DataTable to hold the data</span>
    <span class="kt">var</span> <span class="n">productData</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DataTable</span><span class="p">();</span>
    <span class="n">productData</span><span class="p">.</span><span class="n">Columns</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Id"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">productData</span><span class="p">.</span><span class="n">Columns</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Name"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">));</span>
    <span class="n">productData</span><span class="p">.</span><span class="n">Columns</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Category"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">));</span>
    <span class="n">productData</span><span class="p">.</span><span class="n">Columns</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Price"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">decimal</span><span class="p">));</span>
    <span class="n">productData</span><span class="p">.</span><span class="n">Columns</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"LastModified"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">DateTime</span><span class="p">));</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">p</span> <span class="k">in</span> <span class="n">products</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">productData</span><span class="p">.</span><span class="n">Rows</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">Category</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">Price</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">LastModified</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">await</span> <span class="k">using</span> <span class="nn">var</span> <span class="n">transaction</span> <span class="p">=</span> <span class="p">(</span><span class="n">SqlTransaction</span><span class="p">)</span><span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="nf">BeginTransactionAsync</span><span class="p">();</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// 1. Create a temporary table to stage the data</span>
        <span class="kt">var</span> <span class="n">createTempTableCmd</span> <span class="p">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">CreateCommand</span><span class="p">();</span>
        <span class="n">createTempTableCmd</span><span class="p">.</span><span class="n">Transaction</span> <span class="p">=</span> <span class="n">transaction</span><span class="p">;</span>
        <span class="n">createTempTableCmd</span><span class="p">.</span><span class="n">CommandText</span> <span class="p">=</span> <span class="s">@"
            CREATE TABLE #ProductStaging (
                Id INT PRIMARY KEY,
                Name NVARCHAR(255) NOT NULL,
                Category NVARCHAR(100) NOT NULL,
                Price DECIMAL(18, 2) NOT NULL,
                LastModified DATETIME2 NOT NULL
            );"</span><span class="p">;</span>
        <span class="k">await</span> <span class="n">createTempTableCmd</span><span class="p">.</span><span class="nf">ExecuteNonQueryAsync</span><span class="p">();</span>

        <span class="c1">// 2. Bulk load the data from the DataTable into the staging table</span>
        <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">bulkCopy</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SqlBulkCopy</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">SqlBulkCopyOptions</span><span class="p">.</span><span class="n">Default</span><span class="p">,</span> <span class="n">transaction</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">bulkCopy</span><span class="p">.</span><span class="n">DestinationTableName</span> <span class="p">=</span> <span class="s">"#ProductStaging"</span><span class="p">;</span>
            <span class="n">bulkCopy</span><span class="p">.</span><span class="n">BatchSize</span> <span class="p">=</span> <span class="m">5000</span><span class="p">;</span>
            <span class="c1">// Add column mappings to ensure data goes into the correct columns</span>
            <span class="n">bulkCopy</span><span class="p">.</span><span class="n">ColumnMappings</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Id"</span><span class="p">,</span> <span class="s">"Id"</span><span class="p">);</span>
            <span class="n">bulkCopy</span><span class="p">.</span><span class="n">ColumnMappings</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Name"</span><span class="p">,</span> <span class="s">"Name"</span><span class="p">);</span>
            <span class="n">bulkCopy</span><span class="p">.</span><span class="n">ColumnMappings</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Category"</span><span class="p">,</span> <span class="s">"Category"</span><span class="p">);</span>
            <span class="n">bulkCopy</span><span class="p">.</span><span class="n">ColumnMappings</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Price"</span><span class="p">,</span> <span class="s">"Price"</span><span class="p">);</span>
            <span class="n">bulkCopy</span><span class="p">.</span><span class="n">ColumnMappings</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"LastModified"</span><span class="p">,</span> <span class="s">"LastModified"</span><span class="p">);</span>

            <span class="k">await</span> <span class="n">bulkCopy</span><span class="p">.</span><span class="nf">WriteToServerAsync</span><span class="p">(</span><span class="n">productData</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 3. Merge the staged data into the final Products table</span>
        <span class="kt">var</span> <span class="n">mergeCmd</span> <span class="p">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">CreateCommand</span><span class="p">();</span>
        <span class="n">mergeCmd</span><span class="p">.</span><span class="n">Transaction</span> <span class="p">=</span> <span class="n">transaction</span><span class="p">;</span>
        <span class="n">mergeCmd</span><span class="p">.</span><span class="n">CommandText</span> <span class="p">=</span> <span class="s">@"
            MERGE dbo.Products AS target
            USING #ProductStaging AS source
                ON target.Id = source.Id
            WHEN MATCHED THEN
                UPDATE SET
                    target.Name = source.Name,
                    target.Category = source.Category,
                    target.Price = source.Price,
                    target.LastModified = source.LastModified
            WHEN NOT MATCHED BY TARGET THEN
                INSERT (Id, Name, Category, Price, LastModified)
                VALUES (source.Id, source.Name, source.Category, source.Price, source.LastModified);"</span><span class="p">;</span>

        <span class="k">await</span> <span class="n">mergeCmd</span><span class="p">.</span><span class="nf">ExecuteNonQueryAsync</span><span class="p">();</span>

        <span class="c1">// If all operations were successful, commit the transaction</span>
        <span class="k">await</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">CommitAsync</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If any operation fails, roll back the entire transaction</span>
        <span class="k">await</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">RollbackAsync</span><span class="p">();</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="delete-and-truncate">10.2. DELETE and TRUNCATE</h3>
<div class="paragraph">
<p>T-SQL provides two statements for deleting rows from a table: <code>DELETE</code> and <code>TRUNCATE</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>DELETE</code> statement is a standard statement used to delete data from a table based on an optional filter predicate.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderdate</span> <span class="o">&lt;</span> <span class="s1">'20210101'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>DELETE</code> statement tends to be expensive when deleting a large number of rows, mainly because it’s a fully logged operation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The standard <code>TRUNCATE</code> statement deletes all rows from a table without filter.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The advantage that <code>TRUNCATE</code> has over <code>DELETE</code> is that the former is minimally logged, whereas the latter is fully logged, resulting in significant performance differences.</p>
</li>
<li>
<p><code>TRUNCATE</code> resets the identity value back to the original seed, but <code>DELETE</code> doesn’t—even when used without a filter.</p>
</li>
<li>
<p>The <code>TRUNCATE</code> statement is not allowed when the target table is referenced by a foreign-key constraint, even if the referencing table is empty and even if the foreign key is disabled.</p>
</li>
<li>
<p>The <code>TRUNCATE</code> statement can be used to truncate individual partitions in a partitioned table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">PARTITIONS</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span> <span class="k">TO</span> <span class="mi">10</span><span class="p">)</span> <span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>T-SQL supports a nonstandard <code>DELETE</code> syntax based on joins to delete rows from one table based on a filter against attributes in related rows from another table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">O</span>
 <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="k">C</span>
  <span class="k">ON</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="k">C</span><span class="p">.</span><span class="n">custid</span>
<span class="k">WHERE</span> <span class="k">C</span><span class="p">.</span><span class="n">country</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'USA'</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="update">10.3. UPDATE</h3>
<div class="paragraph">
<p>T-SQL supports a standard <code>UPDATE</code> statement to update rows in a table, and also supports nonstandard forms of the <code>UPDATE</code> statement with joins and with variables.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>UPDATE</code> statement is a standard statement to update a subset of rows in a table.</p>
<div class="ulist">
<ul>
<li>
<p>To identify the subset of rows to update, specify a predicate in a <code>WHERE</code> clause.</p>
</li>
<li>
<p>Specify the assignment of values to columns in a <code>SET</code> clause, separated by commas.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">OrderDetails</span>
  <span class="k">SET</span> <span class="n">discount</span> <span class="o">=</span> <span class="n">discount</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">05</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>T-SQL supports compound assignment operators: <code>+=</code> (plus equal), <code>−=</code> (minus equal), <code>*=</code> (multiplication equal), <code>/=</code> (division equal), <code>%=</code> (modulo equal), and others.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">OrderDetails</span>
  <span class="k">SET</span> <span class="n">discount</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">05</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>All-at-once operations: all expressions that appear in the same logical phase are evaluated as a set, logically at the same point in time.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- the assignments take place all at once, meaning that both assignments use the same value of col1—the value before the update.</span>
<span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span>
  <span class="k">SET</span> <span class="n">col1</span> <span class="o">=</span> <span class="n">col1</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">col1</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- swap the values in the columns col1 and col2</span>
<span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span>
  <span class="k">SET</span> <span class="n">col1</span> <span class="o">=</span> <span class="n">col2</span><span class="p">,</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">col1</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>UPDATE</code> statement also supports a nonstandard form based on joins that serves a filtering purpose.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">UPDATE</span> <span class="n">OD</span>
  <span class="k">SET</span> <span class="n">discount</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">05</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">OrderDetails</span> <span class="k">AS</span> <span class="n">OD</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">ON</span> <span class="n">OD</span><span class="p">.</span><span class="n">orderid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- same task by using standard code (recommended)</span>
<span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">OrderDetails</span>
  <span class="k">SET</span> <span class="n">discount</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">05</span>
<span class="k">WHERE</span> <span class="k">EXISTS</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span> <span class="o">=</span> <span class="n">OrderDetails</span><span class="p">.</span><span class="n">orderid</span>
    <span class="k">AND</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>T-SQL supports a proprietary <code>UPDATE</code> syntax that both updates data in a table and assigns values to variables at the same time.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">nextval</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">;</span>

<span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">MySequences</span>
  <span class="k">SET</span> <span class="o">@</span><span class="n">nextval</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="s1">'SEQ1'</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">@</span><span class="n">nextval</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="merge">10.4. MERGE</h3>
<div class="paragraph">
<p>T-SQL supports a statement called <code>MERGE</code> to merge data from a source into a target, applying different actions (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>) based on conditional logic.</p>
</div>
<div class="paragraph">
<p>A task achieved by a single <code>MERGE</code> statement typically translates to a combination of several other DML statements (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>) without <code>MERGE</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">MERGE</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Customers</span> <span class="k">AS</span> <span class="n">TGT</span>
<span class="k">USING</span> <span class="n">dbo</span><span class="p">.</span><span class="n">CustomersStage</span> <span class="k">AS</span> <span class="n">SRC</span>
  <span class="k">ON</span> <span class="n">TGT</span><span class="p">.</span><span class="n">custid</span> <span class="o">=</span> <span class="n">SRC</span><span class="p">.</span><span class="n">custid</span>
<span class="k">WHEN</span> <span class="n">MATCHED</span> <span class="k">THEN</span>
  <span class="k">UPDATE</span> <span class="k">SET</span>
    <span class="n">TGT</span><span class="p">.</span><span class="n">companyname</span> <span class="o">=</span> <span class="n">SRC</span><span class="p">.</span><span class="n">companyname</span><span class="p">,</span>
    <span class="n">TGT</span><span class="p">.</span><span class="n">phone</span> <span class="o">=</span> <span class="n">SRC</span><span class="p">.</span><span class="n">phone</span><span class="p">,</span>
    <span class="n">TGT</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">SRC</span><span class="p">.</span><span class="n">address</span>
<span class="k">WHEN</span> <span class="k">NOT</span> <span class="n">MATCHED</span> <span class="k">THEN</span>
  <span class="k">INSERT</span> <span class="p">(</span><span class="n">custid</span><span class="p">,</span> <span class="n">companyname</span><span class="p">,</span> <span class="n">phone</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
  <span class="k">VALUES</span> <span class="p">(</span><span class="n">SRC</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">SRC</span><span class="p">.</span><span class="n">companyname</span><span class="p">,</span> <span class="n">SRC</span><span class="p">.</span><span class="n">phone</span><span class="p">,</span> <span class="n">SRC</span><span class="p">.</span><span class="n">address</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="system-versioned-temporal-tables">11. System-Versioned Temporal Tables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Temporal tables provide a powerful mechanism for tracking changes to data over time to easily capture and query historical versions of data, which is crucial for various scenarios such as auditing, data analysis, and data recovery.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Track Data Changes: Capture all modifications (insertions, updates, deletions) to the data over time.</p>
</li>
<li>
<p>Audit Data Modifications: Track who made changes, when they were made, and the previous state of the data for auditing and compliance purposes.</p>
</li>
<li>
<p>Perform Point-in-Time Analysis: Analyze data as it existed at any point in the past.</p>
</li>
<li>
<p>Data Recovery: Easily restore previous versions of data in case of accidental deletions or updates.</p>
</li>
<li>
<p>Support Slowly Changing Dimensions: Efficiently manage slowly changing dimensions (SCDs) in data warehousing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The SQL standard supports three types of temporal tables:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>System-versioned temporal tables rely on the system transaction time to define the validity period of a row.</p>
</li>
<li>
<p>Application-time period tables rely on the application’s definition of the validity period of a row.</p>
</li>
<li>
<p>Bitemporal combines the two types just mentioned (transaction and valid time).</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
SQL Server 2022 supports only system-versioned temporal tables.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>A system-versioned temporal table has two columns representing the validity period of the row, plus a linked history table with a mirrored schema holding older states of modified rows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To create a system-versioned temporal table, make sure the table definition has all the following elements:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span> <span class="p">(</span>
  <span class="n">empid</span> <span class="nb">INT</span>                              <span class="k">NOT</span> <span class="k">NULL</span>
    <span class="k">CONSTRAINT</span> <span class="n">PK_Employees</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">empname</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>                    <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">department</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>                 <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">salary</span> <span class="nb">NUMERIC</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>                  <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">validfrom</span> <span class="n">DATETIME2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">GENERATED</span> <span class="n">ALWAYS</span> <span class="k">AS</span> <span class="k">ROW</span> <span class="k">START</span> <span class="n">HIDDEN</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="n">validto</span> <span class="n">DATETIME2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">GENERATED</span> <span class="n">ALWAYS</span> <span class="k">AS</span> <span class="k">ROW</span> <span class="k">END</span>   <span class="n">HIDDEN</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="n">PERIOD</span> <span class="k">FOR</span> <span class="n">SYSTEM_TIME</span> <span class="p">(</span><span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">)</span>
<span class="k">WITH</span> <span class="p">(</span>
  <span class="n">SYSTEM_VERSIONING</span> <span class="o">=</span> <span class="k">ON</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">(</span>
      <span class="n">HISTORY_TABLE</span> <span class="o">=</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmployeesHistory</span><span class="p">,</span> <i class="conum" data-value="5"></i><b>(5)</b>
      <span class="n">HISTORY_RETENTION_PERIOD</span> <span class="o">=</span> <span class="mi">5</span> <span class="n">YEARS</span>    <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">)</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A primary key</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Two columns defined as <code>DATETIME2</code> with any precision, which are non-nullable and represent the start and end of the row’s validity period in the UTC time zone
<div class="ulist">
<ul>
<li>
<p>A start column that should be marked with the option <code>GENERATED ALWAYS AS ROW START</code></p>
</li>
<li>
<p>An end column that should be marked with the option <code>GENERATED ALWAYS AS ROW END</code></p>
</li>
<li>
<p>Optionally, the period columns can be marked as hidden so that when querying the table with <code>SELECT *</code> they won’t be returned and when inserting data they’ll be ignored.</p>
</li>
<li>
<p>The modification times that SQL Server records in the period columns reflect the transaction start time.</p>
<div class="paragraph">
<p>If a long-running transaction that started at point in time T1 and ended at T2, SQL Server will record T1 as the modification time for all statements.</p>
</div>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A designation of the period columns with the option <code>PERIOD FOR SYSTEM_TIME (&lt;startcol&gt;, &lt;endcol&gt;)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The table option <code>SYSTEM_VERSIONING</code>, which should be set to <code>ON</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A linked history table (which SQL Server can create automatically) to hold the past states of modified rows
<div class="paragraph">
<p>If do not specify a name for the table, SQL Server assigns one using the form <code>MSSQL_TemporalHistoryFor_&lt;object_id&gt;</code>, where <code>object_id</code> is the object ID of the current table.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Optionally, define a history retention policy using the HISTORY_RETENTION_PERIOD subclause of the SYSTEM_VERSIONING clause.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>To drop a system-versioned table, first disable system versioning with an ALTER TABLE command, and then manually drop the current and history tables.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">IF</span> <span class="n">OBJECT_ID</span><span class="p">(</span><span class="n">N</span><span class="s1">'dbo.Employees'</span><span class="p">,</span> <span class="n">N</span><span class="s1">'U'</span><span class="p">)</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="k">BEGIN</span>
  <span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span> <span class="k">SET</span> <span class="p">(</span> <span class="n">SYSTEM_VERSIONING</span> <span class="o">=</span> <span class="k">OFF</span> <span class="p">);</span>
  <span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmployeesHistory</span><span class="p">;</span>
  <span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>When modifying data, interact with the current table, issuing normal data-modification statements.</p>
<div class="paragraph">
<p>SQL Server automatically updates the period columns and moves older versions of rows to the history table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span> <span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">)</span>
  <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Sara'</span><span class="p">,</span> <span class="s1">'IT'</span>       <span class="p">,</span> <span class="mi">50000</span><span class="p">.</span><span class="mi">00</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Don'</span> <span class="p">,</span> <span class="s1">'HR'</span>       <span class="p">,</span> <span class="mi">45000</span><span class="p">.</span><span class="mi">00</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'Judy'</span><span class="p">,</span> <span class="s1">'Sales'</span>    <span class="p">,</span> <span class="mi">55000</span><span class="p">.</span><span class="mi">00</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">'Yael'</span><span class="p">,</span> <span class="s1">'Marketing'</span><span class="p">,</span> <span class="mi">55000</span><span class="p">.</span><span class="mi">00</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">'Sven'</span><span class="p">,</span> <span class="s1">'IT'</span>       <span class="p">,</span> <span class="mi">45000</span><span class="p">.</span><span class="mi">00</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s1">'Paul'</span><span class="p">,</span> <span class="s1">'Sales'</span>    <span class="p">,</span> <span class="mi">40000</span><span class="p">.</span><span class="mi">00</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- current table has the six new rows</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span>

<span class="c1">-- history table is empty at this point</span>
<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmployeesHistory</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- SQL Server moves the deleted row to the history table, setting its validto value to the deletion time.</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">empid</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmployeesHistory</span><span class="p">;</span>
<span class="c1">-- 6	Paul	Sales	40000.00	2025-01-15 03:42:15	2025-01-15 03:44:53</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- An update of a row is treated as a delete plus an insert.</span>
<span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
  <span class="k">SET</span> <span class="n">salary</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">05</span>
<span class="k">WHERE</span> <span class="n">department</span> <span class="o">=</span> <span class="s1">'IT'</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">department</span> <span class="o">=</span> <span class="s1">'IT'</span><span class="p">;</span>
<span class="c1">-- 1	Sara	IT	52500.00	2025-01-15 03:47:42	9999-12-31 23:59:59</span>
<span class="c1">-- 5	Sven	IT	47250.00	2025-01-15 03:47:42	9999-12-31 23:59:59</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmployeesHistory</span>
<span class="k">WHERE</span> <span class="n">department</span> <span class="o">=</span> <span class="s1">'IT'</span><span class="p">;</span>
<span class="c1">-- 1	Sara	IT	50000.00	2025-01-15 03:42:15	2025-01-15 03:47:42</span>
<span class="c1">-- 5	Sven	IT	45000.00	2025-01-15 03:42:15	2025-01-15 03:47:42</span></code></pre>
</div>
</div>
</li>
<li>
<p>When querying data, for the current state, simply query the current table as usual, and to see a past state, correct to a certain point or period of time, query the current table followed by the <code>FOR SYSTEM_TIME</code> clause, plus a subclause that indicates more specifics.</p>
<div class="paragraph">
<p>SQL Server will retrieve the data from both the current and history tables as needed.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Qualifying rows for FOR SYSTEM_TIME subclauses [&lt;datetime2 value&gt;]</caption>
<colgroup>
<col style="width: 37.5%;">
<col style="width: 62.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Subclause</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qualifying rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AS OF @datetime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>validfrom <= @datetime AND validto &gt; @datetime</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FROM @start TO @end</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>validfrom &lt; @end AND validto &gt; @start</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BETWEEN @start AND @end</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>validfrom <= @end AND validto &gt; @start</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINED IN(@start, @end)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>validfrom >= @start AND validto <= @end</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ALL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All rows from both tables (T-SQL*)</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="nb">datetime</span> <span class="k">AS</span> <span class="n">DATETIME2</span> <span class="o">=</span> <span class="s1">'2025-01-15 03:45:00'</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span> <span class="k">FOR</span> <span class="n">SYSTEM_TIME</span> <span class="k">AS</span> <span class="k">OF</span> <span class="o">@</span><span class="nb">datetime</span><span class="p">;</span>

<span class="c1">-- same as</span>

<span class="k">DECLARE</span> <span class="o">@</span><span class="nb">datetime</span> <span class="k">AS</span> <span class="n">DATETIME2</span> <span class="o">=</span> <span class="s1">'2025-01-15 03:45:00'</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">validfrom</span> <span class="o">&lt;=</span> <span class="o">@</span><span class="nb">datetime</span> <span class="k">AND</span> <span class="n">validto</span> <span class="o">&gt;</span> <span class="o">@</span><span class="nb">datetime</span>

<span class="k">UNION</span> <span class="k">ALL</span>

<span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">validfrom</span><span class="p">,</span> <span class="n">validto</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">EmployeesHistory</span>
<span class="k">WHERE</span> <span class="n">validfrom</span> <span class="o">&lt;=</span> <span class="o">@</span><span class="nb">datetime</span> <span class="k">AND</span> <span class="n">validto</span> <span class="o">&gt;</span> <span class="o">@</span><span class="nb">datetime</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transactions-and-concurrency">12. Transactions and Concurrency</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A transaction is a unit of work that might include multiple activities that query and modify data and that can also change the data definition.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transaction boundaries can be defined either explicitly or implicitly.</p>
<div class="ulist">
<ul>
<li>
<p>A transaction explicitly is defined beginning with a <code>BEGIN TRAN</code> (or <code>BEGIN TRANSACTION</code>) statement, and end explicitly with a <code>COMMIT TRAN</code> statement to commit it and with a <code>ROLLBACK TRAN</code> (or <code>ROLLBACK TRANSACTION</code>) statement to undo its changes.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
  <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">);</span>
  <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T2</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">201</span><span class="p">,</span> <span class="s1">'X'</span><span class="p">);</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>If the boundaries of a transaction isn&#8217;t marked explicitly, by default, SQL Server treats each individual statement as a transaction, which is known as an <em>auto-commit mode</em>.</p>
</li>
<li>
<p>Transactions have four properties—atomicity, consistency, isolation, and durability— abbreviated with the acronym ACID:</p>
<div class="ulist">
<ul>
<li>
<p><strong>A</strong>tomicity: A transaction is an atomic unit of work. Either all changes in the transaction take place or none do.</p>
<div class="ulist">
<ul>
<li>
<p>If the system fails before a transaction is completed (before the commit instruction is recorded in the <em>transaction log</em>), upon restart, SQL Server undoes the changes that took place.</p>
</li>
<li>
<p>Also, if errors are encountered during the transaction and the error is considered severe enough, such as the target filegroup being full when trying to insert data, SQL Server automatically rolls back the transaction.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>C</strong>onsistency: The term consistency refers to the state of the data that the relational database management system (RDBMS) as concurrent transactions modify and query it, which is a subjective term, and depends on an application’s needs.</p>
</li>
<li>
<p><strong>I</strong>solation: Isolation ensures that transactions access only consistent data through a mechanism called <em>isolation</em> levels.</p>
<div class="ulist">
<ul>
<li>
<p>With disk-based tables, SQL Server supports two different models to handle isolation: one based purely on <em>locking</em>, and another based on a combination of locking and <em>row versioning</em>.</p>
<div class="ulist">
<ul>
<li>
<p>The model based on <em>locking</em> is the default in a box product.</p>
<div class="paragraph">
<p>In this model, readers require shared locks. If the current state of the data is inconsistent, readers are blocked until the state of the data becomes consistent.</p>
</div>
</li>
<li>
<p>The model based on locking and <em>row versioning</em> is the default in Azure SQL Database.</p>
<div class="paragraph">
<p>In this model, readers don’t take shared locks and don’t need to wait. If the current state of the data is inconsistent, the reader gets an older consistent state.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>D</strong>urability: The durability property means that once a commit instruction is acknowledged by the database engine, the transaction’s changes are guaranteed to be durable—or in other words, persist—in the database.</p>
<div class="ulist">
<ul>
<li>
<p>A commit is acknowledged by getting control back to the application and running the next line of code.</p>
</li>
<li>
<p>Data changes are always written to the database’s <em>transaction log</em> on disk before they are written to the data portion of the database on disk.</p>
</li>
<li>
<p>After the commit instruction is recorded in the transaction log on disk, the transaction is considered durable even if the change hasn’t yet made it to the data portion on disk.</p>
</li>
<li>
<p>When the system starts, either normally or after a system failure, SQL Server runs a recovery process in each database that involves analyzing the log, then applying a <em>redo</em> phase, and then applying an <em>undo</em> phase.</p>
<div class="ulist">
<ul>
<li>
<p>The <em>redo</em> phase involves rolling forward (replaying) all the changes from any transaction whose commit instruction is written to the log but whose changes haven’t yet made it to the data portion.</p>
</li>
<li>
<p>The <em>undo</em> phase involves rolling back (undoing) the changes from any transaction whose commit instruction was not recorded in the log.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Start a new transaction</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
<span class="c1">-- Declare a variable</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">neworderid</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">;</span>
<span class="c1">-- Insert a new order into the Sales.Orders table</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
  <span class="p">(</span><span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span><span class="p">,</span> <span class="n">requireddate</span><span class="p">,</span> <span class="n">shippeddate</span><span class="p">,</span>
  <span class="n">shipperid</span><span class="p">,</span> <span class="n">freight</span><span class="p">,</span> <span class="n">shipname</span><span class="p">,</span> <span class="n">shipaddress</span><span class="p">,</span> <span class="n">shipcity</span><span class="p">,</span>
  <span class="n">shippostalcode</span><span class="p">,</span> <span class="n">shipcountry</span><span class="p">)</span>
<span class="k">VALUES</span>
  <span class="p">(</span><span class="mi">85</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">'20220212'</span><span class="p">,</span> <span class="s1">'20220301'</span><span class="p">,</span> <span class="s1">'20220216'</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">.</span><span class="mi">38</span><span class="p">,</span> <span class="n">N</span><span class="s1">'Ship to 85-B'</span><span class="p">,</span> <span class="n">N</span><span class="s1">'6789 rue de l</span><span class="se">''</span><span class="s1">Abbaye'</span><span class="p">,</span> <span class="n">N</span><span class="s1">'Reims'</span><span class="p">,</span>
    <span class="n">N</span><span class="s1">'10345'</span><span class="p">,</span> <span class="n">N</span><span class="s1">'France'</span><span class="p">);</span>
<span class="c1">-- Save the new order ID in a variable</span>
<span class="k">SET</span> <span class="o">@</span><span class="n">neworderid</span> <span class="o">=</span> <span class="n">SCOPE_IDENTITY</span><span class="p">();</span>
<span class="c1">-- Return the new order ID</span>
<span class="k">SELECT</span> <span class="o">@</span><span class="n">neworderid</span> <span class="k">AS</span> <span class="n">neworderid</span><span class="p">;</span>
<span class="c1">-- Insert order lines for the new order into Sales.OrderDetails</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span>
  <span class="p">(</span><span class="n">orderid</span><span class="p">,</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">discount</span><span class="p">)</span>
<span class="k">VALUES</span><span class="p">(</span><span class="o">@</span><span class="n">neworderid</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000</span><span class="p">),</span>
  <span class="p">(</span><span class="o">@</span><span class="n">neworderid</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">9</span><span class="p">.</span><span class="mi">80</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000</span><span class="p">),</span>
  <span class="p">(</span><span class="o">@</span><span class="n">neworderid</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">34</span><span class="p">.</span><span class="mi">80</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000</span><span class="p">);</span>
<span class="c1">-- Commit the transaction</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="locks-and-blocking">12.1. Locks and Blocking</h3>
<div class="paragraph">
<p>By default, a SQL Server box product uses a pure locking model to enforce the isolation property of transactions, whereas Azure SQL Database uses the row-versioning model by default.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- turn off the database property READ_COMMITTED_SNAPSHOT to switch to the locking model as the default</span>
<span class="k">ALTER</span> <span class="k">DATABASE</span> <span class="n">TSQLV6</span> <span class="k">SET</span> <span class="n">READ_COMMITTED_SNAPSHOT</span> <span class="k">OFF</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="locks">12.1.1. Locks</h4>
<div class="paragraph">
<p>Locks are control resources obtained by a transaction to guard data resources, preventing conflicting or incompatible access by other transactions.</p>
</div>
<div class="sect4">
<h5 id="lock-modes-and-compatibility">12.1.1.1. Lock Modes and Compatibility</h5>
<div class="paragraph">
<p>When trying to modify data, a transaction requests an <strong>exclusive lock</strong> on the data resource, regardless of the isolation level. If granted, the exclusive lock is held until the end of the transaction.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For single- statement transactions, this means that the lock is held until the statement completes.</p>
</li>
<li>
<p>For multistatement transactions, this means that the lock is held until all statements complete and the transaction is ended by a <code>COMMIT TRAN</code> or <code>ROLLBACK TRAN</code> command.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As for reading data, the defaults are different for a SQL Server box product and Azure SQL Database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In SQL Server, the default isolation level is called <code>READ COMMITTED</code>.</p>
<div class="paragraph">
<p>In this isolation, when trying to read data, by default a transaction requests a <strong>shared lock</strong> on the data resource and releases the lock as soon as the read statement is done with that resource.</p>
</div>
</li>
<li>
<p>In Azure SQL Database, the default isolation level is called <code>READ COMMITTED SNAPSHOT</code>.</p>
<div class="paragraph">
<p>Instead of relying only on locking, this isolation level relies on a combination of <em>locking and row versioning</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Under this isolation level, readers do not require shared locks, and therefore they never wait; they rely on the row-versioning technology to provide the expected isolation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Under the <code>READ COMMITTED</code> isolation level, if a transaction modifies rows, until the transaction completes, another transaction can’t read the same rows.</p>
<div class="paragraph">
<p>This approach to concurrency control is known as the <strong>pessimistic concurrency</strong> approach.</p>
</div>
</li>
<li>
<p>Under the <code>READ COMMITTED SNAPSHOT</code> isolation level, if a transaction modifies rows, another transaction trying to read the data will get the last committed state of the rows that was available when the statement started.</p>
<div class="paragraph">
<p>This approach to concurrency control is known as the <strong>optimistic concurrency</strong> approach.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
READ COMMITTED SNAPSHOT is an MVCC-based implementation of the READ COMMITTED isolation level in SQL Server.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Lock compatibility of exclusive and shared locks</caption>
<colgroup>
<col style="width: 27.2727%;">
<col style="width: 36.3636%;">
<col style="width: 36.3637%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Requested mode</th>
<th class="tableblock halign-left valign-top">Granted Exclusive (X)</th>
<th class="tableblock halign-left valign-top">Granted Shared (S)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exclusive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shared</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A “No” in the intersection means that the locks are incompatible and the requested mode is denied; the requester must wait. A “Yes” in the intersection means that the locks are compatible and the requested mode is accepted.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="lockable-resource-types">12.1.1.2. Lockable Resource Types</h5>
<div class="paragraph">
<p>SQL Server can lock different types of resources that include rows (RID in a heap, key in an index), pages, objects (for example, tables), databases, and others. Rows reside within pages, and pages are the physical data blocks that contain table or index data.</p>
</div>
<div class="paragraph">
<p>To obtain a lock on a certain resource type, a transaction must first obtain <em>intent locks</em> of the same mode on higher levels of granularity to efficiently detect incompatible lock requests on higher levels of granularity and prevent the granting of those.</p>
</div>
<div class="paragraph">
<p>SQL Server determines dynamically which resource types to lock.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Naturally, for ideal concurrency, it’s best to lock only what needs to be locked—namely, only the affected rows.</p>
</li>
<li>
<p>However, locks require memory resources and internal management overhead. So SQL Server considers both concurrency and system resources when it’s choosing which resource types to lock.</p>
<div class="ulist">
<ul>
<li>
<p>When SQL Server estimates that a transaction will interact with a small number of rows, it tends to use row locks.</p>
</li>
<li>
<p>With larger numbers of rows, SQL Server tends to use page locks.</p>
</li>
</ul>
</div>
</li>
<li>
<p>SQL Server might first acquire fine-grained locks (such as row or page locks) and, in certain circumstances, try to escalate the fine-grained locks to a table lock to preserve memory.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="blocking">12.1.2. Blocking</h4>
<div class="paragraph">
<p>When one transaction holds a lock on a data resource and another transaction requests an incompatible lock on the same resource, the request is blocked and the requester enters a wait state.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By default, the blocked request keeps waiting until the blocker releases the interfering lock.</p>
<div class="ulist">
<ul>
<li>
<p>To restrict the amount of time the session waits for a lock, set a session option called <code>LOCK_TIMEOUT</code>.</p>
</li>
<li>
<p>Specify a value in milliseconds—such as 5000 for 5 seconds, 0 for an immediate timeout, and –1 for no timeout (which is the default).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SET</span> <span class="n">LOCK_TIMEOUT</span> <span class="mi">5000</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 1222, Level 16, State 51, Line 3
Lock request time out period exceeded.</span></code></pre>
</div>
</div>
</li>
<li>
<p>To remove the lock timeout value, set it back to the default (no timeout), and issue the query again.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SET</span> <span class="n">LOCK_TIMEOUT</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The dynamic management view (DMV) <code>sys.dm_tran_locks</code> can be used to get lock information, including both locks granted to sessions and locks sessions waiting for.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1: hold exclusive lock to write</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
  <span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
    <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">-- no COMMIT TRAN or ROLLBACK TRAN, the transaction remains open, and the lock is still held</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2: needs a shared lock to read, but be blocked and has to wait</span>
<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 3</span>
<span class="k">SELECT</span> <span class="c1">-- use * to explore other available attributes</span>
    <span class="n">request_session_id</span>            <span class="k">AS</span> <span class="n">sid</span><span class="p">,</span>
    <span class="n">resource_type</span>                 <span class="k">AS</span> <span class="n">restype</span><span class="p">,</span>
    <span class="n">resource_database_id</span>          <span class="k">AS</span> <span class="n">dbid</span><span class="p">,</span>
    <span class="n">DB_NAME</span><span class="p">(</span><span class="n">resource_database_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">dbname</span><span class="p">,</span>
    <span class="n">resource_description</span>          <span class="k">AS</span> <span class="n">res</span><span class="p">,</span>
    <span class="n">resource_associated_entity_id</span> <span class="k">AS</span> <span class="n">resid</span><span class="p">,</span>
    <span class="n">request_mode</span>                  <span class="k">AS</span> <span class="k">mode</span><span class="p">,</span>
    <span class="n">request_status</span>                <span class="k">AS</span> <span class="n">status</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_tran_locks</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">sid restype  dbid dbname res            resid             mode status
52  DATABASE 6    TSQLV6                0                 S    GRANT
56  DATABASE 6    TSQLV6                0                 S    GRANT
59  DATABASE 6    TSQLV6                0                 S    GRANT
52  PAGE     6    TSQLV6 1:456          72057594046251008 IS   GRANT
56  PAGE     6    TSQLV6 1:456          72057594046251008 IX   GRANT
52  OBJECT   6    TSQLV6                1029578706        IS   GRANT
56  OBJECT   6    TSQLV6                1029578706        IX   GRANT
56  KEY      6    TSQLV6 (61a06abd401c) 72057594046251008 X    GRANT
52  KEY      6    TSQLV6 (61a06abd401c) 72057594046251008 S    WAIT</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Each session is identified by a unique session ID.</p>
<div class="ulist">
<ul>
<li>
<p>A session’s ID can be determined by querying the function <code>@@SPID</code>.</p>
</li>
<li>
<p>If working with SQL Server Management Studio, the session ID could be found in parentheses to the right of the login name in the status bar at the bottom of the query window that has the focus, and also in the caption of the connected query window.</p>
</li>
</ul>
</div>
</li>
<li>
<p>By observing that both sessions lock a <em>row</em> with the same <em>res</em> and <em>resid</em> values, session 52 is waiting for a shared lock on a row in the sample database <code>TSQLV6</code> that is being held as an exclusive lock by session 56.</p>
</li>
<li>
<p>The involved table can be figured out by moving upward in the lock hierarchy for either session 52 or 56 and inspecting the intent locks on the <em>object</em> (table) where the row resides.</p>
</li>
<li>
<p>The <code>OBJECT_NAME</code> function can be used to translate the object ID (1029578706, in this example) that appears under the <em>resid</em> attribute in the object lock, that is <code>Production.Products</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">OBJECT_NAME</span><span class="p">(</span><span class="mi">1029578706</span><span class="p">);</span> <span class="c1">-- Products</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>sys.dm_tran_locks</code> view gives the information about the IDs of the sessions involved in the <em>blocking chain</em>, that is, two or more sessions that are involved in the blocking situation, such as session <code>x</code> blocking session <code>y</code>, session <code>y</code> blocking session <code>z</code>, and so on—hence the use of the term chain.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The DMV <code>sys.dm_exec_connections</code> can be used to get information about the connections associated with those session IDs and filter only the session IDs that are involved:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="c1">-- use * to explore</span>
    <span class="n">session_id</span> <span class="k">AS</span> <span class="n">sid</span><span class="p">,</span>
    <span class="n">connect_time</span><span class="p">,</span>
    <span class="n">last_read</span><span class="p">,</span>
    <span class="n">last_write</span><span class="p">,</span>
    <span class="n">most_recent_sql_handle</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_connections</span>
<span class="k">WHERE</span> <span class="n">session_id</span> <span class="k">IN</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="mi">56</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">52	2025-01-13 14:50:57.367	2025-01-13 14:54:07.930	2025-01-13 14:54:07.923	0x0200000063FC7D052E09844778CDD615CFE7A2D1FB4118020000000000000000000000000000000000000000
56	2025-01-13 14:53:33.587	2025-01-13 14:53:52.560	2025-01-13 14:53:52.560	0x020000008FAC322CF2FC73472F8E93B0DF1994A69639ED090000000000000000000000000000000000000000</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A binary value holding a handle to the most recent SQL batch run by the connection.</p>
<div class="ulist">
<ul>
<li>
<p>The handle can be provided as an input parameter to a table function called <code>sys.dm_exec_sql_text</code>, and the function returns the batch of code represented by the handle.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">session_id</span><span class="p">,</span> <span class="nb">text</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_connections</span>
  <span class="k">CROSS</span> <span class="n">APPLY</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_sql_text</span><span class="p">(</span><span class="n">most_recent_sql_handle</span><span class="p">)</span> <span class="k">AS</span> <span class="n">ST</span>
<span class="k">WHERE</span> <span class="n">session_id</span> <span class="k">IN</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="mi">56</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">52	(@1 tinyint)SELECT [productid],[unitprice] FROM [Production].[Products] WHERE [productid]=@1
</span><span class="gp">56	BEGIN TRAN;</span><span class="w">    </span>UPDATE Production.Products      SET unitprice +<span class="o">=</span> 1.00    WHERE productid <span class="o">=</span> 2<span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Starting with SQL Server 2016, the function <code>sys.dm_exec_input_buffer</code> instead of <code>sys.dm_exec_sql_text</code> can be used to get the code that the sessions of interest submitted last.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">session_id</span><span class="p">,</span> <span class="n">event_info</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_connections</span>
  <span class="k">CROSS</span> <span class="n">APPLY</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_input_buffer</span><span class="p">(</span><span class="n">session_id</span><span class="p">,</span> <span class="k">NULL</span><span class="p">)</span> <span class="k">AS</span> <span class="n">IB</span>
<span class="k">WHERE</span> <span class="n">session_id</span> <span class="k">IN</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="mi">56</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The DMV <code>sys.dm_exec_sessions</code> can be used to find a lot of useful information about the sessions involved in a blocking situation.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="c1">-- use * to explore</span>
  <span class="n">session_id</span> <span class="k">AS</span> <span class="n">sid</span><span class="p">,</span>
  <span class="n">login_time</span><span class="p">,</span>
  <span class="n">host_name</span><span class="p">,</span>
  <span class="n">program_name</span><span class="p">,</span>
  <span class="n">login_name</span><span class="p">,</span>
  <span class="n">nt_user_name</span><span class="p">,</span>
  <span class="n">last_request_start_time</span><span class="p">,</span>
  <span class="n">last_request_end_time</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_sessions</span>
<span class="k">WHERE</span> <span class="n">session_id</span> <span class="k">IN</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="mi">56</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Another DMV <code>sys.dm_exec_requests</code> can probably be used to find useful for troubleshooting blocking situations.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="c1">-- use * to explore</span>
  <span class="n">session_id</span> <span class="k">AS</span> <span class="n">sid</span><span class="p">,</span>
  <span class="n">blocking_session_id</span><span class="p">,</span>
  <span class="n">command</span><span class="p">,</span>
  <span class="n">sql_handle</span><span class="p">,</span>
  <span class="n">database_id</span><span class="p">,</span>
  <span class="n">wait_type</span><span class="p">,</span>
  <span class="n">wait_time</span><span class="p">,</span>
  <span class="n">wait_resource</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_requests</span>
<span class="k">WHERE</span> <span class="n">blocking_session_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>To terminate the blocker—for example, if realizing that as a result of a bug in the application the transaction remained open and nothing in the application can close it—do so by using the <code>KILL &lt;session_id&gt;</code> command.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">KILL</span> <span class="mi">56</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="isolation-levels">12.2. Isolation Levels</h3>
<div class="paragraph">
<p>Isolation levels determine the level of consistency when interacting with data. In the default isolation level in a box product, a reader uses shared locks on the target resources and a writer uses exclusive locks.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SQL Server supports four isolation levels that are based on the pure locking model: READ UNCOMMITTED, READ COMMITTED (the default in a SQL Server box product), REPEATABLE READ, and SERIALIZABLE.</p>
</li>
<li>
<p>SQL Server also supports two isolation levels that are based on a combination of locking and row versioning: SNAPSHOT and READ COMMITTED SNAPSHOT (the default in Azure SQL Database).</p>
<div class="paragraph">
<p>SNAPSHOT and READ COMMITTED SNAPSHOT are in a sense the row-versioning counterparts of READ COMMITTED and SERIALIZABLE, respectively.</p>
</div>
</li>
<li>
<p>The isolation level of the whole session can be set by using the following command:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="o">&lt;</span><span class="n">isolationname</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The isolation level of a query can be set by using a table hint:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="o">&lt;</span><span class="k">table</span><span class="o">&gt;</span> <span class="k">WITH</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">isolationname</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>With the first four isolation levels, the higher the isolation level, the stricter the locks are that readers request and the longer their duration is; therefore, the higher the isolation level is, the higher the consistency is and the lower the concurrency is.</p>
</li>
<li>
<p>With the two row-versioning-based isolation levels, SQL Server is able to store previous committed versions of rows in a version store. Readers do not request shared locks; instead, if the current version of the rows is not what they are supposed to see, SQL Server provides them with an older version.</p>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Isolation level properties</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Isolation level</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows uncommitted reads?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows nonrepeatable reads?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows lost updates?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows phantom reads?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Detects update conflicts?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses row versioning?</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">READ UNCOMMITTED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">READ COMMITTED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REPEATABLE READ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERIALIZABLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SNAPSHOT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">READ COMMITTED SNAPSHOT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="read-uncommitted">12.2.1. READ UNCOMMITTED</h4>
<div class="paragraph">
<p>READ UNCOMMITTED is the lowest available isolation level, that is, a reader doesn’t ask for a shared lock.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A reader that doesn’t ask for a shared lock can never be in conflict with a writer that is holding an exclusive lock, so that the reader can read uncommitted changes (also known as <em>dirty reads</em>).</p>
</li>
<li>
<p>It also means the reader won’t interfere with a writer that asks for an exclusive lock, that is, a writer can change data while a reader that is running under the READ UNCOMMITTED isolation level reads data.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Open a transaction, update the unit price of product 2 by adding 1.00 to its current price (19.00), and then query the product’s row</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>

<span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="mi">2</span>	<span class="mi">20</span><span class="p">.</span><span class="mi">00</span></code></pre>
</div>
</div>
</li>
<li>
<p>Set the isolation level to READ UNCOMMITTED and query the row for product 2.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The query returned the state of the row after the change, even though the change was not committed
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="mi">2</span>	<span class="mi">20</span><span class="p">.</span><span class="mi">00</span></code></pre>
</div>
</div>
</li>
<li>
<p>Keep in mind that Connection 1 might apply further changes to the row later in the transaction or even roll back at some point.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">ROLLBACK</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The above rollback undoes the update of product 2, changing its price back to 19.00. The value 20.00 that the reader got was never committed which is called dirty read.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="read-committed">12.2.2. READ COMMITTED</h4>
<div class="paragraph">
<p>The lowest isolation level that prevents dirty reads is READ COMMITTED, which is also the default isolation level in SQL Server (the box product), to prevent uncommitted reads by requiring a reader to obtain a shared lock.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="c1">-- open a transaction, update the price of product 2, and query the row to show the new price</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
   <span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
     <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
   <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

   <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
   <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
   <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="c1">-- Keep in mind that this isolation level is the default, so unless previously changed the session’s isolation level, it isn't needed to set it explicitly.</span>
<span class="c1">-- The SELECT statement is currently blocked because it needs a shared lock to be able to read the row, and this shared lock request is in conflict with the exclusive lock held by the writer in Connection 1</span>
<span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="c1">-- commit the transaction</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">-- Connection 2
2	20.00</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- restore the unitprice of the product 2</span>
<span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span> <span class="c1">-- 19.00</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In terms of the duration of locks, in the READ COMMITTED isolation level, a reader holds the shared lock only until it’s done with the resource.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It doesn’t keep the lock until the end of the transaction; in fact, it doesn’t even keep the lock until the end of the statement, that means that in between two reads of the same data resource in the same transaction, no lock is held on the resource.</p>
</li>
<li>
<p>Therefore, another transaction can modify the resource in between those two reads, and the reader might get different values in each read, which is called <em>nonrepeatable reads</em> or <em>inconsistent analysis</em>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repeatable-read">12.2.3. REPEATABLE READ</h4>
<div class="paragraph">
<p>The isolation level REPEATABLE READ can be used to get <em>repeatable reads</em>, or <em>consistent analysis</em> to ensure that no one can change values in between reads that take place in the same transaction, that is, not only does a reader need a shared lock to be able to read, but it also holds the lock until the end of the transaction.</p>
</div>
<div class="paragraph">
<p>The REPEATABLE READ but not by lower isolation levels can also prevent another phenomenon called a <em>lost update</em> that happens when two transactions read a value, make calculations based on what they read, and then update the value.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In isolation levels lower than REPEATABLE READ no lock is held on the resource after the read, both transactions can update the value, and whichever transaction updates the value last “wins,” overwriting the other transaction’s update.</p>
</li>
<li>
<p>In REPEATABLE READ, both sides keep their shared locks after the first read, so neither can acquire an exclusive lock later in order to update, which results in a <em>deadlock</em>, and the update conflict is prevented.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">REPEATABLE</span> <span class="k">READ</span><span class="p">;</span>

<span class="c1">-- keep holding a shared lock on the row for product 2</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="mi">2</span>	<span class="mi">19</span><span class="p">.</span><span class="mi">00</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="c1">-- blocked the modifier’s request for an exclusive lock in conflict with the reader’s granted shared lock.</span>
<span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="c1">-- the second read got the same unit price for product 2 as the first read</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span> <span class="c1">--  commit the transaction and release the shared lock</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="c1">-- obtain the exclusive lock it was waiting for and update the row</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="serializable">12.2.4. SERIALIZABLE</h4>
<div class="paragraph">
<p>Under the REPEATABLE READ isolation level, readers keep shared locks until the end of the transaction that locks only resources (e.g., rows) that the query found the first time it ran, not rows that weren’t there when the query ran, so that a second read in the same transaction might return new rows as well, which happens if, in between the reads, another transaction inserts new rows that satisfy the reader’s query filter, which are called <em>phantoms</em>, and such reads are called <em>phantom reads</em>.</p>
</div>
<div class="paragraph">
<p>The SERIALIZABLE isolation level can be used to prevent phantom reads, that requires a reader to obtain a shared lock on the whole range of keys that qualify for the query’s filter to be able to read, and it keeps the lock until the end of the transaction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="c1">-- set the transaction isolation level to SERIALIZABLE, open a transaction, and query all products with category 1</span>
<span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">SERIALIZABLE</span><span class="p">;</span>

<span class="k">BEGIN</span> <span class="n">TRAN</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">productname</span><span class="p">,</span> <span class="n">categoryid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">categoryid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="c1">-- In all isolation levels that are lower than SERIALIZABLE, such an attempt would be successful.</span>
<span class="c1">-- In the SERIALIZABLE isolation level, the attempt is blocked.</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
    <span class="p">(</span><span class="n">productname</span><span class="p">,</span> <span class="n">supplierid</span><span class="p">,</span> <span class="n">categoryid</span><span class="p">,</span> <span class="n">unitprice</span><span class="p">,</span> <span class="n">discontinued</span><span class="p">)</span>
<span class="k">VALUES</span><span class="p">(</span><span class="s1">'Product ABCDE'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">sid               restype dbid dbname res            resid             mode     status
55 (Connection 1) KEY     6    TSQLV6 (61a06abd401c) 72057594046251008 RangeS-S GRANT
64 (Connection 2) KEY     6    TSQLV6 (61a06abd401c) 72057594046251008 X        WAIT</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="c1">-- get the same output as before, with no phantoms</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">productname</span><span class="p">,</span> <span class="n">categoryid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">categoryid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span> <span class="c1">-- transaction is committed and the shared key-range lock is released</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multi-version-concurrency-control">12.2.5. Multi-Version Concurrency Control</h4>
<div class="paragraph">
<p>With the row-versioning technology, SQL Server can store previous versions of committed rows in a version store.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the Accelerated Database Recovery (ADR) feature is not enabled in the database, the version store resides in the tempdb database.</p>
</li>
<li>
<p>If ADR is enabled, the version store resides in the user database in question.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SQL Server supports two isolation levels, called SNAPSHOT and READ COMMITTED SNAPSHOT, that are based on this row-versioning technology.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The SNAPSHOT isolation level is logically similar to the SERIALIZABLE isolation level in terms of the types of consistency problems that can or cannot happen.</p>
</li>
<li>
<p>The READ COMMITTED SNAPSHOT isolation level is similar to the READ COMMITTED isolation level.</p>
</li>
<li>
<p>Readers using isolation levels based on row versioning do not acquire shared locks, so they don’t wait when the requested data is exclusively locked.</p>
<div class="ulist">
<ul>
<li>
<p>In other words, <em>readers don’t block writers and writers don’t block readers</em>.</p>
</li>
<li>
<p>Readers still get levels of consistency similar to SERIALIZABLE and READ COMMITTED.</p>
</li>
<li>
<p>SQL Server provides readers with an older version of the row if the current version is not the one they are supposed to see.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that if enabling any of the row-versioning-based isolation levels (which are enabled in Azure SQL Database by default), the DELETE and UPDATE statements need to copy the version of the row before the change to the version store (Copy-on-Write); INSERT statements don’t need to write anything to the version store, because no earlier version of the row exists.</p>
</div>
<div class="paragraph">
<p>But it’s important to be aware that enabling any of the isolation levels that are based on row versioning might have a negative impact on the performance of updates and deletes.</p>
</div>
<div class="paragraph">
<p>The performance of readers usually improves, sometimes dramatically, because they do not acquire shared locks and don’t need to wait when data is exclusively locked or its version is not the expected one.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="snapshot">12.2.5.1. SNAPSHOT</h5>
<div class="paragraph">
<p>The SNAPSHOT isolation level, relies on row versioning instead of using shared locks, guarantees the reader to get the last committed version of the row that was available when the transaction started to get committed reads and repeatable reads, and not phantom reads.</p>
</div>
<div class="paragraph">
<p>To work with the SNAPSHOT isolation level in a SQL Server box product instance (enabled by default in Azure SQL Database), first enable the option at the database level by running the following code in any open query window:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">ALTER</span> <span class="k">DATABASE</span> <span class="n">TSQLV6</span> <span class="k">SET</span> <span class="n">ALLOW_SNAPSHOT_ISOLATION</span> <span class="k">ON</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open a transaction, update the price of product <code>2</code> by adding <code>1.00</code> to its current price of <code>19.00</code>, and show the new price.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>

  <span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
    <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	20.00</span></code></pre>
</div>
</div>
</li>
<li>
<p>If someone begins a transaction using the SNAPSHOT isolation level, that session can request the version before the update.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="n">SNAPSHOT</span><span class="p">;</span>

<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	19.00</span></code></pre>
</div>
</div>
</li>
<li>
<p>If a transaction were under the SERIALIZABLE isolation level, the query would be blocked.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 3</span>
<span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span> <span class="c1">-- by default in SQL Server</span>
<span class="k">SET</span> <span class="n">LOCK_TIMEOUT</span> <span class="mi">5000</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 1222, Level 16, State 51, Line 5
Lock request time out period exceeded.</span></code></pre>
</div>
</div>
</li>
<li>
<p>Go back to Connection 1, and commit the transaction.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- at this point, the current version of the row with the price of 20.00 is a committed version.</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Go back to Connection 2, and run the following code.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- still get the last committed version of the row that was available when the transaction started (with a price of 19.00).</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	19.00</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="conflict-detection">12.2.5.2. Conflict Detection</h5>
<div class="paragraph">
<p>The SNAPSHOT isolation level prevents update conflicts, but unlike the REPEATABLE READ and SERIALIZABLE isolation levels that do so by generating a deadlock, the SNAPSHOT isolation level generates a more specific error, indicating that an update conflict was detected by examining the version store to figure out whether another transaction modified the data between a read and a write that took place in a transaction.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Set the transaction isolation level to SNAPSHOT, open a transaction, and read the row for product <code>2</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">SET</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="n">SNAPSHOT</span><span class="p">;</span>

<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	19.00</span></code></pre>
</div>
</div>
</li>
<li>
<p>Update the price of the product queried previously to <code>20.00</code>, and commit the transaction.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
  <span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
    <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">=</span> <span class="mi">20</span><span class="p">.</span><span class="mi">00</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>No other transaction modified the row between the read, calculation, and write; therefore, there was no update conflict and SQL Server allowed the update to take place.</p>
</div>
</li>
<li>
<p>Restore the price of product <code>2</code> back to <code>19.00</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">=</span> <span class="mi">19</span><span class="p">.</span><span class="mi">00</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Next, run the following code in Connection 1, again, to open a transaction, and read the row for product <code>2</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Next, run the following code in Connection 2 to update the price of product <code>2</code> to <code>25.00</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">=</span> <span class="mi">25</span><span class="p">.</span><span class="mi">00</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Go back to Connection 1, and try to update the price of the product to <code>20.00</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>UPDATE Production.Products
  SET unitprice = 20.00
WHERE productid = 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>SQL Server detected that this time another transaction modified the data between the read and write; therefore, it fails the transaction with the following error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 3960, Level 16, State 2, Line 1
Snapshot isolation transaction aborted due to update conflict. You cannot use snapshot isolation to access table 'Production.Products' directly or indirectly in database 'TSQLV6' to update, delete, or insert the row that has been modified or deleted by another transaction. Retry the transaction or change the isolation level for the update/delete statement.</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="read-committed-snapshot">12.2.5.3. READ COMMITTED SNAPSHOT</h5>
<div class="paragraph">
<p>The READ COMMITTED SNAPSHOT isolation level is also based on row versioning, but differs from the SNAPSHOT isolation level in that instead of providing a reader with a <em>transaction-level consistent view</em> of the data, it provides the reader with a <em>statement-level consistent view</em> of the data, and also does not detect update conflicts.</p>
</div>
<div class="paragraph">
<p>To make a reader to acquire a shared lock under READ COMMITTED SNAPSHOT, add a table hint called READCOMMITTEDLOCK to the SELECT statements, as in <code>SELECT * FROM dbo.T1 WITH (READCOMMITTEDLOCK)</code>.</p>
</div>
<div class="paragraph">
<p>To enable the use of the READ COMMITTED SNAPSHOT isolation level in a SQL Server box product (enabled by default in Azure SQL Database), turn on a database option called READ_COMMITTED_SNAPSHOT.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">ALTER</span> <span class="k">DATABASE</span> <span class="n">TSQLV6</span> <span class="k">SET</span> <span class="n">READ_COMMITTED_SNAPSHOT</span> <span class="k">ON</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Unlike the SNAPSHOT isolation level, this flag changes the meaning, or semantics, of the READ COMMITTED isolation level to READ COMMITTED SNAPSHOT, which means that when this database flag is turned on, unless explicitly changing the session’s isolation level, READ COMMITTED SNAPSHOT is the default.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Run the following code in Connection 1 to open a transaction, update the row for product <code>2</code>, and read the row, leaving the transaction open:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>

<span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
<span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
<span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	20.00</span></code></pre>
</div>
</div>
</li>
<li>
<p>In Connection 2, open a transaction and read the row for product 2, leaving the transaction open:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>

  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	19.00</span></code></pre>
</div>
</div>
</li>
<li>
<p>Run the following code in Connection 1 to commit the transaction:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Now run the code in Connection 2 to read the row for product <code>2</code> again, and commit the transaction:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="c1">-- get the last committed version of the row that was available when the statement started (20.00) and not when the transaction started (19.00)</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2	19.00</span></code></pre>
</div>
</div>
</li>
<li>
<p>Close all connections. Open a new connection, and run the following code to disable the isolation levels that are based on row versioning in the <code>TSQLV6</code> database:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">ALTER</span> <span class="k">DATABASE</span> <span class="n">TSQLV6</span> <span class="k">SET</span> <span class="n">ALLOW_SNAPSHOT_ISOLATION</span> <span class="k">OFF</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">DATABASE</span> <span class="n">TSQLV6</span> <span class="k">SET</span> <span class="n">READ_COMMITTED_SNAPSHOT</span> <span class="k">OFF</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deadlocks">12.3. Deadlocks</h3>
<div class="paragraph">
<p>A deadlock is a situation in which two or more sessions block each other.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An example of a two- session deadlock is when session A blocks session B and session B blocks session A.</p>
</li>
<li>
<p>An example of a deadlock involving more than two sessions is when session A blocks session B, session B blocks session C, and session C blocks session A.</p>
</li>
<li>
<p>In any of these cases, SQL Server detects the deadlock and intervenes by terminating one of the transactions.</p>
</li>
<li>
<p>If SQL Server did not intervene, the sessions involved would remain deadlocked forever.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unless otherwise specified (DEADLOCK_PRIORITY), SQL Server chooses to terminate the transaction that did the least work (based on the activity written to the transaction log), because rolling that transaction’s work back is the cheapest option.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Run the following code in Connection 1 to open a new transaction, update a row in the <code>Production.Products</code> table for product <code>2</code>, and leave the transaction open:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>

  <span class="k">UPDATE</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
    <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Run the following code in Connection 2 to open a new transaction, update a row in the <code>Sales.OrderDetails</code> table for product <code>2</code>, and leave the transaction open:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="k">BEGIN</span> <span class="n">TRAN</span><span class="p">;</span>

  <span class="k">UPDATE</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span>
    <span class="k">SET</span> <span class="n">unitprice</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">00</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Run the following code in Connection 1 to attempt to query the rows for product <code>2</code> in the <code>Sales.OrderDetails</code> table, and commit the transaction:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 1</span>
<span class="c1">-- needs a shared lock to be able to perform its read, but blocked by Connection 2</span>
  <span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Next, run the following code in Connection 2 to attempt to query the row for product <code>2</code> in the <code>Production.Products</code> table and commit the transaction:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Connection 2</span>
<span class="c1">-- needs a shared lock to be able to perform its read, but blocked by Connection 1</span>
  <span class="k">SELECT</span> <span class="n">productid</span><span class="p">,</span> <span class="n">unitprice</span>
  <span class="k">FROM</span> <span class="n">Production</span><span class="p">.</span><span class="n">Products</span>
  <span class="k">WHERE</span> <span class="n">productid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRAN</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>At this point, each of the sessions blocks the other —results a deadlock. SQL Server identifies the deadlock (typically within a few seconds), chooses one of the sessions involved as the deadlock victim, and terminates its transaction with the following error:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 1205, Level 13, State 51, Line 3
Transaction (Process ID 57) was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction.</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Deadlocks are expensive because they involve undoing work that has already been done and then, usually with some error-handling logic, redoing the work.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Obviously, the longer the transactions are, the longer locks are kept, increasing the probability of deadlocks.</p>
<div class="ulist">
<ul>
<li>
<p>Keep transactions as short as possible, taking activities out of the transaction that aren’t logically supposed to be part of the same unit of work. For example, don’t use transactions that require user input to finish!</p>
</li>
</ul>
</div>
</li>
<li>
<p>One typical deadlock, also called a <em>deadly embrace deadlock</em> (e.g., the above example), happens when transactions access resources in inverse order.</p>
<div class="ulist">
<ul>
<li>
<p>By swapping the order in one of the transactions, you can prevent this type of deadlock from happening—assuming that it makes no logical difference to your application.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Deadlocks often also happen when there is no real logical conflict (for example, trying to access the same rows), because of a lack of good indexing to support query filters.</p>
<div class="paragraph">
<p>For example, suppose both statements in the transaction in Connection 2 filtered product 5.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Now that the statements in Connection 1 handle product 2 and the statements in Connection 2 handle product 5, there shouldn’t be any conflict.</p>
</li>
<li>
<p>However, if indexes aren&#8217;t defined on the <code>productid</code> column in the tables to support the filter, SQL Server has to scan (and lock) all rows in the table, that is, of course, can lead to a deadlock.</p>
<div class="paragraph">
<p>While scanning the entire table, both connections might attempt to acquire locks on the same or overlapping table pages, leading to a deadlock situation even though they are working with different product data.</p>
</div>
</li>
<li>
<p>In short, good index design can help mitigate the occurrences of deadlocks that have no real logical conflict.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Another option to consider to mitigate deadlock occurrences is the choice of isolation level.</p>
<div class="ulist">
<ul>
<li>
<p>The SELECT statements in the example needed shared locks because they ran under the READ COMMITTED isolation level.</p>
</li>
<li>
<p>If using the READ COMMITTED SNAPSHOT isolation level, readers will not need shared locks, and deadlocks that evolve because of the involvement of shared locks can be eliminated.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="programmable-objects">13. Programmable Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Programmable objects in SQL Server are reusable code blocks that extend the capabilities of the database beyond basic data storage and retrieval.</p>
</div>
<div class="sect2">
<h3 id="variables">13.1. Variables</h3>
<div class="paragraph">
<p>A variable is used to temporarily store data values for later use in the same batch in which they were declared, and a batch is one or more T-SQL statements sent to Microsoft SQL Server for execution as a single unit.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a <code>DECLARE</code> statement to declare one or more variables, and use a <code>SET</code> statement to assign a value to a single variable.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- declares two variables called @i and @j of INT data type and assigns it the value 10 and 20</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">i</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">,</span> <span class="o">@</span><span class="n">j</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">;</span>

<span class="c1">-- SET statement can operate on only one variable at a time</span>
<span class="k">SET</span> <span class="o">@</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">SEt</span> <span class="o">@</span><span class="n">j</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Alternatively, a variable can be declared and initialized in the same statement, like this:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">i</span> <span class="k">AS</span> <span class="nb">INT</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">@</span><span class="n">j</span> <span class="k">AS</span> <span class="nb">INT</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>When assign a value to a scalar variable, the value must be the result of a scalar expression.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">empname</span> <span class="k">AS</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">61</span><span class="p">);</span>

<span class="c1">-- a scalar subquery</span>
<span class="k">SET</span> <span class="o">@</span><span class="n">empname</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">firstname</span> <span class="o">+</span> <span class="n">N</span><span class="s1">' '</span> <span class="o">+</span> <span class="n">lastname</span>
                <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
                <span class="k">WHERE</span> <span class="n">empid</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- a scalar subquery fails at run time if it returns more than one value</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">empname</span> <span class="k">AS</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">61</span><span class="p">);</span>

<span class="k">SET</span> <span class="o">@</span><span class="n">empname</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">firstname</span> <span class="o">+</span> <span class="n">N</span><span class="s1">' '</span> <span class="o">+</span> <span class="n">lastname</span>
                <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
                <span class="k">WHERE</span> <span class="n">mgrid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 512, Level 16, State 1, Line 2
</span><span class="gp">Subquery returned more than 1 value. This is not permitted when the subquery follows =, !=, &lt;, &lt;= , &gt;</span>, <span class="o">&gt;=</span> or when the subquery is used as an expression.</code></pre>
</div>
</div>
</li>
<li>
<p>T-SQL also supports a nonstandard assignment <code>SELECT</code> statement to query data and assign multiple values obtained from the same row to multiple variables by using a single statement.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">firstname</span> <span class="k">AS</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="o">@</span><span class="n">lastname</span> <span class="k">AS</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>

<span class="c1">-- if the query has more than one qualifying row, the values in the variables are those from the last row that SQL Server happened to access.</span>
<span class="k">SELECT</span>
  <span class="o">@</span><span class="n">firstname</span> <span class="o">=</span> <span class="n">firstname</span><span class="p">,</span>
  <span class="o">@</span><span class="n">lastname</span>  <span class="o">=</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">empid</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">@</span><span class="n">firstname</span> <span class="k">AS</span> <span class="n">firstname</span><span class="p">,</span> <span class="o">@</span><span class="n">lastname</span> <span class="k">AS</span> <span class="n">lastname</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="batchs">13.2. Batchs</h3>
<div class="paragraph">
<p>A batch is one or more T-SQL statements sent by a client application to SQL Server for execution as a single unit.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A transaction is an atomic unit of work. A batch can have multiple transactions, and a transaction can be submitted in parts as multiple batches.
</td>
</tr>
</table>
</div>
<div class="ulist NOTE">
<ul class="NOTE">
<li>
<p>Client application programming interfaces (APIs) such as ADO.NET provide methods for submitting a batch of code to SQL Server for execution.</p>
</li>
<li>
<p>SQL Server utilities such as SQL Server Management Studio (SSMS), Azure Data Studio (ADS), SQLCMD, and OSQL provide a client tool command called <code>GO</code> that signals the end of a batch.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Note that the <code>GO</code> command is a client tool command and not a T-SQL server command, and do not terminate the <code>GO</code> command with a semicolon.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>A batch is a set of commands that are parsed and executed as a unit.</p>
<div class="ulist">
<ul>
<li>
<p>If the parsing is successful, SQL Server then attempts to execute the batch.</p>
</li>
<li>
<p>In the event of a syntax error in the batch, the whole batch is not submitted to SQL Server for execution.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Valid batch</span>
<span class="n">PRINT</span> <span class="s1">'First batch'</span><span class="p">;</span>
<span class="n">USE</span> <span class="n">TSQLV6</span><span class="p">;</span>
<span class="k">GO</span>
<span class="c1">-- Invalid batch</span>
<span class="n">PRINT</span> <span class="s1">'Second batch'</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">custid</span> <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">orderid</span> <span class="n">FOM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span><span class="p">;</span>
<span class="k">GO</span>
<span class="c1">-- Valid batch</span>
<span class="n">PRINT</span> <span class="s1">'Third batch'</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">empid</span> <span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">First batch
Msg 102, Level 15, State 1, Line 8
Incorrect syntax near 'Sales'.
Third batch</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A variable is local to the batch in which it’s defined, that is, it can’t be referred to in another batch.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">i</span> <span class="k">AS</span> <span class="nb">INT</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">-- Succeeds</span>
<span class="n">PRINT</span> <span class="o">@</span><span class="n">i</span><span class="p">;</span>
<span class="k">GO</span>

<span class="c1">-- Fails</span>
<span class="n">PRINT</span> <span class="o">@</span><span class="n">i</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">10
Msg 137, Level 15, State 2, Line 6
Must declare the scalar variable "@i".</span></code></pre>
</div>
</div>
</li>
<li>
<p>The CREATE statements cannot be combined with other statements in the same batch.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- CREATE DEFAULT, CREATE FUNCTION, CREATE PROCEDURE, CREATE RULE, CREATE SCHEMA, CREATE TRIGGER, and CREATE VIEW</span>
<span class="k">DROP</span> <span class="k">VIEW</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">Sales</span><span class="p">.</span><span class="n">MyView</span><span class="p">;</span>
<span class="c1">-- GO -- To get around the problem, add a GO command here</span>

<span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">Sales</span><span class="p">.</span><span class="n">MyView</span>
<span class="k">AS</span>
<span class="k">SELECT</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span> <span class="k">COUNT</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">numorders</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">);</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Msg 111, Level 15, State 1, Line 3
'CREATE VIEW' must be the first statement in a query batch.</span></code></pre>
</div>
</div>
</li>
<li>
<p>A batch is a unit of resolution (also known as binding), that means that checking the existence of objects and columns happens at the batch level.</p>
<div class="paragraph">
<p>When applying schema changes to an object and try to manipulate the object data in the same batch, SQL Server might not be aware of the schema changes yet and fail the data-manipulation statement with a resolution error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">col1</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">GO</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span> <span class="k">ADD</span> <span class="n">col2</span> <span class="nb">INT</span><span class="p">;</span>
<span class="c1">-- GO -- To get around the problem, add a GO command here</span>
<span class="k">SELECT</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span> <span class="c1">-- Invalid column name 'col2'.</span>
<span class="k">GO</span>

<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>GO</code> command is not really a T-SQL command; it’s actually a command used by SQL Server’s client tools, such as SSMS, to denote the end of a batch. It also supports an argument indicating how many times you want to execute the batch.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">col1</span> <span class="nb">INT</span> <span class="k">IDENTITY</span><span class="p">);</span>
<span class="k">GO</span>

<span class="k">SET</span> <span class="n">NOCOUNT</span> <span class="k">ON</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span> <span class="k">DEFAULT</span> <span class="k">VALUES</span><span class="p">;</span>
<span class="k">GO</span> <span class="mi">100</span>

<span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col1</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span> <span class="c1">-- (1 + 100) * 100 / 2 = 5050</span>
<span class="k">GO</span>

<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="flow-elements-if-and-while">13.3. Flow Elements: IF and WHILE</h3>
<div class="paragraph">
<p>T-SQL provides basic forms of control with flow elements to control the flow of the code, including the <code>IF . . . ELSE</code> element and the <code>WHILE</code> element.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>IF . . . ELSE</code> element is used to control the flow of a code based on the result of a predicate.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">IF</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">SYSDATETIME</span><span class="p">())</span> <span class="o">&lt;&gt;</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">DATEADD</span><span class="p">(</span><span class="k">day</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SYSDATETIME</span><span class="p">()))</span>
<span class="c1">-- a statement or statement block that is executed if the predicate is TRUE</span>
   <span class="n">PRINT</span> <span class="s1">'Today is the last day of the year.'</span><span class="p">;</span>
<span class="c1">-- optionally a statement or statement block that is executed if the predicate is FALSE or UNKNOWN.</span>
<span class="k">ELSE</span>
<span class="k">BEGIN</span> <span class="c1">-- mark the boundaries of a statement block with the BEGIN and END keywords</span>
  <span class="n">IF</span> <span class="k">MONTH</span><span class="p">(</span><span class="n">SYSDATETIME</span><span class="p">())</span> <span class="o">&lt;&gt;</span> <span class="k">MONTH</span><span class="p">(</span><span class="n">DATEADD</span><span class="p">(</span><span class="k">day</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SYSDATETIME</span><span class="p">()))</span>
    <span class="n">PRINT</span> <span class="s1">'Today is the last day of the month but not the last day of the year.'</span><span class="p">;</span>
  <span class="k">ELSE</span>
    <span class="n">PRINT</span> <span class="s1">'Today is not the last day of the month.'</span><span class="p">;</span>
<span class="k">END</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">score</span> <span class="k">AS</span> <span class="nb">INT</span> <span class="o">=</span> <span class="k">CAST</span><span class="p">(</span><span class="n">RAND</span><span class="p">()</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">);</span>

<span class="n">IF</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;</span> <span class="mi">90</span>
  <span class="n">PRINT</span> <span class="s1">'A'</span><span class="p">;</span>
<span class="k">ELSE</span> <span class="n">IF</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;</span> <span class="mi">80</span>
  <span class="n">PRINT</span> <span class="s1">'B'</span><span class="p">;</span>
<span class="k">ELSE</span> <span class="n">IF</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;</span> <span class="mi">70</span>
  <span class="n">PRINT</span> <span class="s1">'C'</span><span class="p">;</span>
<span class="k">ELSE</span> <span class="n">IF</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;</span> <span class="mi">60</span>
  <span class="n">PRINT</span> <span class="s1">'D'</span><span class="p">;</span>
<span class="k">ELSE</span>
  <span class="n">PRINT</span> <span class="s1">'F'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- CASE is expression, instead of statement</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">score</span> <span class="k">AS</span> <span class="nb">INT</span> <span class="o">=</span> <span class="k">CAST</span><span class="p">(</span><span class="n">RAND</span><span class="p">()</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">);</span>

<span class="k">SELECT</span> <span class="k">CASE</span>
  <span class="k">WHEN</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">90</span> <span class="k">THEN</span> <span class="s1">'A'</span>
  <span class="k">WHEN</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">80</span> <span class="k">THEN</span> <span class="s1">'B'</span>
  <span class="k">WHEN</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">70</span> <span class="k">THEN</span> <span class="s1">'C'</span>
  <span class="k">WHEN</span> <span class="o">@</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">60</span> <span class="k">THEN</span> <span class="s1">'D'</span>
  <span class="k">ELSE</span> <span class="s1">'F'</span>
<span class="k">END</span> <span class="k">AS</span> <span class="n">Grade</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>WHILE</code> element executes a statement or statement block repeatedly while the predicate specified after the <code>WHILE</code> keyword is <code>TRUE</code>, otherwise, the loop terminates when the predicate is <code>FALSE</code> or <code>UNKNOWN</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">i</span> <span class="k">AS</span> <span class="nb">INT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">WHILE</span> <span class="o">@</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span>
<span class="k">BEGIN</span>
  <span class="k">SET</span> <span class="o">@</span><span class="n">i</span> <span class="o">=</span> <span class="o">@</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">IF</span> <span class="o">@</span><span class="n">i</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">CONTINUE</span><span class="p">;</span> <span class="c1">-- skip the rest of the activity in the current iteration and evaluate the loop’s predicate again</span>
  <span class="n">PRINT</span> <span class="o">@</span><span class="n">i</span><span class="p">;</span>
  <span class="n">IF</span> <span class="o">@</span><span class="n">i</span> <span class="o">=</span> <span class="mi">7</span> <span class="n">BREAK</span><span class="p">;</span>    <span class="c1">-- break out of the current loop and proceed to execute the statement that appears after the loop’s body</span>
<span class="k">END</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="cursors">13.4. Cursors</h3>
<div class="paragraph">
<p>SQL and T-SQL also support an object called <em>cursor</em> to process rows from a result of a query one at a time and in a requested order.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Primarily, the use of cursors contradicts the fundamental principles of the relational model, which is grounded in set theory.</p>
</li>
<li>
<p>Cursors, due to their record-by-record processing, incur significant overhead compared to set-based operations, resulting in significantly slower execution times even for similar underlying physical processing.</p>
</li>
<li>
<p>Cursor solutions, being imperative, tend to be longer, less readable, and harder to maintain than the declarative set solutions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Working with a cursor generally involves the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Declare the cursor based on a query.</p>
</li>
<li>
<p>Open the cursor.</p>
</li>
<li>
<p>Fetch attribute values from the first cursor record into variables.</p>
</li>
<li>
<p>While not reaching the end of the cursor (the value of a function called <code>@@FETCH_STATUS</code> is <code>0</code>), loop through the cursor records.</p>
<div class="paragraph">
<p>In each iteration of the loop, perform the processing needed for the current row, and then fetch the attribute values from the next row into the variables.</p>
</div>
</li>
<li>
<p>Close the cursor.</p>
</li>
<li>
<p>Deallocate the cursor.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">VIEW</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">Sales</span><span class="p">.</span><span class="n">CustOrders</span><span class="p">;</span>
<span class="k">GO</span>

<span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">Sales</span><span class="p">.</span><span class="n">CustOrders</span>
<span class="k">AS</span>
  <span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">O</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderdate</span> <span class="k">AS</span> <span class="n">ordermonth</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">OD</span><span class="p">.</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">qty</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span> <span class="k">AS</span> <span class="n">OD</span>
    <span class="k">ON</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span> <span class="o">=</span> <span class="n">OD</span><span class="p">.</span><span class="n">orderid</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">o</span><span class="p">.</span><span class="n">custid</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">orderdate</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Suppress messages indicating how many rows were affected</span>
<span class="k">SET</span> <span class="n">NOCOUNT</span> <span class="k">ON</span><span class="p">;</span>

<span class="c1">-- Declare table variable to hold the final result</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="k">Result</span> <span class="k">AS</span> <span class="k">TABLE</span>
<span class="p">(</span>
  <span class="n">custid</span>     <span class="nb">INT</span><span class="p">,</span>
  <span class="n">ordermonth</span> <span class="nb">DATE</span><span class="p">,</span>
  <span class="n">qty</span>        <span class="nb">INT</span><span class="p">,</span>
  <span class="n">runqty</span>     <span class="nb">INT</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">custid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">)</span>
<span class="p">);</span>

<span class="c1">-- Declare local variables that are used to store intermediate variables</span>
<span class="k">DECLARE</span>
  <span class="o">@</span><span class="n">custid</span>     <span class="k">AS</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="o">@</span><span class="n">prvcustid</span>  <span class="k">AS</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="o">@</span><span class="n">ordermonth</span> <span class="k">AS</span> <span class="nb">DATE</span><span class="p">,</span>
  <span class="o">@</span><span class="n">qty</span>        <span class="k">AS</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="o">@</span><span class="n">runqty</span>     <span class="k">AS</span> <span class="nb">INT</span><span class="p">;</span>

<span class="c1">-- Step 1: Declare the cursor based on a query</span>
<span class="k">DECLARE</span> <span class="k">C</span> <span class="k">CURSOR</span> <span class="n">FAST_FORWARD</span> <span class="cm">/* read only, forward only */</span> <span class="k">FOR</span>
  <span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">,</span> <span class="n">qty</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">CustOrders</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">;</span>

<span class="c1">-- Step 2: Open the cursor</span>
<span class="k">OPEN</span> <span class="k">C</span><span class="p">;</span>

<span class="c1">-- Step 3: Fetch attribute values from the first cursor record into variables</span>
<span class="k">FETCH</span> <span class="k">NEXT</span> <span class="k">FROM</span> <span class="k">C</span> <span class="k">INTO</span> <span class="o">@</span><span class="n">custid</span><span class="p">,</span> <span class="o">@</span><span class="n">ordermonth</span><span class="p">,</span> <span class="o">@</span><span class="n">qty</span><span class="p">;</span>

<span class="c1">-- Initialize variables</span>
<span class="k">SELECT</span> <span class="o">@</span><span class="n">prvcustid</span> <span class="o">=</span> <span class="o">@</span><span class="n">custid</span><span class="p">,</span> <span class="o">@</span><span class="n">runqty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">-- Step 4: Loop through the cursor records while last fetch was</span>
<span class="c1">--         In each iteration:</span>
<span class="c1">--            Reset variables if customer ID changes</span>
<span class="c1">--            Compute current running total and insert into table</span>
<span class="c1">--            Fetch next cursor record</span>
<span class="n">WHILE</span> <span class="o">@@</span><span class="n">FETCH_STATUS</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">BEGIN</span>
  <span class="n">IF</span> <span class="o">@</span><span class="n">custid</span> <span class="o">&lt;&gt;</span> <span class="o">@</span><span class="n">prvcustid</span>
    <span class="k">SELECT</span> <span class="o">@</span><span class="n">prvcustid</span> <span class="o">=</span> <span class="o">@</span><span class="n">custid</span><span class="p">,</span> <span class="o">@</span><span class="n">runqty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">SET</span> <span class="o">@</span><span class="n">runqty</span> <span class="o">=</span> <span class="o">@</span><span class="n">runqty</span> <span class="o">+</span> <span class="o">@</span><span class="n">qty</span><span class="p">;</span>

  <span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">@</span><span class="k">Result</span> <span class="k">VALUES</span><span class="p">(</span><span class="o">@</span><span class="n">custid</span><span class="p">,</span> <span class="o">@</span><span class="n">ordermonth</span><span class="p">,</span> <span class="o">@</span><span class="n">qty</span><span class="p">,</span> <span class="o">@</span><span class="n">runqty</span><span class="p">);</span>

  <span class="k">FETCH</span> <span class="k">NEXT</span> <span class="k">FROM</span> <span class="k">C</span> <span class="k">INTO</span> <span class="o">@</span><span class="n">custid</span><span class="p">,</span> <span class="o">@</span><span class="n">ordermonth</span><span class="p">,</span> <span class="o">@</span><span class="n">qty</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>

<span class="c1">-- Step 5: Close the cursor</span>
<span class="k">CLOSE</span> <span class="k">C</span><span class="p">;</span>

<span class="c1">-- Step 6: Deallocate the cursor</span>
<span class="k">DEALLOCATE</span> <span class="k">C</span><span class="p">;</span>

<span class="c1">-- Enable showing messages indicating how many rows were affected</span>
<span class="k">SET</span> <span class="n">NOCOUNT</span> <span class="k">OFF</span><span class="p">;</span>

<span class="c1">-- Query the table variable to return the final result</span>
<span class="k">SELECT</span>
  <span class="n">custid</span><span class="p">,</span>
  <span class="k">CONVERT</span><span class="p">(</span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">ordermonth</span><span class="p">,</span> <span class="mi">121</span><span class="p">)</span> <span class="k">AS</span> <span class="n">ordermonth</span><span class="p">,</span>
  <span class="n">qty</span><span class="p">,</span>
  <span class="n">runqty</span>
<span class="k">FROM</span> <span class="o">@</span><span class="k">Result</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- address the same task with a window function</span>
<span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">custid</span>
                <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ordermonth</span>
                <span class="k">ROWS</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span><span class="p">)</span> <span class="k">AS</span> <span class="n">runqty</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">CustOrders</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">custid</span><span class="p">,</span> <span class="n">ordermonth</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="temporary-tables">13.5. Temporary Tables</h3>
<div class="paragraph">
<p>Temporary tables are temporary storage structures within a SQL Server database. Unlike permanent tables, they are designed for short-term data storage and have limited lifespans.</p>
</div>
<div class="paragraph">
<p>SQL Server supports three kinds of temporary tables to be more conveniental to work with than permanent tables in such cases: local temporary tables, global temporary tables, and table variables. All three kinds of temporary tables are created in the <em>tempdb</em> database.</p>
</div>
<div class="paragraph">
<p>It&#8217;s crucial to distinguish temporary tables (local, global, table variables) from system-versioned temporal tables.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Temporary Tables: Primarily used for temporary storage within a specific session or batch, often for intermediate results or data manipulation.</p>
</li>
<li>
<p>System-Versioned Temporal Tables: Specifically designed to track the history of data changes over time.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="local-temporary-tables">13.5.1. Local Temporary Tables</h4>
<div class="paragraph">
<p>A <em>local temporary table</em> is created by naming it with a single number sign (<code>#</code>) as a prefix, such as <code>#T1</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A local temporary table is visible only to the session that created it, in the creating level and all inner levels in the call stack (inner procedures, triggers, and dynamic batches).</p>
</li>
<li>
<p>A local temporary table is destroyed automatically by SQL Server when the creating level in the call stack goes out of scope.</p>
</li>
<li>
<p>A suffix is added to the table name by SQL Server internally that makes it unique in <em>tempdb</em>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="o">#</span><span class="n">MyOrderTotalsByYear</span><span class="p">;</span>
<span class="k">GO</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">#</span><span class="n">MyOrderTotalsByYear</span>
<span class="p">(</span>
  <span class="n">orderyear</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">qty</span>       <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">#</span><span class="n">MyOrderTotalsByYear</span><span class="p">(</span><span class="n">orderyear</span><span class="p">,</span> <span class="n">qty</span><span class="p">)</span>
  <span class="k">SELECT</span>
    <span class="nb">YEAR</span><span class="p">(</span><span class="n">O</span><span class="p">.</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span>
    <span class="k">SUM</span><span class="p">(</span><span class="n">OD</span><span class="p">.</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">qty</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
    <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span> <span class="k">AS</span> <span class="n">OD</span>
      <span class="k">ON</span> <span class="n">OD</span><span class="p">.</span><span class="n">orderid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">);</span>

<span class="k">SELECT</span> <span class="n">Cur</span><span class="p">.</span><span class="n">orderyear</span><span class="p">,</span> <span class="n">Cur</span><span class="p">.</span><span class="n">qty</span> <span class="k">AS</span> <span class="n">curyearqty</span><span class="p">,</span> <span class="n">Prv</span><span class="p">.</span><span class="n">qty</span> <span class="k">AS</span> <span class="n">prvyearq</span>
<span class="k">FROM</span> <span class="o">#</span><span class="n">MyOrderTotalsByYear</span> <span class="k">AS</span> <span class="n">Cur</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="o">#</span><span class="n">MyOrderTotalsByYear</span> <span class="k">AS</span> <span class="n">Prv</span>
    <span class="k">ON</span> <span class="n">Cur</span><span class="p">.</span><span class="n">orderyear</span> <span class="o">=</span> <span class="n">Prv</span><span class="p">.</span><span class="n">orderyear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- clean up resources as soon as possible</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="o">#</span><span class="n">MyOrderTotalsByYear</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="global-temporary-tables">13.5.2. Global Temporary Tables</h4>
<div class="paragraph">
<p>A <em>global temporary table</em> is created by naming it with a double number sign (<code>##</code>) as a prefix, such as <code>##T1</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A global temporary table is visible to all other sessions.</p>
</li>
<li>
<p>A global temporary table is destroyed automatically by SQL Server when the creating session disconnects and there are no active references to the table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- creates a global temporary table called ##Globals with columns called id and val</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">##</span><span class="n">Globals</span>
<span class="p">(</span>
  <span class="n">id</span>  <span class="n">sysname</span>     <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">val</span> <span class="n">SQL_VARIANT</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- anyone can insert rows into the table.</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">##</span><span class="n">Globals</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="n">N</span><span class="s1">'I'</span><span class="p">,</span> <span class="k">CAST</span><span class="p">(</span><span class="mi">10</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- anyone can modify and retrieve data from the table.</span>
<span class="k">SELECT</span> <span class="n">val</span> <span class="k">FROM</span> <span class="o">##</span><span class="n">Globals</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'I'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- explicitly destroy the global temporary table</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="o">##</span><span class="n">Globals</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="table-variables">13.5.3. Table Variables</h4>
<div class="paragraph">
<p>A table variable is a local, temporary table-like data structure declared within a single batch.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As with local temporary tables, table variables have a physical presence as a table in the <em>tempdb</em> database.</p>
</li>
<li>
<p>Like local temporary tables, table variables are visible only to the creating session, but because they are variables they have a more limited scope: only the current batch.</p>
</li>
<li>
<p>If an explicit transaction is rolled back, changes made to temporary tables in that transaction are rolled back as well; however, changes made to table variables by statements that completed in the transaction aren’t rolled back.</p>
</li>
<li>
<p>In terms of performance, usually it makes more sense to use table variables with small volumes of data (only a few rows) and to use local temporary tables otherwise.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">MyOrderTotalsByYear</span> <span class="k">TABLE</span>
<span class="p">(</span>
  <span class="n">orderyear</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">qty</span>       <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">@</span><span class="n">MyOrderTotalsByYear</span><span class="p">(</span><span class="n">orderyear</span><span class="p">,</span> <span class="n">qty</span><span class="p">)</span>
  <span class="k">SELECT</span>
    <span class="nb">YEAR</span><span class="p">(</span><span class="n">O</span><span class="p">.</span><span class="n">orderdate</span><span class="p">)</span> <span class="k">AS</span> <span class="n">orderyear</span><span class="p">,</span>
    <span class="k">SUM</span><span class="p">(</span><span class="n">OD</span><span class="p">.</span><span class="n">qty</span><span class="p">)</span> <span class="k">AS</span> <span class="n">qty</span>
  <span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span> <span class="k">AS</span> <span class="n">O</span>
    <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">Sales</span><span class="p">.</span><span class="n">OrderDetails</span> <span class="k">AS</span> <span class="n">OD</span>
      <span class="k">ON</span> <span class="n">OD</span><span class="p">.</span><span class="n">orderid</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">orderid</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">);</span>

<span class="k">SELECT</span> <span class="n">Cur</span><span class="p">.</span><span class="n">orderyear</span><span class="p">,</span> <span class="n">Cur</span><span class="p">.</span><span class="n">qty</span> <span class="k">AS</span> <span class="n">curyearqty</span><span class="p">,</span> <span class="n">Prv</span><span class="p">.</span><span class="n">qty</span> <span class="k">AS</span> <span class="n">prvyearqty</span>
<span class="k">FROM</span> <span class="o">@</span><span class="n">MyOrderTotalsByYear</span> <span class="k">AS</span> <span class="n">Cur</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="o">@</span><span class="n">MyOrderTotalsByYear</span> <span class="k">AS</span> <span class="n">Prv</span>
    <span class="k">ON</span> <span class="n">Cur</span><span class="p">.</span><span class="n">orderyear</span> <span class="o">=</span> <span class="n">Prv</span><span class="p">.</span><span class="n">orderyear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A table type is a user-defined data structure that defines the schema (columns, data types) of a table to be reused as the table definition of table variables and input parameters of stored procedures and user-defined functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- create a table type called dbo.OrderTotalsByYear</span>
<span class="k">DROP</span> <span class="k">TYPE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">OrderTotalsByYear</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TYPE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">OrderTotalsByYear</span> <span class="k">AS</span> <span class="k">TABLE</span>
<span class="p">(</span>
  <span class="n">orderyear</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">qty</span>       <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- simply specify dbo.OrderTotalsByYear as the variable’s type</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">MyOrderTotalsByYear</span> <span class="k">AS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">OrderTotalsByYear</span><span class="p">;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-sql">13.6. Dynamic SQL</h3>
<div class="paragraph">
<p>A <em>dynamic SQL</em> in SQL Server is a batch of T-SQL code as a character string that can be executed by using the <code>EXEC</code> command and the <code>sp_executesql</code> stored procedure.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>EXEC</code> (short for <code>EXECUTE</code>) command accepts a regular or Unicode character string in parentheses as input and executes the batch of code within the character string.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="k">sql</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="k">SET</span> <span class="o">@</span><span class="k">sql</span> <span class="o">=</span> <span class="s1">'PRINT </span><span class="se">''</span><span class="s1">This message was printed by a dynamic SQL batch</span><span class="se">''</span><span class="s1">'</span>
<span class="k">EXEC</span><span class="p">(</span><span class="o">@</span><span class="k">sql</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>sp_executesql</code> stored procedure is an alternative tool to the <code>EXEC</code> command for executing dynamic SQL code.</p>
<div class="ulist">
<ul>
<li>
<p>It’s more secure and more flexible in the sense that it has an interface; that is, it supports input and output parameters.</p>
<div class="paragraph">
<p>In terms of security, parameters that appear in the code cannot be considered part of the code—they can only be considered operands in expressions.</p>
</div>
</li>
<li>
<p>Note that unlike EXEC, <code>sp_executesql</code> supports only Unicode character strings as the input batch of code.</p>
</li>
<li>
<p>The <code>sp_executesql</code> stored procedure can perform better than <code>EXEC</code> because its parameterization aids in reusing cached execution plans, which incur cost when SQL Server needs to create them anew.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>An <em>execution plan</em> is the physical processing plan SQL Server produces for a query, with the set of instructions describing which objects to access, in what order, which indexes to use, how to access them, which join algorithms to use, and so on.</p>
</li>
<li>
<p>One of the requirements for reusing a previously cached plan is that the query string be the same as the one for which the cached plan was created.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="k">sql</span> <span class="k">AS</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

<span class="k">SET</span> <span class="o">@</span><span class="k">sql</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'SELECT orderid, custid, empid, orderdate
FROM Sales.Orders
WHERE orderid = @orderid;'</span><span class="p">;</span>

<span class="k">EXEC</span> <span class="n">sp_executesql</span>
  <span class="o">@</span><span class="n">stmt</span> <span class="o">=</span> <span class="o">@</span><span class="k">sql</span><span class="p">,</span> <span class="c1">-- a Unicode character string holding the batch of code</span>
  <span class="o">@</span><span class="n">params</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'@orderid AS INT'</span><span class="p">,</span> <span class="c1">-- a Unicode character string holding the declarations of input and output parameters</span>
  <span class="o">@</span><span class="n">orderid</span> <span class="o">=</span> <span class="mi">10248</span><span class="p">;</span> <span class="c1">-- an input parameter called @orderid</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="routines">13.7. Routines</h3>
<div class="paragraph">
<p>Routines are programmable objects that encapsulate code to calculate a result or to execute activity. SQL Server supports three types of routines: user-defined functions, stored procedures, and triggers.</p>
</div>
<div class="sect3">
<h4 id="user-defined-functions">13.7.1. User-defined Functions</h4>
<div class="paragraph">
<p>A user-defined function (UDF) is used to encapsulate logic that calculates something, possibly based on input parameters, and return a result. SQL Server supports scalar and table-valued UDFs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Scalar UDFs return a single value; table-valued UDFs return a table.</p>
</li>
<li>
<p>Scalar UDFs can appear anywhere in the query where an expression that returns a single value can appear (for example, in the <code>SELECT</code> list).</p>
</li>
<li>
<p>Table UDFs can appear in the <code>FROM</code> clause of a query.</p>
</li>
<li>
<p>UDFs are not allowed to have any side effects, that means UDFs are not allowed to apply any schema or data changes in the database.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">FUNCTION</span> <span class="n">dbo</span><span class="p">.</span><span class="n">GetNewID</span><span class="p">()</span>
<span class="k">RETURNS</span> <span class="n">UNIQUEIDENTIFIER</span>
<span class="k">AS</span>
<span class="k">BEGIN</span>
  <span class="k">RETURN</span> <span class="n">NEWID</span><span class="p">();</span> <span class="c1">-- Invalid use of a side-effecting operator 'newid' within a function.</span>
<span class="k">END</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- create a UDF called dbo.GetAge that returns the age of a person</span>
<span class="k">DROP</span> <span class="k">FUNCTION</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">GetAge</span><span class="p">;</span>
<span class="k">GO</span>

<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">FUNCTION</span> <span class="n">dbo</span><span class="p">.</span><span class="n">GetAge</span>
<span class="p">(</span>
  <span class="o">@</span><span class="n">birthdate</span> <span class="k">AS</span> <span class="nb">DATE</span><span class="p">,</span> <span class="c1">-- a specified birth date (@birthdate argument)</span>
  <span class="o">@</span><span class="n">eventdate</span> <span class="k">AS</span> <span class="nb">DATE</span>  <span class="c1">-- a specified event date (@eventdate argument)</span>
<span class="p">)</span>
<span class="k">RETURNS</span> <span class="nb">INT</span>
<span class="k">AS</span>

<span class="k">BEGIN</span>
  <span class="k">RETURN</span> <span class="c1">-- a RETURN clause that returns a value</span>
    <span class="n">DATEDIFF</span><span class="p">(</span><span class="nb">year</span><span class="p">,</span> <span class="o">@</span><span class="n">birthdate</span><span class="p">,</span> <span class="o">@</span><span class="n">eventdate</span><span class="p">)</span>
    <span class="o">-</span> <span class="k">CASE</span> <span class="k">WHEN</span> <span class="mi">100</span> <span class="o">*</span> <span class="k">MONTH</span><span class="p">(</span><span class="o">@</span><span class="n">eventdate</span><span class="p">)</span> <span class="o">+</span> <span class="k">DAY</span><span class="p">(</span><span class="o">@</span><span class="n">eventdate</span><span class="p">)</span>
              <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">*</span> <span class="k">MONTH</span><span class="p">(</span><span class="o">@</span><span class="n">birthdate</span><span class="p">)</span> <span class="o">+</span> <span class="k">DAY</span><span class="p">(</span><span class="o">@</span><span class="n">birthdate</span><span class="p">)</span>
           <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span>
      <span class="k">END</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="k">GO</span>

<span class="c1">-- use a UDF in a query</span>
<span class="k">SELECT</span>
  <span class="n">empid</span><span class="p">,</span> <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span><span class="p">,</span> <span class="n">birthdate</span><span class="p">,</span>
  <span class="n">dbo</span><span class="p">.</span><span class="n">GetAge</span><span class="p">(</span><span class="n">birthdate</span><span class="p">,</span> <span class="n">SYSDATETIME</span><span class="p">())</span> <span class="k">AS</span> <span class="n">age</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="stored-procedures">13.7.2. Stored Procedures</h4>
<div class="paragraph">
<p>Stored procedures are routines that encapsulate logic with input and output parameters, return result sets of queries, and can have side effects.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stored procedures encapsulate logic, allowing for centralized modification and ensuring all users utilize the updated implementation.</p>
</li>
<li>
<p>Stored procedures give better control of security.</p>
<div class="ulist">
<ul>
<li>
<p>A user permissions can be granted to execute the procedure without granting the user direct permissions to perform the underlying activities to ensure that all the required validations and auditing always take place.</p>
</li>
<li>
<p>Stored procedures with parameters can help prevent SQL injection.</p>
</li>
</ul>
</div>
</li>
<li>
<p>All error-handling code can be incorporated within a procedure, silently taking corrective action where relevant.</p>
</li>
<li>
<p>Stored procedures give performance benefits.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Parameterized queries within stored procedures enhance performance by leveraging cached execution plans.</p>
</li>
<li>
<p>Stored procedures reduce network traffic by minimizing data exchange between the client and server.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- create a stored procedure called Sales.GetCustomerOrders</span>
<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="n">PROC</span> <span class="n">Sales</span><span class="p">.</span><span class="n">GetCustomerOrders</span>
  <span class="c1">-- a customer ID (@custid) and a date range (@fromdate and @todate) as inputs</span>
  <span class="o">@</span><span class="n">custid</span>   <span class="k">AS</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="o">@</span><span class="n">fromdate</span> <span class="k">AS</span> <span class="nb">DATETIME</span> <span class="o">=</span> <span class="s1">'19000101'</span><span class="p">,</span> <span class="c1">-- default 19000101</span>
  <span class="o">@</span><span class="n">todate</span>   <span class="k">AS</span> <span class="nb">DATETIME</span> <span class="o">=</span> <span class="s1">'99991231'</span><span class="p">,</span> <span class="c1">-- default 99991231</span>
  <span class="o">@</span><span class="n">numrows</span>  <span class="k">AS</span> <span class="nb">INT</span> <span class="k">OUTPUT</span> <span class="c1">-- the number of affected rows (@numrows) as an output</span>
<span class="k">AS</span>
<span class="k">SET</span> <span class="n">NOCOUNT</span> <span class="k">ON</span><span class="p">;</span> <span class="c1">-- suppress messages indicating affected rows by DML</span>

<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">custid</span> <span class="o">=</span> <span class="o">@</span><span class="n">custid</span>
  <span class="k">AND</span> <span class="n">orderdate</span> <span class="o">&gt;=</span> <span class="o">@</span><span class="n">fromdate</span>
  <span class="k">AND</span> <span class="n">orderdate</span> <span class="o">&lt;</span> <span class="o">@</span><span class="n">todate</span><span class="p">;</span>

<span class="k">SET</span> <span class="o">@</span><span class="n">numrows</span> <span class="o">=</span> <span class="o">@@</span><span class="n">rowcount</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- execute the procedure, and absorb the value of the output parameter @numrows in the variable @rc</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">rc</span> <span class="k">AS</span> <span class="nb">INT</span><span class="p">;</span>

<span class="k">EXEC</span> <span class="n">Sales</span><span class="p">.</span><span class="n">GetCustomerOrders</span>
  <span class="o">@</span><span class="n">custid</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="o">@</span><span class="n">fromdate</span> <span class="o">=</span> <span class="s1">'20210101'</span><span class="p">,</span>
  <span class="o">@</span><span class="n">todate</span>   <span class="o">=</span> <span class="s1">'20220101'</span><span class="p">,</span>
  <span class="o">@</span><span class="n">numrows</span>  <span class="o">=</span> <span class="o">@</span><span class="n">rc</span> <span class="k">OUTPUT</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">@</span><span class="n">rc</span> <span class="k">AS</span> <span class="n">numrows</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="triggers">13.7.3. Triggers</h4>
<div class="paragraph">
<p>A trigger is a special kind of stored procedure attached to an event—one that cannot be executed explicitly.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SQL Server supports the association of triggers with two kinds of events: data manipulation events (DML triggers) such as INSERT, and data definition events (DDL triggers) such as CREATE TABLE.</p>
</li>
<li>
<p>A trigger is considered part of the transaction that includes the event that caused the trigger to fire.</p>
</li>
<li>
<p>Triggers in SQL Server fire per statement and not per modified row.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="dml-triggers">13.7.3.1. DML Triggers</h5>
<div class="paragraph">
<p>SQL Server supports two kinds of DML triggers: <em>after</em> and <em>instead of</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <em>after trigger</em> fires after the event it’s associated with finishes and can be defined only on permanent tables.</p>
</li>
<li>
<p>An <em>instead of trigger</em> fires instead of the event it’s associated with and can be defined on permanent tables and views.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the trigger’s code, pseudo tables called inserted and deleted that contain the rows that were affected by the modification that caused the trigger to fire can be accessed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>inserted table</em> holds the new image of the affected rows in the case of INSERT and UPDATE actions.</p>
</li>
<li>
<p>The <em>deleted table</em> holds the old image of the affected rows in the case of DELETE and UPDATE actions.</p>
</li>
<li>
<p>In the case of instead of triggers, the inserted and deleted tables contain the rows that were supposed to be affected by the modification that caused the trigger to fire.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- create a table called dbo.T1, and a table called dbo.T1_Audit</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1_Audit</span><span class="p">,</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span>
<span class="p">(</span>
  <span class="n">keycol</span>  <span class="nb">INT</span>         <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">datacol</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1_Audit</span>
<span class="p">(</span>
  <span class="n">audit_lsn</span>  <span class="nb">INT</span>          <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="c1">-- audit log serial number</span>
  <span class="n">dt</span>         <span class="n">DATETIME2</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span><span class="p">(</span><span class="n">SYSDATETIME</span><span class="p">()),</span>
  <span class="n">login_name</span> <span class="n">sysname</span>      <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span><span class="p">(</span><span class="n">ORIGINAL_LOGIN</span><span class="p">()),</span>
  <span class="n">keycol</span>     <span class="nb">INT</span>          <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">datacol</span>    <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>
<span class="k">GO</span>

<span class="c1">-- create the AFTER INSERT trigger trg_T1_insert_audit on the T1 table to audit insertions</span>
<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">TRIGGER</span> <span class="n">trg_T1_insert_audit</span> <span class="k">ON</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span> <span class="k">AFTER</span> <span class="k">INSERT</span>
<span class="k">AS</span>
<span class="k">SET</span> <span class="n">NOCOUNT</span> <span class="k">ON</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1_Audit</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="n">datacol</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">keycol</span><span class="p">,</span> <span class="n">datacol</span> <span class="k">FROM</span> <span class="n">inserted</span><span class="p">;</span>
<span class="k">GO</span>

<span class="c1">-- trigger fires after each statement</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="n">datacol</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="n">datacol</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="n">datacol</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="s1">'g'</span><span class="p">);</span>
<span class="k">GO</span>

<span class="k">SELECT</span> <span class="n">audit_lsn</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">login_name</span><span class="p">,</span> <span class="n">keycol</span><span class="p">,</span> <span class="n">datacol</span>
<span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1_Audit</span><span class="p">;</span>
<span class="c1">-- 1	2025-01-15 16:03:50.997	sa	10	a</span>
<span class="c1">-- 2	2025-01-15 16:03:51.004	sa	30	x</span>
<span class="c1">-- 3	2025-01-15 16:03:51.008	sa	20	g</span>
<span class="k">GO</span>

<span class="c1">-- cleanup</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1_Audit</span><span class="p">,</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ddl-triggers">13.7.3.2. DDL Triggers</h5>
<div class="paragraph">
<p>SQL Server supports DDL triggers, which can be used for purposes such as auditing, policy enforcement, and change management.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SQL Server box product supports the creation of DDL triggers at two scopes, the database scope and the server scope, depending on the scope of the event.</p>
</li>
<li>
<p>Azure SQL Database currently supports only database triggers.</p>
</li>
<li>
<p>SQL Server supports only after DDL triggers; it doesn’t support instead of DDL triggers.</p>
</li>
<li>
<p>Within the trigger, information about the event that caused the trigger to fire can be obtained by querying a function called <code>EVENTDATA</code>, which returns the event information as an XML instance.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- creates the dbo.AuditDDLEvents table to hold the audit information</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">AuditDDLEvents</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">AuditDDLEvents</span>
<span class="p">(</span>
  <span class="n">audit_lsn</span>        <span class="nb">INT</span>          <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">,</span>
  <span class="n">posttime</span>         <span class="n">DATETIME2</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">eventtype</span>        <span class="n">sysname</span>      <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">loginname</span>        <span class="n">sysname</span>      <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">schemaname</span>       <span class="n">sysname</span>      <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">objectname</span>       <span class="n">sysname</span>      <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">targetobjectname</span> <span class="n">sysname</span>      <span class="k">NULL</span><span class="p">,</span>
  <span class="n">eventdata</span>        <span class="n">XML</span>          <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">CONSTRAINT</span> <span class="n">PK_AuditDDLEvents</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">audit_lsn</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">GO</span>

<span class="c1">-- create the trg_audit_ddl_events audit trigger on the database by using the event group DDL_DATABASE_LEVEL_EVENTS</span>
<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="k">TRIGGER</span> <span class="n">trg_audit_ddl_events</span>
  <span class="k">ON</span> <span class="k">DATABASE</span> <span class="k">FOR</span> <span class="n">DDL_DATABASE_LEVEL_EVENTS</span>
<span class="k">AS</span>
<span class="k">SET</span> <span class="n">NOCOUNT</span> <span class="k">ON</span><span class="p">;</span>

<span class="k">DECLARE</span> <span class="o">@</span><span class="n">eventdata</span> <span class="k">AS</span> <span class="n">XML</span> <span class="o">=</span> <span class="n">eventdata</span><span class="p">();</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">AuditDDLEvents</span><span class="p">(</span>
  <span class="n">posttime</span><span class="p">,</span> <span class="n">eventtype</span><span class="p">,</span> <span class="n">loginname</span><span class="p">,</span> <span class="n">schemaname</span><span class="p">,</span>
  <span class="n">objectname</span><span class="p">,</span> <span class="n">targetobjectname</span><span class="p">,</span> <span class="n">eventdata</span><span class="p">)</span>
  <span class="k">VALUES</span><span class="p">(</span>
    <span class="o">@</span><span class="n">eventdata</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s1">'(/EVENT_INSTANCE/PostTime)[1]'</span><span class="p">,</span> <span class="s1">'VARCHAR(23)'</span><span class="p">),</span> <span class="c1">-- XQuery expressions</span>
    <span class="o">@</span><span class="n">eventdata</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s1">'(/EVENT_INSTANCE/EventType)[1]'</span><span class="p">,</span> <span class="s1">'sysname'</span><span class="p">),</span>
    <span class="o">@</span><span class="n">eventdata</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s1">'(/EVENT_INSTANCE/LoginName)[1]'</span><span class="p">,</span> <span class="s1">'sysname'</span><span class="p">),</span>
    <span class="o">@</span><span class="n">eventdata</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s1">'(/EVENT_INSTANCE/SchemaName)[1]'</span><span class="p">,</span> <span class="s1">'sysname'</span><span class="p">),</span>
    <span class="o">@</span><span class="n">eventdata</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s1">'(/EVENT_INSTANCE/ObjectName)[1]'</span><span class="p">,</span> <span class="s1">'sysname'</span><span class="p">),</span>
    <span class="o">@</span><span class="n">eventdata</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s1">'(/EVENT_INSTANCE/TargetObjectName)[1]'</span><span class="p">,</span> <span class="s1">'sysname'</span><span class="p">),</span>
    <span class="o">@</span><span class="n">eventdata</span><span class="p">);</span>
<span class="k">GO</span>

<span class="c1">-- test the trigger</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">col1</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">);</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span> <span class="k">ADD</span> <span class="n">col2</span> <span class="nb">INT</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span> <span class="k">ALTER</span> <span class="k">COLUMN</span> <span class="n">col2</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="n">NONCLUSTERED</span> <span class="k">INDEX</span> <span class="n">idx1</span> <span class="k">ON</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">(</span><span class="n">col2</span><span class="p">);</span>
<span class="k">GO</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">AuditDDLEvents</span><span class="p">;</span>
<span class="k">GO</span>

<span class="c1">-- cleanup</span>
<span class="k">DROP</span> <span class="k">TRIGGER</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">trg_audit_ddl_events</span> <span class="k">ON</span> <span class="k">DATABASE</span><span class="p">;</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">AuditDDLEvents</span><span class="p">,</span> <span class="n">dbo</span><span class="p">.</span><span class="n">T1</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error-handling-try-catch">13.8. Error Handling: TRY-CATCH</h3>
<div class="paragraph">
<p>The <code>TRY. . .CATCH</code> construct in SQL Server handles errors by placing the usual T-SQL code in a <code>TRY</code> block and placing all the error-handling code in the adjacent <code>CATCH</code> block.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the <code>TRY</code> block has no error, the <code>CATCH</code> block is simply skipped.</p>
</li>
<li>
<p>If the <code>TRY</code> block has an error, control is passed to the corresponding <code>CATCH</code> block.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">BEGIN</span> <span class="n">TRY</span>   <span class="c1">-- TRY block (between the BEGIN TRY and END TRY keywords)</span>
  <span class="n">PRINT</span> <span class="mi">10</span><span class="o">/</span><span class="mi">0</span><span class="p">;</span>
  <span class="n">PRINT</span> <span class="s1">'No error'</span><span class="p">;</span>
<span class="k">END</span> <span class="n">TRY</span>
<span class="k">BEGIN</span> <span class="n">CATCH</span> <span class="c1">-- CATCH block (between the BEGIN CATCH and END CATCH keywords)</span>
  <span class="n">PRINT</span> <span class="s1">'    Error Message : '</span> <span class="o">+</span> <span class="n">ERROR_MESSAGE</span><span class="p">();</span>
  <span class="n">PRINT</span> <span class="s1">'    Error Line    : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_LINE</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="k">END</span> <span class="n">CATCH</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>SQL Server also provides a set of functions to get information about the error.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>ERROR_NUMBER</code> function returns an integer with the number of the error.</p>
</li>
<li>
<p>The <code>ERROR_MESSAGE</code> function returns error-message text.</p>
<div class="paragraph">
<p>To get the list of error numbers and messages, query the <code>sys.messages</code> catalog view.</p>
</div>
</li>
<li>
<p>The <code>ERROR_SEVERITY</code> and <code>ERROR_STATE</code> functions return the error severity and state.</p>
</li>
<li>
<p>The <code>ERROR_LINE</code> function returns the line number in the code where the error happened.</p>
</li>
<li>
<p>The <code>ERROR_PROCEDURE</code> function returns the name of the procedure in which the error happened and returns <code>NULL</code> if the error did not happen within a procedure.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- create a table called dbo.Employees</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span>
<span class="p">(</span>
  <span class="n">empid</span>   <span class="nb">INT</span>         <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">empname</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">mgrid</span>   <span class="nb">INT</span>         <span class="k">NULL</span><span class="p">,</span>
  <span class="k">CONSTRAINT</span> <span class="n">PK_Employees</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">empid</span><span class="p">),</span>
  <span class="k">CONSTRAINT</span> <span class="n">CHK_Employees_empid</span> <span class="k">CHECK</span><span class="p">(</span><span class="n">empid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
  <span class="k">CONSTRAINT</span> <span class="n">FK_Employees_Employees</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="n">mgrid</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">(</span><span class="n">empid</span><span class="p">)</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">BEGIN</span> <span class="n">TRY</span>
  <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">)</span>
    <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Emp1'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">);</span>
  <span class="c1">-- Also try with empid = 0, 'A', NULL</span>
<span class="k">END</span> <span class="n">TRY</span>
<span class="k">BEGIN</span> <span class="n">CATCH</span>
  <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2627</span>
  <span class="k">BEGIN</span>
    <span class="n">PRINT</span> <span class="s1">'    Handling PK violation...'</span><span class="p">;</span>
  <span class="k">END</span><span class="p">;</span>
  <span class="k">ELSE</span> <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">547</span>
  <span class="k">BEGIN</span>
    <span class="n">PRINT</span> <span class="s1">'    Handling CHECK/FK constraint violation...'</span><span class="p">;</span>
  <span class="k">END</span><span class="p">;</span>
  <span class="k">ELSE</span> <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">515</span>
  <span class="k">BEGIN</span>
    <span class="n">PRINT</span> <span class="s1">'    Handling NULL violation...'</span><span class="p">;</span>
  <span class="k">END</span><span class="p">;</span>
  <span class="k">ELSE</span> <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">245</span>
  <span class="k">BEGIN</span>
    <span class="n">PRINT</span> <span class="s1">'    Handling conversion error...'</span><span class="p">;</span>
  <span class="k">END</span><span class="p">;</span>
  <span class="k">ELSE</span>
  <span class="k">BEGIN</span>
    <span class="n">PRINT</span> <span class="s1">'Re-throwing error...'</span><span class="p">;</span>
  <span class="n">THROW</span><span class="p">;</span>    <span class="c1">--  re-throws the error</span>
  <span class="k">END</span><span class="p">;</span>
  <span class="n">PRINT</span> <span class="s1">'    Error Number  : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">PRINT</span> <span class="s1">'    Error Message : '</span> <span class="o">+</span> <span class="n">ERROR_MESSAGE</span><span class="p">();</span>
  <span class="n">PRINT</span> <span class="s1">'    Error Severity: '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_SEVERITY</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">PRINT</span> <span class="s1">'    Error State   : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_STATE</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">PRINT</span> <span class="s1">'    Error Line    : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_LINE</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">PRINT</span> <span class="s1">'    Error Proc    : '</span> <span class="o">+</span> <span class="n">COALESCE</span><span class="p">(</span><span class="n">ERROR_PROCEDURE</span><span class="p">(),</span> <span class="s1">'Not within a procedure'</span><span class="p">);</span>
<span class="k">END</span> <span class="n">CATCH</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- a stored procedure that encapsulates reusable error-handling code</span>
<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">ALTER</span> <span class="n">PROC</span> <span class="n">dbo</span><span class="p">.</span><span class="n">ErrInsertHandler</span>
<span class="k">AS</span>
<span class="k">SET</span> <span class="n">NOCOUNT</span> <span class="k">ON</span><span class="p">;</span>
<span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2627</span>
<span class="k">BEGIN</span>
  <span class="n">PRINT</span> <span class="s1">'Handling PK violation...'</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="k">ELSE</span> <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">547</span>
<span class="k">BEGIN</span>
  <span class="n">PRINT</span> <span class="s1">'Handling CHECK/FK constraint violation...'</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="k">ELSE</span> <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">515</span>
<span class="k">BEGIN</span>
  <span class="n">PRINT</span> <span class="s1">'Handling NULL violation...'</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="k">ELSE</span> <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="o">=</span> <span class="mi">245</span>
<span class="k">BEGIN</span>
  <span class="n">PRINT</span> <span class="s1">'Handling conversion error...'</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="n">PRINT</span> <span class="s1">'Error Number  : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="n">PRINT</span> <span class="s1">'Error Number  : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="n">PRINT</span> <span class="s1">'Error Message : '</span> <span class="o">+</span> <span class="n">ERROR_MESSAGE</span><span class="p">();</span>
<span class="n">PRINT</span> <span class="s1">'Error Severity: '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_SEVERITY</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="n">PRINT</span> <span class="s1">'Error State   : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_STATE</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="n">PRINT</span> <span class="s1">'Error Line    : '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="n">ERROR_LINE</span><span class="p">()</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="n">PRINT</span> <span class="s1">'Error Proc    : '</span> <span class="o">+</span> <span class="n">COALESCE</span><span class="p">(</span><span class="n">ERROR_PROCEDURE</span><span class="p">(),</span> <span class="s1">'Not within a procedure'</span><span class="p">);</span>
<span class="k">GO</span>

<span class="k">BEGIN</span> <span class="n">TRY</span>
  <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">(</span><span class="n">empid</span><span class="p">,</span> <span class="n">empname</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">)</span>
    <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Emp1'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">);</span>
<span class="k">END</span> <span class="n">TRY</span>
<span class="k">BEGIN</span> <span class="n">CATCH</span>
  <span class="n">IF</span> <span class="n">ERROR_NUMBER</span><span class="p">()</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">2627</span><span class="p">,</span> <span class="mi">547</span><span class="p">,</span> <span class="mi">515</span><span class="p">,</span> <span class="mi">245</span><span class="p">)</span>
    <span class="k">EXEC</span> <span class="n">dbo</span><span class="p">.</span><span class="n">ErrInsertHandler</span><span class="p">;</span>
<span class="k">ELSE</span> <span class="n">THROW</span><span class="p">;</span>
<span class="k">END</span> <span class="n">CATCH</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- clean up</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span>
<span class="k">DROP</span> <span class="n">PROC</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dbo</span><span class="p">.</span><span class="n">ErrInsertHandler</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="json">14. JSON</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JSON is a widely-used text format for data exchange in modern applications and for storing unstructured data. SQL Server 2016 and later versions provide built-in functions that integrate JSON with relational data, enabling the storage and querying of JSON documents within the database and the formatting of relational query results as JSON text.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A native <a href="https://learn.microsoft.com/en-us/sql/t-sql/data-types/json-data-type"><code>JSON</code></a> data type, available in Azure SQL and in preview for SQL Server 2025, stores JSON in an optimized binary format, which provides more efficient reads, writes, and storage compared to traditional string types, while maintaining compatibility with existing query functions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="isjson-json_value-json_query-and-json_modify">14.1. ISJSON, JSON_VALUE, JSON_QUERY, and JSON_MODIFY</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/isjson-transact-sql"><code>ISJSON()</code></a> checks if a string contains valid JSON.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/json-value-transact-sql"><code>JSON_VALUE()</code></a> extracts a single scalar value (like a string or number).</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/json-query-transact-sql"><code>JSON_QUERY()</code></a> extracts a JSON object or an array.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/json-modify-transact-sql"><code>JSON_MODIFY()</code></a> updates a property within a JSON string and returns the new string.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These functions use a JavaScript-like <a href="https://learn.microsoft.com/en-us/sql/relational-databases/json/json-path-expressions-sql-server">path syntax</a> to reference nested elements, and the extracted values can be used in any part of a T-SQL query, such as <code>WHERE</code> or <code>ORDER BY</code> clauses.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The path expressions for <code>JSON_VALUE</code>, <code>JSON_QUERY</code>, and <code>JSON_MODIFY</code> can be prefixed with <code>lax</code> (the default) or <code>strict</code>. <code>lax</code> mode returns <code>NULL</code> (or an empty result for <code>JSON_QUERY</code>) if the path is not found, whereas <code>strict</code> mode will raise an error.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the input JSON expression is <code>NULL</code>, all JSON functions will return <code>NULL</code>. However, if the input is not <code>NULL</code> but is an invalid JSON text, the functions will raise an error. It is a best practice to use <code>ISJSON()</code> to validate the input before applying other JSON functions.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Declare a variable to hold JSON data</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">person</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="k">MAX</span><span class="p">)</span> <span class="o">=</span> <span class="s1">'{ "name": "Jane Doe", "status": "Active", "location": { "city": "Belgrade", "country": "Serbia" }, "skills": [ "T-SQL", "Power BI" ] }'</span><span class="p">;</span>

<span class="c1">-- Check if the JSON is valid before querying</span>
<span class="n">IF</span> <span class="n">ISJSON</span><span class="p">(</span><span class="o">@</span><span class="n">person</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">BEGIN</span>
    <span class="c1">-- Extract values and use them in a SELECT statement</span>
    <span class="c1">-- This uses the default 'lax' mode. A non-existent path would return NULL.</span>
    <span class="k">SELECT</span>
        <span class="n">JSON_VALUE</span><span class="p">(</span><span class="o">@</span><span class="n">person</span><span class="p">,</span> <span class="s1">'$.name'</span><span class="p">)</span> <span class="k">AS</span> <span class="n">Name</span><span class="p">,</span>
        <span class="n">JSON_VALUE</span><span class="p">(</span><span class="o">@</span><span class="n">person</span><span class="p">,</span> <span class="s1">'$.location.city'</span><span class="p">)</span> <span class="k">AS</span> <span class="n">City</span><span class="p">,</span>
        <span class="n">JSON_QUERY</span><span class="p">(</span><span class="o">@</span><span class="n">person</span><span class="p">,</span> <span class="s1">'$.skills'</span><span class="p">)</span> <span class="k">AS</span> <span class="n">Skills</span><span class="p">,</span>
        <span class="n">JSON_VALUE</span><span class="p">(</span><span class="o">@</span><span class="n">person</span><span class="p">,</span> <span class="s1">'$.info.age'</span><span class="p">)</span> <span class="k">AS</span> <span class="n">Age</span><span class="p">;</span> <span class="c1">-- This path doesn't exist, will return NULL</span>

    <span class="c1">-- Using 'strict' mode will cause an error if the path is not found.</span>
    <span class="c1">-- SELECT JSON_VALUE(@person, 'strict $.info.age'); -- This would raise an error.</span>

    <span class="c1">-- Modify the city from "Belgrade" to "London"</span>
    <span class="k">SET</span> <span class="o">@</span><span class="n">person</span> <span class="o">=</span> <span class="n">JSON_MODIFY</span><span class="p">(</span><span class="o">@</span><span class="n">person</span><span class="p">,</span> <span class="s1">'$.location.city'</span><span class="p">,</span> <span class="s1">'London'</span><span class="p">);</span>

    <span class="c1">-- Display the updated JSON</span>
    <span class="k">SELECT</span> <span class="o">@</span><span class="n">person</span> <span class="k">AS</span> <span class="n">UpdatedPersonJSON</span><span class="p">;</span>
<span class="k">END</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>ISJSON</code> function returns <code>1</code> for valid JSON, <code>0</code> for invalid, and <code>NULL</code> for a <code>NULL</code> input, and the conditions <code>ISJSON(col) &gt; 0</code> and <code>ISJSON(col) = 1</code> are functionally identical for validation and result in the same execution plan.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="openjson">14.2. OPENJSON</h3>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql"><code>OPENJSON</code></a> rowset function transforms JSON text into a structured rowset to enable standard T-SQL querying, requiring <a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/view-or-change-the-compatibility-level-of-a-database">database compatibility</a> level 130 or higher. By default, the function returns first-level key/value pairs from a JSON object or all elements with their indexes from a JSON array.</p>
</div>
<div class="paragraph">
<p>It operates in two primary modes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Default Schema (without a <code>WITH</code> clause) returns a key-value table with <code>key</code>, <code>value</code>, and <code>type</code> columns, which is useful for inspecting a document&#8217;s structure.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">json</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="k">MAX</span><span class="p">)</span> <span class="o">=</span>
<span class="s1">'{
    "name": "John Doe",
    "age": 45,
    "isStudent": false,
    "skills": [ "SQL", "C#" ]
}'</span><span class="p">;</span>

<span class="c1">-- Use the default schema to return a key-value table</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">OPENJSON</span><span class="p">(</span><span class="o">@</span><span class="n">json</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Result Set</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">key         value               type
---
name        John Doe            1
age         45                  2
isStudent   false               0
</span><span class="gp">skills      ["SQL","C#</span><span class="s2">"]        4</span></code></pre>
</div>
</div>
</li>
<li>
<p>Explicit Schema (with a <code>WITH</code> clause) shreds a JSON array into a relational format by mapping user-defined columns, data types, and JSON paths in an explicit schema definition.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">json</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="k">MAX</span><span class="p">)</span> <span class="o">=</span>
<span class="n">N</span><span class="s1">'[
    { "OrderNumber": "SO43659", "OrderDate": "2024-05-31", "Customer": "AW29825", "Quantity": 1 },
    { "OrderNumber": "SO43661", "OrderDate": "2024-06-01", "Customer": "AW73565", "Quantity": 3 }
]'</span><span class="p">;</span>

<span class="c1">-- Use an explicit schema to define the output table structure</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">OPENJSON</span><span class="p">(</span><span class="o">@</span><span class="n">json</span><span class="p">)</span>
<span class="k">WITH</span> <span class="p">(</span>
    <span class="n">Number</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="s1">'$.OrderNumber'</span><span class="p">,</span>
    <span class="p">[</span><span class="nb">Date</span><span class="p">]</span> <span class="nb">DATETIME</span> <span class="s1">'$.OrderDate'</span><span class="p">,</span>
    <span class="n">CustomerAcct</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="s1">'$.Customer'</span><span class="p">,</span>
    <span class="n">Qty</span> <span class="nb">INT</span> <span class="s1">'$.Quantity'</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Result Set</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Number     Date                    CustomerAcct   Qty
---
SO43659    2024-05-31 00:00:00.000   AW29825        1
SO43661    2024-06-01 00:00:00.000   AW73565        3</span></code></pre>
</div>
</div>
</li>
<li>
<p>JSON documents might have sub-elements and hierarchical data that can&#8217;t be directly mapped into the standard relational columns. To flatten hierarchical JSON, a primary <code>OPENJSON</code> call extracts a nested array as a JSON text fragment using the <code>AS JSON</code> option, which is then unnested by a second <code>OPENJSON</code> call via an <code>APPLY</code> operator.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">json</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="k">MAX</span><span class="p">)</span> <span class="o">=</span> <span class="n">N</span><span class="s1">'[
  {"id": 2, "info": {"name": "John", "surname": "Smith"}, "age": 25},
  {"id": 5, "info": {"name": "Jane", "surname": "Smith", "skills": ["SQL", "C#", "Azure"]}, "dob": "2005-11-04T12:00:00"}
]'</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">firstName</span><span class="p">,</span> <span class="n">lastName</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">dateOfBirth</span><span class="p">,</span> <span class="n">skill</span>
<span class="k">FROM</span> <span class="n">OPENJSON</span><span class="p">(</span><span class="o">@</span><span class="n">json</span><span class="p">)</span>
<span class="k">WITH</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INT</span> <span class="s1">'strict $.id'</span><span class="p">,</span>
    <span class="n">firstName</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="s1">'$.info.name'</span><span class="p">,</span>
    <span class="n">lastName</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="s1">'$.info.surname'</span><span class="p">,</span>
    <span class="n">age</span> <span class="nb">INT</span><span class="p">,</span>
    <span class="n">dateOfBirth</span> <span class="n">DATETIME2</span> <span class="s1">'$.dob'</span><span class="p">,</span>
    <span class="n">skills</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="k">MAX</span><span class="p">)</span> <span class="s1">'$.info.skills'</span> <span class="k">AS</span> <span class="n">JSON</span>
<span class="p">)</span>
<span class="k">OUTER</span> <span class="n">APPLY</span> <span class="n">OPENJSON</span><span class="p">(</span><span class="n">skills</span><span class="p">)</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">skill</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="s1">'$'</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Result Set</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">id  firstName   lastName    age     dateOfBirth                 skill
---
2   John        Smith       25      NULL                        NULL
5   Jane        Smith       NULL    2005-11-04 12:00:00.0000000 SQL
</span><span class="gp">5   Jane        Smith       NULL    2005-11-04 12:00:00.0000000 C#</span><span class="w">
</span><span class="go">5   Jane        Smith       NULL    2005-11-04 12:00:00.0000000 Azure</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="for-json">14.3. FOR JSON</h3>
<div class="paragraph">
<p>The <code>FOR JSON</code> clause in a <code>SELECT</code> statement formats query results into JSON text, delegating the formatting task from the client application to the database.</p>
</div>
<div class="paragraph">
<p>It operates in two primary modes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FOR JSON AUTO</code> automatically creates a nested JSON structure based on the tables used in the <code>SELECT</code> statement and their join relationships.</p>
</li>
<li>
<p><code>FOR JSON PATH</code> provides explicit control over the output format, allowing for the creation of custom nested objects and arrays using dot notation (i.e., <code>'Order.Details.ProductID'</code>) in column aliases.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Further customization is available through options like <code>ROOT</code> to add a top-level element, <code>INCLUDE_NULL_VALUES</code> to retain properties with null values, and <code>WITHOUT_ARRAY_WRAPPER</code> to remove the default surrounding array brackets, which is useful for generating a single JSON object from a single-row result.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">TOP</span> <span class="mi">2</span>
    <span class="n">SalesOrderID</span> <span class="k">AS</span> <span class="s1">'Order.ID'</span><span class="p">,</span>
    <span class="n">OrderDate</span> <span class="k">AS</span> <span class="s1">'Order.Date'</span><span class="p">,</span>
    <span class="n">AccountNumber</span> <span class="k">AS</span> <span class="s1">'Customer.Account'</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">SalesOrderHeader</span>
<span class="k">FOR</span> <span class="n">JSON</span> <span class="n">PATH</span><span class="p">,</span> <span class="n">ROOT</span><span class="p">(</span><span class="s1">'Orders'</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Result Set</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nl">"Orders"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"Order"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"ID"</span><span class="p">:</span><span class="w"> </span><span class="mi">43659</span><span class="p">,</span><span class="w">
                </span><span class="nl">"Date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2011-05-31T00:00:00"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"Customer"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="nl">"Account"</span><span class="p">:</span><span class="w"> </span><span class="s2">"10-4020-000676"</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"Order"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"ID"</span><span class="p">:</span><span class="w"> </span><span class="mi">43660</span><span class="p">,</span><span class="w">
                </span><span class="nl">"Date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2011-05-31T00:00:00"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"Customer"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="nl">"Account"</span><span class="p">:</span><span class="w"> </span><span class="s2">"10-4020-000117"</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="vectors-and-embeddings">15. Vectors and embeddings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The SQL Database Engine supports storing and querying structured and unstructured data, including performing vector search, which is beneficial for unified data search without external services.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Vectors are ordered arrays of numbers (typically floats) representing data (e.g., pixel values, text ASCII values).</p>
</li>
<li>
<p>Vectorization is the process of converting data into vectors, which are efficiently stored using the SQL Server <a href="https://learn.microsoft.com/en-us/sql/t-sql/data-types/vector-data-type"><code>VECTOR</code></a> data type.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Vector features are available in SQL Server 2025 (17.x) Preview, Azure SQL Database, and Azure SQL Managed Instance (configured with the Always-up-to-date update policy).
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="embeddings">15.1. Embeddings</h3>
<div class="paragraph">
<p>Embeddings are a specialized type of vector that capture important features of data, often generated by deep learning models, with the ability of representing semantic similarity between various data entities, such as words or images.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Azure OpenAI provides models for creating text embeddings, which can be stored in SQL Server alongside their data to enable vector search for similar data points.</p>
</li>
<li>
<p>Storing generated embeddings in a SQL Server database allows for co-location with the represented data and facilitates vector search queries to find similar data points.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="vector-search">15.2. Vector search</h3>
<div class="paragraph">
<p>Vector search refers to the process of finding vectors in a dataset that are similar to a specific query vector.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Similarity is measured using distance metrics like cosine distance; closer vectors indicate higher similarity.</p>
</li>
<li>
<p>SQL Server provides built-in support for vectors via the <code>VECTOR</code> data type, storing data in an optimized binary format yet is exposed as JSON arrays for convenience.</p>
</li>
<li>
<p>Vectors, typically managed as arrays of floats, can be created by casting JSON arrays to the <code>VECTOR</code> data type. For example:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span>
    <span class="k">CAST</span><span class="p">(</span><span class="s1">'[1.0, -0.2, 30]'</span> <span class="k">AS</span> <span class="n">VECTOR</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="k">AS</span> <span class="n">v1</span><span class="p">,</span>
    <span class="k">CAST</span><span class="p">(</span><span class="n">JSON_ARRAY</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="k">AS</span> <span class="n">VECTOR</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="k">AS</span> <span class="n">v2</span><span class="p">;</span>

<span class="k">DECLARE</span> <span class="o">@</span><span class="n">v1</span> <span class="n">VECTOR</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="s1">'[1.0, -0.2, 30]'</span><span class="p">;</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">v2</span> <span class="n">VECTOR</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">JSON_ARRAY</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="o">@</span><span class="n">v1</span> <span class="k">as</span> <span class="n">v1</span><span class="p">,</span> <span class="o">@</span><span class="n">v2</span> <span class="k">as</span> <span class="n">v2</span><span class="p">;</span>

<span class="k">DECLARE</span> <span class="o">@</span><span class="n">v</span> <span class="n">VECTOR</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="s1">'[1.0, -0.2, 30]'</span><span class="p">;</span>
<span class="k">SELECT</span>
    <span class="k">CAST</span><span class="p">(</span><span class="o">@</span><span class="n">v</span> <span class="k">AS</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="k">MAX</span><span class="p">))</span> <span class="k">AS</span> <span class="n">s</span><span class="p">,</span>
    <span class="k">CAST</span><span class="p">(</span><span class="o">@</span><span class="n">v</span> <span class="k">AS</span> <span class="n">JSON</span><span class="p">)</span> <span class="k">AS</span> <span class="n">j</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="exact-nearest-neighbor-k-nn-search-and-vector-distance">15.2.1. Exact nearest neighbor (k-NN) search and vector distance</h4>
<div class="paragraph">
<p>Exact search, also known as k-nearest neighbor (k-NN) search, involves calculating the distance between a given vector and all other vectors in a dataset, sorting the results, and selecting the closest neighbors based on a specified distance metric.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>k-nearest neighbor (k-NN) search guarantees precise nearest neighbor retrieval by performing an exhaustive distance calculation across all indexed vectors, making it computationally intensive but suitable for smaller datasets or when accuracy is paramount.</p>
</li>
<li>
<p>Vector distance functions, such as Euclidean distance, cosine similarity, and dot product, measure vector closeness and are essential for accurate k-NN searches.</p>
</li>
<li>
<p>In the SQL Database Engine, k-NN searches utilize the <a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/vector-distance-transact-sql"><code>VECTOR_DISTANCE</code></a> function for efficient distance calculation and nearest neighbor retrieval.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The terms "exact search," "k-nearest neighbor (k-NN) search," and "exact nearest neighbor (ENN) vector search" are used interchangeably to refer to this precise, exhaustive search method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to do k-NN to return the top 10 most similar vectors stored in the content_vector table to the given query vector @qv.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">qv</span> <span class="n">VECTOR</span><span class="p">(</span><span class="mi">1536</span><span class="p">)</span> <span class="o">=</span> <span class="n">AI_GENERATE_EMBEDDINGS</span><span class="p">(</span><span class="n">N</span><span class="s1">'Pink Floyd music style'</span> <span class="n">USE</span> <span class="n">MODEL</span> <span class="n">Ada2Embeddings</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="n">TOP</span> <span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">id</span><span class="p">,</span> <span class="n">VECTOR_DISTANCE</span><span class="p">(</span><span class="s1">'cosine'</span><span class="p">,</span> <span class="o">@</span><span class="n">qv</span><span class="p">,</span> <span class="p">[</span><span class="n">content_vector</span><span class="p">])</span> <span class="k">AS</span> <span class="n">distance</span><span class="p">,</span> <span class="n">title</span>
<span class="k">FROM</span> <span class="p">[</span><span class="n">dbo</span><span class="p">].[</span><span class="n">wikipedia_articles_embeddings</span><span class="p">]</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">distance</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Exact search is recommended for datasets with fewer than 50,000 vectors. Larger tables can use exact search if search predicates effectively reduce the number of vectors for neighbor search to 50,000 or fewer.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="approximate-nearest-neighbors-ann-and-vector-index">15.2.2. Approximate nearest neighbors (ANN) and vector index</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Approximate vector index and vector search are in preview and currently only available in SQL Server 2025 (17.x) Preview.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Approximate Nearest Neighbors (ANN) offers a high-performance alternative to the slow and resource-intensive exact k-nearest neighbors (k-NN) search. While k-NN requires comparing a query vector against every vector in a database, ANN trades a small degree of accuracy (recall) for a massive gain in search speed, making it a practical solution for large-scale vector search.</p>
</div>
<div class="paragraph">
<p>Recall is a metric that measures the proportion of relevant items successfully retrieved out of all truly relevant items.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In vector search, recall specifically quantifies how many of the exact nearest neighbors found by an exhaustive search are successfully identified by an Approximate Nearest Neighbors (ANN) algorithm.</p>
</li>
<li>
<p>It serves as a crucial measure of the approximation&#8217;s quality, with a perfect recall of 1 indicating that the ANN algorithm found all the exact nearest neighbors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For AI applications, the inherent approximation of vector embeddings makes ANN a highly advantageous trade-off over exact k-NN, offering significant performance and resource benefits well-suited for operational databases.</p>
</div>
<div class="paragraph">
<p>A vector index is a data structure optimized for efficiently finding approximate nearest neighbors in high-dimensional vector spaces, thereby returning approximate results for ANN searches, unlike traditional relational database indexes (e.g., B-trees, LSM-trees) designed for exact lookups and range queries on scalar values.</p>
</div>
<div class="paragraph">
<p>In the SQL Database engine, vector indexes are based on the <a href="https://www.microsoft.com/en-us/research/publication/diskann-fast-accurate-billion-point-nearest-neighbor-search-on-a-single-node">DiskANN</a> algorithm.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DiskANN is a graph-based system that indexes and searches large vector datasets by creating a navigable graph to quickly find the closest match to a given vector.</p>
</li>
<li>
<p>DiskANN efficiently uses SSDs and minimal memory to handle significantly more data than in-memory indices, while maintaining high queries per second (QPS) and low latency, ensuring a balance between memory, CPU and I/O usage and search performance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An approximate nearest neighbors algorithm search can be done first creating a vector index using the <code>CREATE VECTOR INDEX</code> T-SQL command and then using <a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/vector-search-transact-sql"><code>VECTOR_SEARCH</code></a> T-SQL function to run the approximate search.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DECLARE</span> <span class="o">@</span><span class="n">qv</span> <span class="n">VECTOR</span><span class="p">(</span><span class="mi">1536</span><span class="p">)</span> <span class="o">=</span> <span class="n">AI_GENERATE_EMBEDDINGS</span><span class="p">(</span><span class="n">N</span><span class="s1">'Pink Floyd music style'</span> <span class="n">USE</span> <span class="n">MODEL</span> <span class="n">Ada2Embeddings</span><span class="p">);</span>
<span class="k">SELECT</span>
    <span class="n">t</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">title</span>
<span class="k">FROM</span>
    <span class="n">VECTOR_SEARCH</span><span class="p">(</span>
        <span class="k">TABLE</span> <span class="o">=</span> <span class="p">[</span><span class="n">dbo</span><span class="p">].[</span><span class="n">wikipedia_articles_embeddings</span><span class="p">]</span> <span class="k">AS</span> <span class="n">t</span><span class="p">,</span>
        <span class="k">COLUMN</span> <span class="o">=</span> <span class="p">[</span><span class="n">content_vector</span><span class="p">],</span>
        <span class="n">SIMILAR_TO</span> <span class="o">=</span> <span class="o">@</span><span class="n">qv</span><span class="p">,</span>
        <span class="n">METRIC</span> <span class="o">=</span> <span class="s1">'cosine'</span><span class="p">,</span>
        <span class="n">TOP_N</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="p">)</span> <span class="k">AS</span> <span class="n">s</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">s</span><span class="p">.</span><span class="n">distance</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-types">Appendix A: Data Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A data type is an attribute that specifies the type of data that the object can hold: integer data, character data, monetary data, date and time data, binary strings, and so on. <a href="#3">[3]</a></p>
</div>
<div class="paragraph">
<p>Data types can be converted either implicitly or explicitly.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implicit conversions are not visible to the user. SQL Server automatically converts the data from one data type to another.</p>
</li>
<li>
<p>Explicit conversions use the <code>CAST</code> or <code>CONVERT</code> functions.</p>
<div class="ulist">
<ul>
<li>
<p>Use <code>CAST</code> instead of <code>CONVERT</code> to write Transact-SQL program code to comply with ISO.</p>
</li>
<li>
<p>Use <code>CONVERT</code> instead of <code>CAST</code> to take advantage of the style functionality in CONVERT.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CAST</span> <span class="p">(</span> <span class="n">expression</span> <span class="k">AS</span> <span class="n">data_type</span> <span class="p">[</span> <span class="p">(</span> <span class="k">length</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CONVERT</span> <span class="p">(</span> <span class="n">data_type</span> <span class="p">[</span> <span class="p">(</span> <span class="k">length</span> <span class="p">)</span> <span class="p">]</span> <span class="p">,</span> <span class="n">expression</span> <span class="p">[</span> <span class="p">,</span> <span class="n">style</span> <span class="p">]</span> <span class="p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">CAST</span><span class="p">(</span><span class="mi">123</span> <span class="k">AS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span> <span class="k">CONVERT</span><span class="p">(</span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="mi">123</span><span class="p">)</span> <span class="c1">-- same result: integer to string</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">CONVERT</span><span class="p">(</span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">GETDATE</span><span class="p">(),</span> <span class="mi">101</span><span class="p">)</span> <span class="c1">-- date to string in MM/dd/yyyy format</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="character">A.1. Character</h3>
<div class="paragraph">
<p>SQL Server supports two kinds of character data type pairs: regular kind (<code>CHAR</code> and <code>VARCHAR</code>) and N-kind (<code>NCHAR</code> and <code>NVARCHAR</code>).</p>
</div>
<div class="paragraph">
<p>Each of the type pairs can support different character encoding systems, and can result in different encoded byte lengths and on-disk storage sizes, based on the effective collation of the data and the character code range in use.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The regular types, with UTF-8 collation, use the UTF-8 encoding system and support full range of Unicode characters.</p>
</li>
<li>
<p>The N-kind types, with supplementary character collation (SC), use the UTF-16 encoding system and support the full range of Unicode characters. Otherwise, they support only the subset of characters from the UCS-2 character encoding system.</p>
</li>
<li>
<p>The <code>VARCHAR(size)</code> defines the maximum size in bytes, while the <code>NVARCHAR(size)</code> defines the size in byte pairs.</p>
</li>
<li>
<p>The literals of regular type character are enclosed in single quotes, while N-kind type require a preceding <code>'N'</code>.</p>
</li>
<li>
<p>Any data type without the <code>VAR</code> element (<code>CHAR</code>, <code>NCHAR</code>) in its name has a fixed length, that is, SQL Server preserves the maximum space in the row based on the column’s defined size and not on the actual user data that is stored.</p>
</li>
<li>
<p>A data type with the <code>VAR</code> element (<code>VARCHAR</code>, <code>NVARCHAR</code>) in its name has a variable length, that is, SQL Server uses as much storage space in the row as required to store the actual character string, plus two extra bytes for offset data.</p>
<div class="ulist">
<ul>
<li>
<p>Updates of variable-length data types can be less efficient than those of fixed-length types due to potential row expansion and data movement.</p>
</li>
<li>
<p>Variable-length data types can use the <code>MAX</code> specifier, allowing for up to 2GB per value.</p>
</li>
<li>
<p>Any value with a size up to a certain threshold (8,000 bytes by default) can be stored inline in the row. Any value with a size above the threshold is stored external to the row as a large object (LOB).</p>
</li>
</ul>
</div>
</li>
<li>
<p>The collation is a property of character data that encapsulates several aspects: language support, sort order, case sensitivity, accent sensitivity, and more.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- get the set of supported collations and their descriptions</span>
<span class="k">SELECT</span> <span class="n">name</span><span class="p">,</span> <span class="n">description</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">fn_helpcollations</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>In an on-premises SQL Server implementation and Azure SQL Managed Instance, collation can be defined at four different levels: instance, database, column, and expression. The lowest level is the effective one that is used.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">DATABASEPROPERTYEX</span><span class="p">(</span><span class="n">DB_NAME</span><span class="p">(),</span> <span class="s1">'Collation'</span><span class="p">);</span> <span class="c1">-- SQL_Latin1_General_CP1_CI_AS</span></code></pre>
</div>
</div>
</li>
<li>
<p>In Azure SQL Database, collation can be defined at the database, column, and expression levels.</p>
</li>
</ul>
</div>
</li>
<li>
<p>T-SQL provides the plus-sign (<code>+</code>) operator and the <code>CONCAT</code> and <code>CONCAT_WS</code> functions to concatenate strings.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">firstname</span> <span class="o">+</span> <span class="n">N</span><span class="s1">' '</span> <span class="o">+</span> <span class="n">lastname</span> <span class="k">AS</span> <span class="n">fullname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Standard SQL dictates that a concatenation with a <code>NULL</code> should yield a <code>NULL</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span>
  <span class="n">country</span> <span class="o">+</span> <span class="n">N</span><span class="s1">','</span> <span class="o">+</span> <span class="n">region</span> <span class="o">+</span> <span class="n">N</span><span class="s1">','</span> <span class="o">+</span> <span class="n">city</span> <span class="k">AS</span> <span class="k">location</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">custid	country    	region       	city           	location
9     	France     	NULL         	Marseille      	NULL
10    	Canada     	BC           	Tsawassen      	Canada,BC,Tsawassen</span></code></pre>
</div>
</div>
</li>
<li>
<p>To treat a <code>NULL</code> as an empty string—or more accurately, to substitute a <code>NULL</code> with an empty string—use the <code>COALESCE</code> function that accepts a list of input values and returns the first that is not <code>NULL</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span>
  <span class="n">country</span> <span class="o">+</span> <span class="n">COALESCE</span><span class="p">(</span><span class="n">N</span><span class="s1">','</span> <span class="o">+</span> <span class="n">region</span><span class="p">,</span> <span class="n">N</span><span class="s1">''</span><span class="p">)</span> <span class="o">+</span> <span class="n">N</span><span class="s1">','</span> <span class="o">+</span> <span class="n">city</span> <span class="k">AS</span> <span class="k">location</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">custid	country    	region       	city           	location
8     	Spain      	NULL         	Madrid         	Spain,Madrid
9     	France     	NULL         	Marseille      	France,Marseille</span></code></pre>
</div>
</div>
</li>
<li>
<p>T-SQL supports a function called <code>CONCAT</code>, which accepts a list of inputs for concatenation and automatically substitutes NULLs with empty strings.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span>
  <span class="n">CONCAT</span><span class="p">(</span><span class="n">country</span><span class="p">,</span> <span class="n">N</span><span class="s1">','</span> <span class="o">+</span> <span class="n">region</span><span class="p">,</span> <span class="n">N</span><span class="s1">','</span> <span class="o">+</span> <span class="n">city</span><span class="p">)</span> <span class="k">AS</span> <span class="k">location</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>T-SQL also supports a function called <code>CONCAT_WS</code>, which accepts the separator as the first parameter, specifying it only once, and then the list of inputs for concatenation.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">custid</span><span class="p">,</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span>
  <span class="n">CONCAT_WS</span><span class="p">(</span><span class="n">N</span><span class="s1">','</span><span class="p">,</span> <span class="n">country</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="k">AS</span> <span class="k">location</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Customers</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>PATINDEX</code> function returns the position of the first occurrence of a pattern, similar to the patterns used by the <code>LIKE</code> predicate in T-SQL, within a string.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">PATINDEX</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">PATINDEX</span><span class="p">(</span><span class="s1">'%[0-9]%'</span><span class="p">,</span> <span class="s1">'abcd123efgh'</span><span class="p">);</span>
<span class="c1">-- 5</span></code></pre>
</div>
</div>
</li>
<li>
<p>T-SQL provides a predicate called <code>LIKE</code> to check whether a character string matches a specified pattern.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>%</code> (percent sign) wildcard represents a string of any size, including an empty string.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">lastname</span> <span class="k">LIKE</span> <span class="n">N</span><span class="s1">'D%'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">empid	lastname
1    	Davis
9    	Doyle</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>_</code> (underscore) wildcard represents a single character.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">lastname</span> <span class="k">LIKE</span> <span class="n">N</span><span class="s1">'_e%'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">empid	lastname
3    	Lew
4    	Peled</span></code></pre>
</div>
</div>
</li>
<li>
<p>The square bracket wildcard <code>[&lt;list of characters&gt;]</code>, with a list of characters (such as <code>[ABC]</code>), represents a single character that must be one of the characters specified in the list.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">lastname</span> <span class="k">LIKE</span> <span class="n">N</span><span class="s1">'[ABC]%'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">empid</span>	<span class="n">lastname</span>
<span class="mi">8</span>    	<span class="n">Cameron</span></code></pre>
</div>
</div>
</li>
<li>
<p>The square bracket wildcard <code>[&lt;character&gt;-&lt;character&gt;]</code>, with a character range (such as <code>[A–E]</code>), represents a single character that must be within the specified range.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">lastname</span> <span class="k">LIKE</span> <span class="n">N</span><span class="s1">'[A-E]%'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">empid</span>	<span class="n">lastname</span>
<span class="mi">8</span>    	<span class="n">Cameron</span>
<span class="mi">1</span>    	<span class="n">Davis</span>
<span class="mi">9</span>    	<span class="n">Doyle</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The square bracket wildcard <code>[^&lt;character list or range&gt;]</code>, with a caret sign (<code>^</code>) followed by a character list or range (such as <code>[^A–E]</code>), represents a single character that is not in the specified character list or range.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">empid</span><span class="p">,</span> <span class="n">lastname</span>
<span class="k">FROM</span> <span class="n">HR</span><span class="p">.</span><span class="n">Employees</span>
<span class="k">WHERE</span> <span class="n">lastname</span> <span class="k">LIKE</span> <span class="n">N</span><span class="s1">'[^A-E]%'</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">empid	lastname
2    	Funk
7    	King</span></code></pre>
</div>
</div>
</li>
<li>
<p>To search for a character that is also a wildcard, use an escape character before it in the <code>LIKE</code> pattern, and specify the escape character using the <code>ESCAPE</code> keyword.</p>
<div class="ulist">
<ul>
<li>
<p>A character put in front of a wildcard character to indicate that the wildcard is interpreted as a regular character and not as a wildcard.</p>
</li>
<li>
<p><code>escape_character</code> is a character expression that has no default and must evaluate to only one character.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- specify character (!, @, $, or #) as the escape character</span>
<span class="n">col1</span> <span class="k">LIKE</span> <span class="s1">'%!_%'</span> <span class="k">ESCAPE</span> <span class="s1">'!'</span>
<span class="n">col1</span> <span class="k">LIKE</span> <span class="s1">'%@_%'</span> <span class="k">ESCAPE</span> <span class="s1">'@'</span>
<span class="n">col1</span> <span class="k">LIKE</span> <span class="s1">'%$%_'</span> <span class="k">ESCAPE</span> <span class="s1">'$'</span>
<span class="n">col1</span> <span class="k">LIKE</span> <span class="s1">'%#%_'</span> <span class="k">ESCAPE</span> <span class="s1">'#'</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="date-and-time">A.2. Date and Time</h3>
<div class="paragraph">
<p>T-SQL supports six date and time data types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The legacy types <code>DATETIME</code> and <code>SMALLDATETIME</code> include date and time components that are inseparable.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">DATETIME      	'YYYYMMDD hh:mm:ss.nnn'               	'20220212 12:30:15.123'
DATETIME      	'YYYYMMDD'                            	'20220212'
SMALLDATETIME 	'YYYYMMDD hh:mm'                      	'20220212 12:30'
SMALLDATETIME 	'YYYYMMDD'                            	'20220212'</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>DATE</code> and <code>TIME</code> data types provide a separation between the date and time components.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">DATE          	'YYYYMMDD'                            	'20220212'
TIME          	'hh:mm:ss.nnnnnnn'                    	'12:30:15.1234567'</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>DATETIME2</code> data type has a bigger date range and better precision than the legacy types.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">DATETIME2     	'YYYYMMDD hh:mm:ss.nnnnnnn'           	'20220212 12:30:15.1234567'</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>DATETIMEOFFSET</code> data type is similar to <code>DATETIME2</code>, but it also includes the offset from UTC.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">DATETIMEOFFSET	'YYYYMMDD hh:mm:ss.nnnnnnn [+|-]hh:mm'	'20220212 12:30:15.1234567 +02:00'</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">GETDATE</span><span class="p">()</span> <span class="k">UNION</span> <span class="k">ALL</span>          <span class="c1">-- DATETIME   current date and time</span>
<span class="k">SELECT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">UNION</span> <span class="k">ALL</span>  <span class="c1">-- DATETIME   same as GETDATE but SQL-compliant</span>
<span class="k">SELECT</span> <span class="n">GETUTCDATE</span><span class="p">()</span> <span class="k">UNION</span> <span class="k">ALL</span>       <span class="c1">-- DATETIME   current date and time in UTC</span>
<span class="k">SELECT</span> <span class="n">SYSDATETIME</span><span class="p">()</span> <span class="k">UNION</span> <span class="k">ALL</span>      <span class="c1">-- DATETIME2  current date and time</span>
<span class="k">SELECT</span> <span class="n">SYSUTCDATETIME</span><span class="p">()</span> <span class="k">UNION</span> <span class="k">ALL</span>   <span class="c1">-- DATETIME2  current date and time in UTC</span>
<span class="k">SELECT</span> <span class="n">SYSDATETIMEOFFSET</span><span class="p">()</span>          <span class="c1">-- DATETIME2  current date and time in UTC with Time Zone</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">2025-01-18 15:07:52.9766667 +00:00
2025-01-18 15:07:52.9766667 +00:00
2025-01-18 07:07:52.9766667 +00:00
2025-01-18 15:07:52.9755919 +00:00
2025-01-18 07:07:52.9755919 +00:00
2025-01-18 15:07:52.9755919 +08:00</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>T-SQL doesn’t provide the means to express a date and time literal; instead, a convertible literal of a different type can be specified—explicitly or implicitly—to a date and time data type.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is a best practice to use character strings with language-neutral formats to express date and time values.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderdate</span> <span class="o">=</span> <span class="s1">'20220212'</span><span class="p">;</span> <span class="c1">-- equivalent to: WHERE orderdate = CAST('20220212' AS DATE);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Each login has a default language, which affects how date and time literals are interpreted.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SET</span> <span class="k">LANGUAGE</span> <span class="n">British</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="k">CAST</span><span class="p">(</span><span class="s1">'02/12/2022'</span> <span class="k">AS</span> <span class="nb">DATE</span><span class="p">);</span> <span class="c1">-- 2022-12-02</span>

<span class="k">SET</span> <span class="k">LANGUAGE</span> <span class="n">us_english</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="k">CAST</span><span class="p">(</span><span class="s1">'02/12/2022'</span> <span class="k">AS</span> <span class="nb">DATE</span><span class="p">);</span> <span class="c1">-- 2022-02-12</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>DATEFORMAT</code> setting, expressed as a combination of the characters <code>d</code>, <code>m</code>, and <code>y</code>, determines how SQL Server interprets date and time literals from character strings (e.g., <code>'mdy'</code> for US English, <code>'dmy'</code> for British English).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SET</span> <span class="n">DATEFORMAT</span> <span class="n">dmy</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="k">CAST</span><span class="p">(</span><span class="s1">'02/12/2022'</span> <span class="k">AS</span> <span class="nb">DATE</span><span class="p">);</span> <span class="c1">-- 2022-12-02</span>

<span class="k">SET</span> <span class="n">DATEFORMAT</span> <span class="n">mdy</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="k">CAST</span><span class="p">(</span><span class="s1">'02/12/2022'</span> <span class="k">AS</span> <span class="nb">DATE</span><span class="p">);</span> <span class="c1">-- 2022-02-12</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>LANGUAGE/DATEFORMAT</code> setting affects only the way the values inputed are interpreted, and have no impact on the format used in the output for presentation purposes.</p>
</li>
</ul>
</div>
</li>
<li>
<p>SQL Server may not efficiently utilize indexes when functions like <code>YEAR</code> are applied to the column within the <code>WHERE</code> clause.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="nb">YEAR</span><span class="p">(</span><span class="n">orderdate</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2021</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- better</span>
<span class="k">SELECT</span> <span class="n">orderid</span><span class="p">,</span> <span class="n">custid</span><span class="p">,</span> <span class="n">empid</span><span class="p">,</span> <span class="n">orderdate</span>
<span class="k">FROM</span> <span class="n">Sales</span><span class="p">.</span><span class="n">Orders</span>
<span class="k">WHERE</span> <span class="n">orderdate</span> <span class="o">&gt;=</span> <span class="s1">'20210101'</span> <span class="k">AND</span> <span class="n">orderdate</span> <span class="o">&lt;</span> <span class="s1">'20220101'</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="t-sql-fund"></a>[1] Itzik Ben-Gan <em>T-SQL Fundamentals</em>. 3rd edition, Microsoft Press; August 3, 2016</p>
</li>
<li>
<p><a id="t-sql-query"></a>[2] Itzik Ben-Gan, Adam Machanic, Dejan Sarka, Kevin Farlee <em>T-SQL Querying</em>. 1st Edition Microsoft Press; March 6, 2015</p>
</li>
<li>
<p><a id="t-sql-ref"></a>[3] <a href="https://learn.microsoft.com/en-us/sql/t-sql/language-reference" class="bare">https://learn.microsoft.com/en-us/sql/t-sql/language-reference</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
