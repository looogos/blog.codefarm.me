<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>WPF (.NET) Learning Notes | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="WPF (.NET) Learning Notes" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. MVVM pattern and toolkit 1.1. MVVM pattern 1.1.1. View 1.1.2. ViewModel 1.1.3. Model 1.1.4. Connecting view models to views 1.1.4.1. Creating a view model declaratively 1.1.4.2. Creating a view model programmatically 1.1.5. Updating views in response to changes in the underlying view model or model 1.2. MVVM Toolkit 2. Data binding 2.1. Data context 2.2. Data flow 2.3. Data conversion 2.4. Data validation 2.5. Binding path 2.6. Binding source 2.7. Binding in XAML 2.8. Binding in code 3. Property system 3.1. Dependency properties and CLR properties 3.2. Dependency properties back CLR properties 3.3. Attached properties 3.4. Property value inheritance 4. Routed events 4.1. Routed event and event handler 4.2. Attached events 4.3. WPF input events 4.4. Weak event patterns 5. Commands 6. Windows 6.1. Lifetime 6.2. Appearance 6.3. Dialog boxes 6.4. Multiple windows, multiple threads 7. Styles, templates, and triggers 7.1. Styles 7.2. Control templates 7.3. Data templates 7.4. Triggers References 1. MVVM pattern and toolkit The MVVM pattern [1] helps cleanly separate an application&#8217;s business and presentation logic from its user interface (UI). Maintaining a clean separation between application logic and the UI helps address numerous development issues and makes an application easier to test, maintain, and evolve. It can also significantly improve code re-use opportunities and allows developers and UI designers to collaborate more easily when developing their respective parts of an app. 1.1. MVVM pattern There are three core components in the MVVM pattern: the model, the view, and the view model. Using the MVVM pattern, the UI of the app and the underlying presentation and business logic are separated into three separate classes: the view, which encapsulates the UI and UI logic; the view model, which encapsulates presentation logic and state; and the model, which encapsulates the app&#8217;s business logic and data. 1.1.1. View The view is responsible for defining the structure, layout, and appearance of what the user sees on screen. Ideally, each view is defined in XAML, with a limited code-behind that does not contain business logic. However, in some cases, the code-behind might contain UI logic that implements visual behavior that is difficult to express in XAML, such as animations. Enable and disable UI elements by binding to view model properties, rather than enabling and disabling them in code-behind. Ensure that the view models are responsible for defining logical state changes that affect some aspects of the view&#8217;s display, such as whether a command is available, or an indication that an operation is pending. There are several options for executing code on the view model in response to interactions on the view, such as a button click or item selection. If a control supports commands, the control&#8217;s Command property can be data-bound to an ICommand property on the view model. When the control&#8217;s command is invoked, the code in the view model will be executed. In addition to commands, behaviors can be attached to an object in the view and can listen for either a command to be invoked or the event to be raised. In response, the behavior can then invoke an ICommand on the view model or a method on the view model. 1.1.2. ViewModel The view model implements properties and commands to which the view can data bind to, and notifies the view of any state changes through change notification events. The properties and commands that the view model provides define the functionality to be offered by the UI, but the view determines how that functionality is to be displayed. Multi-platform apps should keep the UI thread unblocked to improve the user&#8217;s perception of performance. Therefore, in the view model, use asynchronous methods for I/O operations and raise events to asynchronously notify views of property changes. The view model is also responsible for coordinating the view&#8217;s interactions with one or many model classes that are required. The view model might choose to expose model classes directly to the view so that controls in the view can data bind directly to them. In this case, the model classes will need to be designed to support data binding and change notification events. Each view model provides data from a model in a form that the view can easily consume. Placing the data conversion in the view model is a good idea because it provides properties that the view can bind to. For example, the view model might combine the values of two properties to make it easier to display by the view. It&#8217;s also possible to use converters as a separate data conversion layer that sits between the view model and the view. This can be necessary, for example, when data requires special formatting that the view model doesn&#8217;t provide. In order for the view model to participate in two-way data binding with the view, its properties must raise the PropertyChanged event. View models satisfy this requirement by implementing the INotifyPropertyChanged interface, and raising the PropertyChanged event when a property is changed. For collections, the view-friendly ObservableCollection&lt;T&gt; is provided. This collection implements collection changed notification, relieving the developer from having to implement the INotifyCollectionChanged interface on collections. 1.1.3. Model Model classes are non-visual classes that encapsulate the app&#8217;s data. Model classes can be thought of as representing the app&#8217;s domain model that includes a data model along with business and validation logic. Examples of model objects include data transfer objects (DTOs), Plain Old CLR Objects (POCOs), and generated entity and proxy objects. Model classes are typically used in conjunction with services or repositories that encapsulate data access and caching. 1.1.4. Connecting view models to views View models can be connected to views by using the data-binding capabilities. 1.1.4.1. Creating a view model declaratively The simplest approach is for the view to declaratively instantiate its corresponding view model in XAML. When the view is constructed, the corresponding view model object will also be constructed. &lt;Grid.DataContext&gt; &lt;vm:MainViewModel /&gt; &lt;/Grid.DataContext&gt; Though the declarative construction and assignment of the view model by the view has the advantage that it&#8217;s simple, but has the disadvantage that it requires a default (parameter-less) constructor in the view model. 1.1.4.2. Creating a view model programmatically A view can have code in the code-behind file, resulting in the view-model being assigned to its DataContext property. public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); DataContext = new MainViewModel(); } } The programmatic construction and assignment of the view model within the view&#8217;s code-behind has the advantage that it&#8217;s simple. However, the main disadvantage of this approach is that the view needs to provide the view model with any required dependencies. Using a dependency injection container can help to maintain loose coupling between the view and view model. 1.1.5. Updating views in response to changes in the underlying view model or model All view model and model classes that are accessible to a view should implement the INotifyPropertyChanged interface. Implementing this interface in a view model or model class allows the class to provide change notifications to any data-bound controls in the view when the underlying property value changes. Always raising a PropertyChanged event if a public property&#8217;s value changes. Always raising a PropertyChanged event for any calculated properties whose values are used by other properties in the view model or model. Always raising the PropertyChanged event at the end of the method that makes a property change, or when the object is known to be in a safe state. Never raising a PropertyChanged event if the property does not change. Never raising the PropertyChanged event during a view model&#8217;s constructor if you are initializing a property. Never raising more than one PropertyChanged event with the same property name argument within a single synchronous invocation of a public method of a class. public sealed class MainViewModel : INotifyPropertyChanged { private string? _title; public string? Title { get { return _title; } set { if (_title != value) { _title = value; OnPropertyChanged(); } } } public event PropertyChangedEventHandler? PropertyChanged; private void OnPropertyChanged([CallerMemberName] string? propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } 1.2. MVVM Toolkit The CommunityToolkit.Mvvm package (aka MVVM Toolkit, formerly named Microsoft.Toolkit.Mvvm) is a modern, fast, and modular MVVM library. [2] dotnet add package CommunityToolkit.Mvvm # --version 8.3.1 CommunityToolkit.Mvvm.ComponentModel ObservableObject public abstract class ObservableObject : INotifyPropertyChanged, INotifyPropertyChanging public sealed class MainViewModel : ObservableObject { private string? _title; public string? Title { get =&gt; _title; set =&gt; SetProperty(ref _title, value); } private TaskNotifier? myTask; public Task? MyTask { get =&gt; myTask; set =&gt; SetPropertyAndNotifyOnCompletion(ref myTask, value); } } &lt;StackPanel&gt; &lt;Label Content=&quot;{Binding MyTask.Status}&quot; /&gt; &lt;TextBox Text=&quot;{Binding Title}&quot; /&gt; &lt;/StackPanel&gt; ObservableRecipient public abstract class ObservableRecipient : ObservableObject public sealed class MainViewModel : ObservableRecipient, IRecipient&lt;RequestMessage&lt;int&gt;&gt; { public void Receive(RequestMessage&lt;int&gt; message) =&gt; throw new NotImplementedException(); } public sealed class MainViewModel : ObservableRecipient { // For best results and to avoid memory leaks, it&#39;s recommended to use OnActivated to register // to messages, and to use OnDeactivated to do cleanup operations. protected override void OnActivated() =&gt; Messenger.Register&lt;MainViewModel, RequestMessage&lt;int&gt;&gt;(this, (r, m) =&gt; r.Receive(m)); // By default, OnDeactivated automatically unregisters the current instance from all registered messages. protected override void OnDeactivated() =&gt; base.OnDeactivated(); public void Receive(RequestMessage&lt;int&gt; message) =&gt; throw new NotImplementedException(); } ObservableValidator public abstract class ObservableValidator : ObservableObject, INotifyDataErrorInfo public class RegistrationForm : ObservableValidator { private string name; [Required] [MinLength(2)] [MaxLength(100)] public string Name { get =&gt; name; // Here we are calling the SetProperty&lt;T&gt;(ref T, T, bool, string) method exposed // by ObservableValidator, and that additional bool parameter set to true indicates // that we also want to validate the property when its value is updated. set =&gt; SetProperty(ref name, value, true); } } &lt;TextBox Text=&quot;{Binding Name, ValidatesOnDataErrors=True}&quot; /&gt; ObservableProperty [ObservableProperty] [NotifyPropertyChangedFor(nameof(FullName))] // Notifying dependent properties [NotifyCanExecuteChangedFor(nameof(MyCommand))] // Notifying dependent commands [NotifyDataErrorInfo] // Requesting property validation [Required] [MinLength(2)] // Any other validation attributes too... [NotifyPropertyChangedRecipients] // Sending notification messages [PropertyChangedMessage&lt;T&gt;] [property: JsonPropertyName(&quot;name&quot;)] // Adding custom attributes private string? _name; INotifyPropertyChanged // only use in cases where the target types cannot just inherit from the equivalent // types (eg. from ObservableObject). [INotifyPropertyChanged] public partial class MyViewModel : SomeOtherType CommunityToolkit.Mvvm.DependencyInjection Ioc dotnet add package Microsoft.Extensions.DependencyInjection # --version 8.0.0 public partial class App : Application { public IServiceProvider Services { get; set; } public App() { Services = ConfigureServices(); } protected override void OnStartup(StartupEventArgs e) { var mainWindow = Services.GetRequiredService&lt;MainWindow&gt;(); mainWindow.Show(); } private ServiceProvider ConfigureServices() { var services = new ServiceCollection(); services.AddTransient&lt;MainWindow&gt;(); services.AddTransient&lt;MainViewModel&gt;(); return services.BuildServiceProvider(); } } CommunityToolkit.Mvvm.Input RelayCommand RelayCommand&lt;T&gt; AsyncRelayCommand AsyncRelayCommand&lt;T&gt; IRelayCommand IRelayCommand&lt;T&gt; IAsyncRelayCommand IAsyncRelayCommand&lt;T&gt; public sealed class MainViewModel : ObservableObject { public IRelayCommand OKCommand { get; } = new RelayCommand(() =&gt; { }, () =&gt; true); public IAsyncRelayCommand CancelCommand { get; } = new AsyncRelayCommand(() =&gt; Task.CompletedTask); } RelayCommand [RelayCommand(CanExecute = nameof(CanGreetUser))] private void GreetUser(User? user) { Console.WriteLine($&quot;Hello {user!.Name}!&quot;); } private bool CanGreetUser(User? user) { return user is not null; } [ObservableProperty] [NotifyCanExecuteChangedFor(nameof(GreetUserCommand))] private User? selectedUser; // Call IAsyncRelayCommand.Cancel to signal that token. [RelayCommand(IncludeCancelCommand = true)] private async Task DoWorkAsync(CancellationToken token) { // Do some long running work... } CommunityToolkit.Mvvm.Messaging IMessenger WeakReferenceMessenger StrongReferenceMessenger IRecipient&lt;TMessage&gt; MessageHandler&lt;TRecipient, TMessage&gt; CommunityToolkit.Mvvm.Messaging.Messages PropertyChangedMessage&lt;T&gt; RequestMessage&lt;T&gt; AsyncRequestMessage&lt;T&gt; CollectionRequestMessage&lt;T&gt; AsyncCollectionRequestMessage&lt;T&gt; ValueChangedMessage&lt;T&gt; 2. Data binding Data binding is the process that establishes a connection between the app UI and the data it displays. If the binding has the correct settings and the data provides the proper notifications, when the data changes its value, the elements that are bound to the data reflect changes automatically. Data binding can also mean that if an outer representation of the data in an element changes, then the underlying data can be automatically updated to reflect the change. Typically, each binding has four components: A binding target object. A target property. A binding source. A path to the value in the binding source to use. For example, to bound the content of a TextBox to the Employee.Name property: Target: TextBox Target property: Text Source object: Employee Source object value path: Name A binding contains all the information that can be shared across several binding expressions. A BindingExpression is an instance expression that cannot be shared and contains all the instance information of the Binding. // Make a new source var myDataObject = new MyData(); var myBinding = new Binding(&quot;ColorName&quot;) { Source = myDataObject }; // Bind the data source to the TextBox control&#39;s Text dependency property myText.SetBinding(TextBlock.TextProperty, myBinding); A binding source object can be treated either as a single object whose properties contain data or as a data collection of polymorphic objects that are often grouped together (such as the result of a query to a database). Any collection that implements the IEnumerable interface can be enumerated over. However, to set up dynamic bindings so that insertions or deletions in the collection update the UI automatically, the collection must implement the INotifyCollectionChanged interface. WPF provides the ObservableCollection&lt;T&gt; class, which is a built-in implementation of a data collection that exposes the INotifyCollectionChanged interface. To fully support transferring data values from source objects to targets, each object in your collection that supports bindable properties must also implement the INotifyPropertyChanged interface. A collection view is a layer on top of a binding source collection that allows you to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself. A collection view also maintains a pointer to the current item in the collection. If the source collection implements the INotifyCollectionChanged interface, the changes raised by the CollectionChanged event are propagated to the views. Because views do not change the underlying source collections, each source collection can have multiple views associated with it. Once ItemsControl is bound to a data collection, the data may need to be sorted, filtered, or grouped. To do that, use collection views, which are classes that implement the ICollectionView interface. A collection view is a layer on top of a binding source collection that allows to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself. A collection view also maintains a pointer to the current item in the collection. If the source collection implements the INotifyCollectionChanged interface, the changes raised by the CollectionChanged event are propagated to the views. Because views do not change the underlying source collections, each source collection can have multiple views associated with it. &lt;Window.Resources&gt; &lt;CollectionViewSource Source=&quot;{Binding Source={x:Static Application.Current}, Path=AuctionItems}&quot; x:Key=&quot;listingDataView&quot; /&gt; &lt;/Window.Resources&gt; &lt;ListBox Name=&quot;Master&quot; Grid.Row=&quot;2&quot; Grid.ColumnSpan=&quot;3&quot; Margin=&quot;8&quot; ItemsSource=&quot;{Binding Source={StaticResource listingDataView}}&quot; /&gt; private void AddSortCheckBox_Checked(object sender, RoutedEventArgs e) { // Sort the items first by Category and then by StartDate listingDataView.SortDescriptions.Add(new SortDescription(&quot;Category&quot;, ListSortDirection.Ascending)); listingDataView.SortDescriptions.Add(new SortDescription(&quot;StartDate&quot;, ListSortDirection.Ascending)); } private void AddFilteringCheckBox_Checked(object sender, RoutedEventArgs e) { if (((CheckBox)sender).IsChecked == true) listingDataView.Filter += ListingDataView_Filter; else listingDataView.Filter -= ListingDataView_Filter; } private void ListingDataView_Filter(object sender, FilterEventArgs e) { // Start with everything excluded e.Accepted = false; // Only inlcude items with a price less than 25 if (e.Item is AuctionItem product &amp;&amp; product.CurrentPrice &lt; 25) e.Accepted = true; } // This groups the items in the view by the property &quot;Category&quot; var groupDescription = new PropertyGroupDescription(); groupDescription.PropertyName = &quot;Category&quot;; listingDataView.GroupDescriptions.Add(groupDescription); 2.1. Data context When data binding is declared on XAML elements, they resolve data binding by looking at their immediate DataContext property. The data context is typically the binding source object for the binding source value path evaluation. If the DataContext property for the object hosting the binding isn&#8217;t set, the parent element&#8217;s DataContext property is checked, and so on, up until the root of the XAML object tree. In short, the data context used to resolve binding is inherited from the parent unless explicitly set on the object. Bindings can be configured to resolve with a specific object, as opposed to using the data context for binding resolution. When the DataContext property changes, all bindings that could be affected by the data context are reevaluated. 2.2. Data flow OneWay binding causes changes to the source property to automatically update the target property, but changes to the target property are not propagated back to the source property, which is appropriate if the control being bound is implicitly read-only. TwoWay binding causes changes to either the source property or the target property to automatically update the other, which is appropriate for editable forms or other fully interactive UI scenarios.. Most properties default to OneWay binding, but some dependency properties (typically properties of user-editable controls such as the TextBox.Text and CheckBox.IsChecked default to TwoWay binding. A programmatic way to determine whether a dependency property binds one-way or two-way by default is to get the property metadata with DependencyProperty.GetMetadata. if (TextBox.TextProperty.GetMetadata(typeof(TextBox)) is FrameworkPropertyMetadata meta) { Console.WriteLine($&quot;{meta.BindsTwoWayByDefault}&quot;); // True } OneWayToSource is the reverse of OneWay binding; it updates the source property when the target property changes, which is appropriate if you only need to reevaluate the source value from the UI. OneTime binding causes the source property to initialize the target property but doesn&#8217;t propagate subsequent changes which is appropriate if either a snapshot of the current state is appropriate or the data is truly static. If the data context changes or the object in the data context changes, the change is not reflected in the target property. To detect source changes (applicable to OneWay and TwoWay bindings), the source must implement a suitable property change notification mechanism such as INotifyPropertyChanged. Bindings that are TwoWay or OneWayToSource listen for changes in the target property and propagate them back to the source, known as updating the source. The Binding.UpdateSourceTrigger property determines what triggers the update of the source. If the UpdateSourceTrigger value is UpdateSourceTrigger.PropertyChanged, then the value pointed to by the right arrow of TwoWay or the OneWayToSource bindings is updated as soon as the target property changes. However, if the UpdateSourceTrigger value is LostFocus, then that value only is updated with the new value when the target property loses focus. If the UpdateSourceTrigger value of the binding is set to Explicit, the UpdateSource method must be called or the changes will not propagate back to the source. var textBlock = new TextBlock(); var nameBindingObject = new Binding(&quot;Name&quot;); nameBindingObject.UpdateSourceTrigger = UpdateSourceTrigger.Explicit; // ... textBlock.SetBinding(TextBlock.TextProperty, nameBindingObject); var bindingExpression = textBlock.GetBindingExpression(TextBlock.TextProperty); bindingExpression.UpdateSource(); 2.3. Data conversion [ValueConversion(typeof(Color), typeof(SolidColorBrush))] public class ColorBrushConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { Color color = (Color)value; return new SolidColorBrush(color); } public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { return null; } } /// &lt;summary&gt; /// Provides a way to apply custom logic to a binding. /// &lt;/summary&gt; /// &lt;remarks&gt;Value converters are culture-aware. Both the Convert and ConvertBack methods have a culture parameter that indicates the cultural information.&lt;/remarks&gt; public interface IValueConverter { /// &lt;summary&gt; /// The data binding engine calls this method when it propagates a value from the binding source to the binding target. /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;The value produced by the binding source.&lt;/param&gt; /// &lt;param name=&quot;targetType&quot;&gt;The type of the binding target property.&lt;/param&gt; /// &lt;param name=&quot;parameter&quot;&gt;The converter parameter to use.&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;The culture to use in the converter.&lt;/param&gt; /// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt; /// &lt;remarks&gt; /// A return value of &lt;see cref=&quot;DependencyProperty.UnsetValue&quot;/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt;, if available, or the default value instead. /// A return value of &lt;see cref=&quot;Binding.DoNothing&quot;/&gt; indicates that the binding does not transfer the value or use the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt; or default value. /// &lt;/remarks&gt; object Convert(object value, Type targetType, object parameter, CultureInfo culture); /// &lt;summary&gt; /// The data binding engine calls this method when it propagates a value from the binding target to the binding source. /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;The value that is produced by the binding target.&lt;/param&gt; /// &lt;param name=&quot;targetType&quot;&gt;The type to convert to.&lt;/param&gt; /// &lt;param name=&quot;parameter&quot;&gt;The converter parameter to use.&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;The culture to use in the converter.&lt;/param&gt; /// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt; /// &lt;remarks&gt; /// A return value of &lt;see cref=&quot;DependencyProperty.UnsetValue&quot;/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt;, if available, or the default value instead. /// A return value of &lt;see cref=&quot;Binding.DoNothing&quot;/&gt; indicates that the binding does not transfer the value or use the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt; or default value. /// &lt;/remarks&gt; object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture); } 2.4. Data validation WPF has two types of built-in ValidationRule objects to check whether the value of a property is valid. A ExceptionValidationRule checks for exceptions thrown during the update of the binding source property. An alternative syntax to setting the ExceptionValidationRule explicitly is to set the ValidatesOnExceptions property to true on a Binding or MultiBinding object. A DataErrorValidationRule object checks for errors that are raised by objects that implement the IDataErrorInfo or INotifyDataErrorInfo interface. An alternative syntax to setting the DataErrorValidationRule explicitly is to set the ValidatesOnDataErrors property to true on a Binding or MultiBinding object. Custom validation rule objects can also be defined by deriving from the ValidationRule class and implementing the Validate method. One way to provide some feedback about the error on the app UI is to set the Validation.ErrorTemplate attached property to a custom ControlTemplate. &lt;ControlTemplate x:Key=&quot;validationTemplate&quot;&gt; &lt;DockPanel&gt; &lt;TextBlock Foreground=&quot;Red&quot; FontSize=&quot;20&quot;&gt;!&lt;/TextBlock&gt; &lt;!-- The AdornedElementPlaceholder element specifies where the control being adorned should be placed. --&gt; &lt;AdornedElementPlaceholder/&gt; &lt;/DockPanel&gt; &lt;/ControlTemplate&gt; In addition, the error message may also be displayed using a ToolTip. &lt;Style x:Key=&quot;textStyleTextBox&quot; TargetType=&quot;TextBox&quot;&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;#333333&quot; /&gt; &lt;Setter Property=&quot;MaxLength&quot; Value=&quot;40&quot; /&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;392&quot; /&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;Validation.HasError&quot; Value=&quot;true&quot;&gt; &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;{Binding (Validation.Errors).CurrentItem.ErrorContent, RelativeSource={RelativeSource Self}}&quot; /&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; 2.5. Binding path If the binding source is an object, use the Binding.Path property to specify the value to use for the binding. If binding to XML data, use the Binding.XPath property to specify the value. Use the Path property to specify the source value to bind to: In the simplest case, the Path property value is the name of the property of the source object to use for the binding, such as Path=PropertyName. Subproperties of a property can be specified by a similar syntax as in C#. For instance, the clause Path=ShoppingCart.Order sets the binding to the subproperty Order of the object or property ShoppingCart. To bind to an attached property, place parentheses around the attached property. For example, to bind to the attached property DockPanel.Dock, the syntax is Path=(DockPanel.Dock). Indexers of a property can be specified within square brackets following the property name where the indexer is applied. For instance, the clause Path=ShoppingCart[0] sets the binding to the index that corresponds to how your property&#8217;s internal indexing handles the literal string &quot;0&quot;. Nested indexers are also supported. Indexers and subproperties can be mixed in a Path clause; for example, Path=ShoppingCart.ShippingInfo[MailingAddress,Street]. Inside indexers, there can be multiple indexer parameters separated by commas (,). The type of each parameter can be specified with parentheses. For example, Path=&quot;[(sys:Int32)42,(sys:Int32)24]&quot;, where sys is mapped to the System namespace. When the source is a collection view, the current item can be specified with a slash (/). For example, the clause Path=/ sets the binding to the current item in the view. When the source is a collection, this syntax specifies the current item of the default collection view. Property names and slashes can be combined to traverse properties that are collections. For example, Path=/Offices/ManagerName specifies the current item of the source collection, which contains an Offices property that is also a collection. Its current item is an object that contains a ManagerName property. Optionally, a period (.) path can be used to bind to the current source. For example, Text=&quot;{Binding}&quot; is equivalent to Text=&quot;{Binding Path=.}&quot;. 2.6. Binding source Using the DataContext property on a parent element is useful when binding multiple properties to the same source. However, sometimes it may be more appropriate to specify the binding source on individual binding declarations. &lt;DockPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:c=&quot;clr-namespace:SDKSample&quot;&gt; &lt;DockPanel.Resources&gt; &lt;c:MyData x:Key=&quot;myDataSource&quot;/&gt; &lt;/DockPanel.Resources&gt; &lt;DockPanel.DataContext&gt; &lt;Binding Source=&quot;{StaticResource myDataSource}&quot;/&gt; &lt;/DockPanel.DataContext&gt; &lt;Button Background=&quot;{Binding Path=ColorName}&quot; Width=&quot;150&quot; Height=&quot;30&quot;&gt; I am bound to be RED! &lt;/Button&gt; &lt;/DockPanel&gt; &lt;DockPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:c=&quot;clr-namespace:SDKSample&quot;&gt; &lt;DockPanel.Resources&gt; &lt;c:MyData x:Key=&quot;myDataSource&quot;/&gt; &lt;/DockPanel.Resources&gt; &lt;Button Background=&quot;{Binding Source={StaticResource myDataSource}, Path=ColorName}&quot; Width=&quot;150&quot; Height=&quot;30&quot;&gt; I am bound to be RED! &lt;/Button&gt; &lt;/DockPanel&gt; The Binding.ElementName and Binding.RelativeSource properties also be used to set the source of the binding explicitly. &lt;StackPanel&gt; &lt;Slider Name=&quot;RectangleHeight&quot; Width=&quot;100&quot; HorizontalAlignment=&quot;Left&quot; Maximum=&quot;72&quot; Minimum=&quot;5&quot; Orientation=&quot;Horizontal&quot; Value=&quot;16&quot; /&gt; &lt;Button FontSize=&quot;{Binding ElementName=RectangleHeight, Path=Value}&quot;&gt;Hello World!&lt;/Button&gt; &lt;/StackPanel&gt; 2.7. Binding in XAML Binding is a markup extension. When using the binding extension to declare a binding, the declaration consists of a series of clauses following the Binding keyword and separated by commas (,). The clauses in the binding declaration can be in any order and there are many possible combinations. The clauses are Name=Value pairs, where Name is the name of the Binding property and Value is the value for the property. When creating binding declaration strings in markup, they must be attached to the specific dependency property of a target object. &lt;TextBlock Text=&quot;{Binding Source={StaticResource myDataSource}, Path=Name}&quot;/&gt; Object element syntax is an alternative to creating the binding declaration. In most cases, there&#8217;s no particular advantage to using either the markup extension or the object element syntax. &lt;TextBlock&gt; &lt;TextBlock.Text&gt; &lt;Binding Source=&quot;{StaticResource myDataSource}&quot; Path=&quot;Name&quot;/&gt; &lt;/TextBlock.Text&gt; &lt;/TextBlock&gt; 2.8. Binding in code Another way to specify a binding is to set properties directly on a Binding object in code, and then assign the binding to a property. private void Window_Loaded(object sender, RoutedEventArgs e) { // Make a new data source object var personDetails = new Person() { Name = &quot;John&quot;, Birthdate = DateTime.Parse(&quot;2001-02-03&quot;) }; // New binding object using the path of &#39;Name&#39; for whatever source object is used var nameBindingObject = new Binding(&quot;Name&quot;); // Configure the binding nameBindingObject.Mode = BindingMode.OneWay; nameBindingObject.Source = personDetails; nameBindingObject.Converter = NameConverter.Instance; nameBindingObject.ConverterCulture = new CultureInfo(&quot;en-US&quot;); // Set the binding to a target object. The TextBlock.Name property on the NameBlock UI element BindingOperations.SetBinding(NameBlock, TextBlock.TextProperty, nameBindingObject); } 3. Property system Windows Presentation Foundation (WPF) provides a set of services that can be used to extend the functionality of a type&#8217;s property. Collectively, these services are referred to as the WPF property system. A property that&#8217;s backed by the WPF property system is known as a dependency property. Attached properties are a XAML concept, dependency properties are a WPF concept. Attached properties enable extra property/value pairs to be set on any XAML element that derives from DependencyObject, even though the element doesn&#8217;t define those extra properties in its object model. 3.1. Dependency properties and CLR properties WPF properties are typically exposed as standard .NET properties. The purpose of dependency properties is to provide a way to compute the value of a property based on the value of other inputs, such as: System properties, such as themes and user preference. Just-in-time property determination mechanisms, such as data binding and animations/storyboards. Multiple-use templates, such as resources and styles. Values known through parent-child relationships with other elements in the element tree. Also, a dependency property can provide: Self-contained validation. Default values. Callbacks that monitor changes to other properties. A system that can coerce property values based on runtime information. Derived classes can change some characteristics of an existing property by overriding the metadata of a dependency property, rather than overriding the actual implementation of existing properties or creating new properties. 3.2. Dependency properties back CLR properties Dependency properties and the WPF property system extend property functionality by providing a DependencyProperty type that backs a property, as an alternative to the standard pattern of backing a property with a private field. Here&#8217;s some commonly used terminology: Dependency property, which is a property that&#8217;s backed by a DependencyProperty. Dependency property identifier, which is a DependencyProperty instance obtained as a return value when registering a dependency property, and then stored as a static member of a class. Many of the APIs that interact with the WPF property system use the dependency property identifier as a parameter. CLR &quot;wrapper&quot;, which is the get and set implementations for the property. These implementations incorporate the dependency property identifier by using it in the GetValue and SetValue calls. In this way, the WPF property system provides the backing for the property. The following example defines the IsSpinning dependency property to show the relationship of the DependencyProperty identifier to the property that it backs. public static readonly DependencyProperty IsSpinningProperty = DependencyProperty.Register( &quot;IsSpinning&quot;, typeof(bool), typeof(MainWindow) ); public bool IsSpinning { get =&gt; (bool)GetValue(IsSpinningProperty); set =&gt; SetValue(IsSpinningProperty, value); } The naming convention of the property and its backing DependencyProperty field is important. The name of the field is always the name of the property, with the suffix Property appended. 3.3. Attached properties Although any object can set an attached property value, that doesn&#8217;t mean setting a value will produce a tangible result or the value will be used by another object. Attached property usage typically follows one of these models: The type that defines the attached property is the parent of the elements that set values for the attached property. The parent type iterates its child objects through internal logic that acts on the object tree structure, obtains the values, and acts on those values in some manner. The type that defines the attached property is used as the child element for various possible parent elements and content models. The type that defines the attached property represents a service. Other types set values for the attached property. Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class. Attached properties in WPF don&#8217;t have the typical CLR get and set wrapper methods because the properties might be set from outside of the CLR namespace. To permit a XAML processor to set those values when parsing XAML, the class that defines the attached property must implement dedicated accessor methods in the form of Get&lt;property name&gt; and Set&lt;property name&gt;. // Attached properties in code DockPanel myDockPanel = new(); TextBox myTextBox = new(); myTextBox.Text = &quot;Enter text&quot;; // Add child element to the DockPanel. myDockPanel.Children.Add(myTextBox); // Set the attached property value. DockPanel.SetDock(myTextBox, Dock.Top); public static Dock GetDock(UIElement element); public static void SetDock(UIElement element, Dock dock); &lt;!-- Attached properties in XAML --&gt; &lt;DockPanel&gt; &lt;TextBox DockPanel.Dock=&quot;Top&quot;&gt;Enter text&lt;/TextBox&gt; &lt;/DockPanel&gt; Define attached property as a dependency in the defining class by declaring a public static readonly field of type DependencyProperty. Then, assign the return value of the RegisterAttached method to the field, which is also known as the dependency property identifier. Follow the WPF property naming convention that distinguishes fields from the properties that they represent, by naming the identifier field &lt;property name&gt;Property. Also, provide static Get&lt;property name&gt; and Set&lt;property name&gt; accessor methods, which lets the property system access the attached property. public class Aquarium : UIElement { // Register an attached dependency property with the specified // property name, property type, owner type, and property metadata. public static readonly DependencyProperty HasFishProperty = DependencyProperty.RegisterAttached( &quot;HasFish&quot;, typeof(bool), typeof(Aquarium), new FrameworkPropertyMetadata(defaultValue: false, flags: FrameworkPropertyMetadataOptions.AffectsRender) ); // Declare a get accessor method. public static bool GetHasFish(UIElement target) =&gt; (bool)target.GetValue(HasFishProperty); // Declare a set accessor method. public static void SetHasFish(UIElement target, bool value) =&gt; target.SetValue(HasFishProperty, value); } The get accessor method signature is public static object Get&lt;property name&gt;(DependencyObject target), where: target is the DependencyObject from which the attached property is read. The target type can be more specific than DependencyObject. For example, the DockPanel.GetDock accessor method types the target as UIElement because the attached property is intended to be set on UIElement instances. The return type can be more specific than object. For example, the GetDock method types the returned value as Dock because the return value should be a Dock enumeration. The set accessor method signature is public static void Set&lt;property name&gt;(DependencyObject target, object value), where: target is the DependencyObject on which the attached property is written. The target type can be more specific than DependencyObject. For example, the SetDock method types the target as UIElement because the attached property is intended to be set on UIElement instances. The value type can be more specific than object. For example, the SetDock method requires a Dock value. 3.4. Property value inheritance Property value inheritance is a feature of the Windows Presentation Foundation (WPF) property system and applies to dependency properties. Property value inheritance lets child elements in a tree of elements obtain the value of a particular property from the nearest parent element. Since a parent element might also have obtained its property value through property value inheritance, the system potentially recurses back to the page root. The WPF property system doesn&#8217;t enable property value inheritance by default, and value inheritance is inactive unless specifically enabled in dependency property metadata. Even with property value inheritance enabled, a child element will only inherit a property value in the absence of a higher precedence value. 4. Routed events Windows Presentation Foundation (WPF) application developers and component authors can use routed events to propagate events through an element tree, and invoke event handlers on multiple listeners in the tree. From a functional perspective, a routed event is a type of event that can invoke handlers on multiple listeners in an element tree, not just on the event source. An event listener is the element where an event handler is attached and invoked. An event source is the element or object that originally raised an event. From an implementation perspective, a routed event is an event registered with the WPF event system, backed by an instance of the RoutedEvent class, and processed by the WPF event system. Typically, a routed event is implemented with a CLR event &quot;wrapper&quot; to enable attaching handlers in XAML and in code-behind as you would a CLR event. Depending on how a routed event is defined, when the event is raised on a source element it: Bubbles up through element tree from the source element to the root element, which is typically a page or window. Tunnels down through the element tree from the root element to the source element. Doesn&#8217;t travel through the element tree, and only occurs on the source element directly. 4.1. Routed event and event handler A routed event is an event registered with the WPF event system, backed by an instance of the RoutedEvent class, and processed by the WPF event system. The RoutedEvent instance, obtained from registration, is typically stored as a public static readonly member of the &quot;owner&quot; class, that registered it. Typically, a routed event implements an identically named CLR event &quot;wrapper&quot; that is similar to how a dependency property is a CLR property. The CLR event wrapper contains add and remove accessors to enable attaching handlers in XAML and in code-behind through language-specific event syntax. The add and remove accessors override their CLR implementation and call the routed event AddHandler and RemoveHandler methods. // Register a custom routed event using the Bubble routing strategy. public static readonly RoutedEvent TapEvent = EventManager.RegisterRoutedEvent( name: &quot;Tap&quot;, routingStrategy: RoutingStrategy.Bubble, handlerType: typeof(RoutedEventHandler), ownerType: typeof(CustomButton)); // Provide CLR accessors for adding and removing an event handler. public event RoutedEventHandler Tap { add { AddHandler(TapEvent, value); } remove { RemoveHandler(TapEvent, value); } } In XAML, attach an event handler to an element by declaring the event name as an attribute on the event listener element. The attribute value is the handler method name. The handler method must be implemented in the code-behind partial class for the XAML page. The event listener is the element where the event handler is attached and invoked. If the event isn&#8217;t a member of the listener&#8217;s class, use the qualified event name in the form of &lt;owner type&gt;.&lt;event name&gt;. &lt;StackPanel Button.Click=&quot;YesNoCancelButton_Click&quot;&gt; &lt;Button Name=&quot;YesButton&quot; Click=&quot;YesButtonClick&quot;&gt;Yes&lt;/Button&gt; &lt;Button Name=&quot;NoButton&quot; Click=&quot;NoButtonClick&quot;&gt;No&lt;/Button&gt; &lt;Button Name=&quot;CancelButton&quot; Click=&quot;CancelClick&quot;&gt;Cancel&lt;/Button&gt; &lt;/StackPanel&gt; The signature of the event handler method in code-behind must match the delegate type for the routed event. private void YesNoCancelButtonClick(object sender, RoutedEventArgs e) { } To attach an event handler for a routed event to an element using code: Directly call the AddHandler method. // Routed event handlers can always be attached this way. Button1.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(Button_Click)); StackPanel1.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(Button_Click)); If the routed event implements a CLR event wrapper, use language-specific event syntax to add event handlers. Button1.Click += Button_Click; 4.2. Attached events WPF attached events are implemented as routed events backed by a RoutedEvent field. public class AquariumFilter { // Register a custom routed event using the bubble routing strategy. public static readonly RoutedEvent CleanEvent = EventManager.RegisterRoutedEvent( &quot;Clean&quot;, RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(AquariumFilter)); // Provide an add handler accessor method for the Clean event. public static void AddCleanHandler(DependencyObject dependencyObject, RoutedEventHandler handler) { if (dependencyObject is not UIElement uiElement) { return; } uiElement.AddHandler(CleanEvent, handler); } // Provide a remove handler accessor method for the Clean event. public static void RemoveCleanHandler(DependencyObject dependencyObject, RoutedEventHandler handler) { if (dependencyObject is not UIElement uiElement) { return; } uiElement.RemoveHandler(CleanEvent, handler); } } An Add&lt;event name&gt;Handler method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to add. The method must be public and static, with no return value. The method calls the AddHandler base class method, passing in the routed event and handler as arguments. This method supports the XAML attribute syntax for attaching an event handler to an element. This method also enables code access to the event handler store for the attached event. A Remove&lt;event name&gt;Handler method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to remove. The method must be public and static, with no return value. The method calls the RemoveHandler base class method, passing in the routed event and handler as arguments. This method enables code access to the event handler store for the attached event. WPF implements attached events as routed events because the identifier for a RoutedEvent is defined by the WPF event system. The RegisterRoutedEvent method that returns the attached event identifier is the same method used to register non-attached routed events. Unlike the CLR event &quot;wrapper&quot; used to back non-attached routed events, the attached event accessor methods can be implemented in classes that don&#8217;t derive from UIElement or ContentElement. It is possible because the attached event backing code calls the UIElement.AddHandler and UIElement.RemoveHandler methods on a passed in UIElement instance. In contrast, the CLR wrapper for non-attached routed events calls those methods directly on the owning class, so that class must derive from UIElement. When defining a custom attached event using the WPF model of basing attached events on routed events, use the UIElement.RaiseEvent method to raise an attached event on any UIElement or ContentElement. When raising a routed event, whether it&#8217;s attached or not, an element is required to designate in the element tree as the event source. That source is then reported as the RaiseEvent caller. For example, to raise the AquariumFilter.Clean attached routed event on aquarium1: aquarium1.RaiseEvent(new RoutedEventArgs(AquariumFilter.CleanEvent)); In XAML syntax, an attached event is specified by its event name and its owner type, in the form of &lt;owner type&gt;.&lt;event name&gt;. Because the event name is qualified with the name of its owner type, the syntax allows the event to be attached to any element that can be instantiated. It is also applicable to handlers for regular routed events that attach to an arbitrary element along the event route. &lt;!-- attaches the AquariumFilter_Clean handler for the AquariumFilter.Clean attached event to the aquarium1 element --&gt; &lt;aqua:Aquarium x:Name=&quot;aquarium1&quot; Height=&quot;300&quot; Width=&quot;400&quot; aqua:AquariumFilter.Clean=&quot;AquariumFilter_Clean&quot;/&gt; Event handlers can also be attached for attached events in code behind, by calling the AddHandler method on the object that the handler should attach to and pass the event identifier and handler as parameters to the method. aquarium1.AddHandler(AquariumFilter.Clean, new RoutedEventHandler(AquariumFilter_Clean), true); 4.3. WPF input events By convention, WPF routed events that follow a tunneling route have a name that&#8217;s prefixed with &quot;Preview&quot;. Input events often come in pairs, with one being a preview event and the other a bubbling routed event. The Preview prefix signifies that the preview event completes before the paired bubbling event starts. A preview input event that&#8217;s marked as handled won&#8217;t invoke any normally registered event handlers for the remainder of the preview route, and the paired bubbling event won&#8217;t be raised. The order of event processing following a mouse-down action on leaf element #2 is: PreviewMouseDown tunneling event on the root element. PreviewMouseDown tunneling event on intermediate element #1. PreviewMouseDown tunneling event on leaf element #2, which is the source element. MouseDown bubbling event on leaf element #2, which is the source element. MouseDown bubbling event on intermediate element #1. MouseDown bubbling event on the root element. 4.4. Weak event patterns Listening for events can lead to memory leaks. The typical technique for listening to an event is to use the language-specific syntax that attaches a handler to an event on a source. For example, in C#, that syntax is: source.SomeEvent += new SomeEventHandler(MyEventHandler) that creates a strong reference from the event source to the event listener. Ordinarily, attaching an event handler for a listener causes the listener to have an object lifetime that is influenced by the object lifetime of the source (unless the event handler is explicitly removed). Whenever the source object lifetime extends beyond the object lifetime of the listener, the normal event pattern leads to a memory leak: the listener is kept alive longer than intended. The weak event pattern can be used whenever a listener needs to register for an event, but the listener does not explicitly know when to unregister, and can also be used whenever the object lifetime of the source exceeds the useful object lifetime of the listener. 5. Commands A command can be used to: separate the semantics and the object that invokes a command from the logic that executes the command. indicate whether an action is possible by implementing the CanExecute method. The routed command model in WPF can be broken up into four main concepts: The command is the action to be executed. The command source is the object which invokes the command. The command target is the object that the command is being executed on. The command binding is the object which maps the command logic to the command. A commands is created by implementing the ICommand interface. Execute method performs the actions that are associated with the command. CanExecute method determines whether the command can execute on the current command target. CanExecuteChanged event is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding. The RelayCommand and RelayCommand&lt;T&gt; are ICommand implementations that can expose a method or delegate to the view. These types act as a way to bind commands between the viewmodel and UI elements. They provide a base implementation of the ICommand interface. They also implement the IRelayCommand (and IRelayCommand&lt;T&gt;) interface, which exposes a NotifyCanExecuteChanged method to raise the CanExecuteChanged event. They expose constructors taking delegates like Action and Func&lt;T&gt;, which allow the wrapping of standard methods and lambda expressions. public class MyViewModel : ObservableObject { public MyViewModel() { IncrementCounterCommand = new RelayCommand(IncrementCounter); } private int counter; public int Counter { get =&gt; counter; private set =&gt; SetProperty(ref counter, value); } public ICommand IncrementCounterCommand { get; } private void IncrementCounter() =&gt; Counter++; } &lt;Page x:Class=&quot;MyApp.Views.MyPage&quot; xmlns:viewModels=&quot;using:MyApp.ViewModels&quot;&gt; &lt;Page.DataContext&gt; &lt;viewModels:MyViewModel x:Name=&quot;ViewModel&quot;/&gt; &lt;/Page.DataContext&gt; &lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock Text=&quot;{x:Bind ViewModel.Counter, Mode=OneWay}&quot;/&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;{x:Bind ViewModel.IncrementCounterCommand}&quot;/&gt; &lt;/StackPanel&gt; &lt;/Page&gt; A command source is the object that generally implements the ICommandSource interface, which invokes the command. Examples of command sources are MenuItem, Button, and KeyGesture. A command source like a Button can subscribe to the CanExecuteChanged event and be disabled if CanExecute returns false or be enabled if CanExecute returns true. Command is the command to execute when the command source is invoked. CommandTarget is the object on which to execute the command, which is only applicable when the ICommand is a RoutedCommand. If the CommandTarget is set on an ICommandSource and the corresponding command is not a RoutedCommand, the command target is ignored. If the CommandTarget is not set, the element with keyboard focus will be the command target. CommandParameter is a user-defined data type used to pass information to the handlers implementing the command. A CommandBinding associates a command with the event handlers that implement the command. The CommandBinding class contains a Command property, and PreviewExecuted, Executed, PreviewCanExecute, and CanExecute events. &lt;Window.CommandBindings&gt; &lt;CommandBinding Command=&quot;ApplicationCommands.Open&quot; Executed=&quot;OpenCmdExecuted&quot; CanExecute=&quot;OpenCmdCanExecute&quot;/&gt; &lt;/Window.CommandBindings&gt; // Creating CommandBinding and attaching an Executed and CanExecute handler CommandBinding OpenCmdBinding = new CommandBinding( ApplicationCommands.Open, OpenCmdExecuted, OpenCmdCanExecute); this.CommandBindings.Add(OpenCmdBinding); void OpenCmdExecuted(object target, ExecutedRoutedEventArgs e) { String command, targetobj; command = ((RoutedCommand)e.Command).Name; targetobj = ((FrameworkElement)target).Name; MessageBox.Show(&quot;The &quot; + command + &quot; command has been invoked on target object &quot; + targetobj); } void OpenCmdCanExecute(object sender, CanExecuteRoutedEventArgs e) { e.CanExecute = true; } A command target is the element on which the command is executed. With regards to a RoutedCommand, the command target is the element at which routing of the Executed and CanExecute starts. The command source can explicitly set the command target. If the command target is not defined, the element with keyboard focus will be used as the command target. &lt;StackPanel&gt; &lt;Menu&gt; &lt;MenuItem Command=&quot;ApplicationCommands.Paste&quot; CommandTarget=&quot;{Binding ElementName=mainTextBox}&quot; /&gt; &lt;/Menu&gt; &lt;TextBox Name=&quot;mainTextBox&quot;/&gt; &lt;/StackPanel&gt; // Creating the UI objects StackPanel mainStackPanel = new StackPanel(); TextBox pasteTextBox = new TextBox(); Menu stackPanelMenu = new Menu(); MenuItem pasteMenuItem = new MenuItem(); // Adding objects to the panel and the menu stackPanelMenu.Items.Add(pasteMenuItem); mainStackPanel.Children.Add(stackPanelMenu); mainStackPanel.Children.Add(pasteTextBox); // Setting the command to the Paste command pasteMenuItem.Command = ApplicationCommands.Paste; // Setting the command target to the TextBox pasteMenuItem.CommandTarget = pasteTextBox; The CommandManager serves a number of command related functions. It provides a set of static methods for adding and removing PreviewExecuted, Executed, PreviewCanExecute, and CanExecute event handlers to and from a specific element. It provides a means to register CommandBinding and InputBinding objects onto a specific class. The CommandManager also provides a means, through the RequerySuggested event, to notify a command when it should raise the CanExecuteChanged event. The InvalidateRequerySuggested method forces the CommandManager to raise the RequerySuggested event, which is useful for conditions that should disable/enable a command but are not conditions that the CommandManager is aware of. 6. Windows In WPF, a window is encapsulated by the Window class that used to do the following: Display a window. Configure the size, position, and appearance of a window. Host application-specific content. Manage the lifetime of a window. A window is divided into two areas: the non-client area and client area. The non-client area of a window is implemented by WPF and includes the parts of a window that are common to most windows, including the following: A title bar (1-5). An icon (1). Title (2). Minimize (3), Maximize (4), and Close (5) buttons. System menu (6) with menu items. Appears when clicking on the icon (1). Border (7). The client area of a window is the area within a window&#8217;s non-client area and is used by developers to add application-specific content, such as menu bars, tool bars, and controls. Client area (8). Resize grip (9). This is a control added to the Client area (8). For a window that is defined using both XAML markup and code-behind: XAML markup files are configured as MSBuild Page items. Code-behind files are configured as MSBuild Compile items. .NET SDK projects automatically import the correct Page and Compile items. When the project is configured for WPF, the XAML markup files are automatically imported as Page items, and the corresponding code-behind file is imported as Compile. 6.1. Lifetime A window that is opened by using the Show method doesn&#8217;t have an implicit relationship with the window that created it. Users can interact with either window independently of the other, which means that either window can do the following: Cover the other (unless one of the windows has its Topmost property set to true). Be minimized, maximized, and restored without affecting the other. After ownership by setting the Owner property of the owned window with a reference to the owner window is established: The owned window can reference its owner window by inspecting the value of its Owner property. The owner window can discover all the windows it owns by inspecting the value of its OwnedWindows property. A window opened by calling Show is a modeless window, and the application doesn&#8217;t prevent users from interacting with other windows in the application. Opening a window with ShowDialog opens a window as modal and restricts user interaction to the specific window. The life of a window starts coming to an end when a user closes it. Once a window is closed, it can&#8217;t be reopened. A window can be closed by using elements in the non-client area, including the following: The Close item of the System menu. Pressing ALT + F4. public MainWindow() { InitializeComponent(); KeyDown += (s, e) =&gt; { // inhibit the ALT + F4 e.Handled = e.SystemKey == Key.F4 &amp;&amp; Keyboard.Modifiers == ModifierKeys.Alt; }; } Pressing the Close button. Pressing ESC when a button has the IsCancel property set to true on a modal window. The following illustration shows the sequence of the principal events in the lifetime of a window: The following illustration shows the sequence of the principal events in the lifetime of a window that is shown without activation (ShowActivated is set to false before the window is shown): 6.2. Appearance To configure the non-client area, Window provides several properties, which include Icon to set a window&#8217;s icon and Title to set its title. The appearance and behavior of non-client area border can also be changed by configuring a window&#8217;s resize mode, window style, and whether it appears as a button in the desktop task bar. &lt;!-- Non-rectangular window style --&gt; &lt;Window x:Class=&quot;WindowsOverview.ClippedWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;ClippedWindow&quot; SizeToContent=&quot;WidthAndHeight&quot; WindowStyle=&quot;None&quot; AllowsTransparency=&quot;True&quot; Background=&quot;Transparent&quot;&gt; &lt;Grid Margin=&quot;20&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;20&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Rectangle Stroke=&quot;#FF000000&quot; RadiusX=&quot;10&quot; RadiusY=&quot;10&quot;/&gt; &lt;Path Fill=&quot;White&quot; Stretch=&quot;Fill&quot; Stroke=&quot;#FF000000&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;15,-5.597,0,-0.003&quot; Width=&quot;30&quot; Grid.Row=&quot;1&quot; Data=&quot;M22.166642,154.45381 L29.999666,187.66699 40.791059,154.54395&quot;/&gt; &lt;Rectangle Fill=&quot;White&quot; RadiusX=&quot;10&quot; RadiusY=&quot;10&quot; Margin=&quot;1&quot;/&gt; &lt;TextBlock HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;25&quot; Text=&quot;Greetings!&quot; TextWrapping=&quot;Wrap&quot; Margin=&quot;5,5,50,5&quot;/&gt; &lt;Button HorizontalAlignment=&quot;Right&quot; VerticalAlignment=&quot;Top&quot; Background=&quot;Transparent&quot; BorderBrush=&quot;{x:Null}&quot; Foreground=&quot;Red&quot; Content=&quot;❌&quot; FontSize=&quot;15&quot; /&gt; &lt;Grid.Effect&gt; &lt;DropShadowEffect BlurRadius=&quot;10&quot; ShadowDepth=&quot;3&quot; Color=&quot;LightBlue&quot;/&gt; &lt;/Grid.Effect&gt; &lt;/Grid&gt; &lt;/Window&gt; // Hide the Minimize, Maximize, and Close buttons public MainWindow() { InitializeComponent(); SourceInitialized += (s, e) =&gt; { const int WM_SYSTEM_MENU = 0x80000; const int WM_GW_STYLE = -16; var hWnd = new System.Windows.Interop.WindowInteropHelper(this).Handle; if (hWnd == IntPtr.Zero) { throw new InvalidOperationException(&quot;The window has not yet been completely initialized&quot;); } // Hide the Minimize, Maximize, and Close buttons SetWindow(hWnd, WM_GW_STYLE, GetWindow(hWnd, WM_GW_STYLE) &amp; ~WM_SYSTEM_MENU); }; } [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetWindowLong&quot;)] private static extern int GetWindow(IntPtr hWnd, int nIndex); [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SetWindowLong&quot;, SetLastError = true)] private static extern int SetWindow(IntPtr hWnd, int nIndex, int dwNew); 6.3. Dialog boxes When designing a dialog box, follow these suggestions to create a good user experience: ❌ DON&#8217;T clutter the dialog window. The dialog experience is for the user to enter some data, or to make a choice. ✔️ DO provide an OK button to close the window. ✔️ DO set the OK button&#8217;s IsDefault property to true to allow the user to press the ENTER key to accept and close the window. ✔️ CONSIDER adding a Cancel button so that the user can close the window and indicate that they don&#8217;t want to continue. ✔️ DO set the Cancel button&#8217;s IsCancel property to true to allow the user to press the ESC key to close the window. ✔️ DO set the title of the window to accurately describe what the dialog represents, or what the user should do with the dialog. ✔️ DO set minimum width and height values for the window, preventing the user from resizing the window too small. ✔️ CONSIDER disabling the ability to resize the window if ShowInTaskbar is set to false. ✔️ DO When a menu item or button runs a function that requires user interaction through a dialog box before the function can continue, the control should use an ellipsis at the end of its header text: &lt;MenuItem Header=&quot;_Open...&quot; Click=&quot;openMenuItem_Click&quot; /&gt; &lt;!-- or --&gt; &lt;Button Content=&quot;_Save As...&quot; Click=&quot;saveAsButton_Click&quot; /&gt; ✔️ DO When a menu item or button runs a function that displays a dialog box that does NOT require user interaction, such as an About dialog box, an ellipsis isn&#8217;t required. 6.4. Multiple windows, multiple threads Typically, WPF applications start with two threads: one for handling rendering and another for managing the UI. The rendering thread effectively runs hidden in the background while the UI thread receives input, handles events, paints the screen, and runs application code. Most applications use a single UI thread, although in some situations it is best to use several. The UI thread queues work items inside an object called a Dispatcher that selects work items on a priority basis and runs each one to completion. Every UI thread must have at least one Dispatcher, and each Dispatcher can execute work items in exactly one thread. The trick to building responsive, user-friendly applications is to maximize the Dispatcher throughput by keeping the work items small. Most classes derive from DispatcherObject that stores a reference to the Dispatcher linked to the currently running thread that creates it at construction. A DispatcherObject can call its public VerifyAccess method that examines the Dispatcher associated with the current thread and compares it to the Dispatcher reference stored during construction, and if they don&#8217;t match, VerifyAccess throws an exception. VerifyAccess is intended to be called at the beginning of every method belonging to a DispatcherObject. A background thread can ask the UI thread to perform an operation on its behalf by registering a work item with the Dispatcher of the UI thread. The Dispatcher class provides the methods for registering work items: InvokeAsync, BeginInvoke, and Invoke. Invoke is a synchronous call – that is, it doesn&#8217;t return until the UI thread actually finishes executing the delegate. InvokeAsync and BeginInvoke are asynchronous and return immediately. The Dispatcher orders the elements in its queue by priority that maintained in the DispatcherPriority enumeration. WPF application may require multiple top-level windows to do a better job, which is especially true if there&#8217;s any chance that one of the windows will monopolize the thread. private void NewThreadWindow_Click(object sender, RoutedEventArgs e) { Thread newWindowThread = new Thread(ThreadStartingPoint); newWindowThread.SetApartmentState(ApartmentState.STA); newWindowThread.IsBackground = true; newWindowThread.Start(); } private void ThreadStartingPoint() { new MultiWindow().Show(); System.Windows.Threading.Dispatcher.Run(); } Windows Explorer works in multiple top-level windows within multiple threads fashion. Each new Explorer window belongs to the original process, but it&#8217;s created under the control of an independent thread. When Explorer becomes nonresponsive, such as when looking for network resources, other Explorer windows continue to be responsive and usable. 7. Styles, templates, and triggers 7.1. Styles A Style, commonly declared as a resource, can apply a set of property values to one or more elements. When setting the TargetType of a style and omit the x:Key attribute, the style is applied to all the TargetType elements scoped to the style, which is generally the XAML file itself. &lt;Window.Resources&gt; &lt;!--A Style that affects all TextBlocks--&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; If adding an x:Key attribute with value to the style, the style is no longer implicitly applied to all elements of TargetType. Only elements that explicitly reference the style will have the style applied to them. &lt;Window.Resources&gt; &lt;Style x:Key=&quot;TitleText&quot; TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;StackPanel&gt; &lt;TextBlock Style=&quot;{StaticResource TitleText}&quot;&gt;My Pictures&lt;/TextBlock&gt; &lt;TextBlock&gt;Check out my new pictures!&lt;/TextBlock&gt; &lt;/StackPanel&gt; To assign a named style to an element programmatically, get the style from the resources collection and assign it to the element&#8217;s Style property. textblock1.Style = (Style)Resources[&quot;TitleText&quot;]; A style can extend another style with the BaseOn property. &lt;Window.Resources&gt; &lt;!-- .... other resources .... --&gt; &lt;!--A Style that affects all TextBlocks--&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;!-- x:Key is implicitly set to {x:Type TextBlock} --&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;!--A Style that extends the previous TextBlock Style with an x:Key of TitleText--&gt; &lt;Style BasedOn=&quot;{StaticResource {x:Type TextBlock}}&quot; TargetType=&quot;TextBlock&quot; x:Key=&quot;TitleText&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;26&quot;/&gt; &lt;Setter Property=&quot;Foreground&quot;&gt; &lt;Setter.Value&gt; &lt;LinearGradientBrush StartPoint=&quot;0.5,0&quot; EndPoint=&quot;0.5,1&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Offset=&quot;0.0&quot; Color=&quot;#90DDDD&quot; /&gt; &lt;GradientStop Offset=&quot;1.0&quot; Color=&quot;#5BFFFF&quot; /&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; The x:Key of a style is implicitly set to {x:Type TargetType}. It means that if explicitly setting the x:Key value to anything other than {x:Type TargetType}, the Style isn&#8217;t applied to all TargetType elements automatically. If TargetType isn&#8217;t specified, the properties must be qualified in the Setter objects with a class name by using the syntax Property=&quot;ClassName.Property&quot;. Also note that many WPF controls consist of a combination of other WPF controls. If creating a style that applies to all controls of a type, unexpected results might happen. For example, if creating a style that targets the TextBlock type in a Window, the style is applied to all TextBlock controls in the window, even if the TextBlock is part of another control, such as a ListBox. 7.2. Control templates In WPF, the ControlTemplate of a control, Commonly declared as a resource, defines the appearance of the control. Each control has a default template assigned to the Control.Template property. A control template rewrites the visual appearance of the entire control, while a style simply applies property changes to the existing control. However, since the template of a control is applied by setting the Control.Template property, a template can be defined or set using a style. A TemplateBinding is an optimized form of a binding for template scenarios, analogous to a binding constructed with {Binding RelativeSource={RelativeSource TemplatedParent}}, such as for binding parts of the template to properties of the control. If a ContentPresenter is declared in the ControlTemplate of a ContentControl, the ContentPresenter will automatically bind to the ContentTemplate and Content properties. Likewise, an ItemsPresenter that is in the ControlTemplate of an ItemsControl will automatically bind to the ItemTemplate and Items properties. &lt;UserControl&gt; &lt;UserControl.Resources&gt; &lt;!-- Defined a ControlTemplate as a resource --&gt; &lt;ControlTemplate x:Key=&quot;roundbutton&quot; TargetType=&quot;Button&quot;&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;{TemplateBinding Background}&quot; Stroke=&quot;{TemplateBinding Foreground}&quot; /&gt; &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/UserControl.Resources&gt; &lt;StackPanel&gt; &lt;!-- Set the button&#39;s Template property to the roundbutton resource --&gt; &lt;Button Template=&quot;{StaticResource roundbutton}&quot;&gt;Hello&lt;/Button&gt; &lt;!-- Defined the ControlTemplate inline --&gt; &lt;Button Background=&quot;Red&quot; Foreground=&quot;White&quot;&gt; &lt;Button.Content&gt;World&lt;/Button.Content&gt; &lt;Button.Template&gt; &lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;{TemplateBinding Background}&quot; Stroke=&quot;{TemplateBinding Foreground}&quot; /&gt; &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; &lt;/StackPanel&gt; &lt;/UserControl&gt; 7.3. Data templates In WPF, the DataTemplate is used to custom the presentation and appearance of the data objects. In most cases, all other aspects of presentation, such as what an item looks like when it is selected or how a ListBox lays out the items, do not belong in the definition of a DataTemplate. &lt;!-- Defined the DataTemplate inline --&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot;&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt; &lt;!-- Defined a DataTemplate as a resource --&gt; &lt;UserControl.Resources&gt; &lt;DataTemplate x:Key=&quot;myTaskTemplate&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot; /&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/UserControl.Resources&gt; &lt;StackPanel&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemTemplate=&quot;{StaticResource myTaskTemplate}&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot; /&gt; &lt;/StackPanel&gt; The DataTemplate class has a DataType property that is very similar to the TargetType property of the Style class. &lt;DataTemplate DataType=&quot;{x:Type local:Task}&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; To supply logic to choose which DataTemplate to use based on the Priority value of the data object, create a subclass of DataTemplateSelector and override the SelectTemplate method. namespace SDKSample { public class TaskListDataTemplateSelector : DataTemplateSelector { public override DataTemplate SelectTemplate(object item, DependencyObject container) { FrameworkElement element = container as FrameworkElement; if (element != null &amp;&amp; item != null &amp;&amp; item is Task) { Task taskitem = item as Task; if (taskitem.Priority == 1) return element.FindResource(&quot;importantTaskTemplate&quot;) as DataTemplate; else return element.FindResource(&quot;myTaskTemplate&quot;) as DataTemplate; } return null; } } } &lt;Window.Resources&gt; &lt;local:TaskListDataTemplateSelector x:Key=&quot;myDataTemplateSelector&quot; /&gt; &lt;/Window.Resources&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot; ItemTemplateSelector=&quot;{StaticResource myDataTemplateSelector}&quot; HorizontalContentAlignment=&quot;Stretch&quot;/&gt; Styling and Templating an ItemsControl &lt;ItemsControl Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot;&gt; &lt;!--The ItemsControl has no default visual appearance. Use the Template property to specify a ControlTemplate to define the appearance of an ItemsControl. The ItemsPresenter uses the specified ItemsPanelTemplate (see below) to layout the items. If an ItemsPanelTemplate is not specified, the default is used. (For ItemsControl, the default is an ItemsPanelTemplate that specifies a StackPanel.--&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;Border BorderBrush=&quot;Aqua&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;15&quot;&gt; &lt;ItemsPresenter/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;!--Use the ItemsPanel property to specify an ItemsPanelTemplate that defines the panel that is used to hold the generated items. In other words, use this property if you want to affect how the items are laid out.--&gt; &lt;ItemsControl.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;WrapPanel /&gt; &lt;/ItemsPanelTemplate&gt; &lt;/ItemsControl.ItemsPanel&gt; &lt;!--Use the ItemTemplate to set a DataTemplate to define the visualization of the data objects. This DataTemplate specifies that each data object appears with the Proriity and TaskName on top of a silver ellipse.--&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;DataTemplate.Resources&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;18&quot;/&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;/Style&gt; &lt;/DataTemplate.Resources&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;Silver&quot;/&gt; &lt;StackPanel&gt; &lt;TextBlock Margin=&quot;3,3,3,0&quot; Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;TextBlock Margin=&quot;3,0,3,7&quot; Text=&quot;{Binding Path=TaskName}&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;!--Use the ItemContainerStyle property to specify the appearance of the element that contains the data. This ItemContainerStyle gives each item container a margin and a width. There is also a trigger that sets a tooltip that shows the description of the data object when the mouse hovers over the item container.--&gt; &lt;ItemsControl.ItemContainerStyle&gt; &lt;Style&gt; &lt;Setter Property=&quot;Control.Width&quot; Value=&quot;100&quot;/&gt; &lt;Setter Property=&quot;Control.Margin&quot; Value=&quot;5&quot;/&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;Control.IsMouseOver&quot; Value=&quot;True&quot;&gt; &lt;Setter Property=&quot;Control.ToolTip&quot; Value=&quot;{Binding RelativeSource={x:Static RelativeSource.Self}, Path=Content.Description}&quot;/&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/ItemsControl.ItemContainerStyle&gt; &lt;/ItemsControl&gt; The HierarchicalDataTemplate class is designed to be used with HeaderedItemsControl types to display collection data that contains other collections such as a Menu or a TreeView. &lt;Window x:Class=&quot;SDKSample.Window1&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:src=&quot;clr-namespace:SDKSample&quot; Title=&quot;HierarchicalDataTemplate Sample&quot;&gt; &lt;DockPanel&gt; &lt;DockPanel.Resources&gt; &lt;src:ListLeagueList x:Key=&quot;MyList&quot; /&gt; &lt;HierarchicalDataTemplate DataType=&quot;{x:Type src:League}&quot; ItemsSource=&quot;{Binding Path=Divisions}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/HierarchicalDataTemplate&gt; &lt;HierarchicalDataTemplate DataType=&quot;{x:Type src:Division}&quot; ItemsSource=&quot;{Binding Path=Teams}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/HierarchicalDataTemplate&gt; &lt;DataTemplate DataType=&quot;{x:Type src:Team}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/DataTemplate&gt; &lt;/DockPanel.Resources&gt; &lt;Menu Name=&quot;menu1&quot; Margin=&quot;10,10,10,10&quot; DockPanel.Dock=&quot;Top&quot;&gt; &lt;MenuItem Header=&quot;My Soccer Leagues&quot; ItemsSource=&quot;{Binding Source={StaticResource MyList}}&quot; /&gt; &lt;/Menu&gt; &lt;TreeView&gt; &lt;TreeViewItem Header=&quot;My Soccer Leagues&quot; ItemsSource=&quot;{Binding Source={StaticResource MyList}}&quot; /&gt; &lt;/TreeView&gt; &lt;/DockPanel&gt; &lt;/Window&gt; 7.4. Triggers A trigger sets properties or starts actions, such as an animation, when a property value changes or when an event is raised. Style, ControlTemplate, and DataTemplate all have a Triggers property that can contain a set of triggers. A Trigger that sets property values or starts actions based on the value of a property is called a property trigger. &lt;Window.Resources&gt; &lt;!-- .... other resources .... --&gt; &lt;Style TargetType=&quot;ListBoxItem&quot;&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;0.5&quot; /&gt; &lt;Setter Property=&quot;MaxHeight&quot; Value=&quot;75&quot; /&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsSelected&quot; Value=&quot;True&quot;&gt; &lt;Trigger.Setters&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;1.0&quot; /&gt; &lt;/Trigger.Setters&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; The properties changed by triggers are automatically reset to their previous value when the triggered condition is no longer satisfied. Another type of trigger is the EventTrigger, which starts a set of actions based on the occurrence of an event. &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsSelected&quot; Value=&quot;True&quot;&gt; &lt;Trigger.Setters&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;1.0&quot; /&gt; &lt;/Trigger.Setters&gt; &lt;/Trigger&gt; &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseEnter&quot;&gt; &lt;EventTrigger.Actions&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Duration=&quot;0:0:0.2&quot; Storyboard.TargetProperty=&quot;MaxHeight&quot; To=&quot;90&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger.Actions&gt; &lt;/EventTrigger&gt; &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseLeave&quot;&gt; &lt;EventTrigger.Actions&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Duration=&quot;0:0:1&quot; Storyboard.TargetProperty=&quot;MaxHeight&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger.Actions&gt; &lt;/EventTrigger&gt; &lt;/Style.Triggers&gt; MultiTriggers applly property values or performs actions when a set of conditions are satisfied. &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsEnabled&quot; Value=&quot;false&quot;&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;#EEEEEE&quot; /&gt; &lt;/Trigger&gt; &lt;MultiTrigger&gt; &lt;MultiTrigger.Conditions&gt; &lt;Condition Property=&quot;HasItems&quot; Value=&quot;false&quot; /&gt; &lt;Condition Property=&quot;Width&quot; Value=&quot;Auto&quot; /&gt; &lt;/MultiTrigger.Conditions&gt; &lt;Setter Property=&quot;MinWidth&quot; Value=&quot;120&quot;/&gt; &lt;/MultiTrigger&gt; &lt;MultiTrigger&gt; &lt;MultiTrigger.Conditions&gt; &lt;Condition Property=&quot;HasItems&quot; Value=&quot;false&quot; /&gt; &lt;Condition Property=&quot;Height&quot; Value=&quot;Auto&quot; /&gt; &lt;/MultiTrigger.Conditions&gt; &lt;Setter Property=&quot;MinHeight&quot; Value=&quot;95&quot;/&gt; &lt;/MultiTrigger&gt; &lt;/Style.Triggers&gt; Event setters invoke the specified event handlers in response to routed events, which apply to all elements that reference the Style rather than requiring to attach instance handlers to each individual element. Only Style.Setters support EventSetter objects. Handlers attached through event setters are invoked after any class handlers for an event, and also after any instance handlers. As a result, if a class handler or instance handler marks an event handled in its arguments, then the handler declared by an event setter is not invoked, unless the event setter specifically sets HandledEventsToo true. &lt;StackPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; x:Class=&quot;SDKSample.EventOvw2&quot; Name=&quot;dpanel2&quot; Initialized=&quot;PrimeHandledToo&quot;&gt; &lt;StackPanel.Resources&gt; &lt;Style TargetType=&quot;{x:Type Button}&quot;&gt; &lt;EventSetter Event=&quot;Click&quot; Handler=&quot;b1SetColor&quot;/&gt; &lt;/Style&gt; &lt;/StackPanel.Resources&gt; &lt;Button&gt;Click me&lt;/Button&gt; &lt;Button Name=&quot;ThisButton&quot; Click=&quot;HandleThis&quot;&gt; Raise event, handle it, use handled=true handler to get it anyway. &lt;/Button&gt; &lt;/StackPanel&gt; void b1SetColor(object sender, RoutedEventArgs e) { Button b = e.Source as Button; b.Background = new SolidColorBrush(Colors.Azure); } void HandleThis(object sender, RoutedEventArgs e) { e.Handled=true; } References [1] https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm [2] https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/ [3] https://learn.microsoft.com/en-us/dotnet/desktop/wpf" />
<meta property="og:description" content="1. MVVM pattern and toolkit 1.1. MVVM pattern 1.1.1. View 1.1.2. ViewModel 1.1.3. Model 1.1.4. Connecting view models to views 1.1.4.1. Creating a view model declaratively 1.1.4.2. Creating a view model programmatically 1.1.5. Updating views in response to changes in the underlying view model or model 1.2. MVVM Toolkit 2. Data binding 2.1. Data context 2.2. Data flow 2.3. Data conversion 2.4. Data validation 2.5. Binding path 2.6. Binding source 2.7. Binding in XAML 2.8. Binding in code 3. Property system 3.1. Dependency properties and CLR properties 3.2. Dependency properties back CLR properties 3.3. Attached properties 3.4. Property value inheritance 4. Routed events 4.1. Routed event and event handler 4.2. Attached events 4.3. WPF input events 4.4. Weak event patterns 5. Commands 6. Windows 6.1. Lifetime 6.2. Appearance 6.3. Dialog boxes 6.4. Multiple windows, multiple threads 7. Styles, templates, and triggers 7.1. Styles 7.2. Control templates 7.3. Data templates 7.4. Triggers References 1. MVVM pattern and toolkit The MVVM pattern [1] helps cleanly separate an application&#8217;s business and presentation logic from its user interface (UI). Maintaining a clean separation between application logic and the UI helps address numerous development issues and makes an application easier to test, maintain, and evolve. It can also significantly improve code re-use opportunities and allows developers and UI designers to collaborate more easily when developing their respective parts of an app. 1.1. MVVM pattern There are three core components in the MVVM pattern: the model, the view, and the view model. Using the MVVM pattern, the UI of the app and the underlying presentation and business logic are separated into three separate classes: the view, which encapsulates the UI and UI logic; the view model, which encapsulates presentation logic and state; and the model, which encapsulates the app&#8217;s business logic and data. 1.1.1. View The view is responsible for defining the structure, layout, and appearance of what the user sees on screen. Ideally, each view is defined in XAML, with a limited code-behind that does not contain business logic. However, in some cases, the code-behind might contain UI logic that implements visual behavior that is difficult to express in XAML, such as animations. Enable and disable UI elements by binding to view model properties, rather than enabling and disabling them in code-behind. Ensure that the view models are responsible for defining logical state changes that affect some aspects of the view&#8217;s display, such as whether a command is available, or an indication that an operation is pending. There are several options for executing code on the view model in response to interactions on the view, such as a button click or item selection. If a control supports commands, the control&#8217;s Command property can be data-bound to an ICommand property on the view model. When the control&#8217;s command is invoked, the code in the view model will be executed. In addition to commands, behaviors can be attached to an object in the view and can listen for either a command to be invoked or the event to be raised. In response, the behavior can then invoke an ICommand on the view model or a method on the view model. 1.1.2. ViewModel The view model implements properties and commands to which the view can data bind to, and notifies the view of any state changes through change notification events. The properties and commands that the view model provides define the functionality to be offered by the UI, but the view determines how that functionality is to be displayed. Multi-platform apps should keep the UI thread unblocked to improve the user&#8217;s perception of performance. Therefore, in the view model, use asynchronous methods for I/O operations and raise events to asynchronously notify views of property changes. The view model is also responsible for coordinating the view&#8217;s interactions with one or many model classes that are required. The view model might choose to expose model classes directly to the view so that controls in the view can data bind directly to them. In this case, the model classes will need to be designed to support data binding and change notification events. Each view model provides data from a model in a form that the view can easily consume. Placing the data conversion in the view model is a good idea because it provides properties that the view can bind to. For example, the view model might combine the values of two properties to make it easier to display by the view. It&#8217;s also possible to use converters as a separate data conversion layer that sits between the view model and the view. This can be necessary, for example, when data requires special formatting that the view model doesn&#8217;t provide. In order for the view model to participate in two-way data binding with the view, its properties must raise the PropertyChanged event. View models satisfy this requirement by implementing the INotifyPropertyChanged interface, and raising the PropertyChanged event when a property is changed. For collections, the view-friendly ObservableCollection&lt;T&gt; is provided. This collection implements collection changed notification, relieving the developer from having to implement the INotifyCollectionChanged interface on collections. 1.1.3. Model Model classes are non-visual classes that encapsulate the app&#8217;s data. Model classes can be thought of as representing the app&#8217;s domain model that includes a data model along with business and validation logic. Examples of model objects include data transfer objects (DTOs), Plain Old CLR Objects (POCOs), and generated entity and proxy objects. Model classes are typically used in conjunction with services or repositories that encapsulate data access and caching. 1.1.4. Connecting view models to views View models can be connected to views by using the data-binding capabilities. 1.1.4.1. Creating a view model declaratively The simplest approach is for the view to declaratively instantiate its corresponding view model in XAML. When the view is constructed, the corresponding view model object will also be constructed. &lt;Grid.DataContext&gt; &lt;vm:MainViewModel /&gt; &lt;/Grid.DataContext&gt; Though the declarative construction and assignment of the view model by the view has the advantage that it&#8217;s simple, but has the disadvantage that it requires a default (parameter-less) constructor in the view model. 1.1.4.2. Creating a view model programmatically A view can have code in the code-behind file, resulting in the view-model being assigned to its DataContext property. public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); DataContext = new MainViewModel(); } } The programmatic construction and assignment of the view model within the view&#8217;s code-behind has the advantage that it&#8217;s simple. However, the main disadvantage of this approach is that the view needs to provide the view model with any required dependencies. Using a dependency injection container can help to maintain loose coupling between the view and view model. 1.1.5. Updating views in response to changes in the underlying view model or model All view model and model classes that are accessible to a view should implement the INotifyPropertyChanged interface. Implementing this interface in a view model or model class allows the class to provide change notifications to any data-bound controls in the view when the underlying property value changes. Always raising a PropertyChanged event if a public property&#8217;s value changes. Always raising a PropertyChanged event for any calculated properties whose values are used by other properties in the view model or model. Always raising the PropertyChanged event at the end of the method that makes a property change, or when the object is known to be in a safe state. Never raising a PropertyChanged event if the property does not change. Never raising the PropertyChanged event during a view model&#8217;s constructor if you are initializing a property. Never raising more than one PropertyChanged event with the same property name argument within a single synchronous invocation of a public method of a class. public sealed class MainViewModel : INotifyPropertyChanged { private string? _title; public string? Title { get { return _title; } set { if (_title != value) { _title = value; OnPropertyChanged(); } } } public event PropertyChangedEventHandler? PropertyChanged; private void OnPropertyChanged([CallerMemberName] string? propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } 1.2. MVVM Toolkit The CommunityToolkit.Mvvm package (aka MVVM Toolkit, formerly named Microsoft.Toolkit.Mvvm) is a modern, fast, and modular MVVM library. [2] dotnet add package CommunityToolkit.Mvvm # --version 8.3.1 CommunityToolkit.Mvvm.ComponentModel ObservableObject public abstract class ObservableObject : INotifyPropertyChanged, INotifyPropertyChanging public sealed class MainViewModel : ObservableObject { private string? _title; public string? Title { get =&gt; _title; set =&gt; SetProperty(ref _title, value); } private TaskNotifier? myTask; public Task? MyTask { get =&gt; myTask; set =&gt; SetPropertyAndNotifyOnCompletion(ref myTask, value); } } &lt;StackPanel&gt; &lt;Label Content=&quot;{Binding MyTask.Status}&quot; /&gt; &lt;TextBox Text=&quot;{Binding Title}&quot; /&gt; &lt;/StackPanel&gt; ObservableRecipient public abstract class ObservableRecipient : ObservableObject public sealed class MainViewModel : ObservableRecipient, IRecipient&lt;RequestMessage&lt;int&gt;&gt; { public void Receive(RequestMessage&lt;int&gt; message) =&gt; throw new NotImplementedException(); } public sealed class MainViewModel : ObservableRecipient { // For best results and to avoid memory leaks, it&#39;s recommended to use OnActivated to register // to messages, and to use OnDeactivated to do cleanup operations. protected override void OnActivated() =&gt; Messenger.Register&lt;MainViewModel, RequestMessage&lt;int&gt;&gt;(this, (r, m) =&gt; r.Receive(m)); // By default, OnDeactivated automatically unregisters the current instance from all registered messages. protected override void OnDeactivated() =&gt; base.OnDeactivated(); public void Receive(RequestMessage&lt;int&gt; message) =&gt; throw new NotImplementedException(); } ObservableValidator public abstract class ObservableValidator : ObservableObject, INotifyDataErrorInfo public class RegistrationForm : ObservableValidator { private string name; [Required] [MinLength(2)] [MaxLength(100)] public string Name { get =&gt; name; // Here we are calling the SetProperty&lt;T&gt;(ref T, T, bool, string) method exposed // by ObservableValidator, and that additional bool parameter set to true indicates // that we also want to validate the property when its value is updated. set =&gt; SetProperty(ref name, value, true); } } &lt;TextBox Text=&quot;{Binding Name, ValidatesOnDataErrors=True}&quot; /&gt; ObservableProperty [ObservableProperty] [NotifyPropertyChangedFor(nameof(FullName))] // Notifying dependent properties [NotifyCanExecuteChangedFor(nameof(MyCommand))] // Notifying dependent commands [NotifyDataErrorInfo] // Requesting property validation [Required] [MinLength(2)] // Any other validation attributes too... [NotifyPropertyChangedRecipients] // Sending notification messages [PropertyChangedMessage&lt;T&gt;] [property: JsonPropertyName(&quot;name&quot;)] // Adding custom attributes private string? _name; INotifyPropertyChanged // only use in cases where the target types cannot just inherit from the equivalent // types (eg. from ObservableObject). [INotifyPropertyChanged] public partial class MyViewModel : SomeOtherType CommunityToolkit.Mvvm.DependencyInjection Ioc dotnet add package Microsoft.Extensions.DependencyInjection # --version 8.0.0 public partial class App : Application { public IServiceProvider Services { get; set; } public App() { Services = ConfigureServices(); } protected override void OnStartup(StartupEventArgs e) { var mainWindow = Services.GetRequiredService&lt;MainWindow&gt;(); mainWindow.Show(); } private ServiceProvider ConfigureServices() { var services = new ServiceCollection(); services.AddTransient&lt;MainWindow&gt;(); services.AddTransient&lt;MainViewModel&gt;(); return services.BuildServiceProvider(); } } CommunityToolkit.Mvvm.Input RelayCommand RelayCommand&lt;T&gt; AsyncRelayCommand AsyncRelayCommand&lt;T&gt; IRelayCommand IRelayCommand&lt;T&gt; IAsyncRelayCommand IAsyncRelayCommand&lt;T&gt; public sealed class MainViewModel : ObservableObject { public IRelayCommand OKCommand { get; } = new RelayCommand(() =&gt; { }, () =&gt; true); public IAsyncRelayCommand CancelCommand { get; } = new AsyncRelayCommand(() =&gt; Task.CompletedTask); } RelayCommand [RelayCommand(CanExecute = nameof(CanGreetUser))] private void GreetUser(User? user) { Console.WriteLine($&quot;Hello {user!.Name}!&quot;); } private bool CanGreetUser(User? user) { return user is not null; } [ObservableProperty] [NotifyCanExecuteChangedFor(nameof(GreetUserCommand))] private User? selectedUser; // Call IAsyncRelayCommand.Cancel to signal that token. [RelayCommand(IncludeCancelCommand = true)] private async Task DoWorkAsync(CancellationToken token) { // Do some long running work... } CommunityToolkit.Mvvm.Messaging IMessenger WeakReferenceMessenger StrongReferenceMessenger IRecipient&lt;TMessage&gt; MessageHandler&lt;TRecipient, TMessage&gt; CommunityToolkit.Mvvm.Messaging.Messages PropertyChangedMessage&lt;T&gt; RequestMessage&lt;T&gt; AsyncRequestMessage&lt;T&gt; CollectionRequestMessage&lt;T&gt; AsyncCollectionRequestMessage&lt;T&gt; ValueChangedMessage&lt;T&gt; 2. Data binding Data binding is the process that establishes a connection between the app UI and the data it displays. If the binding has the correct settings and the data provides the proper notifications, when the data changes its value, the elements that are bound to the data reflect changes automatically. Data binding can also mean that if an outer representation of the data in an element changes, then the underlying data can be automatically updated to reflect the change. Typically, each binding has four components: A binding target object. A target property. A binding source. A path to the value in the binding source to use. For example, to bound the content of a TextBox to the Employee.Name property: Target: TextBox Target property: Text Source object: Employee Source object value path: Name A binding contains all the information that can be shared across several binding expressions. A BindingExpression is an instance expression that cannot be shared and contains all the instance information of the Binding. // Make a new source var myDataObject = new MyData(); var myBinding = new Binding(&quot;ColorName&quot;) { Source = myDataObject }; // Bind the data source to the TextBox control&#39;s Text dependency property myText.SetBinding(TextBlock.TextProperty, myBinding); A binding source object can be treated either as a single object whose properties contain data or as a data collection of polymorphic objects that are often grouped together (such as the result of a query to a database). Any collection that implements the IEnumerable interface can be enumerated over. However, to set up dynamic bindings so that insertions or deletions in the collection update the UI automatically, the collection must implement the INotifyCollectionChanged interface. WPF provides the ObservableCollection&lt;T&gt; class, which is a built-in implementation of a data collection that exposes the INotifyCollectionChanged interface. To fully support transferring data values from source objects to targets, each object in your collection that supports bindable properties must also implement the INotifyPropertyChanged interface. A collection view is a layer on top of a binding source collection that allows you to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself. A collection view also maintains a pointer to the current item in the collection. If the source collection implements the INotifyCollectionChanged interface, the changes raised by the CollectionChanged event are propagated to the views. Because views do not change the underlying source collections, each source collection can have multiple views associated with it. Once ItemsControl is bound to a data collection, the data may need to be sorted, filtered, or grouped. To do that, use collection views, which are classes that implement the ICollectionView interface. A collection view is a layer on top of a binding source collection that allows to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself. A collection view also maintains a pointer to the current item in the collection. If the source collection implements the INotifyCollectionChanged interface, the changes raised by the CollectionChanged event are propagated to the views. Because views do not change the underlying source collections, each source collection can have multiple views associated with it. &lt;Window.Resources&gt; &lt;CollectionViewSource Source=&quot;{Binding Source={x:Static Application.Current}, Path=AuctionItems}&quot; x:Key=&quot;listingDataView&quot; /&gt; &lt;/Window.Resources&gt; &lt;ListBox Name=&quot;Master&quot; Grid.Row=&quot;2&quot; Grid.ColumnSpan=&quot;3&quot; Margin=&quot;8&quot; ItemsSource=&quot;{Binding Source={StaticResource listingDataView}}&quot; /&gt; private void AddSortCheckBox_Checked(object sender, RoutedEventArgs e) { // Sort the items first by Category and then by StartDate listingDataView.SortDescriptions.Add(new SortDescription(&quot;Category&quot;, ListSortDirection.Ascending)); listingDataView.SortDescriptions.Add(new SortDescription(&quot;StartDate&quot;, ListSortDirection.Ascending)); } private void AddFilteringCheckBox_Checked(object sender, RoutedEventArgs e) { if (((CheckBox)sender).IsChecked == true) listingDataView.Filter += ListingDataView_Filter; else listingDataView.Filter -= ListingDataView_Filter; } private void ListingDataView_Filter(object sender, FilterEventArgs e) { // Start with everything excluded e.Accepted = false; // Only inlcude items with a price less than 25 if (e.Item is AuctionItem product &amp;&amp; product.CurrentPrice &lt; 25) e.Accepted = true; } // This groups the items in the view by the property &quot;Category&quot; var groupDescription = new PropertyGroupDescription(); groupDescription.PropertyName = &quot;Category&quot;; listingDataView.GroupDescriptions.Add(groupDescription); 2.1. Data context When data binding is declared on XAML elements, they resolve data binding by looking at their immediate DataContext property. The data context is typically the binding source object for the binding source value path evaluation. If the DataContext property for the object hosting the binding isn&#8217;t set, the parent element&#8217;s DataContext property is checked, and so on, up until the root of the XAML object tree. In short, the data context used to resolve binding is inherited from the parent unless explicitly set on the object. Bindings can be configured to resolve with a specific object, as opposed to using the data context for binding resolution. When the DataContext property changes, all bindings that could be affected by the data context are reevaluated. 2.2. Data flow OneWay binding causes changes to the source property to automatically update the target property, but changes to the target property are not propagated back to the source property, which is appropriate if the control being bound is implicitly read-only. TwoWay binding causes changes to either the source property or the target property to automatically update the other, which is appropriate for editable forms or other fully interactive UI scenarios.. Most properties default to OneWay binding, but some dependency properties (typically properties of user-editable controls such as the TextBox.Text and CheckBox.IsChecked default to TwoWay binding. A programmatic way to determine whether a dependency property binds one-way or two-way by default is to get the property metadata with DependencyProperty.GetMetadata. if (TextBox.TextProperty.GetMetadata(typeof(TextBox)) is FrameworkPropertyMetadata meta) { Console.WriteLine($&quot;{meta.BindsTwoWayByDefault}&quot;); // True } OneWayToSource is the reverse of OneWay binding; it updates the source property when the target property changes, which is appropriate if you only need to reevaluate the source value from the UI. OneTime binding causes the source property to initialize the target property but doesn&#8217;t propagate subsequent changes which is appropriate if either a snapshot of the current state is appropriate or the data is truly static. If the data context changes or the object in the data context changes, the change is not reflected in the target property. To detect source changes (applicable to OneWay and TwoWay bindings), the source must implement a suitable property change notification mechanism such as INotifyPropertyChanged. Bindings that are TwoWay or OneWayToSource listen for changes in the target property and propagate them back to the source, known as updating the source. The Binding.UpdateSourceTrigger property determines what triggers the update of the source. If the UpdateSourceTrigger value is UpdateSourceTrigger.PropertyChanged, then the value pointed to by the right arrow of TwoWay or the OneWayToSource bindings is updated as soon as the target property changes. However, if the UpdateSourceTrigger value is LostFocus, then that value only is updated with the new value when the target property loses focus. If the UpdateSourceTrigger value of the binding is set to Explicit, the UpdateSource method must be called or the changes will not propagate back to the source. var textBlock = new TextBlock(); var nameBindingObject = new Binding(&quot;Name&quot;); nameBindingObject.UpdateSourceTrigger = UpdateSourceTrigger.Explicit; // ... textBlock.SetBinding(TextBlock.TextProperty, nameBindingObject); var bindingExpression = textBlock.GetBindingExpression(TextBlock.TextProperty); bindingExpression.UpdateSource(); 2.3. Data conversion [ValueConversion(typeof(Color), typeof(SolidColorBrush))] public class ColorBrushConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { Color color = (Color)value; return new SolidColorBrush(color); } public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { return null; } } /// &lt;summary&gt; /// Provides a way to apply custom logic to a binding. /// &lt;/summary&gt; /// &lt;remarks&gt;Value converters are culture-aware. Both the Convert and ConvertBack methods have a culture parameter that indicates the cultural information.&lt;/remarks&gt; public interface IValueConverter { /// &lt;summary&gt; /// The data binding engine calls this method when it propagates a value from the binding source to the binding target. /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;The value produced by the binding source.&lt;/param&gt; /// &lt;param name=&quot;targetType&quot;&gt;The type of the binding target property.&lt;/param&gt; /// &lt;param name=&quot;parameter&quot;&gt;The converter parameter to use.&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;The culture to use in the converter.&lt;/param&gt; /// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt; /// &lt;remarks&gt; /// A return value of &lt;see cref=&quot;DependencyProperty.UnsetValue&quot;/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt;, if available, or the default value instead. /// A return value of &lt;see cref=&quot;Binding.DoNothing&quot;/&gt; indicates that the binding does not transfer the value or use the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt; or default value. /// &lt;/remarks&gt; object Convert(object value, Type targetType, object parameter, CultureInfo culture); /// &lt;summary&gt; /// The data binding engine calls this method when it propagates a value from the binding target to the binding source. /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;The value that is produced by the binding target.&lt;/param&gt; /// &lt;param name=&quot;targetType&quot;&gt;The type to convert to.&lt;/param&gt; /// &lt;param name=&quot;parameter&quot;&gt;The converter parameter to use.&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;The culture to use in the converter.&lt;/param&gt; /// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt; /// &lt;remarks&gt; /// A return value of &lt;see cref=&quot;DependencyProperty.UnsetValue&quot;/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt;, if available, or the default value instead. /// A return value of &lt;see cref=&quot;Binding.DoNothing&quot;/&gt; indicates that the binding does not transfer the value or use the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt; or default value. /// &lt;/remarks&gt; object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture); } 2.4. Data validation WPF has two types of built-in ValidationRule objects to check whether the value of a property is valid. A ExceptionValidationRule checks for exceptions thrown during the update of the binding source property. An alternative syntax to setting the ExceptionValidationRule explicitly is to set the ValidatesOnExceptions property to true on a Binding or MultiBinding object. A DataErrorValidationRule object checks for errors that are raised by objects that implement the IDataErrorInfo or INotifyDataErrorInfo interface. An alternative syntax to setting the DataErrorValidationRule explicitly is to set the ValidatesOnDataErrors property to true on a Binding or MultiBinding object. Custom validation rule objects can also be defined by deriving from the ValidationRule class and implementing the Validate method. One way to provide some feedback about the error on the app UI is to set the Validation.ErrorTemplate attached property to a custom ControlTemplate. &lt;ControlTemplate x:Key=&quot;validationTemplate&quot;&gt; &lt;DockPanel&gt; &lt;TextBlock Foreground=&quot;Red&quot; FontSize=&quot;20&quot;&gt;!&lt;/TextBlock&gt; &lt;!-- The AdornedElementPlaceholder element specifies where the control being adorned should be placed. --&gt; &lt;AdornedElementPlaceholder/&gt; &lt;/DockPanel&gt; &lt;/ControlTemplate&gt; In addition, the error message may also be displayed using a ToolTip. &lt;Style x:Key=&quot;textStyleTextBox&quot; TargetType=&quot;TextBox&quot;&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;#333333&quot; /&gt; &lt;Setter Property=&quot;MaxLength&quot; Value=&quot;40&quot; /&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;392&quot; /&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;Validation.HasError&quot; Value=&quot;true&quot;&gt; &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;{Binding (Validation.Errors).CurrentItem.ErrorContent, RelativeSource={RelativeSource Self}}&quot; /&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; 2.5. Binding path If the binding source is an object, use the Binding.Path property to specify the value to use for the binding. If binding to XML data, use the Binding.XPath property to specify the value. Use the Path property to specify the source value to bind to: In the simplest case, the Path property value is the name of the property of the source object to use for the binding, such as Path=PropertyName. Subproperties of a property can be specified by a similar syntax as in C#. For instance, the clause Path=ShoppingCart.Order sets the binding to the subproperty Order of the object or property ShoppingCart. To bind to an attached property, place parentheses around the attached property. For example, to bind to the attached property DockPanel.Dock, the syntax is Path=(DockPanel.Dock). Indexers of a property can be specified within square brackets following the property name where the indexer is applied. For instance, the clause Path=ShoppingCart[0] sets the binding to the index that corresponds to how your property&#8217;s internal indexing handles the literal string &quot;0&quot;. Nested indexers are also supported. Indexers and subproperties can be mixed in a Path clause; for example, Path=ShoppingCart.ShippingInfo[MailingAddress,Street]. Inside indexers, there can be multiple indexer parameters separated by commas (,). The type of each parameter can be specified with parentheses. For example, Path=&quot;[(sys:Int32)42,(sys:Int32)24]&quot;, where sys is mapped to the System namespace. When the source is a collection view, the current item can be specified with a slash (/). For example, the clause Path=/ sets the binding to the current item in the view. When the source is a collection, this syntax specifies the current item of the default collection view. Property names and slashes can be combined to traverse properties that are collections. For example, Path=/Offices/ManagerName specifies the current item of the source collection, which contains an Offices property that is also a collection. Its current item is an object that contains a ManagerName property. Optionally, a period (.) path can be used to bind to the current source. For example, Text=&quot;{Binding}&quot; is equivalent to Text=&quot;{Binding Path=.}&quot;. 2.6. Binding source Using the DataContext property on a parent element is useful when binding multiple properties to the same source. However, sometimes it may be more appropriate to specify the binding source on individual binding declarations. &lt;DockPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:c=&quot;clr-namespace:SDKSample&quot;&gt; &lt;DockPanel.Resources&gt; &lt;c:MyData x:Key=&quot;myDataSource&quot;/&gt; &lt;/DockPanel.Resources&gt; &lt;DockPanel.DataContext&gt; &lt;Binding Source=&quot;{StaticResource myDataSource}&quot;/&gt; &lt;/DockPanel.DataContext&gt; &lt;Button Background=&quot;{Binding Path=ColorName}&quot; Width=&quot;150&quot; Height=&quot;30&quot;&gt; I am bound to be RED! &lt;/Button&gt; &lt;/DockPanel&gt; &lt;DockPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:c=&quot;clr-namespace:SDKSample&quot;&gt; &lt;DockPanel.Resources&gt; &lt;c:MyData x:Key=&quot;myDataSource&quot;/&gt; &lt;/DockPanel.Resources&gt; &lt;Button Background=&quot;{Binding Source={StaticResource myDataSource}, Path=ColorName}&quot; Width=&quot;150&quot; Height=&quot;30&quot;&gt; I am bound to be RED! &lt;/Button&gt; &lt;/DockPanel&gt; The Binding.ElementName and Binding.RelativeSource properties also be used to set the source of the binding explicitly. &lt;StackPanel&gt; &lt;Slider Name=&quot;RectangleHeight&quot; Width=&quot;100&quot; HorizontalAlignment=&quot;Left&quot; Maximum=&quot;72&quot; Minimum=&quot;5&quot; Orientation=&quot;Horizontal&quot; Value=&quot;16&quot; /&gt; &lt;Button FontSize=&quot;{Binding ElementName=RectangleHeight, Path=Value}&quot;&gt;Hello World!&lt;/Button&gt; &lt;/StackPanel&gt; 2.7. Binding in XAML Binding is a markup extension. When using the binding extension to declare a binding, the declaration consists of a series of clauses following the Binding keyword and separated by commas (,). The clauses in the binding declaration can be in any order and there are many possible combinations. The clauses are Name=Value pairs, where Name is the name of the Binding property and Value is the value for the property. When creating binding declaration strings in markup, they must be attached to the specific dependency property of a target object. &lt;TextBlock Text=&quot;{Binding Source={StaticResource myDataSource}, Path=Name}&quot;/&gt; Object element syntax is an alternative to creating the binding declaration. In most cases, there&#8217;s no particular advantage to using either the markup extension or the object element syntax. &lt;TextBlock&gt; &lt;TextBlock.Text&gt; &lt;Binding Source=&quot;{StaticResource myDataSource}&quot; Path=&quot;Name&quot;/&gt; &lt;/TextBlock.Text&gt; &lt;/TextBlock&gt; 2.8. Binding in code Another way to specify a binding is to set properties directly on a Binding object in code, and then assign the binding to a property. private void Window_Loaded(object sender, RoutedEventArgs e) { // Make a new data source object var personDetails = new Person() { Name = &quot;John&quot;, Birthdate = DateTime.Parse(&quot;2001-02-03&quot;) }; // New binding object using the path of &#39;Name&#39; for whatever source object is used var nameBindingObject = new Binding(&quot;Name&quot;); // Configure the binding nameBindingObject.Mode = BindingMode.OneWay; nameBindingObject.Source = personDetails; nameBindingObject.Converter = NameConverter.Instance; nameBindingObject.ConverterCulture = new CultureInfo(&quot;en-US&quot;); // Set the binding to a target object. The TextBlock.Name property on the NameBlock UI element BindingOperations.SetBinding(NameBlock, TextBlock.TextProperty, nameBindingObject); } 3. Property system Windows Presentation Foundation (WPF) provides a set of services that can be used to extend the functionality of a type&#8217;s property. Collectively, these services are referred to as the WPF property system. A property that&#8217;s backed by the WPF property system is known as a dependency property. Attached properties are a XAML concept, dependency properties are a WPF concept. Attached properties enable extra property/value pairs to be set on any XAML element that derives from DependencyObject, even though the element doesn&#8217;t define those extra properties in its object model. 3.1. Dependency properties and CLR properties WPF properties are typically exposed as standard .NET properties. The purpose of dependency properties is to provide a way to compute the value of a property based on the value of other inputs, such as: System properties, such as themes and user preference. Just-in-time property determination mechanisms, such as data binding and animations/storyboards. Multiple-use templates, such as resources and styles. Values known through parent-child relationships with other elements in the element tree. Also, a dependency property can provide: Self-contained validation. Default values. Callbacks that monitor changes to other properties. A system that can coerce property values based on runtime information. Derived classes can change some characteristics of an existing property by overriding the metadata of a dependency property, rather than overriding the actual implementation of existing properties or creating new properties. 3.2. Dependency properties back CLR properties Dependency properties and the WPF property system extend property functionality by providing a DependencyProperty type that backs a property, as an alternative to the standard pattern of backing a property with a private field. Here&#8217;s some commonly used terminology: Dependency property, which is a property that&#8217;s backed by a DependencyProperty. Dependency property identifier, which is a DependencyProperty instance obtained as a return value when registering a dependency property, and then stored as a static member of a class. Many of the APIs that interact with the WPF property system use the dependency property identifier as a parameter. CLR &quot;wrapper&quot;, which is the get and set implementations for the property. These implementations incorporate the dependency property identifier by using it in the GetValue and SetValue calls. In this way, the WPF property system provides the backing for the property. The following example defines the IsSpinning dependency property to show the relationship of the DependencyProperty identifier to the property that it backs. public static readonly DependencyProperty IsSpinningProperty = DependencyProperty.Register( &quot;IsSpinning&quot;, typeof(bool), typeof(MainWindow) ); public bool IsSpinning { get =&gt; (bool)GetValue(IsSpinningProperty); set =&gt; SetValue(IsSpinningProperty, value); } The naming convention of the property and its backing DependencyProperty field is important. The name of the field is always the name of the property, with the suffix Property appended. 3.3. Attached properties Although any object can set an attached property value, that doesn&#8217;t mean setting a value will produce a tangible result or the value will be used by another object. Attached property usage typically follows one of these models: The type that defines the attached property is the parent of the elements that set values for the attached property. The parent type iterates its child objects through internal logic that acts on the object tree structure, obtains the values, and acts on those values in some manner. The type that defines the attached property is used as the child element for various possible parent elements and content models. The type that defines the attached property represents a service. Other types set values for the attached property. Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class. Attached properties in WPF don&#8217;t have the typical CLR get and set wrapper methods because the properties might be set from outside of the CLR namespace. To permit a XAML processor to set those values when parsing XAML, the class that defines the attached property must implement dedicated accessor methods in the form of Get&lt;property name&gt; and Set&lt;property name&gt;. // Attached properties in code DockPanel myDockPanel = new(); TextBox myTextBox = new(); myTextBox.Text = &quot;Enter text&quot;; // Add child element to the DockPanel. myDockPanel.Children.Add(myTextBox); // Set the attached property value. DockPanel.SetDock(myTextBox, Dock.Top); public static Dock GetDock(UIElement element); public static void SetDock(UIElement element, Dock dock); &lt;!-- Attached properties in XAML --&gt; &lt;DockPanel&gt; &lt;TextBox DockPanel.Dock=&quot;Top&quot;&gt;Enter text&lt;/TextBox&gt; &lt;/DockPanel&gt; Define attached property as a dependency in the defining class by declaring a public static readonly field of type DependencyProperty. Then, assign the return value of the RegisterAttached method to the field, which is also known as the dependency property identifier. Follow the WPF property naming convention that distinguishes fields from the properties that they represent, by naming the identifier field &lt;property name&gt;Property. Also, provide static Get&lt;property name&gt; and Set&lt;property name&gt; accessor methods, which lets the property system access the attached property. public class Aquarium : UIElement { // Register an attached dependency property with the specified // property name, property type, owner type, and property metadata. public static readonly DependencyProperty HasFishProperty = DependencyProperty.RegisterAttached( &quot;HasFish&quot;, typeof(bool), typeof(Aquarium), new FrameworkPropertyMetadata(defaultValue: false, flags: FrameworkPropertyMetadataOptions.AffectsRender) ); // Declare a get accessor method. public static bool GetHasFish(UIElement target) =&gt; (bool)target.GetValue(HasFishProperty); // Declare a set accessor method. public static void SetHasFish(UIElement target, bool value) =&gt; target.SetValue(HasFishProperty, value); } The get accessor method signature is public static object Get&lt;property name&gt;(DependencyObject target), where: target is the DependencyObject from which the attached property is read. The target type can be more specific than DependencyObject. For example, the DockPanel.GetDock accessor method types the target as UIElement because the attached property is intended to be set on UIElement instances. The return type can be more specific than object. For example, the GetDock method types the returned value as Dock because the return value should be a Dock enumeration. The set accessor method signature is public static void Set&lt;property name&gt;(DependencyObject target, object value), where: target is the DependencyObject on which the attached property is written. The target type can be more specific than DependencyObject. For example, the SetDock method types the target as UIElement because the attached property is intended to be set on UIElement instances. The value type can be more specific than object. For example, the SetDock method requires a Dock value. 3.4. Property value inheritance Property value inheritance is a feature of the Windows Presentation Foundation (WPF) property system and applies to dependency properties. Property value inheritance lets child elements in a tree of elements obtain the value of a particular property from the nearest parent element. Since a parent element might also have obtained its property value through property value inheritance, the system potentially recurses back to the page root. The WPF property system doesn&#8217;t enable property value inheritance by default, and value inheritance is inactive unless specifically enabled in dependency property metadata. Even with property value inheritance enabled, a child element will only inherit a property value in the absence of a higher precedence value. 4. Routed events Windows Presentation Foundation (WPF) application developers and component authors can use routed events to propagate events through an element tree, and invoke event handlers on multiple listeners in the tree. From a functional perspective, a routed event is a type of event that can invoke handlers on multiple listeners in an element tree, not just on the event source. An event listener is the element where an event handler is attached and invoked. An event source is the element or object that originally raised an event. From an implementation perspective, a routed event is an event registered with the WPF event system, backed by an instance of the RoutedEvent class, and processed by the WPF event system. Typically, a routed event is implemented with a CLR event &quot;wrapper&quot; to enable attaching handlers in XAML and in code-behind as you would a CLR event. Depending on how a routed event is defined, when the event is raised on a source element it: Bubbles up through element tree from the source element to the root element, which is typically a page or window. Tunnels down through the element tree from the root element to the source element. Doesn&#8217;t travel through the element tree, and only occurs on the source element directly. 4.1. Routed event and event handler A routed event is an event registered with the WPF event system, backed by an instance of the RoutedEvent class, and processed by the WPF event system. The RoutedEvent instance, obtained from registration, is typically stored as a public static readonly member of the &quot;owner&quot; class, that registered it. Typically, a routed event implements an identically named CLR event &quot;wrapper&quot; that is similar to how a dependency property is a CLR property. The CLR event wrapper contains add and remove accessors to enable attaching handlers in XAML and in code-behind through language-specific event syntax. The add and remove accessors override their CLR implementation and call the routed event AddHandler and RemoveHandler methods. // Register a custom routed event using the Bubble routing strategy. public static readonly RoutedEvent TapEvent = EventManager.RegisterRoutedEvent( name: &quot;Tap&quot;, routingStrategy: RoutingStrategy.Bubble, handlerType: typeof(RoutedEventHandler), ownerType: typeof(CustomButton)); // Provide CLR accessors for adding and removing an event handler. public event RoutedEventHandler Tap { add { AddHandler(TapEvent, value); } remove { RemoveHandler(TapEvent, value); } } In XAML, attach an event handler to an element by declaring the event name as an attribute on the event listener element. The attribute value is the handler method name. The handler method must be implemented in the code-behind partial class for the XAML page. The event listener is the element where the event handler is attached and invoked. If the event isn&#8217;t a member of the listener&#8217;s class, use the qualified event name in the form of &lt;owner type&gt;.&lt;event name&gt;. &lt;StackPanel Button.Click=&quot;YesNoCancelButton_Click&quot;&gt; &lt;Button Name=&quot;YesButton&quot; Click=&quot;YesButtonClick&quot;&gt;Yes&lt;/Button&gt; &lt;Button Name=&quot;NoButton&quot; Click=&quot;NoButtonClick&quot;&gt;No&lt;/Button&gt; &lt;Button Name=&quot;CancelButton&quot; Click=&quot;CancelClick&quot;&gt;Cancel&lt;/Button&gt; &lt;/StackPanel&gt; The signature of the event handler method in code-behind must match the delegate type for the routed event. private void YesNoCancelButtonClick(object sender, RoutedEventArgs e) { } To attach an event handler for a routed event to an element using code: Directly call the AddHandler method. // Routed event handlers can always be attached this way. Button1.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(Button_Click)); StackPanel1.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(Button_Click)); If the routed event implements a CLR event wrapper, use language-specific event syntax to add event handlers. Button1.Click += Button_Click; 4.2. Attached events WPF attached events are implemented as routed events backed by a RoutedEvent field. public class AquariumFilter { // Register a custom routed event using the bubble routing strategy. public static readonly RoutedEvent CleanEvent = EventManager.RegisterRoutedEvent( &quot;Clean&quot;, RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(AquariumFilter)); // Provide an add handler accessor method for the Clean event. public static void AddCleanHandler(DependencyObject dependencyObject, RoutedEventHandler handler) { if (dependencyObject is not UIElement uiElement) { return; } uiElement.AddHandler(CleanEvent, handler); } // Provide a remove handler accessor method for the Clean event. public static void RemoveCleanHandler(DependencyObject dependencyObject, RoutedEventHandler handler) { if (dependencyObject is not UIElement uiElement) { return; } uiElement.RemoveHandler(CleanEvent, handler); } } An Add&lt;event name&gt;Handler method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to add. The method must be public and static, with no return value. The method calls the AddHandler base class method, passing in the routed event and handler as arguments. This method supports the XAML attribute syntax for attaching an event handler to an element. This method also enables code access to the event handler store for the attached event. A Remove&lt;event name&gt;Handler method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to remove. The method must be public and static, with no return value. The method calls the RemoveHandler base class method, passing in the routed event and handler as arguments. This method enables code access to the event handler store for the attached event. WPF implements attached events as routed events because the identifier for a RoutedEvent is defined by the WPF event system. The RegisterRoutedEvent method that returns the attached event identifier is the same method used to register non-attached routed events. Unlike the CLR event &quot;wrapper&quot; used to back non-attached routed events, the attached event accessor methods can be implemented in classes that don&#8217;t derive from UIElement or ContentElement. It is possible because the attached event backing code calls the UIElement.AddHandler and UIElement.RemoveHandler methods on a passed in UIElement instance. In contrast, the CLR wrapper for non-attached routed events calls those methods directly on the owning class, so that class must derive from UIElement. When defining a custom attached event using the WPF model of basing attached events on routed events, use the UIElement.RaiseEvent method to raise an attached event on any UIElement or ContentElement. When raising a routed event, whether it&#8217;s attached or not, an element is required to designate in the element tree as the event source. That source is then reported as the RaiseEvent caller. For example, to raise the AquariumFilter.Clean attached routed event on aquarium1: aquarium1.RaiseEvent(new RoutedEventArgs(AquariumFilter.CleanEvent)); In XAML syntax, an attached event is specified by its event name and its owner type, in the form of &lt;owner type&gt;.&lt;event name&gt;. Because the event name is qualified with the name of its owner type, the syntax allows the event to be attached to any element that can be instantiated. It is also applicable to handlers for regular routed events that attach to an arbitrary element along the event route. &lt;!-- attaches the AquariumFilter_Clean handler for the AquariumFilter.Clean attached event to the aquarium1 element --&gt; &lt;aqua:Aquarium x:Name=&quot;aquarium1&quot; Height=&quot;300&quot; Width=&quot;400&quot; aqua:AquariumFilter.Clean=&quot;AquariumFilter_Clean&quot;/&gt; Event handlers can also be attached for attached events in code behind, by calling the AddHandler method on the object that the handler should attach to and pass the event identifier and handler as parameters to the method. aquarium1.AddHandler(AquariumFilter.Clean, new RoutedEventHandler(AquariumFilter_Clean), true); 4.3. WPF input events By convention, WPF routed events that follow a tunneling route have a name that&#8217;s prefixed with &quot;Preview&quot;. Input events often come in pairs, with one being a preview event and the other a bubbling routed event. The Preview prefix signifies that the preview event completes before the paired bubbling event starts. A preview input event that&#8217;s marked as handled won&#8217;t invoke any normally registered event handlers for the remainder of the preview route, and the paired bubbling event won&#8217;t be raised. The order of event processing following a mouse-down action on leaf element #2 is: PreviewMouseDown tunneling event on the root element. PreviewMouseDown tunneling event on intermediate element #1. PreviewMouseDown tunneling event on leaf element #2, which is the source element. MouseDown bubbling event on leaf element #2, which is the source element. MouseDown bubbling event on intermediate element #1. MouseDown bubbling event on the root element. 4.4. Weak event patterns Listening for events can lead to memory leaks. The typical technique for listening to an event is to use the language-specific syntax that attaches a handler to an event on a source. For example, in C#, that syntax is: source.SomeEvent += new SomeEventHandler(MyEventHandler) that creates a strong reference from the event source to the event listener. Ordinarily, attaching an event handler for a listener causes the listener to have an object lifetime that is influenced by the object lifetime of the source (unless the event handler is explicitly removed). Whenever the source object lifetime extends beyond the object lifetime of the listener, the normal event pattern leads to a memory leak: the listener is kept alive longer than intended. The weak event pattern can be used whenever a listener needs to register for an event, but the listener does not explicitly know when to unregister, and can also be used whenever the object lifetime of the source exceeds the useful object lifetime of the listener. 5. Commands A command can be used to: separate the semantics and the object that invokes a command from the logic that executes the command. indicate whether an action is possible by implementing the CanExecute method. The routed command model in WPF can be broken up into four main concepts: The command is the action to be executed. The command source is the object which invokes the command. The command target is the object that the command is being executed on. The command binding is the object which maps the command logic to the command. A commands is created by implementing the ICommand interface. Execute method performs the actions that are associated with the command. CanExecute method determines whether the command can execute on the current command target. CanExecuteChanged event is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding. The RelayCommand and RelayCommand&lt;T&gt; are ICommand implementations that can expose a method or delegate to the view. These types act as a way to bind commands between the viewmodel and UI elements. They provide a base implementation of the ICommand interface. They also implement the IRelayCommand (and IRelayCommand&lt;T&gt;) interface, which exposes a NotifyCanExecuteChanged method to raise the CanExecuteChanged event. They expose constructors taking delegates like Action and Func&lt;T&gt;, which allow the wrapping of standard methods and lambda expressions. public class MyViewModel : ObservableObject { public MyViewModel() { IncrementCounterCommand = new RelayCommand(IncrementCounter); } private int counter; public int Counter { get =&gt; counter; private set =&gt; SetProperty(ref counter, value); } public ICommand IncrementCounterCommand { get; } private void IncrementCounter() =&gt; Counter++; } &lt;Page x:Class=&quot;MyApp.Views.MyPage&quot; xmlns:viewModels=&quot;using:MyApp.ViewModels&quot;&gt; &lt;Page.DataContext&gt; &lt;viewModels:MyViewModel x:Name=&quot;ViewModel&quot;/&gt; &lt;/Page.DataContext&gt; &lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock Text=&quot;{x:Bind ViewModel.Counter, Mode=OneWay}&quot;/&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;{x:Bind ViewModel.IncrementCounterCommand}&quot;/&gt; &lt;/StackPanel&gt; &lt;/Page&gt; A command source is the object that generally implements the ICommandSource interface, which invokes the command. Examples of command sources are MenuItem, Button, and KeyGesture. A command source like a Button can subscribe to the CanExecuteChanged event and be disabled if CanExecute returns false or be enabled if CanExecute returns true. Command is the command to execute when the command source is invoked. CommandTarget is the object on which to execute the command, which is only applicable when the ICommand is a RoutedCommand. If the CommandTarget is set on an ICommandSource and the corresponding command is not a RoutedCommand, the command target is ignored. If the CommandTarget is not set, the element with keyboard focus will be the command target. CommandParameter is a user-defined data type used to pass information to the handlers implementing the command. A CommandBinding associates a command with the event handlers that implement the command. The CommandBinding class contains a Command property, and PreviewExecuted, Executed, PreviewCanExecute, and CanExecute events. &lt;Window.CommandBindings&gt; &lt;CommandBinding Command=&quot;ApplicationCommands.Open&quot; Executed=&quot;OpenCmdExecuted&quot; CanExecute=&quot;OpenCmdCanExecute&quot;/&gt; &lt;/Window.CommandBindings&gt; // Creating CommandBinding and attaching an Executed and CanExecute handler CommandBinding OpenCmdBinding = new CommandBinding( ApplicationCommands.Open, OpenCmdExecuted, OpenCmdCanExecute); this.CommandBindings.Add(OpenCmdBinding); void OpenCmdExecuted(object target, ExecutedRoutedEventArgs e) { String command, targetobj; command = ((RoutedCommand)e.Command).Name; targetobj = ((FrameworkElement)target).Name; MessageBox.Show(&quot;The &quot; + command + &quot; command has been invoked on target object &quot; + targetobj); } void OpenCmdCanExecute(object sender, CanExecuteRoutedEventArgs e) { e.CanExecute = true; } A command target is the element on which the command is executed. With regards to a RoutedCommand, the command target is the element at which routing of the Executed and CanExecute starts. The command source can explicitly set the command target. If the command target is not defined, the element with keyboard focus will be used as the command target. &lt;StackPanel&gt; &lt;Menu&gt; &lt;MenuItem Command=&quot;ApplicationCommands.Paste&quot; CommandTarget=&quot;{Binding ElementName=mainTextBox}&quot; /&gt; &lt;/Menu&gt; &lt;TextBox Name=&quot;mainTextBox&quot;/&gt; &lt;/StackPanel&gt; // Creating the UI objects StackPanel mainStackPanel = new StackPanel(); TextBox pasteTextBox = new TextBox(); Menu stackPanelMenu = new Menu(); MenuItem pasteMenuItem = new MenuItem(); // Adding objects to the panel and the menu stackPanelMenu.Items.Add(pasteMenuItem); mainStackPanel.Children.Add(stackPanelMenu); mainStackPanel.Children.Add(pasteTextBox); // Setting the command to the Paste command pasteMenuItem.Command = ApplicationCommands.Paste; // Setting the command target to the TextBox pasteMenuItem.CommandTarget = pasteTextBox; The CommandManager serves a number of command related functions. It provides a set of static methods for adding and removing PreviewExecuted, Executed, PreviewCanExecute, and CanExecute event handlers to and from a specific element. It provides a means to register CommandBinding and InputBinding objects onto a specific class. The CommandManager also provides a means, through the RequerySuggested event, to notify a command when it should raise the CanExecuteChanged event. The InvalidateRequerySuggested method forces the CommandManager to raise the RequerySuggested event, which is useful for conditions that should disable/enable a command but are not conditions that the CommandManager is aware of. 6. Windows In WPF, a window is encapsulated by the Window class that used to do the following: Display a window. Configure the size, position, and appearance of a window. Host application-specific content. Manage the lifetime of a window. A window is divided into two areas: the non-client area and client area. The non-client area of a window is implemented by WPF and includes the parts of a window that are common to most windows, including the following: A title bar (1-5). An icon (1). Title (2). Minimize (3), Maximize (4), and Close (5) buttons. System menu (6) with menu items. Appears when clicking on the icon (1). Border (7). The client area of a window is the area within a window&#8217;s non-client area and is used by developers to add application-specific content, such as menu bars, tool bars, and controls. Client area (8). Resize grip (9). This is a control added to the Client area (8). For a window that is defined using both XAML markup and code-behind: XAML markup files are configured as MSBuild Page items. Code-behind files are configured as MSBuild Compile items. .NET SDK projects automatically import the correct Page and Compile items. When the project is configured for WPF, the XAML markup files are automatically imported as Page items, and the corresponding code-behind file is imported as Compile. 6.1. Lifetime A window that is opened by using the Show method doesn&#8217;t have an implicit relationship with the window that created it. Users can interact with either window independently of the other, which means that either window can do the following: Cover the other (unless one of the windows has its Topmost property set to true). Be minimized, maximized, and restored without affecting the other. After ownership by setting the Owner property of the owned window with a reference to the owner window is established: The owned window can reference its owner window by inspecting the value of its Owner property. The owner window can discover all the windows it owns by inspecting the value of its OwnedWindows property. A window opened by calling Show is a modeless window, and the application doesn&#8217;t prevent users from interacting with other windows in the application. Opening a window with ShowDialog opens a window as modal and restricts user interaction to the specific window. The life of a window starts coming to an end when a user closes it. Once a window is closed, it can&#8217;t be reopened. A window can be closed by using elements in the non-client area, including the following: The Close item of the System menu. Pressing ALT + F4. public MainWindow() { InitializeComponent(); KeyDown += (s, e) =&gt; { // inhibit the ALT + F4 e.Handled = e.SystemKey == Key.F4 &amp;&amp; Keyboard.Modifiers == ModifierKeys.Alt; }; } Pressing the Close button. Pressing ESC when a button has the IsCancel property set to true on a modal window. The following illustration shows the sequence of the principal events in the lifetime of a window: The following illustration shows the sequence of the principal events in the lifetime of a window that is shown without activation (ShowActivated is set to false before the window is shown): 6.2. Appearance To configure the non-client area, Window provides several properties, which include Icon to set a window&#8217;s icon and Title to set its title. The appearance and behavior of non-client area border can also be changed by configuring a window&#8217;s resize mode, window style, and whether it appears as a button in the desktop task bar. &lt;!-- Non-rectangular window style --&gt; &lt;Window x:Class=&quot;WindowsOverview.ClippedWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;ClippedWindow&quot; SizeToContent=&quot;WidthAndHeight&quot; WindowStyle=&quot;None&quot; AllowsTransparency=&quot;True&quot; Background=&quot;Transparent&quot;&gt; &lt;Grid Margin=&quot;20&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;20&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Rectangle Stroke=&quot;#FF000000&quot; RadiusX=&quot;10&quot; RadiusY=&quot;10&quot;/&gt; &lt;Path Fill=&quot;White&quot; Stretch=&quot;Fill&quot; Stroke=&quot;#FF000000&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;15,-5.597,0,-0.003&quot; Width=&quot;30&quot; Grid.Row=&quot;1&quot; Data=&quot;M22.166642,154.45381 L29.999666,187.66699 40.791059,154.54395&quot;/&gt; &lt;Rectangle Fill=&quot;White&quot; RadiusX=&quot;10&quot; RadiusY=&quot;10&quot; Margin=&quot;1&quot;/&gt; &lt;TextBlock HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;25&quot; Text=&quot;Greetings!&quot; TextWrapping=&quot;Wrap&quot; Margin=&quot;5,5,50,5&quot;/&gt; &lt;Button HorizontalAlignment=&quot;Right&quot; VerticalAlignment=&quot;Top&quot; Background=&quot;Transparent&quot; BorderBrush=&quot;{x:Null}&quot; Foreground=&quot;Red&quot; Content=&quot;❌&quot; FontSize=&quot;15&quot; /&gt; &lt;Grid.Effect&gt; &lt;DropShadowEffect BlurRadius=&quot;10&quot; ShadowDepth=&quot;3&quot; Color=&quot;LightBlue&quot;/&gt; &lt;/Grid.Effect&gt; &lt;/Grid&gt; &lt;/Window&gt; // Hide the Minimize, Maximize, and Close buttons public MainWindow() { InitializeComponent(); SourceInitialized += (s, e) =&gt; { const int WM_SYSTEM_MENU = 0x80000; const int WM_GW_STYLE = -16; var hWnd = new System.Windows.Interop.WindowInteropHelper(this).Handle; if (hWnd == IntPtr.Zero) { throw new InvalidOperationException(&quot;The window has not yet been completely initialized&quot;); } // Hide the Minimize, Maximize, and Close buttons SetWindow(hWnd, WM_GW_STYLE, GetWindow(hWnd, WM_GW_STYLE) &amp; ~WM_SYSTEM_MENU); }; } [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetWindowLong&quot;)] private static extern int GetWindow(IntPtr hWnd, int nIndex); [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SetWindowLong&quot;, SetLastError = true)] private static extern int SetWindow(IntPtr hWnd, int nIndex, int dwNew); 6.3. Dialog boxes When designing a dialog box, follow these suggestions to create a good user experience: ❌ DON&#8217;T clutter the dialog window. The dialog experience is for the user to enter some data, or to make a choice. ✔️ DO provide an OK button to close the window. ✔️ DO set the OK button&#8217;s IsDefault property to true to allow the user to press the ENTER key to accept and close the window. ✔️ CONSIDER adding a Cancel button so that the user can close the window and indicate that they don&#8217;t want to continue. ✔️ DO set the Cancel button&#8217;s IsCancel property to true to allow the user to press the ESC key to close the window. ✔️ DO set the title of the window to accurately describe what the dialog represents, or what the user should do with the dialog. ✔️ DO set minimum width and height values for the window, preventing the user from resizing the window too small. ✔️ CONSIDER disabling the ability to resize the window if ShowInTaskbar is set to false. ✔️ DO When a menu item or button runs a function that requires user interaction through a dialog box before the function can continue, the control should use an ellipsis at the end of its header text: &lt;MenuItem Header=&quot;_Open...&quot; Click=&quot;openMenuItem_Click&quot; /&gt; &lt;!-- or --&gt; &lt;Button Content=&quot;_Save As...&quot; Click=&quot;saveAsButton_Click&quot; /&gt; ✔️ DO When a menu item or button runs a function that displays a dialog box that does NOT require user interaction, such as an About dialog box, an ellipsis isn&#8217;t required. 6.4. Multiple windows, multiple threads Typically, WPF applications start with two threads: one for handling rendering and another for managing the UI. The rendering thread effectively runs hidden in the background while the UI thread receives input, handles events, paints the screen, and runs application code. Most applications use a single UI thread, although in some situations it is best to use several. The UI thread queues work items inside an object called a Dispatcher that selects work items on a priority basis and runs each one to completion. Every UI thread must have at least one Dispatcher, and each Dispatcher can execute work items in exactly one thread. The trick to building responsive, user-friendly applications is to maximize the Dispatcher throughput by keeping the work items small. Most classes derive from DispatcherObject that stores a reference to the Dispatcher linked to the currently running thread that creates it at construction. A DispatcherObject can call its public VerifyAccess method that examines the Dispatcher associated with the current thread and compares it to the Dispatcher reference stored during construction, and if they don&#8217;t match, VerifyAccess throws an exception. VerifyAccess is intended to be called at the beginning of every method belonging to a DispatcherObject. A background thread can ask the UI thread to perform an operation on its behalf by registering a work item with the Dispatcher of the UI thread. The Dispatcher class provides the methods for registering work items: InvokeAsync, BeginInvoke, and Invoke. Invoke is a synchronous call – that is, it doesn&#8217;t return until the UI thread actually finishes executing the delegate. InvokeAsync and BeginInvoke are asynchronous and return immediately. The Dispatcher orders the elements in its queue by priority that maintained in the DispatcherPriority enumeration. WPF application may require multiple top-level windows to do a better job, which is especially true if there&#8217;s any chance that one of the windows will monopolize the thread. private void NewThreadWindow_Click(object sender, RoutedEventArgs e) { Thread newWindowThread = new Thread(ThreadStartingPoint); newWindowThread.SetApartmentState(ApartmentState.STA); newWindowThread.IsBackground = true; newWindowThread.Start(); } private void ThreadStartingPoint() { new MultiWindow().Show(); System.Windows.Threading.Dispatcher.Run(); } Windows Explorer works in multiple top-level windows within multiple threads fashion. Each new Explorer window belongs to the original process, but it&#8217;s created under the control of an independent thread. When Explorer becomes nonresponsive, such as when looking for network resources, other Explorer windows continue to be responsive and usable. 7. Styles, templates, and triggers 7.1. Styles A Style, commonly declared as a resource, can apply a set of property values to one or more elements. When setting the TargetType of a style and omit the x:Key attribute, the style is applied to all the TargetType elements scoped to the style, which is generally the XAML file itself. &lt;Window.Resources&gt; &lt;!--A Style that affects all TextBlocks--&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; If adding an x:Key attribute with value to the style, the style is no longer implicitly applied to all elements of TargetType. Only elements that explicitly reference the style will have the style applied to them. &lt;Window.Resources&gt; &lt;Style x:Key=&quot;TitleText&quot; TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;StackPanel&gt; &lt;TextBlock Style=&quot;{StaticResource TitleText}&quot;&gt;My Pictures&lt;/TextBlock&gt; &lt;TextBlock&gt;Check out my new pictures!&lt;/TextBlock&gt; &lt;/StackPanel&gt; To assign a named style to an element programmatically, get the style from the resources collection and assign it to the element&#8217;s Style property. textblock1.Style = (Style)Resources[&quot;TitleText&quot;]; A style can extend another style with the BaseOn property. &lt;Window.Resources&gt; &lt;!-- .... other resources .... --&gt; &lt;!--A Style that affects all TextBlocks--&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;!-- x:Key is implicitly set to {x:Type TextBlock} --&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;!--A Style that extends the previous TextBlock Style with an x:Key of TitleText--&gt; &lt;Style BasedOn=&quot;{StaticResource {x:Type TextBlock}}&quot; TargetType=&quot;TextBlock&quot; x:Key=&quot;TitleText&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;26&quot;/&gt; &lt;Setter Property=&quot;Foreground&quot;&gt; &lt;Setter.Value&gt; &lt;LinearGradientBrush StartPoint=&quot;0.5,0&quot; EndPoint=&quot;0.5,1&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Offset=&quot;0.0&quot; Color=&quot;#90DDDD&quot; /&gt; &lt;GradientStop Offset=&quot;1.0&quot; Color=&quot;#5BFFFF&quot; /&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; The x:Key of a style is implicitly set to {x:Type TargetType}. It means that if explicitly setting the x:Key value to anything other than {x:Type TargetType}, the Style isn&#8217;t applied to all TargetType elements automatically. If TargetType isn&#8217;t specified, the properties must be qualified in the Setter objects with a class name by using the syntax Property=&quot;ClassName.Property&quot;. Also note that many WPF controls consist of a combination of other WPF controls. If creating a style that applies to all controls of a type, unexpected results might happen. For example, if creating a style that targets the TextBlock type in a Window, the style is applied to all TextBlock controls in the window, even if the TextBlock is part of another control, such as a ListBox. 7.2. Control templates In WPF, the ControlTemplate of a control, Commonly declared as a resource, defines the appearance of the control. Each control has a default template assigned to the Control.Template property. A control template rewrites the visual appearance of the entire control, while a style simply applies property changes to the existing control. However, since the template of a control is applied by setting the Control.Template property, a template can be defined or set using a style. A TemplateBinding is an optimized form of a binding for template scenarios, analogous to a binding constructed with {Binding RelativeSource={RelativeSource TemplatedParent}}, such as for binding parts of the template to properties of the control. If a ContentPresenter is declared in the ControlTemplate of a ContentControl, the ContentPresenter will automatically bind to the ContentTemplate and Content properties. Likewise, an ItemsPresenter that is in the ControlTemplate of an ItemsControl will automatically bind to the ItemTemplate and Items properties. &lt;UserControl&gt; &lt;UserControl.Resources&gt; &lt;!-- Defined a ControlTemplate as a resource --&gt; &lt;ControlTemplate x:Key=&quot;roundbutton&quot; TargetType=&quot;Button&quot;&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;{TemplateBinding Background}&quot; Stroke=&quot;{TemplateBinding Foreground}&quot; /&gt; &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/UserControl.Resources&gt; &lt;StackPanel&gt; &lt;!-- Set the button&#39;s Template property to the roundbutton resource --&gt; &lt;Button Template=&quot;{StaticResource roundbutton}&quot;&gt;Hello&lt;/Button&gt; &lt;!-- Defined the ControlTemplate inline --&gt; &lt;Button Background=&quot;Red&quot; Foreground=&quot;White&quot;&gt; &lt;Button.Content&gt;World&lt;/Button.Content&gt; &lt;Button.Template&gt; &lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;{TemplateBinding Background}&quot; Stroke=&quot;{TemplateBinding Foreground}&quot; /&gt; &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; &lt;/StackPanel&gt; &lt;/UserControl&gt; 7.3. Data templates In WPF, the DataTemplate is used to custom the presentation and appearance of the data objects. In most cases, all other aspects of presentation, such as what an item looks like when it is selected or how a ListBox lays out the items, do not belong in the definition of a DataTemplate. &lt;!-- Defined the DataTemplate inline --&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot;&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt; &lt;!-- Defined a DataTemplate as a resource --&gt; &lt;UserControl.Resources&gt; &lt;DataTemplate x:Key=&quot;myTaskTemplate&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot; /&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/UserControl.Resources&gt; &lt;StackPanel&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemTemplate=&quot;{StaticResource myTaskTemplate}&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot; /&gt; &lt;/StackPanel&gt; The DataTemplate class has a DataType property that is very similar to the TargetType property of the Style class. &lt;DataTemplate DataType=&quot;{x:Type local:Task}&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; To supply logic to choose which DataTemplate to use based on the Priority value of the data object, create a subclass of DataTemplateSelector and override the SelectTemplate method. namespace SDKSample { public class TaskListDataTemplateSelector : DataTemplateSelector { public override DataTemplate SelectTemplate(object item, DependencyObject container) { FrameworkElement element = container as FrameworkElement; if (element != null &amp;&amp; item != null &amp;&amp; item is Task) { Task taskitem = item as Task; if (taskitem.Priority == 1) return element.FindResource(&quot;importantTaskTemplate&quot;) as DataTemplate; else return element.FindResource(&quot;myTaskTemplate&quot;) as DataTemplate; } return null; } } } &lt;Window.Resources&gt; &lt;local:TaskListDataTemplateSelector x:Key=&quot;myDataTemplateSelector&quot; /&gt; &lt;/Window.Resources&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot; ItemTemplateSelector=&quot;{StaticResource myDataTemplateSelector}&quot; HorizontalContentAlignment=&quot;Stretch&quot;/&gt; Styling and Templating an ItemsControl &lt;ItemsControl Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot;&gt; &lt;!--The ItemsControl has no default visual appearance. Use the Template property to specify a ControlTemplate to define the appearance of an ItemsControl. The ItemsPresenter uses the specified ItemsPanelTemplate (see below) to layout the items. If an ItemsPanelTemplate is not specified, the default is used. (For ItemsControl, the default is an ItemsPanelTemplate that specifies a StackPanel.--&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;Border BorderBrush=&quot;Aqua&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;15&quot;&gt; &lt;ItemsPresenter/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;!--Use the ItemsPanel property to specify an ItemsPanelTemplate that defines the panel that is used to hold the generated items. In other words, use this property if you want to affect how the items are laid out.--&gt; &lt;ItemsControl.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;WrapPanel /&gt; &lt;/ItemsPanelTemplate&gt; &lt;/ItemsControl.ItemsPanel&gt; &lt;!--Use the ItemTemplate to set a DataTemplate to define the visualization of the data objects. This DataTemplate specifies that each data object appears with the Proriity and TaskName on top of a silver ellipse.--&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;DataTemplate.Resources&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;18&quot;/&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;/Style&gt; &lt;/DataTemplate.Resources&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;Silver&quot;/&gt; &lt;StackPanel&gt; &lt;TextBlock Margin=&quot;3,3,3,0&quot; Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;TextBlock Margin=&quot;3,0,3,7&quot; Text=&quot;{Binding Path=TaskName}&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;!--Use the ItemContainerStyle property to specify the appearance of the element that contains the data. This ItemContainerStyle gives each item container a margin and a width. There is also a trigger that sets a tooltip that shows the description of the data object when the mouse hovers over the item container.--&gt; &lt;ItemsControl.ItemContainerStyle&gt; &lt;Style&gt; &lt;Setter Property=&quot;Control.Width&quot; Value=&quot;100&quot;/&gt; &lt;Setter Property=&quot;Control.Margin&quot; Value=&quot;5&quot;/&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;Control.IsMouseOver&quot; Value=&quot;True&quot;&gt; &lt;Setter Property=&quot;Control.ToolTip&quot; Value=&quot;{Binding RelativeSource={x:Static RelativeSource.Self}, Path=Content.Description}&quot;/&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/ItemsControl.ItemContainerStyle&gt; &lt;/ItemsControl&gt; The HierarchicalDataTemplate class is designed to be used with HeaderedItemsControl types to display collection data that contains other collections such as a Menu or a TreeView. &lt;Window x:Class=&quot;SDKSample.Window1&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:src=&quot;clr-namespace:SDKSample&quot; Title=&quot;HierarchicalDataTemplate Sample&quot;&gt; &lt;DockPanel&gt; &lt;DockPanel.Resources&gt; &lt;src:ListLeagueList x:Key=&quot;MyList&quot; /&gt; &lt;HierarchicalDataTemplate DataType=&quot;{x:Type src:League}&quot; ItemsSource=&quot;{Binding Path=Divisions}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/HierarchicalDataTemplate&gt; &lt;HierarchicalDataTemplate DataType=&quot;{x:Type src:Division}&quot; ItemsSource=&quot;{Binding Path=Teams}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/HierarchicalDataTemplate&gt; &lt;DataTemplate DataType=&quot;{x:Type src:Team}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/DataTemplate&gt; &lt;/DockPanel.Resources&gt; &lt;Menu Name=&quot;menu1&quot; Margin=&quot;10,10,10,10&quot; DockPanel.Dock=&quot;Top&quot;&gt; &lt;MenuItem Header=&quot;My Soccer Leagues&quot; ItemsSource=&quot;{Binding Source={StaticResource MyList}}&quot; /&gt; &lt;/Menu&gt; &lt;TreeView&gt; &lt;TreeViewItem Header=&quot;My Soccer Leagues&quot; ItemsSource=&quot;{Binding Source={StaticResource MyList}}&quot; /&gt; &lt;/TreeView&gt; &lt;/DockPanel&gt; &lt;/Window&gt; 7.4. Triggers A trigger sets properties or starts actions, such as an animation, when a property value changes or when an event is raised. Style, ControlTemplate, and DataTemplate all have a Triggers property that can contain a set of triggers. A Trigger that sets property values or starts actions based on the value of a property is called a property trigger. &lt;Window.Resources&gt; &lt;!-- .... other resources .... --&gt; &lt;Style TargetType=&quot;ListBoxItem&quot;&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;0.5&quot; /&gt; &lt;Setter Property=&quot;MaxHeight&quot; Value=&quot;75&quot; /&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsSelected&quot; Value=&quot;True&quot;&gt; &lt;Trigger.Setters&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;1.0&quot; /&gt; &lt;/Trigger.Setters&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; The properties changed by triggers are automatically reset to their previous value when the triggered condition is no longer satisfied. Another type of trigger is the EventTrigger, which starts a set of actions based on the occurrence of an event. &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsSelected&quot; Value=&quot;True&quot;&gt; &lt;Trigger.Setters&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;1.0&quot; /&gt; &lt;/Trigger.Setters&gt; &lt;/Trigger&gt; &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseEnter&quot;&gt; &lt;EventTrigger.Actions&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Duration=&quot;0:0:0.2&quot; Storyboard.TargetProperty=&quot;MaxHeight&quot; To=&quot;90&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger.Actions&gt; &lt;/EventTrigger&gt; &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseLeave&quot;&gt; &lt;EventTrigger.Actions&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Duration=&quot;0:0:1&quot; Storyboard.TargetProperty=&quot;MaxHeight&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger.Actions&gt; &lt;/EventTrigger&gt; &lt;/Style.Triggers&gt; MultiTriggers applly property values or performs actions when a set of conditions are satisfied. &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsEnabled&quot; Value=&quot;false&quot;&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;#EEEEEE&quot; /&gt; &lt;/Trigger&gt; &lt;MultiTrigger&gt; &lt;MultiTrigger.Conditions&gt; &lt;Condition Property=&quot;HasItems&quot; Value=&quot;false&quot; /&gt; &lt;Condition Property=&quot;Width&quot; Value=&quot;Auto&quot; /&gt; &lt;/MultiTrigger.Conditions&gt; &lt;Setter Property=&quot;MinWidth&quot; Value=&quot;120&quot;/&gt; &lt;/MultiTrigger&gt; &lt;MultiTrigger&gt; &lt;MultiTrigger.Conditions&gt; &lt;Condition Property=&quot;HasItems&quot; Value=&quot;false&quot; /&gt; &lt;Condition Property=&quot;Height&quot; Value=&quot;Auto&quot; /&gt; &lt;/MultiTrigger.Conditions&gt; &lt;Setter Property=&quot;MinHeight&quot; Value=&quot;95&quot;/&gt; &lt;/MultiTrigger&gt; &lt;/Style.Triggers&gt; Event setters invoke the specified event handlers in response to routed events, which apply to all elements that reference the Style rather than requiring to attach instance handlers to each individual element. Only Style.Setters support EventSetter objects. Handlers attached through event setters are invoked after any class handlers for an event, and also after any instance handlers. As a result, if a class handler or instance handler marks an event handled in its arguments, then the handler declared by an event setter is not invoked, unless the event setter specifically sets HandledEventsToo true. &lt;StackPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; x:Class=&quot;SDKSample.EventOvw2&quot; Name=&quot;dpanel2&quot; Initialized=&quot;PrimeHandledToo&quot;&gt; &lt;StackPanel.Resources&gt; &lt;Style TargetType=&quot;{x:Type Button}&quot;&gt; &lt;EventSetter Event=&quot;Click&quot; Handler=&quot;b1SetColor&quot;/&gt; &lt;/Style&gt; &lt;/StackPanel.Resources&gt; &lt;Button&gt;Click me&lt;/Button&gt; &lt;Button Name=&quot;ThisButton&quot; Click=&quot;HandleThis&quot;&gt; Raise event, handle it, use handled=true handler to get it anyway. &lt;/Button&gt; &lt;/StackPanel&gt; void b1SetColor(object sender, RoutedEventArgs e) { Button b = e.Source as Button; b.Background = new SolidColorBrush(Colors.Azure); } void HandleThis(object sender, RoutedEventArgs e) { e.Handled=true; } References [1] https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm [2] https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/ [3] https://learn.microsoft.com/en-us/dotnet/desktop/wpf" />
<link rel="canonical" href="https://blog.codefarm.me/2024/09/18/wpf-dotnet-learning-notes/" />
<meta property="og:url" content="https://blog.codefarm.me/2024/09/18/wpf-dotnet-learning-notes/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-18T09:10:49+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="WPF (.NET) Learning Notes" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-18T09:10:49+08:00","datePublished":"2024-09-18T09:10:49+08:00","description":"1. MVVM pattern and toolkit 1.1. MVVM pattern 1.1.1. View 1.1.2. ViewModel 1.1.3. Model 1.1.4. Connecting view models to views 1.1.4.1. Creating a view model declaratively 1.1.4.2. Creating a view model programmatically 1.1.5. Updating views in response to changes in the underlying view model or model 1.2. MVVM Toolkit 2. Data binding 2.1. Data context 2.2. Data flow 2.3. Data conversion 2.4. Data validation 2.5. Binding path 2.6. Binding source 2.7. Binding in XAML 2.8. Binding in code 3. Property system 3.1. Dependency properties and CLR properties 3.2. Dependency properties back CLR properties 3.3. Attached properties 3.4. Property value inheritance 4. Routed events 4.1. Routed event and event handler 4.2. Attached events 4.3. WPF input events 4.4. Weak event patterns 5. Commands 6. Windows 6.1. Lifetime 6.2. Appearance 6.3. Dialog boxes 6.4. Multiple windows, multiple threads 7. Styles, templates, and triggers 7.1. Styles 7.2. Control templates 7.3. Data templates 7.4. Triggers References 1. MVVM pattern and toolkit The MVVM pattern [1] helps cleanly separate an application&#8217;s business and presentation logic from its user interface (UI). Maintaining a clean separation between application logic and the UI helps address numerous development issues and makes an application easier to test, maintain, and evolve. It can also significantly improve code re-use opportunities and allows developers and UI designers to collaborate more easily when developing their respective parts of an app. 1.1. MVVM pattern There are three core components in the MVVM pattern: the model, the view, and the view model. Using the MVVM pattern, the UI of the app and the underlying presentation and business logic are separated into three separate classes: the view, which encapsulates the UI and UI logic; the view model, which encapsulates presentation logic and state; and the model, which encapsulates the app&#8217;s business logic and data. 1.1.1. View The view is responsible for defining the structure, layout, and appearance of what the user sees on screen. Ideally, each view is defined in XAML, with a limited code-behind that does not contain business logic. However, in some cases, the code-behind might contain UI logic that implements visual behavior that is difficult to express in XAML, such as animations. Enable and disable UI elements by binding to view model properties, rather than enabling and disabling them in code-behind. Ensure that the view models are responsible for defining logical state changes that affect some aspects of the view&#8217;s display, such as whether a command is available, or an indication that an operation is pending. There are several options for executing code on the view model in response to interactions on the view, such as a button click or item selection. If a control supports commands, the control&#8217;s Command property can be data-bound to an ICommand property on the view model. When the control&#8217;s command is invoked, the code in the view model will be executed. In addition to commands, behaviors can be attached to an object in the view and can listen for either a command to be invoked or the event to be raised. In response, the behavior can then invoke an ICommand on the view model or a method on the view model. 1.1.2. ViewModel The view model implements properties and commands to which the view can data bind to, and notifies the view of any state changes through change notification events. The properties and commands that the view model provides define the functionality to be offered by the UI, but the view determines how that functionality is to be displayed. Multi-platform apps should keep the UI thread unblocked to improve the user&#8217;s perception of performance. Therefore, in the view model, use asynchronous methods for I/O operations and raise events to asynchronously notify views of property changes. The view model is also responsible for coordinating the view&#8217;s interactions with one or many model classes that are required. The view model might choose to expose model classes directly to the view so that controls in the view can data bind directly to them. In this case, the model classes will need to be designed to support data binding and change notification events. Each view model provides data from a model in a form that the view can easily consume. Placing the data conversion in the view model is a good idea because it provides properties that the view can bind to. For example, the view model might combine the values of two properties to make it easier to display by the view. It&#8217;s also possible to use converters as a separate data conversion layer that sits between the view model and the view. This can be necessary, for example, when data requires special formatting that the view model doesn&#8217;t provide. In order for the view model to participate in two-way data binding with the view, its properties must raise the PropertyChanged event. View models satisfy this requirement by implementing the INotifyPropertyChanged interface, and raising the PropertyChanged event when a property is changed. For collections, the view-friendly ObservableCollection&lt;T&gt; is provided. This collection implements collection changed notification, relieving the developer from having to implement the INotifyCollectionChanged interface on collections. 1.1.3. Model Model classes are non-visual classes that encapsulate the app&#8217;s data. Model classes can be thought of as representing the app&#8217;s domain model that includes a data model along with business and validation logic. Examples of model objects include data transfer objects (DTOs), Plain Old CLR Objects (POCOs), and generated entity and proxy objects. Model classes are typically used in conjunction with services or repositories that encapsulate data access and caching. 1.1.4. Connecting view models to views View models can be connected to views by using the data-binding capabilities. 1.1.4.1. Creating a view model declaratively The simplest approach is for the view to declaratively instantiate its corresponding view model in XAML. When the view is constructed, the corresponding view model object will also be constructed. &lt;Grid.DataContext&gt; &lt;vm:MainViewModel /&gt; &lt;/Grid.DataContext&gt; Though the declarative construction and assignment of the view model by the view has the advantage that it&#8217;s simple, but has the disadvantage that it requires a default (parameter-less) constructor in the view model. 1.1.4.2. Creating a view model programmatically A view can have code in the code-behind file, resulting in the view-model being assigned to its DataContext property. public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); DataContext = new MainViewModel(); } } The programmatic construction and assignment of the view model within the view&#8217;s code-behind has the advantage that it&#8217;s simple. However, the main disadvantage of this approach is that the view needs to provide the view model with any required dependencies. Using a dependency injection container can help to maintain loose coupling between the view and view model. 1.1.5. Updating views in response to changes in the underlying view model or model All view model and model classes that are accessible to a view should implement the INotifyPropertyChanged interface. Implementing this interface in a view model or model class allows the class to provide change notifications to any data-bound controls in the view when the underlying property value changes. Always raising a PropertyChanged event if a public property&#8217;s value changes. Always raising a PropertyChanged event for any calculated properties whose values are used by other properties in the view model or model. Always raising the PropertyChanged event at the end of the method that makes a property change, or when the object is known to be in a safe state. Never raising a PropertyChanged event if the property does not change. Never raising the PropertyChanged event during a view model&#8217;s constructor if you are initializing a property. Never raising more than one PropertyChanged event with the same property name argument within a single synchronous invocation of a public method of a class. public sealed class MainViewModel : INotifyPropertyChanged { private string? _title; public string? Title { get { return _title; } set { if (_title != value) { _title = value; OnPropertyChanged(); } } } public event PropertyChangedEventHandler? PropertyChanged; private void OnPropertyChanged([CallerMemberName] string? propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } 1.2. MVVM Toolkit The CommunityToolkit.Mvvm package (aka MVVM Toolkit, formerly named Microsoft.Toolkit.Mvvm) is a modern, fast, and modular MVVM library. [2] dotnet add package CommunityToolkit.Mvvm # --version 8.3.1 CommunityToolkit.Mvvm.ComponentModel ObservableObject public abstract class ObservableObject : INotifyPropertyChanged, INotifyPropertyChanging public sealed class MainViewModel : ObservableObject { private string? _title; public string? Title { get =&gt; _title; set =&gt; SetProperty(ref _title, value); } private TaskNotifier? myTask; public Task? MyTask { get =&gt; myTask; set =&gt; SetPropertyAndNotifyOnCompletion(ref myTask, value); } } &lt;StackPanel&gt; &lt;Label Content=&quot;{Binding MyTask.Status}&quot; /&gt; &lt;TextBox Text=&quot;{Binding Title}&quot; /&gt; &lt;/StackPanel&gt; ObservableRecipient public abstract class ObservableRecipient : ObservableObject public sealed class MainViewModel : ObservableRecipient, IRecipient&lt;RequestMessage&lt;int&gt;&gt; { public void Receive(RequestMessage&lt;int&gt; message) =&gt; throw new NotImplementedException(); } public sealed class MainViewModel : ObservableRecipient { // For best results and to avoid memory leaks, it&#39;s recommended to use OnActivated to register // to messages, and to use OnDeactivated to do cleanup operations. protected override void OnActivated() =&gt; Messenger.Register&lt;MainViewModel, RequestMessage&lt;int&gt;&gt;(this, (r, m) =&gt; r.Receive(m)); // By default, OnDeactivated automatically unregisters the current instance from all registered messages. protected override void OnDeactivated() =&gt; base.OnDeactivated(); public void Receive(RequestMessage&lt;int&gt; message) =&gt; throw new NotImplementedException(); } ObservableValidator public abstract class ObservableValidator : ObservableObject, INotifyDataErrorInfo public class RegistrationForm : ObservableValidator { private string name; [Required] [MinLength(2)] [MaxLength(100)] public string Name { get =&gt; name; // Here we are calling the SetProperty&lt;T&gt;(ref T, T, bool, string) method exposed // by ObservableValidator, and that additional bool parameter set to true indicates // that we also want to validate the property when its value is updated. set =&gt; SetProperty(ref name, value, true); } } &lt;TextBox Text=&quot;{Binding Name, ValidatesOnDataErrors=True}&quot; /&gt; ObservableProperty [ObservableProperty] [NotifyPropertyChangedFor(nameof(FullName))] // Notifying dependent properties [NotifyCanExecuteChangedFor(nameof(MyCommand))] // Notifying dependent commands [NotifyDataErrorInfo] // Requesting property validation [Required] [MinLength(2)] // Any other validation attributes too... [NotifyPropertyChangedRecipients] // Sending notification messages [PropertyChangedMessage&lt;T&gt;] [property: JsonPropertyName(&quot;name&quot;)] // Adding custom attributes private string? _name; INotifyPropertyChanged // only use in cases where the target types cannot just inherit from the equivalent // types (eg. from ObservableObject). [INotifyPropertyChanged] public partial class MyViewModel : SomeOtherType CommunityToolkit.Mvvm.DependencyInjection Ioc dotnet add package Microsoft.Extensions.DependencyInjection # --version 8.0.0 public partial class App : Application { public IServiceProvider Services { get; set; } public App() { Services = ConfigureServices(); } protected override void OnStartup(StartupEventArgs e) { var mainWindow = Services.GetRequiredService&lt;MainWindow&gt;(); mainWindow.Show(); } private ServiceProvider ConfigureServices() { var services = new ServiceCollection(); services.AddTransient&lt;MainWindow&gt;(); services.AddTransient&lt;MainViewModel&gt;(); return services.BuildServiceProvider(); } } CommunityToolkit.Mvvm.Input RelayCommand RelayCommand&lt;T&gt; AsyncRelayCommand AsyncRelayCommand&lt;T&gt; IRelayCommand IRelayCommand&lt;T&gt; IAsyncRelayCommand IAsyncRelayCommand&lt;T&gt; public sealed class MainViewModel : ObservableObject { public IRelayCommand OKCommand { get; } = new RelayCommand(() =&gt; { }, () =&gt; true); public IAsyncRelayCommand CancelCommand { get; } = new AsyncRelayCommand(() =&gt; Task.CompletedTask); } RelayCommand [RelayCommand(CanExecute = nameof(CanGreetUser))] private void GreetUser(User? user) { Console.WriteLine($&quot;Hello {user!.Name}!&quot;); } private bool CanGreetUser(User? user) { return user is not null; } [ObservableProperty] [NotifyCanExecuteChangedFor(nameof(GreetUserCommand))] private User? selectedUser; // Call IAsyncRelayCommand.Cancel to signal that token. [RelayCommand(IncludeCancelCommand = true)] private async Task DoWorkAsync(CancellationToken token) { // Do some long running work... } CommunityToolkit.Mvvm.Messaging IMessenger WeakReferenceMessenger StrongReferenceMessenger IRecipient&lt;TMessage&gt; MessageHandler&lt;TRecipient, TMessage&gt; CommunityToolkit.Mvvm.Messaging.Messages PropertyChangedMessage&lt;T&gt; RequestMessage&lt;T&gt; AsyncRequestMessage&lt;T&gt; CollectionRequestMessage&lt;T&gt; AsyncCollectionRequestMessage&lt;T&gt; ValueChangedMessage&lt;T&gt; 2. Data binding Data binding is the process that establishes a connection between the app UI and the data it displays. If the binding has the correct settings and the data provides the proper notifications, when the data changes its value, the elements that are bound to the data reflect changes automatically. Data binding can also mean that if an outer representation of the data in an element changes, then the underlying data can be automatically updated to reflect the change. Typically, each binding has four components: A binding target object. A target property. A binding source. A path to the value in the binding source to use. For example, to bound the content of a TextBox to the Employee.Name property: Target: TextBox Target property: Text Source object: Employee Source object value path: Name A binding contains all the information that can be shared across several binding expressions. A BindingExpression is an instance expression that cannot be shared and contains all the instance information of the Binding. // Make a new source var myDataObject = new MyData(); var myBinding = new Binding(&quot;ColorName&quot;) { Source = myDataObject }; // Bind the data source to the TextBox control&#39;s Text dependency property myText.SetBinding(TextBlock.TextProperty, myBinding); A binding source object can be treated either as a single object whose properties contain data or as a data collection of polymorphic objects that are often grouped together (such as the result of a query to a database). Any collection that implements the IEnumerable interface can be enumerated over. However, to set up dynamic bindings so that insertions or deletions in the collection update the UI automatically, the collection must implement the INotifyCollectionChanged interface. WPF provides the ObservableCollection&lt;T&gt; class, which is a built-in implementation of a data collection that exposes the INotifyCollectionChanged interface. To fully support transferring data values from source objects to targets, each object in your collection that supports bindable properties must also implement the INotifyPropertyChanged interface. A collection view is a layer on top of a binding source collection that allows you to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself. A collection view also maintains a pointer to the current item in the collection. If the source collection implements the INotifyCollectionChanged interface, the changes raised by the CollectionChanged event are propagated to the views. Because views do not change the underlying source collections, each source collection can have multiple views associated with it. Once ItemsControl is bound to a data collection, the data may need to be sorted, filtered, or grouped. To do that, use collection views, which are classes that implement the ICollectionView interface. A collection view is a layer on top of a binding source collection that allows to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself. A collection view also maintains a pointer to the current item in the collection. If the source collection implements the INotifyCollectionChanged interface, the changes raised by the CollectionChanged event are propagated to the views. Because views do not change the underlying source collections, each source collection can have multiple views associated with it. &lt;Window.Resources&gt; &lt;CollectionViewSource Source=&quot;{Binding Source={x:Static Application.Current}, Path=AuctionItems}&quot; x:Key=&quot;listingDataView&quot; /&gt; &lt;/Window.Resources&gt; &lt;ListBox Name=&quot;Master&quot; Grid.Row=&quot;2&quot; Grid.ColumnSpan=&quot;3&quot; Margin=&quot;8&quot; ItemsSource=&quot;{Binding Source={StaticResource listingDataView}}&quot; /&gt; private void AddSortCheckBox_Checked(object sender, RoutedEventArgs e) { // Sort the items first by Category and then by StartDate listingDataView.SortDescriptions.Add(new SortDescription(&quot;Category&quot;, ListSortDirection.Ascending)); listingDataView.SortDescriptions.Add(new SortDescription(&quot;StartDate&quot;, ListSortDirection.Ascending)); } private void AddFilteringCheckBox_Checked(object sender, RoutedEventArgs e) { if (((CheckBox)sender).IsChecked == true) listingDataView.Filter += ListingDataView_Filter; else listingDataView.Filter -= ListingDataView_Filter; } private void ListingDataView_Filter(object sender, FilterEventArgs e) { // Start with everything excluded e.Accepted = false; // Only inlcude items with a price less than 25 if (e.Item is AuctionItem product &amp;&amp; product.CurrentPrice &lt; 25) e.Accepted = true; } // This groups the items in the view by the property &quot;Category&quot; var groupDescription = new PropertyGroupDescription(); groupDescription.PropertyName = &quot;Category&quot;; listingDataView.GroupDescriptions.Add(groupDescription); 2.1. Data context When data binding is declared on XAML elements, they resolve data binding by looking at their immediate DataContext property. The data context is typically the binding source object for the binding source value path evaluation. If the DataContext property for the object hosting the binding isn&#8217;t set, the parent element&#8217;s DataContext property is checked, and so on, up until the root of the XAML object tree. In short, the data context used to resolve binding is inherited from the parent unless explicitly set on the object. Bindings can be configured to resolve with a specific object, as opposed to using the data context for binding resolution. When the DataContext property changes, all bindings that could be affected by the data context are reevaluated. 2.2. Data flow OneWay binding causes changes to the source property to automatically update the target property, but changes to the target property are not propagated back to the source property, which is appropriate if the control being bound is implicitly read-only. TwoWay binding causes changes to either the source property or the target property to automatically update the other, which is appropriate for editable forms or other fully interactive UI scenarios.. Most properties default to OneWay binding, but some dependency properties (typically properties of user-editable controls such as the TextBox.Text and CheckBox.IsChecked default to TwoWay binding. A programmatic way to determine whether a dependency property binds one-way or two-way by default is to get the property metadata with DependencyProperty.GetMetadata. if (TextBox.TextProperty.GetMetadata(typeof(TextBox)) is FrameworkPropertyMetadata meta) { Console.WriteLine($&quot;{meta.BindsTwoWayByDefault}&quot;); // True } OneWayToSource is the reverse of OneWay binding; it updates the source property when the target property changes, which is appropriate if you only need to reevaluate the source value from the UI. OneTime binding causes the source property to initialize the target property but doesn&#8217;t propagate subsequent changes which is appropriate if either a snapshot of the current state is appropriate or the data is truly static. If the data context changes or the object in the data context changes, the change is not reflected in the target property. To detect source changes (applicable to OneWay and TwoWay bindings), the source must implement a suitable property change notification mechanism such as INotifyPropertyChanged. Bindings that are TwoWay or OneWayToSource listen for changes in the target property and propagate them back to the source, known as updating the source. The Binding.UpdateSourceTrigger property determines what triggers the update of the source. If the UpdateSourceTrigger value is UpdateSourceTrigger.PropertyChanged, then the value pointed to by the right arrow of TwoWay or the OneWayToSource bindings is updated as soon as the target property changes. However, if the UpdateSourceTrigger value is LostFocus, then that value only is updated with the new value when the target property loses focus. If the UpdateSourceTrigger value of the binding is set to Explicit, the UpdateSource method must be called or the changes will not propagate back to the source. var textBlock = new TextBlock(); var nameBindingObject = new Binding(&quot;Name&quot;); nameBindingObject.UpdateSourceTrigger = UpdateSourceTrigger.Explicit; // ... textBlock.SetBinding(TextBlock.TextProperty, nameBindingObject); var bindingExpression = textBlock.GetBindingExpression(TextBlock.TextProperty); bindingExpression.UpdateSource(); 2.3. Data conversion [ValueConversion(typeof(Color), typeof(SolidColorBrush))] public class ColorBrushConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { Color color = (Color)value; return new SolidColorBrush(color); } public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { return null; } } /// &lt;summary&gt; /// Provides a way to apply custom logic to a binding. /// &lt;/summary&gt; /// &lt;remarks&gt;Value converters are culture-aware. Both the Convert and ConvertBack methods have a culture parameter that indicates the cultural information.&lt;/remarks&gt; public interface IValueConverter { /// &lt;summary&gt; /// The data binding engine calls this method when it propagates a value from the binding source to the binding target. /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;The value produced by the binding source.&lt;/param&gt; /// &lt;param name=&quot;targetType&quot;&gt;The type of the binding target property.&lt;/param&gt; /// &lt;param name=&quot;parameter&quot;&gt;The converter parameter to use.&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;The culture to use in the converter.&lt;/param&gt; /// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt; /// &lt;remarks&gt; /// A return value of &lt;see cref=&quot;DependencyProperty.UnsetValue&quot;/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt;, if available, or the default value instead. /// A return value of &lt;see cref=&quot;Binding.DoNothing&quot;/&gt; indicates that the binding does not transfer the value or use the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt; or default value. /// &lt;/remarks&gt; object Convert(object value, Type targetType, object parameter, CultureInfo culture); /// &lt;summary&gt; /// The data binding engine calls this method when it propagates a value from the binding target to the binding source. /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;The value that is produced by the binding target.&lt;/param&gt; /// &lt;param name=&quot;targetType&quot;&gt;The type to convert to.&lt;/param&gt; /// &lt;param name=&quot;parameter&quot;&gt;The converter parameter to use.&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;The culture to use in the converter.&lt;/param&gt; /// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt; /// &lt;remarks&gt; /// A return value of &lt;see cref=&quot;DependencyProperty.UnsetValue&quot;/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt;, if available, or the default value instead. /// A return value of &lt;see cref=&quot;Binding.DoNothing&quot;/&gt; indicates that the binding does not transfer the value or use the &lt;see cref=&quot;BindingBase.FallbackValue&quot;/&gt; or default value. /// &lt;/remarks&gt; object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture); } 2.4. Data validation WPF has two types of built-in ValidationRule objects to check whether the value of a property is valid. A ExceptionValidationRule checks for exceptions thrown during the update of the binding source property. An alternative syntax to setting the ExceptionValidationRule explicitly is to set the ValidatesOnExceptions property to true on a Binding or MultiBinding object. A DataErrorValidationRule object checks for errors that are raised by objects that implement the IDataErrorInfo or INotifyDataErrorInfo interface. An alternative syntax to setting the DataErrorValidationRule explicitly is to set the ValidatesOnDataErrors property to true on a Binding or MultiBinding object. Custom validation rule objects can also be defined by deriving from the ValidationRule class and implementing the Validate method. One way to provide some feedback about the error on the app UI is to set the Validation.ErrorTemplate attached property to a custom ControlTemplate. &lt;ControlTemplate x:Key=&quot;validationTemplate&quot;&gt; &lt;DockPanel&gt; &lt;TextBlock Foreground=&quot;Red&quot; FontSize=&quot;20&quot;&gt;!&lt;/TextBlock&gt; &lt;!-- The AdornedElementPlaceholder element specifies where the control being adorned should be placed. --&gt; &lt;AdornedElementPlaceholder/&gt; &lt;/DockPanel&gt; &lt;/ControlTemplate&gt; In addition, the error message may also be displayed using a ToolTip. &lt;Style x:Key=&quot;textStyleTextBox&quot; TargetType=&quot;TextBox&quot;&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;#333333&quot; /&gt; &lt;Setter Property=&quot;MaxLength&quot; Value=&quot;40&quot; /&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;392&quot; /&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;Validation.HasError&quot; Value=&quot;true&quot;&gt; &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;{Binding (Validation.Errors).CurrentItem.ErrorContent, RelativeSource={RelativeSource Self}}&quot; /&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; 2.5. Binding path If the binding source is an object, use the Binding.Path property to specify the value to use for the binding. If binding to XML data, use the Binding.XPath property to specify the value. Use the Path property to specify the source value to bind to: In the simplest case, the Path property value is the name of the property of the source object to use for the binding, such as Path=PropertyName. Subproperties of a property can be specified by a similar syntax as in C#. For instance, the clause Path=ShoppingCart.Order sets the binding to the subproperty Order of the object or property ShoppingCart. To bind to an attached property, place parentheses around the attached property. For example, to bind to the attached property DockPanel.Dock, the syntax is Path=(DockPanel.Dock). Indexers of a property can be specified within square brackets following the property name where the indexer is applied. For instance, the clause Path=ShoppingCart[0] sets the binding to the index that corresponds to how your property&#8217;s internal indexing handles the literal string &quot;0&quot;. Nested indexers are also supported. Indexers and subproperties can be mixed in a Path clause; for example, Path=ShoppingCart.ShippingInfo[MailingAddress,Street]. Inside indexers, there can be multiple indexer parameters separated by commas (,). The type of each parameter can be specified with parentheses. For example, Path=&quot;[(sys:Int32)42,(sys:Int32)24]&quot;, where sys is mapped to the System namespace. When the source is a collection view, the current item can be specified with a slash (/). For example, the clause Path=/ sets the binding to the current item in the view. When the source is a collection, this syntax specifies the current item of the default collection view. Property names and slashes can be combined to traverse properties that are collections. For example, Path=/Offices/ManagerName specifies the current item of the source collection, which contains an Offices property that is also a collection. Its current item is an object that contains a ManagerName property. Optionally, a period (.) path can be used to bind to the current source. For example, Text=&quot;{Binding}&quot; is equivalent to Text=&quot;{Binding Path=.}&quot;. 2.6. Binding source Using the DataContext property on a parent element is useful when binding multiple properties to the same source. However, sometimes it may be more appropriate to specify the binding source on individual binding declarations. &lt;DockPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:c=&quot;clr-namespace:SDKSample&quot;&gt; &lt;DockPanel.Resources&gt; &lt;c:MyData x:Key=&quot;myDataSource&quot;/&gt; &lt;/DockPanel.Resources&gt; &lt;DockPanel.DataContext&gt; &lt;Binding Source=&quot;{StaticResource myDataSource}&quot;/&gt; &lt;/DockPanel.DataContext&gt; &lt;Button Background=&quot;{Binding Path=ColorName}&quot; Width=&quot;150&quot; Height=&quot;30&quot;&gt; I am bound to be RED! &lt;/Button&gt; &lt;/DockPanel&gt; &lt;DockPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:c=&quot;clr-namespace:SDKSample&quot;&gt; &lt;DockPanel.Resources&gt; &lt;c:MyData x:Key=&quot;myDataSource&quot;/&gt; &lt;/DockPanel.Resources&gt; &lt;Button Background=&quot;{Binding Source={StaticResource myDataSource}, Path=ColorName}&quot; Width=&quot;150&quot; Height=&quot;30&quot;&gt; I am bound to be RED! &lt;/Button&gt; &lt;/DockPanel&gt; The Binding.ElementName and Binding.RelativeSource properties also be used to set the source of the binding explicitly. &lt;StackPanel&gt; &lt;Slider Name=&quot;RectangleHeight&quot; Width=&quot;100&quot; HorizontalAlignment=&quot;Left&quot; Maximum=&quot;72&quot; Minimum=&quot;5&quot; Orientation=&quot;Horizontal&quot; Value=&quot;16&quot; /&gt; &lt;Button FontSize=&quot;{Binding ElementName=RectangleHeight, Path=Value}&quot;&gt;Hello World!&lt;/Button&gt; &lt;/StackPanel&gt; 2.7. Binding in XAML Binding is a markup extension. When using the binding extension to declare a binding, the declaration consists of a series of clauses following the Binding keyword and separated by commas (,). The clauses in the binding declaration can be in any order and there are many possible combinations. The clauses are Name=Value pairs, where Name is the name of the Binding property and Value is the value for the property. When creating binding declaration strings in markup, they must be attached to the specific dependency property of a target object. &lt;TextBlock Text=&quot;{Binding Source={StaticResource myDataSource}, Path=Name}&quot;/&gt; Object element syntax is an alternative to creating the binding declaration. In most cases, there&#8217;s no particular advantage to using either the markup extension or the object element syntax. &lt;TextBlock&gt; &lt;TextBlock.Text&gt; &lt;Binding Source=&quot;{StaticResource myDataSource}&quot; Path=&quot;Name&quot;/&gt; &lt;/TextBlock.Text&gt; &lt;/TextBlock&gt; 2.8. Binding in code Another way to specify a binding is to set properties directly on a Binding object in code, and then assign the binding to a property. private void Window_Loaded(object sender, RoutedEventArgs e) { // Make a new data source object var personDetails = new Person() { Name = &quot;John&quot;, Birthdate = DateTime.Parse(&quot;2001-02-03&quot;) }; // New binding object using the path of &#39;Name&#39; for whatever source object is used var nameBindingObject = new Binding(&quot;Name&quot;); // Configure the binding nameBindingObject.Mode = BindingMode.OneWay; nameBindingObject.Source = personDetails; nameBindingObject.Converter = NameConverter.Instance; nameBindingObject.ConverterCulture = new CultureInfo(&quot;en-US&quot;); // Set the binding to a target object. The TextBlock.Name property on the NameBlock UI element BindingOperations.SetBinding(NameBlock, TextBlock.TextProperty, nameBindingObject); } 3. Property system Windows Presentation Foundation (WPF) provides a set of services that can be used to extend the functionality of a type&#8217;s property. Collectively, these services are referred to as the WPF property system. A property that&#8217;s backed by the WPF property system is known as a dependency property. Attached properties are a XAML concept, dependency properties are a WPF concept. Attached properties enable extra property/value pairs to be set on any XAML element that derives from DependencyObject, even though the element doesn&#8217;t define those extra properties in its object model. 3.1. Dependency properties and CLR properties WPF properties are typically exposed as standard .NET properties. The purpose of dependency properties is to provide a way to compute the value of a property based on the value of other inputs, such as: System properties, such as themes and user preference. Just-in-time property determination mechanisms, such as data binding and animations/storyboards. Multiple-use templates, such as resources and styles. Values known through parent-child relationships with other elements in the element tree. Also, a dependency property can provide: Self-contained validation. Default values. Callbacks that monitor changes to other properties. A system that can coerce property values based on runtime information. Derived classes can change some characteristics of an existing property by overriding the metadata of a dependency property, rather than overriding the actual implementation of existing properties or creating new properties. 3.2. Dependency properties back CLR properties Dependency properties and the WPF property system extend property functionality by providing a DependencyProperty type that backs a property, as an alternative to the standard pattern of backing a property with a private field. Here&#8217;s some commonly used terminology: Dependency property, which is a property that&#8217;s backed by a DependencyProperty. Dependency property identifier, which is a DependencyProperty instance obtained as a return value when registering a dependency property, and then stored as a static member of a class. Many of the APIs that interact with the WPF property system use the dependency property identifier as a parameter. CLR &quot;wrapper&quot;, which is the get and set implementations for the property. These implementations incorporate the dependency property identifier by using it in the GetValue and SetValue calls. In this way, the WPF property system provides the backing for the property. The following example defines the IsSpinning dependency property to show the relationship of the DependencyProperty identifier to the property that it backs. public static readonly DependencyProperty IsSpinningProperty = DependencyProperty.Register( &quot;IsSpinning&quot;, typeof(bool), typeof(MainWindow) ); public bool IsSpinning { get =&gt; (bool)GetValue(IsSpinningProperty); set =&gt; SetValue(IsSpinningProperty, value); } The naming convention of the property and its backing DependencyProperty field is important. The name of the field is always the name of the property, with the suffix Property appended. 3.3. Attached properties Although any object can set an attached property value, that doesn&#8217;t mean setting a value will produce a tangible result or the value will be used by another object. Attached property usage typically follows one of these models: The type that defines the attached property is the parent of the elements that set values for the attached property. The parent type iterates its child objects through internal logic that acts on the object tree structure, obtains the values, and acts on those values in some manner. The type that defines the attached property is used as the child element for various possible parent elements and content models. The type that defines the attached property represents a service. Other types set values for the attached property. Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class. Attached properties in WPF don&#8217;t have the typical CLR get and set wrapper methods because the properties might be set from outside of the CLR namespace. To permit a XAML processor to set those values when parsing XAML, the class that defines the attached property must implement dedicated accessor methods in the form of Get&lt;property name&gt; and Set&lt;property name&gt;. // Attached properties in code DockPanel myDockPanel = new(); TextBox myTextBox = new(); myTextBox.Text = &quot;Enter text&quot;; // Add child element to the DockPanel. myDockPanel.Children.Add(myTextBox); // Set the attached property value. DockPanel.SetDock(myTextBox, Dock.Top); public static Dock GetDock(UIElement element); public static void SetDock(UIElement element, Dock dock); &lt;!-- Attached properties in XAML --&gt; &lt;DockPanel&gt; &lt;TextBox DockPanel.Dock=&quot;Top&quot;&gt;Enter text&lt;/TextBox&gt; &lt;/DockPanel&gt; Define attached property as a dependency in the defining class by declaring a public static readonly field of type DependencyProperty. Then, assign the return value of the RegisterAttached method to the field, which is also known as the dependency property identifier. Follow the WPF property naming convention that distinguishes fields from the properties that they represent, by naming the identifier field &lt;property name&gt;Property. Also, provide static Get&lt;property name&gt; and Set&lt;property name&gt; accessor methods, which lets the property system access the attached property. public class Aquarium : UIElement { // Register an attached dependency property with the specified // property name, property type, owner type, and property metadata. public static readonly DependencyProperty HasFishProperty = DependencyProperty.RegisterAttached( &quot;HasFish&quot;, typeof(bool), typeof(Aquarium), new FrameworkPropertyMetadata(defaultValue: false, flags: FrameworkPropertyMetadataOptions.AffectsRender) ); // Declare a get accessor method. public static bool GetHasFish(UIElement target) =&gt; (bool)target.GetValue(HasFishProperty); // Declare a set accessor method. public static void SetHasFish(UIElement target, bool value) =&gt; target.SetValue(HasFishProperty, value); } The get accessor method signature is public static object Get&lt;property name&gt;(DependencyObject target), where: target is the DependencyObject from which the attached property is read. The target type can be more specific than DependencyObject. For example, the DockPanel.GetDock accessor method types the target as UIElement because the attached property is intended to be set on UIElement instances. The return type can be more specific than object. For example, the GetDock method types the returned value as Dock because the return value should be a Dock enumeration. The set accessor method signature is public static void Set&lt;property name&gt;(DependencyObject target, object value), where: target is the DependencyObject on which the attached property is written. The target type can be more specific than DependencyObject. For example, the SetDock method types the target as UIElement because the attached property is intended to be set on UIElement instances. The value type can be more specific than object. For example, the SetDock method requires a Dock value. 3.4. Property value inheritance Property value inheritance is a feature of the Windows Presentation Foundation (WPF) property system and applies to dependency properties. Property value inheritance lets child elements in a tree of elements obtain the value of a particular property from the nearest parent element. Since a parent element might also have obtained its property value through property value inheritance, the system potentially recurses back to the page root. The WPF property system doesn&#8217;t enable property value inheritance by default, and value inheritance is inactive unless specifically enabled in dependency property metadata. Even with property value inheritance enabled, a child element will only inherit a property value in the absence of a higher precedence value. 4. Routed events Windows Presentation Foundation (WPF) application developers and component authors can use routed events to propagate events through an element tree, and invoke event handlers on multiple listeners in the tree. From a functional perspective, a routed event is a type of event that can invoke handlers on multiple listeners in an element tree, not just on the event source. An event listener is the element where an event handler is attached and invoked. An event source is the element or object that originally raised an event. From an implementation perspective, a routed event is an event registered with the WPF event system, backed by an instance of the RoutedEvent class, and processed by the WPF event system. Typically, a routed event is implemented with a CLR event &quot;wrapper&quot; to enable attaching handlers in XAML and in code-behind as you would a CLR event. Depending on how a routed event is defined, when the event is raised on a source element it: Bubbles up through element tree from the source element to the root element, which is typically a page or window. Tunnels down through the element tree from the root element to the source element. Doesn&#8217;t travel through the element tree, and only occurs on the source element directly. 4.1. Routed event and event handler A routed event is an event registered with the WPF event system, backed by an instance of the RoutedEvent class, and processed by the WPF event system. The RoutedEvent instance, obtained from registration, is typically stored as a public static readonly member of the &quot;owner&quot; class, that registered it. Typically, a routed event implements an identically named CLR event &quot;wrapper&quot; that is similar to how a dependency property is a CLR property. The CLR event wrapper contains add and remove accessors to enable attaching handlers in XAML and in code-behind through language-specific event syntax. The add and remove accessors override their CLR implementation and call the routed event AddHandler and RemoveHandler methods. // Register a custom routed event using the Bubble routing strategy. public static readonly RoutedEvent TapEvent = EventManager.RegisterRoutedEvent( name: &quot;Tap&quot;, routingStrategy: RoutingStrategy.Bubble, handlerType: typeof(RoutedEventHandler), ownerType: typeof(CustomButton)); // Provide CLR accessors for adding and removing an event handler. public event RoutedEventHandler Tap { add { AddHandler(TapEvent, value); } remove { RemoveHandler(TapEvent, value); } } In XAML, attach an event handler to an element by declaring the event name as an attribute on the event listener element. The attribute value is the handler method name. The handler method must be implemented in the code-behind partial class for the XAML page. The event listener is the element where the event handler is attached and invoked. If the event isn&#8217;t a member of the listener&#8217;s class, use the qualified event name in the form of &lt;owner type&gt;.&lt;event name&gt;. &lt;StackPanel Button.Click=&quot;YesNoCancelButton_Click&quot;&gt; &lt;Button Name=&quot;YesButton&quot; Click=&quot;YesButtonClick&quot;&gt;Yes&lt;/Button&gt; &lt;Button Name=&quot;NoButton&quot; Click=&quot;NoButtonClick&quot;&gt;No&lt;/Button&gt; &lt;Button Name=&quot;CancelButton&quot; Click=&quot;CancelClick&quot;&gt;Cancel&lt;/Button&gt; &lt;/StackPanel&gt; The signature of the event handler method in code-behind must match the delegate type for the routed event. private void YesNoCancelButtonClick(object sender, RoutedEventArgs e) { } To attach an event handler for a routed event to an element using code: Directly call the AddHandler method. // Routed event handlers can always be attached this way. Button1.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(Button_Click)); StackPanel1.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(Button_Click)); If the routed event implements a CLR event wrapper, use language-specific event syntax to add event handlers. Button1.Click += Button_Click; 4.2. Attached events WPF attached events are implemented as routed events backed by a RoutedEvent field. public class AquariumFilter { // Register a custom routed event using the bubble routing strategy. public static readonly RoutedEvent CleanEvent = EventManager.RegisterRoutedEvent( &quot;Clean&quot;, RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(AquariumFilter)); // Provide an add handler accessor method for the Clean event. public static void AddCleanHandler(DependencyObject dependencyObject, RoutedEventHandler handler) { if (dependencyObject is not UIElement uiElement) { return; } uiElement.AddHandler(CleanEvent, handler); } // Provide a remove handler accessor method for the Clean event. public static void RemoveCleanHandler(DependencyObject dependencyObject, RoutedEventHandler handler) { if (dependencyObject is not UIElement uiElement) { return; } uiElement.RemoveHandler(CleanEvent, handler); } } An Add&lt;event name&gt;Handler method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to add. The method must be public and static, with no return value. The method calls the AddHandler base class method, passing in the routed event and handler as arguments. This method supports the XAML attribute syntax for attaching an event handler to an element. This method also enables code access to the event handler store for the attached event. A Remove&lt;event name&gt;Handler method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to remove. The method must be public and static, with no return value. The method calls the RemoveHandler base class method, passing in the routed event and handler as arguments. This method enables code access to the event handler store for the attached event. WPF implements attached events as routed events because the identifier for a RoutedEvent is defined by the WPF event system. The RegisterRoutedEvent method that returns the attached event identifier is the same method used to register non-attached routed events. Unlike the CLR event &quot;wrapper&quot; used to back non-attached routed events, the attached event accessor methods can be implemented in classes that don&#8217;t derive from UIElement or ContentElement. It is possible because the attached event backing code calls the UIElement.AddHandler and UIElement.RemoveHandler methods on a passed in UIElement instance. In contrast, the CLR wrapper for non-attached routed events calls those methods directly on the owning class, so that class must derive from UIElement. When defining a custom attached event using the WPF model of basing attached events on routed events, use the UIElement.RaiseEvent method to raise an attached event on any UIElement or ContentElement. When raising a routed event, whether it&#8217;s attached or not, an element is required to designate in the element tree as the event source. That source is then reported as the RaiseEvent caller. For example, to raise the AquariumFilter.Clean attached routed event on aquarium1: aquarium1.RaiseEvent(new RoutedEventArgs(AquariumFilter.CleanEvent)); In XAML syntax, an attached event is specified by its event name and its owner type, in the form of &lt;owner type&gt;.&lt;event name&gt;. Because the event name is qualified with the name of its owner type, the syntax allows the event to be attached to any element that can be instantiated. It is also applicable to handlers for regular routed events that attach to an arbitrary element along the event route. &lt;!-- attaches the AquariumFilter_Clean handler for the AquariumFilter.Clean attached event to the aquarium1 element --&gt; &lt;aqua:Aquarium x:Name=&quot;aquarium1&quot; Height=&quot;300&quot; Width=&quot;400&quot; aqua:AquariumFilter.Clean=&quot;AquariumFilter_Clean&quot;/&gt; Event handlers can also be attached for attached events in code behind, by calling the AddHandler method on the object that the handler should attach to and pass the event identifier and handler as parameters to the method. aquarium1.AddHandler(AquariumFilter.Clean, new RoutedEventHandler(AquariumFilter_Clean), true); 4.3. WPF input events By convention, WPF routed events that follow a tunneling route have a name that&#8217;s prefixed with &quot;Preview&quot;. Input events often come in pairs, with one being a preview event and the other a bubbling routed event. The Preview prefix signifies that the preview event completes before the paired bubbling event starts. A preview input event that&#8217;s marked as handled won&#8217;t invoke any normally registered event handlers for the remainder of the preview route, and the paired bubbling event won&#8217;t be raised. The order of event processing following a mouse-down action on leaf element #2 is: PreviewMouseDown tunneling event on the root element. PreviewMouseDown tunneling event on intermediate element #1. PreviewMouseDown tunneling event on leaf element #2, which is the source element. MouseDown bubbling event on leaf element #2, which is the source element. MouseDown bubbling event on intermediate element #1. MouseDown bubbling event on the root element. 4.4. Weak event patterns Listening for events can lead to memory leaks. The typical technique for listening to an event is to use the language-specific syntax that attaches a handler to an event on a source. For example, in C#, that syntax is: source.SomeEvent += new SomeEventHandler(MyEventHandler) that creates a strong reference from the event source to the event listener. Ordinarily, attaching an event handler for a listener causes the listener to have an object lifetime that is influenced by the object lifetime of the source (unless the event handler is explicitly removed). Whenever the source object lifetime extends beyond the object lifetime of the listener, the normal event pattern leads to a memory leak: the listener is kept alive longer than intended. The weak event pattern can be used whenever a listener needs to register for an event, but the listener does not explicitly know when to unregister, and can also be used whenever the object lifetime of the source exceeds the useful object lifetime of the listener. 5. Commands A command can be used to: separate the semantics and the object that invokes a command from the logic that executes the command. indicate whether an action is possible by implementing the CanExecute method. The routed command model in WPF can be broken up into four main concepts: The command is the action to be executed. The command source is the object which invokes the command. The command target is the object that the command is being executed on. The command binding is the object which maps the command logic to the command. A commands is created by implementing the ICommand interface. Execute method performs the actions that are associated with the command. CanExecute method determines whether the command can execute on the current command target. CanExecuteChanged event is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding. The RelayCommand and RelayCommand&lt;T&gt; are ICommand implementations that can expose a method or delegate to the view. These types act as a way to bind commands between the viewmodel and UI elements. They provide a base implementation of the ICommand interface. They also implement the IRelayCommand (and IRelayCommand&lt;T&gt;) interface, which exposes a NotifyCanExecuteChanged method to raise the CanExecuteChanged event. They expose constructors taking delegates like Action and Func&lt;T&gt;, which allow the wrapping of standard methods and lambda expressions. public class MyViewModel : ObservableObject { public MyViewModel() { IncrementCounterCommand = new RelayCommand(IncrementCounter); } private int counter; public int Counter { get =&gt; counter; private set =&gt; SetProperty(ref counter, value); } public ICommand IncrementCounterCommand { get; } private void IncrementCounter() =&gt; Counter++; } &lt;Page x:Class=&quot;MyApp.Views.MyPage&quot; xmlns:viewModels=&quot;using:MyApp.ViewModels&quot;&gt; &lt;Page.DataContext&gt; &lt;viewModels:MyViewModel x:Name=&quot;ViewModel&quot;/&gt; &lt;/Page.DataContext&gt; &lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock Text=&quot;{x:Bind ViewModel.Counter, Mode=OneWay}&quot;/&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;{x:Bind ViewModel.IncrementCounterCommand}&quot;/&gt; &lt;/StackPanel&gt; &lt;/Page&gt; A command source is the object that generally implements the ICommandSource interface, which invokes the command. Examples of command sources are MenuItem, Button, and KeyGesture. A command source like a Button can subscribe to the CanExecuteChanged event and be disabled if CanExecute returns false or be enabled if CanExecute returns true. Command is the command to execute when the command source is invoked. CommandTarget is the object on which to execute the command, which is only applicable when the ICommand is a RoutedCommand. If the CommandTarget is set on an ICommandSource and the corresponding command is not a RoutedCommand, the command target is ignored. If the CommandTarget is not set, the element with keyboard focus will be the command target. CommandParameter is a user-defined data type used to pass information to the handlers implementing the command. A CommandBinding associates a command with the event handlers that implement the command. The CommandBinding class contains a Command property, and PreviewExecuted, Executed, PreviewCanExecute, and CanExecute events. &lt;Window.CommandBindings&gt; &lt;CommandBinding Command=&quot;ApplicationCommands.Open&quot; Executed=&quot;OpenCmdExecuted&quot; CanExecute=&quot;OpenCmdCanExecute&quot;/&gt; &lt;/Window.CommandBindings&gt; // Creating CommandBinding and attaching an Executed and CanExecute handler CommandBinding OpenCmdBinding = new CommandBinding( ApplicationCommands.Open, OpenCmdExecuted, OpenCmdCanExecute); this.CommandBindings.Add(OpenCmdBinding); void OpenCmdExecuted(object target, ExecutedRoutedEventArgs e) { String command, targetobj; command = ((RoutedCommand)e.Command).Name; targetobj = ((FrameworkElement)target).Name; MessageBox.Show(&quot;The &quot; + command + &quot; command has been invoked on target object &quot; + targetobj); } void OpenCmdCanExecute(object sender, CanExecuteRoutedEventArgs e) { e.CanExecute = true; } A command target is the element on which the command is executed. With regards to a RoutedCommand, the command target is the element at which routing of the Executed and CanExecute starts. The command source can explicitly set the command target. If the command target is not defined, the element with keyboard focus will be used as the command target. &lt;StackPanel&gt; &lt;Menu&gt; &lt;MenuItem Command=&quot;ApplicationCommands.Paste&quot; CommandTarget=&quot;{Binding ElementName=mainTextBox}&quot; /&gt; &lt;/Menu&gt; &lt;TextBox Name=&quot;mainTextBox&quot;/&gt; &lt;/StackPanel&gt; // Creating the UI objects StackPanel mainStackPanel = new StackPanel(); TextBox pasteTextBox = new TextBox(); Menu stackPanelMenu = new Menu(); MenuItem pasteMenuItem = new MenuItem(); // Adding objects to the panel and the menu stackPanelMenu.Items.Add(pasteMenuItem); mainStackPanel.Children.Add(stackPanelMenu); mainStackPanel.Children.Add(pasteTextBox); // Setting the command to the Paste command pasteMenuItem.Command = ApplicationCommands.Paste; // Setting the command target to the TextBox pasteMenuItem.CommandTarget = pasteTextBox; The CommandManager serves a number of command related functions. It provides a set of static methods for adding and removing PreviewExecuted, Executed, PreviewCanExecute, and CanExecute event handlers to and from a specific element. It provides a means to register CommandBinding and InputBinding objects onto a specific class. The CommandManager also provides a means, through the RequerySuggested event, to notify a command when it should raise the CanExecuteChanged event. The InvalidateRequerySuggested method forces the CommandManager to raise the RequerySuggested event, which is useful for conditions that should disable/enable a command but are not conditions that the CommandManager is aware of. 6. Windows In WPF, a window is encapsulated by the Window class that used to do the following: Display a window. Configure the size, position, and appearance of a window. Host application-specific content. Manage the lifetime of a window. A window is divided into two areas: the non-client area and client area. The non-client area of a window is implemented by WPF and includes the parts of a window that are common to most windows, including the following: A title bar (1-5). An icon (1). Title (2). Minimize (3), Maximize (4), and Close (5) buttons. System menu (6) with menu items. Appears when clicking on the icon (1). Border (7). The client area of a window is the area within a window&#8217;s non-client area and is used by developers to add application-specific content, such as menu bars, tool bars, and controls. Client area (8). Resize grip (9). This is a control added to the Client area (8). For a window that is defined using both XAML markup and code-behind: XAML markup files are configured as MSBuild Page items. Code-behind files are configured as MSBuild Compile items. .NET SDK projects automatically import the correct Page and Compile items. When the project is configured for WPF, the XAML markup files are automatically imported as Page items, and the corresponding code-behind file is imported as Compile. 6.1. Lifetime A window that is opened by using the Show method doesn&#8217;t have an implicit relationship with the window that created it. Users can interact with either window independently of the other, which means that either window can do the following: Cover the other (unless one of the windows has its Topmost property set to true). Be minimized, maximized, and restored without affecting the other. After ownership by setting the Owner property of the owned window with a reference to the owner window is established: The owned window can reference its owner window by inspecting the value of its Owner property. The owner window can discover all the windows it owns by inspecting the value of its OwnedWindows property. A window opened by calling Show is a modeless window, and the application doesn&#8217;t prevent users from interacting with other windows in the application. Opening a window with ShowDialog opens a window as modal and restricts user interaction to the specific window. The life of a window starts coming to an end when a user closes it. Once a window is closed, it can&#8217;t be reopened. A window can be closed by using elements in the non-client area, including the following: The Close item of the System menu. Pressing ALT + F4. public MainWindow() { InitializeComponent(); KeyDown += (s, e) =&gt; { // inhibit the ALT + F4 e.Handled = e.SystemKey == Key.F4 &amp;&amp; Keyboard.Modifiers == ModifierKeys.Alt; }; } Pressing the Close button. Pressing ESC when a button has the IsCancel property set to true on a modal window. The following illustration shows the sequence of the principal events in the lifetime of a window: The following illustration shows the sequence of the principal events in the lifetime of a window that is shown without activation (ShowActivated is set to false before the window is shown): 6.2. Appearance To configure the non-client area, Window provides several properties, which include Icon to set a window&#8217;s icon and Title to set its title. The appearance and behavior of non-client area border can also be changed by configuring a window&#8217;s resize mode, window style, and whether it appears as a button in the desktop task bar. &lt;!-- Non-rectangular window style --&gt; &lt;Window x:Class=&quot;WindowsOverview.ClippedWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;ClippedWindow&quot; SizeToContent=&quot;WidthAndHeight&quot; WindowStyle=&quot;None&quot; AllowsTransparency=&quot;True&quot; Background=&quot;Transparent&quot;&gt; &lt;Grid Margin=&quot;20&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;20&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Rectangle Stroke=&quot;#FF000000&quot; RadiusX=&quot;10&quot; RadiusY=&quot;10&quot;/&gt; &lt;Path Fill=&quot;White&quot; Stretch=&quot;Fill&quot; Stroke=&quot;#FF000000&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;15,-5.597,0,-0.003&quot; Width=&quot;30&quot; Grid.Row=&quot;1&quot; Data=&quot;M22.166642,154.45381 L29.999666,187.66699 40.791059,154.54395&quot;/&gt; &lt;Rectangle Fill=&quot;White&quot; RadiusX=&quot;10&quot; RadiusY=&quot;10&quot; Margin=&quot;1&quot;/&gt; &lt;TextBlock HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;25&quot; Text=&quot;Greetings!&quot; TextWrapping=&quot;Wrap&quot; Margin=&quot;5,5,50,5&quot;/&gt; &lt;Button HorizontalAlignment=&quot;Right&quot; VerticalAlignment=&quot;Top&quot; Background=&quot;Transparent&quot; BorderBrush=&quot;{x:Null}&quot; Foreground=&quot;Red&quot; Content=&quot;❌&quot; FontSize=&quot;15&quot; /&gt; &lt;Grid.Effect&gt; &lt;DropShadowEffect BlurRadius=&quot;10&quot; ShadowDepth=&quot;3&quot; Color=&quot;LightBlue&quot;/&gt; &lt;/Grid.Effect&gt; &lt;/Grid&gt; &lt;/Window&gt; // Hide the Minimize, Maximize, and Close buttons public MainWindow() { InitializeComponent(); SourceInitialized += (s, e) =&gt; { const int WM_SYSTEM_MENU = 0x80000; const int WM_GW_STYLE = -16; var hWnd = new System.Windows.Interop.WindowInteropHelper(this).Handle; if (hWnd == IntPtr.Zero) { throw new InvalidOperationException(&quot;The window has not yet been completely initialized&quot;); } // Hide the Minimize, Maximize, and Close buttons SetWindow(hWnd, WM_GW_STYLE, GetWindow(hWnd, WM_GW_STYLE) &amp; ~WM_SYSTEM_MENU); }; } [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetWindowLong&quot;)] private static extern int GetWindow(IntPtr hWnd, int nIndex); [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SetWindowLong&quot;, SetLastError = true)] private static extern int SetWindow(IntPtr hWnd, int nIndex, int dwNew); 6.3. Dialog boxes When designing a dialog box, follow these suggestions to create a good user experience: ❌ DON&#8217;T clutter the dialog window. The dialog experience is for the user to enter some data, or to make a choice. ✔️ DO provide an OK button to close the window. ✔️ DO set the OK button&#8217;s IsDefault property to true to allow the user to press the ENTER key to accept and close the window. ✔️ CONSIDER adding a Cancel button so that the user can close the window and indicate that they don&#8217;t want to continue. ✔️ DO set the Cancel button&#8217;s IsCancel property to true to allow the user to press the ESC key to close the window. ✔️ DO set the title of the window to accurately describe what the dialog represents, or what the user should do with the dialog. ✔️ DO set minimum width and height values for the window, preventing the user from resizing the window too small. ✔️ CONSIDER disabling the ability to resize the window if ShowInTaskbar is set to false. ✔️ DO When a menu item or button runs a function that requires user interaction through a dialog box before the function can continue, the control should use an ellipsis at the end of its header text: &lt;MenuItem Header=&quot;_Open...&quot; Click=&quot;openMenuItem_Click&quot; /&gt; &lt;!-- or --&gt; &lt;Button Content=&quot;_Save As...&quot; Click=&quot;saveAsButton_Click&quot; /&gt; ✔️ DO When a menu item or button runs a function that displays a dialog box that does NOT require user interaction, such as an About dialog box, an ellipsis isn&#8217;t required. 6.4. Multiple windows, multiple threads Typically, WPF applications start with two threads: one for handling rendering and another for managing the UI. The rendering thread effectively runs hidden in the background while the UI thread receives input, handles events, paints the screen, and runs application code. Most applications use a single UI thread, although in some situations it is best to use several. The UI thread queues work items inside an object called a Dispatcher that selects work items on a priority basis and runs each one to completion. Every UI thread must have at least one Dispatcher, and each Dispatcher can execute work items in exactly one thread. The trick to building responsive, user-friendly applications is to maximize the Dispatcher throughput by keeping the work items small. Most classes derive from DispatcherObject that stores a reference to the Dispatcher linked to the currently running thread that creates it at construction. A DispatcherObject can call its public VerifyAccess method that examines the Dispatcher associated with the current thread and compares it to the Dispatcher reference stored during construction, and if they don&#8217;t match, VerifyAccess throws an exception. VerifyAccess is intended to be called at the beginning of every method belonging to a DispatcherObject. A background thread can ask the UI thread to perform an operation on its behalf by registering a work item with the Dispatcher of the UI thread. The Dispatcher class provides the methods for registering work items: InvokeAsync, BeginInvoke, and Invoke. Invoke is a synchronous call – that is, it doesn&#8217;t return until the UI thread actually finishes executing the delegate. InvokeAsync and BeginInvoke are asynchronous and return immediately. The Dispatcher orders the elements in its queue by priority that maintained in the DispatcherPriority enumeration. WPF application may require multiple top-level windows to do a better job, which is especially true if there&#8217;s any chance that one of the windows will monopolize the thread. private void NewThreadWindow_Click(object sender, RoutedEventArgs e) { Thread newWindowThread = new Thread(ThreadStartingPoint); newWindowThread.SetApartmentState(ApartmentState.STA); newWindowThread.IsBackground = true; newWindowThread.Start(); } private void ThreadStartingPoint() { new MultiWindow().Show(); System.Windows.Threading.Dispatcher.Run(); } Windows Explorer works in multiple top-level windows within multiple threads fashion. Each new Explorer window belongs to the original process, but it&#8217;s created under the control of an independent thread. When Explorer becomes nonresponsive, such as when looking for network resources, other Explorer windows continue to be responsive and usable. 7. Styles, templates, and triggers 7.1. Styles A Style, commonly declared as a resource, can apply a set of property values to one or more elements. When setting the TargetType of a style and omit the x:Key attribute, the style is applied to all the TargetType elements scoped to the style, which is generally the XAML file itself. &lt;Window.Resources&gt; &lt;!--A Style that affects all TextBlocks--&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; If adding an x:Key attribute with value to the style, the style is no longer implicitly applied to all elements of TargetType. Only elements that explicitly reference the style will have the style applied to them. &lt;Window.Resources&gt; &lt;Style x:Key=&quot;TitleText&quot; TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;StackPanel&gt; &lt;TextBlock Style=&quot;{StaticResource TitleText}&quot;&gt;My Pictures&lt;/TextBlock&gt; &lt;TextBlock&gt;Check out my new pictures!&lt;/TextBlock&gt; &lt;/StackPanel&gt; To assign a named style to an element programmatically, get the style from the resources collection and assign it to the element&#8217;s Style property. textblock1.Style = (Style)Resources[&quot;TitleText&quot;]; A style can extend another style with the BaseOn property. &lt;Window.Resources&gt; &lt;!-- .... other resources .... --&gt; &lt;!--A Style that affects all TextBlocks--&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;!-- x:Key is implicitly set to {x:Type TextBlock} --&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot; /&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Comic Sans MS&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt; &lt;/Style&gt; &lt;!--A Style that extends the previous TextBlock Style with an x:Key of TitleText--&gt; &lt;Style BasedOn=&quot;{StaticResource {x:Type TextBlock}}&quot; TargetType=&quot;TextBlock&quot; x:Key=&quot;TitleText&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;26&quot;/&gt; &lt;Setter Property=&quot;Foreground&quot;&gt; &lt;Setter.Value&gt; &lt;LinearGradientBrush StartPoint=&quot;0.5,0&quot; EndPoint=&quot;0.5,1&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Offset=&quot;0.0&quot; Color=&quot;#90DDDD&quot; /&gt; &lt;GradientStop Offset=&quot;1.0&quot; Color=&quot;#5BFFFF&quot; /&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; The x:Key of a style is implicitly set to {x:Type TargetType}. It means that if explicitly setting the x:Key value to anything other than {x:Type TargetType}, the Style isn&#8217;t applied to all TargetType elements automatically. If TargetType isn&#8217;t specified, the properties must be qualified in the Setter objects with a class name by using the syntax Property=&quot;ClassName.Property&quot;. Also note that many WPF controls consist of a combination of other WPF controls. If creating a style that applies to all controls of a type, unexpected results might happen. For example, if creating a style that targets the TextBlock type in a Window, the style is applied to all TextBlock controls in the window, even if the TextBlock is part of another control, such as a ListBox. 7.2. Control templates In WPF, the ControlTemplate of a control, Commonly declared as a resource, defines the appearance of the control. Each control has a default template assigned to the Control.Template property. A control template rewrites the visual appearance of the entire control, while a style simply applies property changes to the existing control. However, since the template of a control is applied by setting the Control.Template property, a template can be defined or set using a style. A TemplateBinding is an optimized form of a binding for template scenarios, analogous to a binding constructed with {Binding RelativeSource={RelativeSource TemplatedParent}}, such as for binding parts of the template to properties of the control. If a ContentPresenter is declared in the ControlTemplate of a ContentControl, the ContentPresenter will automatically bind to the ContentTemplate and Content properties. Likewise, an ItemsPresenter that is in the ControlTemplate of an ItemsControl will automatically bind to the ItemTemplate and Items properties. &lt;UserControl&gt; &lt;UserControl.Resources&gt; &lt;!-- Defined a ControlTemplate as a resource --&gt; &lt;ControlTemplate x:Key=&quot;roundbutton&quot; TargetType=&quot;Button&quot;&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;{TemplateBinding Background}&quot; Stroke=&quot;{TemplateBinding Foreground}&quot; /&gt; &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/UserControl.Resources&gt; &lt;StackPanel&gt; &lt;!-- Set the button&#39;s Template property to the roundbutton resource --&gt; &lt;Button Template=&quot;{StaticResource roundbutton}&quot;&gt;Hello&lt;/Button&gt; &lt;!-- Defined the ControlTemplate inline --&gt; &lt;Button Background=&quot;Red&quot; Foreground=&quot;White&quot;&gt; &lt;Button.Content&gt;World&lt;/Button.Content&gt; &lt;Button.Template&gt; &lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;{TemplateBinding Background}&quot; Stroke=&quot;{TemplateBinding Foreground}&quot; /&gt; &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; &lt;/StackPanel&gt; &lt;/UserControl&gt; 7.3. Data templates In WPF, the DataTemplate is used to custom the presentation and appearance of the data objects. In most cases, all other aspects of presentation, such as what an item looks like when it is selected or how a ListBox lays out the items, do not belong in the definition of a DataTemplate. &lt;!-- Defined the DataTemplate inline --&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot;&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt; &lt;!-- Defined a DataTemplate as a resource --&gt; &lt;UserControl.Resources&gt; &lt;DataTemplate x:Key=&quot;myTaskTemplate&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot; /&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/UserControl.Resources&gt; &lt;StackPanel&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemTemplate=&quot;{StaticResource myTaskTemplate}&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot; /&gt; &lt;/StackPanel&gt; The DataTemplate class has a DataType property that is very similar to the TargetType property of the Style class. &lt;DataTemplate DataType=&quot;{x:Type local:Task}&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;{Binding Path=TaskName}&quot; /&gt; &lt;TextBlock Text=&quot;{Binding Path=Description}&quot;/&gt; &lt;TextBlock Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; To supply logic to choose which DataTemplate to use based on the Priority value of the data object, create a subclass of DataTemplateSelector and override the SelectTemplate method. namespace SDKSample { public class TaskListDataTemplateSelector : DataTemplateSelector { public override DataTemplate SelectTemplate(object item, DependencyObject container) { FrameworkElement element = container as FrameworkElement; if (element != null &amp;&amp; item != null &amp;&amp; item is Task) { Task taskitem = item as Task; if (taskitem.Priority == 1) return element.FindResource(&quot;importantTaskTemplate&quot;) as DataTemplate; else return element.FindResource(&quot;myTaskTemplate&quot;) as DataTemplate; } return null; } } } &lt;Window.Resources&gt; &lt;local:TaskListDataTemplateSelector x:Key=&quot;myDataTemplateSelector&quot; /&gt; &lt;/Window.Resources&gt; &lt;ListBox Width=&quot;400&quot; Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot; ItemTemplateSelector=&quot;{StaticResource myDataTemplateSelector}&quot; HorizontalContentAlignment=&quot;Stretch&quot;/&gt; Styling and Templating an ItemsControl &lt;ItemsControl Margin=&quot;10&quot; ItemsSource=&quot;{Binding Source={StaticResource myTodoList}}&quot;&gt; &lt;!--The ItemsControl has no default visual appearance. Use the Template property to specify a ControlTemplate to define the appearance of an ItemsControl. The ItemsPresenter uses the specified ItemsPanelTemplate (see below) to layout the items. If an ItemsPanelTemplate is not specified, the default is used. (For ItemsControl, the default is an ItemsPanelTemplate that specifies a StackPanel.--&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;Border BorderBrush=&quot;Aqua&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;15&quot;&gt; &lt;ItemsPresenter/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;!--Use the ItemsPanel property to specify an ItemsPanelTemplate that defines the panel that is used to hold the generated items. In other words, use this property if you want to affect how the items are laid out.--&gt; &lt;ItemsControl.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;WrapPanel /&gt; &lt;/ItemsPanelTemplate&gt; &lt;/ItemsControl.ItemsPanel&gt; &lt;!--Use the ItemTemplate to set a DataTemplate to define the visualization of the data objects. This DataTemplate specifies that each data object appears with the Proriity and TaskName on top of a silver ellipse.--&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;DataTemplate.Resources&gt; &lt;Style TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;18&quot;/&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;/Style&gt; &lt;/DataTemplate.Resources&gt; &lt;Grid&gt; &lt;Ellipse Fill=&quot;Silver&quot;/&gt; &lt;StackPanel&gt; &lt;TextBlock Margin=&quot;3,3,3,0&quot; Text=&quot;{Binding Path=Priority}&quot;/&gt; &lt;TextBlock Margin=&quot;3,0,3,7&quot; Text=&quot;{Binding Path=TaskName}&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;!--Use the ItemContainerStyle property to specify the appearance of the element that contains the data. This ItemContainerStyle gives each item container a margin and a width. There is also a trigger that sets a tooltip that shows the description of the data object when the mouse hovers over the item container.--&gt; &lt;ItemsControl.ItemContainerStyle&gt; &lt;Style&gt; &lt;Setter Property=&quot;Control.Width&quot; Value=&quot;100&quot;/&gt; &lt;Setter Property=&quot;Control.Margin&quot; Value=&quot;5&quot;/&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;Control.IsMouseOver&quot; Value=&quot;True&quot;&gt; &lt;Setter Property=&quot;Control.ToolTip&quot; Value=&quot;{Binding RelativeSource={x:Static RelativeSource.Self}, Path=Content.Description}&quot;/&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/ItemsControl.ItemContainerStyle&gt; &lt;/ItemsControl&gt; The HierarchicalDataTemplate class is designed to be used with HeaderedItemsControl types to display collection data that contains other collections such as a Menu or a TreeView. &lt;Window x:Class=&quot;SDKSample.Window1&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:src=&quot;clr-namespace:SDKSample&quot; Title=&quot;HierarchicalDataTemplate Sample&quot;&gt; &lt;DockPanel&gt; &lt;DockPanel.Resources&gt; &lt;src:ListLeagueList x:Key=&quot;MyList&quot; /&gt; &lt;HierarchicalDataTemplate DataType=&quot;{x:Type src:League}&quot; ItemsSource=&quot;{Binding Path=Divisions}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/HierarchicalDataTemplate&gt; &lt;HierarchicalDataTemplate DataType=&quot;{x:Type src:Division}&quot; ItemsSource=&quot;{Binding Path=Teams}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/HierarchicalDataTemplate&gt; &lt;DataTemplate DataType=&quot;{x:Type src:Team}&quot;&gt; &lt;TextBlock Text=&quot;{Binding Path=Name}&quot; /&gt; &lt;/DataTemplate&gt; &lt;/DockPanel.Resources&gt; &lt;Menu Name=&quot;menu1&quot; Margin=&quot;10,10,10,10&quot; DockPanel.Dock=&quot;Top&quot;&gt; &lt;MenuItem Header=&quot;My Soccer Leagues&quot; ItemsSource=&quot;{Binding Source={StaticResource MyList}}&quot; /&gt; &lt;/Menu&gt; &lt;TreeView&gt; &lt;TreeViewItem Header=&quot;My Soccer Leagues&quot; ItemsSource=&quot;{Binding Source={StaticResource MyList}}&quot; /&gt; &lt;/TreeView&gt; &lt;/DockPanel&gt; &lt;/Window&gt; 7.4. Triggers A trigger sets properties or starts actions, such as an animation, when a property value changes or when an event is raised. Style, ControlTemplate, and DataTemplate all have a Triggers property that can contain a set of triggers. A Trigger that sets property values or starts actions based on the value of a property is called a property trigger. &lt;Window.Resources&gt; &lt;!-- .... other resources .... --&gt; &lt;Style TargetType=&quot;ListBoxItem&quot;&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;0.5&quot; /&gt; &lt;Setter Property=&quot;MaxHeight&quot; Value=&quot;75&quot; /&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsSelected&quot; Value=&quot;True&quot;&gt; &lt;Trigger.Setters&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;1.0&quot; /&gt; &lt;/Trigger.Setters&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; The properties changed by triggers are automatically reset to their previous value when the triggered condition is no longer satisfied. Another type of trigger is the EventTrigger, which starts a set of actions based on the occurrence of an event. &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsSelected&quot; Value=&quot;True&quot;&gt; &lt;Trigger.Setters&gt; &lt;Setter Property=&quot;Opacity&quot; Value=&quot;1.0&quot; /&gt; &lt;/Trigger.Setters&gt; &lt;/Trigger&gt; &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseEnter&quot;&gt; &lt;EventTrigger.Actions&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Duration=&quot;0:0:0.2&quot; Storyboard.TargetProperty=&quot;MaxHeight&quot; To=&quot;90&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger.Actions&gt; &lt;/EventTrigger&gt; &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseLeave&quot;&gt; &lt;EventTrigger.Actions&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Duration=&quot;0:0:1&quot; Storyboard.TargetProperty=&quot;MaxHeight&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger.Actions&gt; &lt;/EventTrigger&gt; &lt;/Style.Triggers&gt; MultiTriggers applly property values or performs actions when a set of conditions are satisfied. &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsEnabled&quot; Value=&quot;false&quot;&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;#EEEEEE&quot; /&gt; &lt;/Trigger&gt; &lt;MultiTrigger&gt; &lt;MultiTrigger.Conditions&gt; &lt;Condition Property=&quot;HasItems&quot; Value=&quot;false&quot; /&gt; &lt;Condition Property=&quot;Width&quot; Value=&quot;Auto&quot; /&gt; &lt;/MultiTrigger.Conditions&gt; &lt;Setter Property=&quot;MinWidth&quot; Value=&quot;120&quot;/&gt; &lt;/MultiTrigger&gt; &lt;MultiTrigger&gt; &lt;MultiTrigger.Conditions&gt; &lt;Condition Property=&quot;HasItems&quot; Value=&quot;false&quot; /&gt; &lt;Condition Property=&quot;Height&quot; Value=&quot;Auto&quot; /&gt; &lt;/MultiTrigger.Conditions&gt; &lt;Setter Property=&quot;MinHeight&quot; Value=&quot;95&quot;/&gt; &lt;/MultiTrigger&gt; &lt;/Style.Triggers&gt; Event setters invoke the specified event handlers in response to routed events, which apply to all elements that reference the Style rather than requiring to attach instance handlers to each individual element. Only Style.Setters support EventSetter objects. Handlers attached through event setters are invoked after any class handlers for an event, and also after any instance handlers. As a result, if a class handler or instance handler marks an event handled in its arguments, then the handler declared by an event setter is not invoked, unless the event setter specifically sets HandledEventsToo true. &lt;StackPanel xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; x:Class=&quot;SDKSample.EventOvw2&quot; Name=&quot;dpanel2&quot; Initialized=&quot;PrimeHandledToo&quot;&gt; &lt;StackPanel.Resources&gt; &lt;Style TargetType=&quot;{x:Type Button}&quot;&gt; &lt;EventSetter Event=&quot;Click&quot; Handler=&quot;b1SetColor&quot;/&gt; &lt;/Style&gt; &lt;/StackPanel.Resources&gt; &lt;Button&gt;Click me&lt;/Button&gt; &lt;Button Name=&quot;ThisButton&quot; Click=&quot;HandleThis&quot;&gt; Raise event, handle it, use handled=true handler to get it anyway. &lt;/Button&gt; &lt;/StackPanel&gt; void b1SetColor(object sender, RoutedEventArgs e) { Button b = e.Source as Button; b.Background = new SolidColorBrush(Colors.Azure); } void HandleThis(object sender, RoutedEventArgs e) { e.Handled=true; } References [1] https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm [2] https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/ [3] https://learn.microsoft.com/en-us/dotnet/desktop/wpf","headline":"WPF (.NET) Learning Notes","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2024/09/18/wpf-dotnet-learning-notes/"},"url":"https://blog.codefarm.me/2024/09/18/wpf-dotnet-learning-notes/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">WPF (.NET) Learning Notes</h1><p class="c-post-meta">18 Sep 2024</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#mvvm-pattern-and-toolkit">1. MVVM pattern and toolkit</a>
<ul class="sectlevel2">
<li><a href="#mvvm-pattern">1.1. MVVM pattern</a>
<ul class="sectlevel3">
<li><a href="#view">1.1.1. View</a></li>
<li><a href="#viewmodel">1.1.2. ViewModel</a></li>
<li><a href="#model">1.1.3. Model</a></li>
<li><a href="#connecting-view-models-to-views">1.1.4. Connecting view models to views</a>
<ul class="sectlevel4">
<li><a href="#creating-a-view-model-declaratively">1.1.4.1. Creating a view model declaratively</a></li>
<li><a href="#creating-a-view-model-programmatically">1.1.4.2. Creating a view model programmatically</a></li>
</ul>
</li>
<li><a href="#updating-views-in-response-to-changes-in-the-underlying-view-model-or-model">1.1.5. Updating views in response to changes in the underlying view model or model</a></li>
</ul>
</li>
<li><a href="#mvvm-toolkit">1.2. MVVM Toolkit</a></li>
</ul>
</li>
<li><a href="#data-binding">2. Data binding</a>
<ul class="sectlevel2">
<li><a href="#data-context">2.1. Data context</a></li>
<li><a href="#data-flow">2.2. Data flow</a></li>
<li><a href="#data-conversion">2.3. Data conversion</a></li>
<li><a href="#data-validation">2.4. Data validation</a></li>
<li><a href="#binding-path">2.5. Binding path</a></li>
<li><a href="#binding-source">2.6. Binding source</a></li>
<li><a href="#binding-in-xaml">2.7. Binding in XAML</a></li>
<li><a href="#binding-in-code">2.8. Binding in code</a></li>
</ul>
</li>
<li><a href="#property-system">3. Property system</a>
<ul class="sectlevel2">
<li><a href="#dependency-properties-and-clr-properties">3.1. Dependency properties and CLR properties</a></li>
<li><a href="#dependency-properties-back-clr-properties">3.2. Dependency properties back CLR properties</a></li>
<li><a href="#attached-properties">3.3. Attached properties</a></li>
<li><a href="#property-value-inheritance">3.4. Property value inheritance</a></li>
</ul>
</li>
<li><a href="#routed-events">4. Routed events</a>
<ul class="sectlevel2">
<li><a href="#routed-event-and-event-handler">4.1. Routed event and event handler</a></li>
<li><a href="#attached-events">4.2. Attached events</a></li>
<li><a href="#wpf-input-events">4.3. WPF input events</a></li>
<li><a href="#weak-event-patterns">4.4. Weak event patterns</a></li>
</ul>
</li>
<li><a href="#commands">5. Commands</a></li>
<li><a href="#windows">6. Windows</a>
<ul class="sectlevel2">
<li><a href="#lifetime">6.1. Lifetime</a></li>
<li><a href="#appearance">6.2. Appearance</a></li>
<li><a href="#dialog-boxes">6.3. Dialog boxes</a></li>
<li><a href="#multiple-windows-multiple-threads">6.4. Multiple windows, multiple threads</a></li>
</ul>
</li>
<li><a href="#styles-templates-and-triggers">7. Styles, templates, and triggers</a>
<ul class="sectlevel2">
<li><a href="#styles">7.1. Styles</a></li>
<li><a href="#control-templates">7.2. Control templates</a></li>
<li><a href="#data-templates">7.3. Data templates</a></li>
<li><a href="#triggers">7.4. Triggers</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="mvvm-pattern-and-toolkit">1. MVVM pattern and toolkit</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The MVVM pattern <a href="#1">[1]</a> helps cleanly separate an application&#8217;s business and presentation logic from its user interface (UI).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maintaining a clean separation between application logic and the UI helps address numerous development issues and makes an application easier to test, maintain, and evolve.</p>
</li>
<li>
<p>It can also significantly improve code re-use opportunities and allows developers and UI designers to collaborate more easily when developing their respective parts of an app.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="mvvm-pattern">1.1. MVVM pattern</h3>
<div class="paragraph">
<p>There are three core components in the MVVM pattern: the model, the view, and the view model.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/architecture/maui/media/mvvm-pattern.png" alt="The MVVM pattern" width="55%" height="55%">
</div>
</div>
<div class="paragraph">
<p>Using the MVVM pattern, the UI of the app and the underlying presentation and business logic are separated into three separate classes: the view, which encapsulates the UI and UI logic; the view model, which encapsulates presentation logic and state; and the model, which encapsulates the app&#8217;s business logic and data.</p>
</div>
<div class="sect3">
<h4 id="view">1.1.1. View</h4>
<div class="paragraph">
<p>The view is responsible for defining the structure, layout, and appearance of what the user sees on screen.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ideally, each view is defined in XAML, with a limited code-behind that does not contain business logic.</p>
<div class="paragraph">
<p>However, in some cases, the code-behind might contain UI logic that implements visual behavior that is difficult to express in XAML, such as animations.</p>
</div>
</li>
<li>
<p>Enable and disable UI elements by binding to view model properties, rather than enabling and disabling them in code-behind.</p>
<div class="paragraph">
<p>Ensure that the view models are responsible for defining logical state changes that affect some aspects of the view&#8217;s display, such as whether a command is available, or an indication that an operation is pending.</p>
</div>
</li>
<li>
<p>There are several options for executing code on the view model in response to interactions on the view, such as a button click or item selection.</p>
<div class="ulist">
<ul>
<li>
<p>If a control supports commands, the control&#8217;s <code>Command</code> property can be data-bound to an <code>ICommand</code> property on the view model.</p>
<div class="paragraph">
<p>When the control&#8217;s command is invoked, the code in the view model will be executed.</p>
</div>
</li>
<li>
<p>In addition to commands, behaviors can be attached to an object in the view and can listen for either a command to be invoked or the event to be raised.</p>
<div class="paragraph">
<p>In response, the behavior can then invoke an ICommand on the view model or a method on the view model.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="viewmodel">1.1.2. ViewModel</h4>
<div class="paragraph">
<p>The view model implements properties and commands to which the view can data bind to, and notifies the view of any state changes through change notification events. The properties and commands that the view model provides define the functionality to be offered by the UI, but the view determines how that functionality is to be displayed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Multi-platform apps should keep the <strong>UI thread</strong> unblocked to improve the user&#8217;s perception of performance.</p>
<div class="paragraph">
<p>Therefore, in the view model, use <strong>asynchronous methods</strong> for I/O operations and raise <strong>events</strong> to asynchronously notify views of property changes.</p>
</div>
</li>
<li>
<p>The view model is also responsible for coordinating the view&#8217;s interactions with one or many model classes that are required.</p>
<div class="paragraph">
<p>The view model might choose to expose model classes directly to the view so that controls in the view can data bind directly to them. In this case, the model classes will need to be designed to support data binding and change notification events.</p>
</div>
</li>
<li>
<p>Each view model provides data from a model in a form that the view can easily consume.</p>
<div class="ulist">
<ul>
<li>
<p>Placing the data conversion in the view model is a good idea because it provides properties that the view can bind to. For example, the view model might combine the values of two properties to make it easier to display by the view.</p>
</li>
<li>
<p>It&#8217;s also possible to use converters as a separate data conversion layer that sits between the view model and the view. This can be necessary, for example, when data requires special formatting that the view model doesn&#8217;t provide.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In order for the view model to participate in two-way data binding with the view, its properties must raise the <code>PropertyChanged</code> event.</p>
<div class="ulist">
<ul>
<li>
<p>View models satisfy this requirement by implementing the <code>INotifyPropertyChanged</code> interface, and raising the <code>PropertyChanged</code> event when a property is changed.</p>
</li>
<li>
<p>For collections, the view-friendly <code>ObservableCollection&lt;T&gt;</code> is provided.</p>
<div class="paragraph">
<p>This collection implements collection changed notification, relieving the developer from having to implement the <code>INotifyCollectionChanged</code> interface on collections.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="model">1.1.3. Model</h4>
<div class="paragraph">
<p>Model classes are non-visual classes that encapsulate the app&#8217;s data.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Model classes can be thought of as representing the app&#8217;s domain model that includes a data model along with business and validation logic.</p>
</li>
<li>
<p>Examples of model objects include data transfer objects (DTOs), Plain Old CLR Objects (POCOs), and generated entity and proxy objects.</p>
</li>
<li>
<p>Model classes are typically used in conjunction with services or repositories that encapsulate data access and caching.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="connecting-view-models-to-views">1.1.4. Connecting view models to views</h4>
<div class="paragraph">
<p>View models can be connected to views by using the data-binding capabilities.</p>
</div>
<div class="sect4">
<h5 id="creating-a-view-model-declaratively">1.1.4.1. Creating a view model declaratively</h5>
<div class="paragraph">
<p>The simplest approach is for the view to declaratively instantiate its corresponding view model in XAML. When the view is constructed, the corresponding view model object will also be constructed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Grid.DataContext&gt;</span>
    <span class="nt">&lt;vm:MainViewModel</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/Grid.DataContext&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Though the declarative construction and assignment of the view model by the view has the advantage that it&#8217;s simple, but has the disadvantage that it requires a default (parameter-less) constructor in the view model.</p>
</div>
</div>
<div class="sect4">
<h5 id="creating-a-view-model-programmatically">1.1.4.2. Creating a view model programmatically</h5>
<div class="paragraph">
<p>A view can have code in the code-behind file, resulting in the view-model being assigned to its <code>DataContext</code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nf">InitializeComponent</span><span class="p">();</span>
        <span class="n">DataContext</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MainViewModel</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The programmatic construction and assignment of the view model within the view&#8217;s code-behind has the advantage that it&#8217;s simple.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>However, the main disadvantage of this approach is that the view needs to provide the view model with any required dependencies.</p>
</li>
<li>
<p>Using a <a href="https://learn.microsoft.com/en-us/dotnet/architecture/maui/dependency-injection">dependency injection</a> container can help to maintain loose coupling between the view and view model.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updating-views-in-response-to-changes-in-the-underlying-view-model-or-model">1.1.5. Updating views in response to changes in the underlying view model or model</h4>
<div class="paragraph">
<p>All view model and model classes that are accessible to a view should implement the <code>INotifyPropertyChanged</code> interface. Implementing this interface in a view model or model class allows the class to provide change notifications to any data-bound controls in the view when the underlying property value changes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Always raising a <code>PropertyChanged</code> event if a public property&#8217;s value changes.</p>
</li>
<li>
<p>Always raising a <code>PropertyChanged</code> event for any calculated properties whose values are used by other properties in the view model or model.</p>
</li>
<li>
<p>Always raising the <code>PropertyChanged</code> event at the end of the method that makes a property change, or when the object is known to be in a safe state.</p>
</li>
<li>
<p>Never raising a <code>PropertyChanged</code> event if the property does not change.</p>
</li>
<li>
<p>Never raising the <code>PropertyChanged</code> event during a view model&#8217;s constructor if you are initializing a property.</p>
</li>
<li>
<p>Never raising more than one <code>PropertyChanged</code> event with the same property name argument within a single synchronous invocation of a public method of a class.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MainViewModel</span> <span class="p">:</span> <span class="n">INotifyPropertyChanged</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">string</span><span class="p">?</span> <span class="n">_title</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">Title</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_title</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_title</span> <span class="p">!=</span> <span class="k">value</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_title</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
                <span class="nf">OnPropertyChanged</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">event</span> <span class="n">PropertyChangedEventHandler</span><span class="p">?</span> <span class="n">PropertyChanged</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnPropertyChanged</span><span class="p">([</span><span class="n">CallerMemberName</span><span class="p">]</span> <span class="kt">string</span><span class="p">?</span> <span class="n">propertyName</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PropertyChanged</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">new</span> <span class="nf">PropertyChangedEventArgs</span><span class="p">(</span><span class="n">propertyName</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvvm-toolkit">1.2. MVVM Toolkit</h3>
<div class="paragraph">
<p>The <code>CommunityToolkit.Mvvm</code> package (aka MVVM Toolkit, formerly named <code>Microsoft.Toolkit.Mvvm</code>) is a modern, fast, and modular MVVM library. <a href="#communitytoolkit">[2]</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">dotnet add package CommunityToolkit.Mvvm <span class="c"># --version 8.3.1</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//communitytoolkit.mvvm.componentmodel"><em>CommunityToolkit.Mvvm.ComponentModel</em></a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/observableobject">ObservableObject</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ObservableObject</span> <span class="p">:</span> <span class="n">INotifyPropertyChanged</span><span class="p">,</span> <span class="n">INotifyPropertyChanging</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MainViewModel</span> <span class="p">:</span> <span class="n">ObservableObject</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">string</span><span class="p">?</span> <span class="n">_title</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">Title</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">_title</span><span class="p">;</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="k">ref</span> <span class="n">_title</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">TaskNotifier</span><span class="p">?</span> <span class="n">myTask</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">Task</span><span class="p">?</span> <span class="n">MyTask</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">myTask</span><span class="p">;</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetPropertyAndNotifyOnCompletion</span><span class="p">(</span><span class="k">ref</span> <span class="n">myTask</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;StackPanel&gt;</span>
    <span class="nt">&lt;Label</span> <span class="na">Content=</span><span class="s">"{Binding MyTask.Status}"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;TextBox</span> <span class="na">Text=</span><span class="s">"{Binding Title}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/observablerecipient">ObservableRecipient</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ObservableRecipient</span> <span class="p">:</span> <span class="n">ObservableObject</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MainViewModel</span> <span class="p">:</span> <span class="n">ObservableRecipient</span><span class="p">,</span> <span class="n">IRecipient</span><span class="p">&lt;</span><span class="n">RequestMessage</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Receive</span><span class="p">(</span><span class="n">RequestMessage</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">message</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MainViewModel</span> <span class="p">:</span> <span class="n">ObservableRecipient</span>
<span class="p">{</span>
    <span class="c1">// For best results and to avoid memory leaks, it's recommended to use OnActivated to register</span>
    <span class="c1">// to messages, and to use OnDeactivated to do cleanup operations.</span>
    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnActivated</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="n">Messenger</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">MainViewModel</span><span class="p">,</span> <span class="n">RequestMessage</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;&gt;(</span><span class="k">this</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">r</span><span class="p">.</span><span class="nf">Receive</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>

    <span class="c1">// By default, OnDeactivated automatically unregisters the current instance from all registered messages.</span>
    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnDeactivated</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">base</span><span class="p">.</span><span class="nf">OnDeactivated</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Receive</span><span class="p">(</span><span class="n">RequestMessage</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">message</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/observablevalidator">ObservableValidator</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ObservableValidator</span> <span class="p">:</span> <span class="n">ObservableObject</span><span class="p">,</span> <span class="n">INotifyDataErrorInfo</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">RegistrationForm</span> <span class="p">:</span> <span class="n">ObservableValidator</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>

    <span class="p">[</span><span class="n">Required</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">MinLength</span><span class="p">(</span><span class="m">2</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">MaxLength</span><span class="p">(</span><span class="m">100</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">name</span><span class="p">;</span>
        <span class="c1">// Here we are calling the SetProperty&lt;T&gt;(ref T, T, bool, string) method exposed</span>
        <span class="c1">// by ObservableValidator, and that additional bool parameter set to true indicates</span>
        <span class="c1">// that we also want to validate the property when its value is updated.</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="k">ref</span> <span class="n">name</span><span class="p">,</span> <span class="k">value</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;TextBox</span> <span class="na">Text=</span><span class="s">"{Binding Name, ValidatesOnDataErrors=True}"</span> <span class="nt">/&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/observableproperty">ObservableProperty</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="p">[</span><span class="n">ObservableProperty</span><span class="p">]</span>
<span class="p">[</span><span class="nf">NotifyPropertyChangedFor</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">FullName</span><span class="p">))]</span> <span class="c1">// Notifying dependent properties</span>
<span class="p">[</span><span class="nf">NotifyCanExecuteChangedFor</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">MyCommand</span><span class="p">))]</span> <span class="c1">// Notifying dependent commands</span>
<span class="p">[</span><span class="n">NotifyDataErrorInfo</span><span class="p">]</span> <span class="c1">// Requesting property validation</span>
<span class="p">[</span><span class="n">Required</span><span class="p">]</span>
<span class="p">[</span><span class="nf">MinLength</span><span class="p">(</span><span class="m">2</span><span class="p">)]</span> <span class="c1">// Any other validation attributes too...</span>
<span class="p">[</span><span class="n">NotifyPropertyChangedRecipients</span><span class="p">]</span> <span class="c1">// Sending notification messages [PropertyChangedMessage&lt;T&gt;]</span>
<span class="p">[</span><span class="n">property</span><span class="p">:</span> <span class="nf">JsonPropertyName</span><span class="p">(</span><span class="s">"name"</span><span class="p">)]</span> <span class="c1">// Adding custom attributes</span>
<span class="k">private</span> <span class="kt">string</span><span class="p">?</span> <span class="n">_name</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/inotifypropertychanged">INotifyPropertyChanged</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// only use in cases where the target types cannot just inherit from the equivalent</span>
<span class="c1">// types (eg. from ObservableObject).</span>
<span class="p">[</span><span class="n">INotifyPropertyChanged</span><span class="p">]</span>
<span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MyViewModel</span> <span class="p">:</span> <span class="n">SomeOtherType</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//communitytoolkit.mvvm.dependencyinjection"><em>CommunityToolkit.Mvvm.DependencyInjection</em></a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/ioc">Ioc</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">dotnet add package Microsoft.Extensions.DependencyInjection <span class="c"># --version 8.0.0</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">App</span> <span class="p">:</span> <span class="n">Application</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IServiceProvider</span> <span class="n">Services</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">App</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Services</span> <span class="p">=</span> <span class="nf">ConfigureServices</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnStartup</span><span class="p">(</span><span class="n">StartupEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">mainWindow</span> <span class="p">=</span> <span class="n">Services</span><span class="p">.</span><span class="n">GetRequiredService</span><span class="p">&lt;</span><span class="n">MainWindow</span><span class="p">&gt;();</span>
        <span class="n">mainWindow</span><span class="p">.</span><span class="nf">Show</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">ServiceProvider</span> <span class="nf">ConfigureServices</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">services</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServiceCollection</span><span class="p">();</span>

        <span class="n">services</span><span class="p">.</span><span class="n">AddTransient</span><span class="p">&lt;</span><span class="n">MainWindow</span><span class="p">&gt;();</span>
        <span class="n">services</span><span class="p">.</span><span class="n">AddTransient</span><span class="p">&lt;</span><span class="n">MainViewModel</span><span class="p">&gt;();</span>

        <span class="k">return</span> <span class="n">services</span><span class="p">.</span><span class="nf">BuildServiceProvider</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//communitytoolkit.mvvm.input"><em>CommunityToolkit.Mvvm.Input</em></a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/relaycommand">RelayCommand</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/relaycommand">RelayCommand&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/asyncrelaycommand">AsyncRelayCommand</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/asyncrelaycommand">AsyncRelayCommand&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/irelaycommand">IRelayCommand</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/irelaycommand">IRelayCommand&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/iasyncrelaycommand">IAsyncRelayCommand</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/iasyncrelaycommand">IAsyncRelayCommand&lt;T&gt;</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MainViewModel</span> <span class="p">:</span> <span class="n">ObservableObject</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IRelayCommand</span> <span class="n">OKCommand</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RelayCommand</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">true</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">IAsyncRelayCommand</span> <span class="n">CancelCommand</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AsyncRelayCommand</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/relaycommand">RelayCommand</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="p">[</span><span class="nf">RelayCommand</span><span class="p">(</span><span class="n">CanExecute</span> <span class="p">=</span> <span class="k">nameof</span><span class="p">(</span><span class="n">CanGreetUser</span><span class="p">))]</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">GreetUser</span><span class="p">(</span><span class="n">User</span><span class="p">?</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Hello </span><span class="p">{</span><span class="n">user</span><span class="p">!.</span><span class="n">Name</span><span class="p">}</span><span class="s">!"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="kt">bool</span> <span class="nf">CanGreetUser</span><span class="p">(</span><span class="n">User</span><span class="p">?</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">user</span> <span class="k">is</span> <span class="n">not</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">[</span><span class="n">ObservableProperty</span><span class="p">]</span>
<span class="p">[</span><span class="nf">NotifyCanExecuteChangedFor</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">GreetUserCommand</span><span class="p">))]</span>
<span class="k">private</span> <span class="n">User</span><span class="p">?</span> <span class="n">selectedUser</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Call IAsyncRelayCommand.Cancel to signal that token.</span>
<span class="p">[</span><span class="nf">RelayCommand</span><span class="p">(</span><span class="n">IncludeCancelCommand</span> <span class="p">=</span> <span class="k">true</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoWorkAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Do some long running work...</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//communitytoolkit.mvvm.messaging"><em>CommunityToolkit.Mvvm.Messaging</em></a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/messenger">IMessenger</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/messenger">WeakReferenceMessenger</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/messenger">StrongReferenceMessenger</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/messenger">IRecipient&lt;TMessage&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/messenger">MessageHandler&lt;TRecipient, TMessage&gt;</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//communitytoolkit.mvvm.messaging.messages"><em>CommunityToolkit.Mvvm.Messaging.Messages</em></a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//CommunityToolkit.mvvm.Messaging.Messages.PropertyChangedMessage-1">PropertyChangedMessage&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//CommunityToolkit.mvvm.Messaging.Messages.RequestMessage-1">RequestMessage&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//CommunityToolkit.mvvm.Messaging.Messages.AsyncRequestMessage-1">AsyncRequestMessage&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//CommunityToolkit.mvvm.Messaging.Messages.CollectionRequestMessage-1">CollectionRequestMessage&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//CommunityToolkit.mvvm.Messaging.Messages.AsyncCollectionRequestMessage-1">AsyncCollectionRequestMessage&lt;T&gt;</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api//CommunityToolkit.mvvm.Messaging.Messages.ValueChangedMessage-1">ValueChangedMessage&lt;T&gt;</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-binding">2. Data binding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Data binding is the process that establishes a connection between the app UI and the data it displays.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the binding has the correct settings and the data provides the proper notifications, when the data changes its value, the elements that are bound to the data reflect changes automatically.</p>
</li>
<li>
<p>Data binding can also mean that if an outer representation of the data in an element changes, then the underlying data can be automatically updated to reflect the change.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Typically, each binding has four components:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/basic-data-binding-diagram.png" alt="Diagram that shows the basic data binding model.">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A binding target object.</p>
</li>
<li>
<p>A target property.</p>
</li>
<li>
<p>A binding source.</p>
</li>
<li>
<p>A path to the value in the binding source to use.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, to bound the content of a <code>TextBox</code> to the <code>Employee.Name</code> property:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Target: <code>TextBox</code></p>
</li>
<li>
<p>Target property: 	<code>Text</code></p>
</li>
<li>
<p>Source object: 	<code>Employee</code></p>
</li>
<li>
<p>Source object value path: 	<code>Name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A binding contains all the information that can be shared across several binding expressions. A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.bindingexpression">BindingExpression</a> is an instance expression that cannot be shared and contains all the instance information of the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding">Binding</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Make a new source</span>
<span class="kt">var</span> <span class="n">myDataObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MyData</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">myBinding</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Binding</span><span class="p">(</span><span class="s">"ColorName"</span><span class="p">)</span> <span class="p">{</span> <span class="n">Source</span> <span class="p">=</span> <span class="n">myDataObject</span> <span class="p">};</span>

<span class="c1">// Bind the data source to the TextBox control's Text dependency property</span>
<span class="n">myText</span><span class="p">.</span><span class="nf">SetBinding</span><span class="p">(</span><span class="n">TextBlock</span><span class="p">.</span><span class="n">TextProperty</span><span class="p">,</span> <span class="n">myBinding</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A binding source object can be treated either as a single object whose properties contain data or as a data collection of polymorphic objects that are often grouped together (such as the result of a query to a database).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/data-binding-itemscontrol.png" alt="Diagram that shows the data binding ItemsControl object.">
</div>
</div>
<div class="paragraph">
<p>Any collection that implements the <code>IEnumerable</code> interface can be enumerated over. However, to set up dynamic bindings so that insertions or deletions in the collection update the UI automatically, the collection must implement the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged">INotifyCollectionChanged</a> interface.</p>
</div>
<div class="paragraph">
<p>WPF provides the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1">ObservableCollection&lt;T&gt;</a> class, which is a built-in implementation of a data collection that exposes the <code>INotifyCollectionChanged</code> interface.</p>
</div>
<div class="paragraph">
<p>To fully support transferring data values from source objects to targets, each object in your collection that supports bindable properties must also implement the <code>INotifyPropertyChanged</code> interface.</p>
</div>
<div class="paragraph">
<p>A collection view is a layer on top of a binding source collection that allows you to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A collection view also maintains a pointer to the current item in the collection.</p>
<div class="paragraph">
<p>If the source collection implements the <code>INotifyCollectionChanged</code> interface, the changes raised by the <code>CollectionChanged</code> event are propagated to the views.</p>
</div>
</li>
<li>
<p>Because views do not change the underlying source collections, each source collection can have multiple views associated with it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.itemscontrol">ItemsControl</a> is bound to a data collection, the data may need to be sorted, filtered, or grouped. To do that, use collection views, which are classes that implement the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.icollectionview">ICollectionView</a> interface.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A collection view is a layer on top of a binding source collection that allows to navigate and display the source collection based on sort, filter, and group queries, without having to change the underlying source collection itself.</p>
</li>
<li>
<p>A collection view also maintains a pointer to the current item in the collection.</p>
<div class="paragraph">
<p>If the source collection implements the <code>INotifyCollectionChanged</code> interface, the changes raised by the <code>CollectionChanged</code> event are propagated to the views.</p>
</div>
</li>
<li>
<p>Because views do not change the underlying source collections, each source collection can have multiple views associated with it.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="nt">&lt;CollectionViewSource</span>
      <span class="na">Source=</span><span class="s">"{Binding Source={x:Static Application.Current}, Path=AuctionItems}"</span>
      <span class="na">x:Key=</span><span class="s">"listingDataView"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;ListBox</span> <span class="na">Name=</span><span class="s">"Master"</span> <span class="na">Grid.Row=</span><span class="s">"2"</span> <span class="na">Grid.ColumnSpan=</span><span class="s">"3"</span> <span class="na">Margin=</span><span class="s">"8"</span>
         <span class="na">ItemsSource=</span><span class="s">"{Binding Source={StaticResource listingDataView}}"</span> <span class="nt">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">private</span> <span class="k">void</span> <span class="nf">AddSortCheckBox_Checked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Sort the items first by Category and then by StartDate</span>
    <span class="n">listingDataView</span><span class="p">.</span><span class="n">SortDescriptions</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">SortDescription</span><span class="p">(</span><span class="s">"Category"</span><span class="p">,</span> <span class="n">ListSortDirection</span><span class="p">.</span><span class="n">Ascending</span><span class="p">));</span>
    <span class="n">listingDataView</span><span class="p">.</span><span class="n">SortDescriptions</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">SortDescription</span><span class="p">(</span><span class="s">"StartDate"</span><span class="p">,</span> <span class="n">ListSortDirection</span><span class="p">.</span><span class="n">Ascending</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">private</span> <span class="k">void</span> <span class="nf">AddFilteringCheckBox_Checked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">CheckBox</span><span class="p">)</span><span class="n">sender</span><span class="p">).</span><span class="n">IsChecked</span> <span class="p">==</span> <span class="k">true</span><span class="p">)</span>
        <span class="n">listingDataView</span><span class="p">.</span><span class="n">Filter</span> <span class="p">+=</span> <span class="n">ListingDataView_Filter</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">listingDataView</span><span class="p">.</span><span class="n">Filter</span> <span class="p">-=</span> <span class="n">ListingDataView_Filter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">ListingDataView_Filter</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">FilterEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Start with everything excluded</span>
    <span class="n">e</span><span class="p">.</span><span class="n">Accepted</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="c1">// Only inlcude items with a price less than 25</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Item</span> <span class="k">is</span> <span class="n">AuctionItem</span> <span class="n">product</span> <span class="p">&amp;&amp;</span> <span class="n">product</span><span class="p">.</span><span class="n">CurrentPrice</span> <span class="p">&lt;</span> <span class="m">25</span><span class="p">)</span>
        <span class="n">e</span><span class="p">.</span><span class="n">Accepted</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// This groups the items in the view by the property "Category"</span>
<span class="kt">var</span> <span class="n">groupDescription</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PropertyGroupDescription</span><span class="p">();</span>
<span class="n">groupDescription</span><span class="p">.</span><span class="n">PropertyName</span> <span class="p">=</span> <span class="s">"Category"</span><span class="p">;</span>
<span class="n">listingDataView</span><span class="p">.</span><span class="n">GroupDescriptions</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">groupDescription</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="data-context">2.1. Data context</h3>
<div class="paragraph">
<p>When data binding is declared on XAML elements, they resolve data binding by looking at their immediate <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement.datacontext">DataContext</a> property.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The data context is typically the <strong>binding source object</strong> for the <strong>binding source value path</strong> evaluation.</p>
</li>
<li>
<p>If the <code>DataContext</code> property for the object hosting the binding isn&#8217;t set, the parent element&#8217;s <code>DataContext</code> property is checked, and so on, up until the root of the XAML object tree.</p>
</li>
<li>
<p>In short, the data context used to resolve binding is inherited from the parent unless explicitly set on the object.</p>
</li>
<li>
<p>Bindings can be configured to resolve with a specific object, as opposed to using the data context for binding resolution.</p>
</li>
<li>
<p>When the <code>DataContext</code> property changes, all bindings that could be affected by the data context are reevaluated.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="data-flow">2.2. Data flow</h3>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/databinding-dataflow.png" alt="Data binding data flow">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>OneWay</strong> binding causes changes to the source property to automatically update the target property, but changes to the target property are not propagated back to the source property, which is appropriate if the control being bound is implicitly read-only.</p>
</li>
<li>
<p><strong>TwoWay</strong> binding causes changes to either the source property or the target property to automatically update the other, which is appropriate for editable forms or other fully interactive UI scenarios..</p>
<div class="paragraph">
<p>Most properties default to <code>OneWay</code> binding, but some dependency properties (typically properties of user-editable controls such as the <code>TextBox.Text</code> and <code>CheckBox.IsChecked</code> default to <code>TwoWay</code> binding. A programmatic way to determine whether a dependency property binds one-way or two-way by default is to get the property metadata with <code>DependencyProperty.GetMetadata</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">if</span> <span class="p">(</span><span class="n">TextBox</span><span class="p">.</span><span class="n">TextProperty</span><span class="p">.</span><span class="nf">GetMetadata</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">TextBox</span><span class="p">))</span> <span class="k">is</span> <span class="n">FrameworkPropertyMetadata</span> <span class="n">meta</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">meta</span><span class="p">.</span><span class="n">BindsTwoWayByDefault</span><span class="p">}</span><span class="s">"</span><span class="p">);</span> <span class="c1">// True</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>OneWayToSource</strong> is the reverse of <strong>OneWay</strong> binding; it updates the source property when the target property changes, which is appropriate if you only need to reevaluate the source value from the UI.</p>
</li>
<li>
<p><strong>OneTime</strong> binding causes the source property to initialize the target property but doesn&#8217;t propagate subsequent changes which is appropriate if either a snapshot of the current state is appropriate or the data is truly static.</p>
<div class="paragraph">
<p>If the data context changes or the object in the data context changes, the change is not reflected in the target property.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To detect source changes (applicable to <strong>OneWay</strong> and <strong>TwoWay</strong> bindings), the source must implement a suitable property change notification mechanism such as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged">INotifyPropertyChanged</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bindings that are <strong>TwoWay</strong> or <strong>OneWayToSource</strong> listen for changes in the target property and propagate them back to the source, known as updating the source.</p>
</div>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding.updatesourcetrigger#system-windows-data-binding-updatesourcetrigger">Binding.UpdateSourceTrigger</a> property determines what triggers the update of the source.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/data-binding-updatesource-trigger.png" alt="Diagram that shows the role of the UpdateSourceTrigger property.">
</div>
</div>
<div class="paragraph">
<p>If the <code>UpdateSourceTrigger</code> value is <code>UpdateSourceTrigger.PropertyChanged</code>, then the value pointed to by the right arrow of <code>TwoWay</code> or the <code>OneWayToSource</code> bindings is updated as soon as the target property changes.</p>
</div>
<div class="paragraph">
<p>However, if the <code>UpdateSourceTrigger</code> value is <code>LostFocus</code>, then that value only is updated with the new value when the target property loses focus.</p>
</div>
<div class="paragraph">
<p>If the UpdateSourceTrigger value of the binding is set to <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.updatesourcetrigger?view=windowsdesktop-8.0#system-windows-data-updatesourcetrigger-explicit">Explicit</a>, the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.bindingexpression.updatesource">UpdateSource</a> method must be called or the changes will not propagate back to the source.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">textBlock</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TextBlock</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">nameBindingObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Binding</span><span class="p">(</span><span class="s">"Name"</span><span class="p">);</span>
<span class="n">nameBindingObject</span><span class="p">.</span><span class="n">UpdateSourceTrigger</span> <span class="p">=</span> <span class="n">UpdateSourceTrigger</span><span class="p">.</span><span class="n">Explicit</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="n">textBlock</span><span class="p">.</span><span class="nf">SetBinding</span><span class="p">(</span><span class="n">TextBlock</span><span class="p">.</span><span class="n">TextProperty</span><span class="p">,</span> <span class="n">nameBindingObject</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">bindingExpression</span> <span class="p">=</span> <span class="n">textBlock</span><span class="p">.</span><span class="nf">GetBindingExpression</span><span class="p">(</span><span class="n">TextBlock</span><span class="p">.</span><span class="n">TextProperty</span><span class="p">);</span>
<span class="n">bindingExpression</span><span class="p">.</span><span class="nf">UpdateSource</span><span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data-conversion">2.3. Data conversion</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="p">[</span><span class="nf">ValueConversion</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Color</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">SolidColorBrush</span><span class="p">))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ColorBrushConverter</span> <span class="p">:</span> <span class="n">IValueConverter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Globalization</span><span class="p">.</span><span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Color</span> <span class="n">color</span> <span class="p">=</span> <span class="p">(</span><span class="n">Color</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">SolidColorBrush</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">ConvertBack</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Globalization</span><span class="p">.</span><span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/data-binding-button-default-conversion.png" alt="Diagram that shows the data binding Default property.">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Provides a way to apply custom logic to a binding.</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;remarks&gt;Value converters are culture-aware. Both the Convert and ConvertBack methods have a culture parameter that indicates the cultural information.&lt;/remarks&gt;</span>
<span class="k">public</span> <span class="k">interface</span> <span class="nc">IValueConverter</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// The data binding engine calls this method when it propagates a value from the binding source to the binding target.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name="value"&gt;The value produced by the binding source.&lt;/param&gt;</span>
    <span class="c1">/// &lt;param name="targetType"&gt;The type of the binding target property.&lt;/param&gt;</span>
    <span class="c1">/// &lt;param name="parameter"&gt;The converter parameter to use.&lt;/param&gt;</span>
    <span class="c1">/// &lt;param name="culture"&gt;The culture to use in the converter.&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt;</span>
    <span class="c1">/// &lt;remarks&gt;</span>
    <span class="c1">/// A return value of &lt;see cref="DependencyProperty.UnsetValue"/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref="BindingBase.FallbackValue"/&gt;, if available, or the default value instead.</span>
    <span class="c1">/// A return value of &lt;see cref="Binding.DoNothing"/&gt; indicates that the binding does not transfer the value or use the &lt;see cref="BindingBase.FallbackValue"/&gt; or default value.</span>
    <span class="c1">/// &lt;/remarks&gt;</span>
    <span class="kt">object</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">);</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// The data binding engine calls this method when it propagates a value from the binding target to the binding source.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name="value"&gt;The value that is produced by the binding target.&lt;/param&gt;</span>
    <span class="c1">/// &lt;param name="targetType"&gt;The type to convert to.&lt;/param&gt;</span>
    <span class="c1">/// &lt;param name="parameter"&gt;The converter parameter to use.&lt;/param&gt;</span>
    <span class="c1">/// &lt;param name="culture"&gt;The culture to use in the converter.&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;A converted value. If the method returns null, the valid null value is used.&lt;/returns&gt;</span>
    <span class="c1">/// &lt;remarks&gt;</span>
    <span class="c1">/// A return value of &lt;see cref="DependencyProperty.UnsetValue"/&gt; indicates that the converter produced no value and that the binding uses the &lt;see cref="BindingBase.FallbackValue"/&gt;, if available, or the default value instead.</span>
    <span class="c1">/// A return value of &lt;see cref="Binding.DoNothing"/&gt; indicates that the binding does not transfer the value or use the &lt;see cref="BindingBase.FallbackValue"/&gt; or default value.</span>
    <span class="c1">/// &lt;/remarks&gt;</span>
    <span class="kt">object</span> <span class="nf">ConvertBack</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data-validation">2.4. Data validation</h3>
<div class="paragraph">
<p>WPF has two types of built-in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.validationrule">ValidationRule</a> objects to check whether the value of a property is valid.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.exceptionvalidationrule">ExceptionValidationRule</a> checks for exceptions thrown during the update of the binding source property.</p>
<div class="paragraph">
<p>An alternative syntax to setting the <code>ExceptionValidationRule</code> explicitly is to set the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding.validatesonexceptions">ValidatesOnExceptions</a> property to <code>true</code> on a <code>Binding</code> or <code>MultiBinding</code> object.</p>
</div>
</li>
<li>
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.dataerrorvalidationrule">DataErrorValidationRule</a> object checks for errors that are raised by objects that implement the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.idataerrorinfo">IDataErrorInfo</a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifydataerrorinfo">INotifyDataErrorInfo</a> interface.</p>
<div class="paragraph">
<p>An alternative syntax to setting the <code>DataErrorValidationRule</code> explicitly is to set the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding.validatesondataerrors">ValidatesOnDataErrors</a> property to <code>true</code> on a <code>Binding</code> or <code>MultiBinding</code> object.</p>
</div>
</li>
<li>
<p>Custom validation rule  objects can also be defined by deriving from the <code>ValidationRule</code> class and implementing the <code>Validate</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One way to provide some feedback about the error on the app UI is to set the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.validation.errortemplate">Validation.ErrorTemplate</a> attached property to a custom <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.controltemplate">ControlTemplate</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;ControlTemplate</span> <span class="na">x:Key=</span><span class="s">"validationTemplate"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;DockPanel&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Foreground=</span><span class="s">"Red"</span> <span class="na">FontSize=</span><span class="s">"20"</span><span class="nt">&gt;</span>!<span class="nt">&lt;/TextBlock&gt;</span>
        <span class="c">&lt;!-- The AdornedElementPlaceholder element specifies where the control being adorned should be placed. --&gt;</span>
        <span class="nt">&lt;AdornedElementPlaceholder/&gt;</span>
    <span class="nt">&lt;/DockPanel&gt;</span>
<span class="nt">&lt;/ControlTemplate&gt;</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/demo-validation-date.png?view=netdesktop-8.0" alt="Data binding validation error for date">
</div>
</div>
<div class="paragraph">
<p>In addition, the error message may also be displayed using a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.tooltip">ToolTip</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Style</span> <span class="na">x:Key=</span><span class="s">"textStyleTextBox"</span> <span class="na">TargetType=</span><span class="s">"TextBox"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Foreground"</span> <span class="na">Value=</span><span class="s">"#333333"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"MaxLength"</span> <span class="na">Value=</span><span class="s">"40"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Width"</span> <span class="na">Value=</span><span class="s">"392"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;Style.Triggers&gt;</span>
        <span class="nt">&lt;Trigger</span> <span class="na">Property=</span><span class="s">"Validation.HasError"</span> <span class="na">Value=</span><span class="s">"true"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"ToolTip"</span>
                    <span class="na">Value=</span><span class="s">"{Binding (Validation.Errors).CurrentItem.ErrorContent, RelativeSource={RelativeSource Self}}"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/Trigger&gt;</span>
    <span class="nt">&lt;/Style.Triggers&gt;</span>
<span class="nt">&lt;/Style&gt;</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/demo-validation-price.png?view=netdesktop-8.0" alt="Data binding validation error for price">
</div>
</div>
</div>
<div class="sect2">
<h3 id="binding-path">2.5. Binding path</h3>
<div class="paragraph">
<p>If the binding source is an object, use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding.path#system-windows-data-binding-path">Binding.Path</a> property to specify the value to use for the binding. If binding to XML data, use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding.xpath#system-windows-data-binding-xpath">Binding.XPath</a> property to specify the value.</p>
</div>
<div class="paragraph">
<p>Use the <code>Path</code> property to specify the source value to bind to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the simplest case, the <code>Path</code> property value is the name of the property of the source object to use for the binding, such as <code>Path=PropertyName</code>.</p>
</li>
<li>
<p>Subproperties of a property can be specified by a similar syntax as in C#.</p>
<div class="paragraph">
<p>For instance, the clause <code>Path=ShoppingCart.Order</code> sets the binding to the subproperty <code>Order</code> of the object or property <code>ShoppingCart</code>.</p>
</div>
</li>
<li>
<p>To bind to an attached property, place parentheses around the attached property.</p>
<div class="paragraph">
<p>For example, to bind to the attached property <code>DockPanel.Dock</code>, the syntax is <code>Path=(DockPanel.Dock)</code>.</p>
</div>
</li>
<li>
<p>Indexers of a property can be specified within square brackets following the property name where the indexer is applied.</p>
<div class="paragraph">
<p>For instance, the clause <code>Path=ShoppingCart[0]</code> sets the binding to the index that corresponds to how your property&#8217;s internal indexing handles the literal string "0".</p>
</div>
<div class="paragraph">
<p>Nested indexers are also supported.</p>
</div>
</li>
<li>
<p>Indexers and subproperties can be mixed in a <code>Path</code> clause; for example, <code>Path=ShoppingCart.ShippingInfo[MailingAddress,Street]</code>.</p>
</li>
<li>
<p>Inside indexers, there can be multiple indexer parameters separated by commas (<code>,</code>). The type of each parameter can be specified with parentheses.</p>
<div class="paragraph">
<p>For example, <code>Path="[(sys:Int32)42,(sys:Int32)24]"</code>, where <code>sys</code> is mapped to the <code>System</code> namespace.</p>
</div>
</li>
<li>
<p>When the source is a collection view, the current item can be specified with a slash (<code>/</code>).</p>
<div class="paragraph">
<p>For example, the clause <code>Path=/</code> sets the binding to the current item in the view.</p>
</div>
<div class="paragraph">
<p>When the source is a collection, this syntax specifies the current item of the default collection view.</p>
</div>
</li>
<li>
<p>Property names and slashes can be combined to traverse properties that are collections.</p>
<div class="paragraph">
<p>For example, <code>Path=/Offices/ManagerName</code> specifies the current item of the source collection, which contains an <code>Offices</code> property that is also a collection. Its current item is an object that contains a <code>ManagerName</code> property.</p>
</div>
</li>
<li>
<p>Optionally, a period (<code>.</code>) path can be used to bind to the current source.</p>
<div class="paragraph">
<p>For example, <code>Text="{Binding}"</code> is equivalent to <code>Text="{Binding Path=.}"</code>.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="binding-source">2.6. Binding source</h3>
<div class="paragraph">
<p>Using the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement.datacontext">DataContext</a> property on a parent element is useful when binding multiple properties to the same source. However, sometimes it may be more appropriate to specify the binding source on individual binding declarations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;DockPanel</span> <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
           <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
           <span class="na">xmlns:c=</span><span class="s">"clr-namespace:SDKSample"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;DockPanel.Resources&gt;</span>
        <span class="nt">&lt;c:MyData</span> <span class="na">x:Key=</span><span class="s">"myDataSource"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/DockPanel.Resources&gt;</span>
    <span class="nt">&lt;DockPanel.DataContext&gt;</span>
        <span class="nt">&lt;Binding</span> <span class="na">Source=</span><span class="s">"{StaticResource myDataSource}"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/DockPanel.DataContext&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Background=</span><span class="s">"{Binding Path=ColorName}"</span>
            <span class="na">Width=</span><span class="s">"150"</span> <span class="na">Height=</span><span class="s">"30"</span><span class="nt">&gt;</span>
        I am bound to be RED!
    <span class="nt">&lt;/Button&gt;</span>
<span class="nt">&lt;/DockPanel&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;DockPanel</span> <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
           <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
           <span class="na">xmlns:c=</span><span class="s">"clr-namespace:SDKSample"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;DockPanel.Resources&gt;</span>
        <span class="nt">&lt;c:MyData</span> <span class="na">x:Key=</span><span class="s">"myDataSource"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/DockPanel.Resources&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Background=</span><span class="s">"{Binding Source={StaticResource myDataSource}, Path=ColorName}"</span>
            <span class="na">Width=</span><span class="s">"150"</span> <span class="na">Height=</span><span class="s">"30"</span><span class="nt">&gt;</span>
        I am bound to be RED!
    <span class="nt">&lt;/Button&gt;</span>
<span class="nt">&lt;/DockPanel&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding.elementname?view=windowsdesktop-8.0">Binding.ElementName</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding.relativesource?view=windowsdesktop-8.0">Binding.RelativeSource</a> properties also be used to set the source of the binding explicitly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;StackPanel&gt;</span>
    <span class="nt">&lt;Slider</span>
        <span class="na">Name=</span><span class="s">"RectangleHeight"</span>
        <span class="na">Width=</span><span class="s">"100"</span>
        <span class="na">HorizontalAlignment=</span><span class="s">"Left"</span>
        <span class="na">Maximum=</span><span class="s">"72"</span>
        <span class="na">Minimum=</span><span class="s">"5"</span>
        <span class="na">Orientation=</span><span class="s">"Horizontal"</span>
        <span class="na">Value=</span><span class="s">"16"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">FontSize=</span><span class="s">"{Binding ElementName=RectangleHeight, Path=Value}"</span><span class="nt">&gt;</span>Hello World!<span class="nt">&lt;/Button&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="binding-in-xaml">2.7. Binding in XAML</h3>
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding">Binding</a> is a markup extension.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When using the binding extension to declare a binding, the declaration consists of a series of clauses following the Binding keyword and separated by commas (,).</p>
</li>
<li>
<p>The clauses in the binding declaration can be in any order and there are many possible combinations.</p>
</li>
<li>
<p>The clauses are <code>Name=Value</code> pairs, where <code>Name</code> is the name of the Binding property and <code>Value</code> is the value for the property.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When creating binding declaration strings in markup, they must be attached to the specific dependency property of a target object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Source={StaticResource myDataSource}, Path=Name}"</span><span class="nt">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Object element syntax is an alternative to creating the binding declaration. In most cases, there&#8217;s no particular advantage to using either the markup extension or the object element syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;TextBlock&gt;</span>
    <span class="nt">&lt;TextBlock.Text&gt;</span>
        <span class="nt">&lt;Binding</span> <span class="na">Source=</span><span class="s">"{StaticResource myDataSource}"</span> <span class="na">Path=</span><span class="s">"Name"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/TextBlock.Text&gt;</span>
<span class="nt">&lt;/TextBlock&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="binding-in-code">2.8. Binding in code</h3>
<div class="paragraph">
<p>Another way to specify a binding is to set properties directly on a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding">Binding</a> object in code, and then assign the binding to a property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">private</span> <span class="k">void</span> <span class="nf">Window_Loaded</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make a new data source object</span>
    <span class="kt">var</span> <span class="n">personDetails</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Person</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Name</span> <span class="p">=</span> <span class="s">"John"</span><span class="p">,</span>
        <span class="n">Birthdate</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">"2001-02-03"</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// New binding object using the path of 'Name' for whatever source object is used</span>
    <span class="kt">var</span> <span class="n">nameBindingObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Binding</span><span class="p">(</span><span class="s">"Name"</span><span class="p">);</span>

    <span class="c1">// Configure the binding</span>
    <span class="n">nameBindingObject</span><span class="p">.</span><span class="n">Mode</span> <span class="p">=</span> <span class="n">BindingMode</span><span class="p">.</span><span class="n">OneWay</span><span class="p">;</span>
    <span class="n">nameBindingObject</span><span class="p">.</span><span class="n">Source</span> <span class="p">=</span> <span class="n">personDetails</span><span class="p">;</span>
    <span class="n">nameBindingObject</span><span class="p">.</span><span class="n">Converter</span> <span class="p">=</span> <span class="n">NameConverter</span><span class="p">.</span><span class="n">Instance</span><span class="p">;</span>
    <span class="n">nameBindingObject</span><span class="p">.</span><span class="n">ConverterCulture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CultureInfo</span><span class="p">(</span><span class="s">"en-US"</span><span class="p">);</span>

    <span class="c1">// Set the binding to a target object. The TextBlock.Name property on the NameBlock UI element</span>
    <span class="n">BindingOperations</span><span class="p">.</span><span class="nf">SetBinding</span><span class="p">(</span><span class="n">NameBlock</span><span class="p">,</span> <span class="n">TextBlock</span><span class="p">.</span><span class="n">TextProperty</span><span class="p">,</span> <span class="n">nameBindingObject</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="property-system">3. Property system</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Windows Presentation Foundation (WPF) provides a set of services that can be used to extend the functionality of a type&#8217;s property. Collectively, these services are referred to as the <strong>WPF property system</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A property that&#8217;s backed by the WPF property system is known as a <strong>dependency property</strong>.</p>
</li>
<li>
<p><strong>Attached properties</strong> are a XAML concept, dependency properties are a WPF concept.</p>
</li>
<li>
<p>Attached properties enable extra property/value pairs to be set on any XAML element that derives from <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.dependencyobject">DependencyObject</a>, even though the element doesn&#8217;t define those extra properties in its object model.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="dependency-properties-and-clr-properties">3.1. Dependency properties and CLR properties</h3>
<div class="paragraph">
<p>WPF properties are typically exposed as standard .NET properties. The purpose of dependency properties is to provide a way to compute the value of a property based on the value of other inputs, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>System properties, such as themes and user preference.</p>
</li>
<li>
<p>Just-in-time property determination mechanisms, such as data binding and animations/storyboards.</p>
</li>
<li>
<p>Multiple-use templates, such as resources and styles.</p>
</li>
<li>
<p>Values known through parent-child relationships with other elements in the element tree.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also, a dependency property can provide:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Self-contained validation.</p>
</li>
<li>
<p>Default values.</p>
</li>
<li>
<p>Callbacks that monitor changes to other properties.</p>
</li>
<li>
<p>A system that can coerce property values based on runtime information.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Derived classes can change some characteristics of an existing property by overriding the metadata of a dependency property, rather than overriding the actual implementation of existing properties or creating new properties.</p>
</div>
</div>
<div class="sect2">
<h3 id="dependency-properties-back-clr-properties">3.2. Dependency properties back CLR properties</h3>
<div class="paragraph">
<p>Dependency properties and the WPF property system extend property functionality by providing a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.dependencyproperty">DependencyProperty</a> type that backs a property, as an alternative to the standard pattern of backing a property with a private field.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s some commonly used terminology:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Dependency property</strong>, which is a property that&#8217;s backed by a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.dependencyproperty">DependencyProperty</a>.</p>
</li>
<li>
<p><strong>Dependency property identifier</strong>, which is a <code>DependencyProperty</code> instance obtained as a return value when registering a dependency property, and then stored as a static member of a class. Many of the APIs that interact with the WPF property system use the dependency property identifier as a parameter.</p>
</li>
<li>
<p><strong>CLR "wrapper"</strong>, which is the get and set implementations for the property. These implementations incorporate the dependency property identifier by using it in the <code>GetValue</code> and <code>SetValue</code> calls. In this way, the WPF property system provides the backing for the property.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example defines the <code>IsSpinning</code> dependency property to show the relationship of the <code>DependencyProperty</code> identifier to the property that it backs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DependencyProperty</span> <span class="n">IsSpinningProperty</span> <span class="p">=</span> <span class="n">DependencyProperty</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span>
    <span class="s">"IsSpinning"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">bool</span><span class="p">),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">MainWindow</span><span class="p">)</span>
    <span class="p">);</span>

<span class="k">public</span> <span class="kt">bool</span> <span class="n">IsSpinning</span>
<span class="p">{</span>
    <span class="k">get</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">IsSpinningProperty</span><span class="p">);</span>
    <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetValue</span><span class="p">(</span><span class="n">IsSpinningProperty</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The naming convention of the property and its backing <code>DependencyProperty</code> field is important. The name of the field is always the name of the property, with the suffix <code>Property</code> appended.</p>
</div>
</div>
<div class="sect2">
<h3 id="attached-properties">3.3. Attached properties</h3>
<div class="paragraph">
<p>Although any object can set an attached property value, that doesn&#8217;t mean setting a value will produce a tangible result or the value will be used by another object.</p>
</div>
<div class="paragraph">
<p>Attached property usage typically follows one of these models:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The type that defines the attached property is the parent of the elements that set values for the attached property. The parent type iterates its child objects through internal logic that acts on the object tree structure, obtains the values, and acts on those values in some manner.</p>
</li>
<li>
<p>The type that defines the attached property is used as the child element for various possible parent elements and content models.</p>
</li>
<li>
<p>The type that defines the attached property represents a service. Other types set values for the attached property. Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Attached properties in WPF don&#8217;t have the typical CLR <code>get</code> and <code>set</code> wrapper methods because the properties might be set from outside of the CLR namespace.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To permit a XAML processor to set those values when parsing XAML, the class that defines the attached property must implement dedicated accessor methods in the form of <code>Get&lt;property name&gt;</code> and <code>Set&lt;property name&gt;</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Attached properties in code</span>
<span class="n">DockPanel</span> <span class="n">myDockPanel</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
<span class="n">TextBox</span> <span class="n">myTextBox</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
<span class="n">myTextBox</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="s">"Enter text"</span><span class="p">;</span>

<span class="c1">// Add child element to the DockPanel.</span>
<span class="n">myDockPanel</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">myTextBox</span><span class="p">);</span>

<span class="c1">// Set the attached property value.</span>
<span class="n">DockPanel</span><span class="p">.</span><span class="nf">SetDock</span><span class="p">(</span><span class="n">myTextBox</span><span class="p">,</span> <span class="n">Dock</span><span class="p">.</span><span class="n">Top</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">static</span> <span class="n">Dock</span> <span class="nf">GetDock</span><span class="p">(</span><span class="n">UIElement</span> <span class="n">element</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SetDock</span><span class="p">(</span><span class="n">UIElement</span> <span class="n">element</span><span class="p">,</span> <span class="n">Dock</span> <span class="n">dock</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="c">&lt;!-- Attached properties in XAML --&gt;</span>
<span class="nt">&lt;DockPanel&gt;</span>
    <span class="nt">&lt;TextBox</span> <span class="na">DockPanel.Dock=</span><span class="s">"Top"</span><span class="nt">&gt;</span>Enter text<span class="nt">&lt;/TextBox&gt;</span>
<span class="nt">&lt;/DockPanel&gt;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Define attached property as a dependency in the defining class by declaring a <code>public static readonly</code> field of type <code>DependencyProperty</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Then, assign the return value of the <code>RegisterAttached</code> method to the field, which is also known as the <em>dependency property identifier</em>.</p>
</li>
<li>
<p>Follow the WPF property naming convention that distinguishes fields from the properties that they represent, by naming the identifier field <code>&lt;property name&gt;Property</code>.</p>
</li>
<li>
<p>Also, provide static <code>Get&lt;property name&gt;</code> and <code>Set&lt;property name&gt;</code> accessor methods, which lets the property system access the attached property.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">Aquarium</span> <span class="p">:</span> <span class="n">UIElement</span>
<span class="p">{</span>
    <span class="c1">// Register an attached dependency property with the specified</span>
    <span class="c1">// property name, property type, owner type, and property metadata.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DependencyProperty</span> <span class="n">HasFishProperty</span> <span class="p">=</span>
        <span class="n">DependencyProperty</span><span class="p">.</span><span class="nf">RegisterAttached</span><span class="p">(</span>
      <span class="s">"HasFish"</span><span class="p">,</span>
      <span class="k">typeof</span><span class="p">(</span><span class="kt">bool</span><span class="p">),</span>
      <span class="k">typeof</span><span class="p">(</span><span class="n">Aquarium</span><span class="p">),</span>
      <span class="k">new</span> <span class="nf">FrameworkPropertyMetadata</span><span class="p">(</span><span class="n">defaultValue</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
          <span class="n">flags</span><span class="p">:</span> <span class="n">FrameworkPropertyMetadataOptions</span><span class="p">.</span><span class="n">AffectsRender</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">// Declare a get accessor method.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">GetHasFish</span><span class="p">(</span><span class="n">UIElement</span> <span class="n">target</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="n">target</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">HasFishProperty</span><span class="p">);</span>

    <span class="c1">// Declare a set accessor method.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SetHasFish</span><span class="p">(</span><span class="n">UIElement</span> <span class="n">target</span><span class="p">,</span> <span class="kt">bool</span> <span class="k">value</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="n">target</span><span class="p">.</span><span class="nf">SetValue</span><span class="p">(</span><span class="n">HasFishProperty</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>get</code> accessor method signature is <code>public static object Get&lt;property name&gt;(DependencyObject target)</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><code>target</code> is the <code>DependencyObject</code> from which the attached property is read.</p>
<div class="paragraph">
<p>The target type can be more specific than <code>DependencyObject</code>. For example, the <code>DockPanel.GetDock</code> accessor method types the target as <code>UIElement</code> because the attached property is intended to be set on <code>UIElement</code> instances.</p>
</div>
</li>
<li>
<p>The return type can be more specific than <code>object</code>. For example, the <code>GetDock</code> method types the returned value as <code>Dock</code> because the return value should be a <code>Dock</code> enumeration.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>set</code> accessor method signature is <code>public static void Set&lt;property name&gt;(DependencyObject target, object value)</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><code>target</code> is the <code>DependencyObject</code> on which the attached property is written.</p>
<div class="paragraph">
<p>The <code>target</code> type can be more specific than <code>DependencyObject</code>. For example, the <code>SetDock</code> method types the target as <code>UIElement</code> because the attached property is intended to be set on <code>UIElement</code> instances.</p>
</div>
</li>
<li>
<p>The <code>value</code> type can be more specific than <code>object</code>. For example, the <code>SetDock</code> method requires a <code>Dock</code> value.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="property-value-inheritance">3.4. Property value inheritance</h3>
<div class="paragraph">
<p>Property value inheritance is a feature of the Windows Presentation Foundation (WPF) property system and applies to dependency properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Property value inheritance lets child elements in a tree of elements obtain the value of a particular property from the nearest parent element.</p>
</li>
<li>
<p>Since a parent element might also have obtained its property value through property value inheritance, the system potentially recurses back to the page root.</p>
</li>
<li>
<p>The WPF property system doesn&#8217;t enable property value inheritance by default, and value inheritance is inactive unless specifically enabled in dependency property <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.frameworkpropertymetadata.inherits#system-windows-frameworkpropertymetadata-inherits">metadata</a>.</p>
</li>
<li>
<p>Even with property value inheritance enabled, a child element will only inherit a property value in the absence of a higher <a href="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/properties/dependency-property-value-precedence?view=netdesktop-8.0#dependency-property-precedence-list">precedence</a> value.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="routed-events">4. Routed events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Windows Presentation Foundation (WPF) application developers and component authors can use routed events to propagate events through an element tree, and invoke event handlers on multiple listeners in the tree.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From a <strong>functional</strong> perspective, a routed event is a type of event that can invoke handlers on multiple listeners in an element tree, not just on the event source.</p>
<div class="ulist">
<ul>
<li>
<p>An <em>event listener</em> is the element where an <em>event handler</em> is attached and invoked.</p>
</li>
<li>
<p>An <em>event source</em> is the element or object that originally raised an event.</p>
</li>
</ul>
</div>
</li>
<li>
<p>From an <strong>implementation</strong> perspective, a routed event is an event registered with the WPF event system, backed by an instance of the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.routedevent">RoutedEvent</a> class, and processed by the WPF event system.</p>
<div class="ulist">
<ul>
<li>
<p>Typically, a routed event is implemented with a CLR event "wrapper" to enable attaching handlers in XAML and in code-behind as you would a CLR event.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Depending on how a routed event is defined, when the event is raised on a source element it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bubbles</strong> up through element tree from the source element to the root element, which is typically a page or window.</p>
</li>
<li>
<p><strong>Tunnels</strong> down through the element tree from the root element to the source element.</p>
</li>
<li>
<p>Doesn&#8217;t travel through the element tree, and only occurs on the source element <strong>directly</strong>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="routed-event-and-event-handler">4.1. Routed event and event handler</h3>
<div class="paragraph">
<p>A routed event is an event registered with the WPF event system, backed by an instance of the <code>RoutedEvent</code> class, and processed by the WPF event system.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>RoutedEvent</code> instance, obtained from <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.eventmanager.registerroutedevent">registration</a>, is typically stored as a <code>public static readonly</code> member of the "owner" class, that registered it.</p>
</li>
<li>
<p>Typically, a routed event implements an identically named CLR event "wrapper" that is similar to how a dependency property is a CLR property.</p>
<div class="ulist">
<ul>
<li>
<p>The CLR event wrapper contains <code>add</code> and <code>remove</code> accessors to enable attaching handlers in XAML and in code-behind through language-specific event syntax.</p>
</li>
<li>
<p>The <code>add</code> and <code>remove</code> accessors override their CLR implementation and call the routed event <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.uielement.addhandler">AddHandler</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.uielement.removehandler">RemoveHandler</a> methods.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Register a custom routed event using the Bubble routing strategy.</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">RoutedEvent</span> <span class="n">TapEvent</span> <span class="p">=</span> <span class="n">EventManager</span><span class="p">.</span><span class="nf">RegisterRoutedEvent</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s">"Tap"</span><span class="p">,</span>
    <span class="n">routingStrategy</span><span class="p">:</span> <span class="n">RoutingStrategy</span><span class="p">.</span><span class="n">Bubble</span><span class="p">,</span>
    <span class="n">handlerType</span><span class="p">:</span> <span class="k">typeof</span><span class="p">(</span><span class="n">RoutedEventHandler</span><span class="p">),</span>
    <span class="n">ownerType</span><span class="p">:</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CustomButton</span><span class="p">));</span>

<span class="c1">// Provide CLR accessors for adding and removing an event handler.</span>
<span class="k">public</span> <span class="k">event</span> <span class="n">RoutedEventHandler</span> <span class="n">Tap</span>
<span class="p">{</span>
    <span class="k">add</span> <span class="p">{</span> <span class="nf">AddHandler</span><span class="p">(</span><span class="n">TapEvent</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">remove</span> <span class="p">{</span> <span class="nf">RemoveHandler</span><span class="p">(</span><span class="n">TapEvent</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In XAML, attach an event handler to an element by declaring the event name as an attribute on the event listener element.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The attribute value is the handler method name.</p>
</li>
<li>
<p>The handler method must be implemented in the code-behind partial class for the XAML page.</p>
</li>
<li>
<p>The event listener is the element where the event handler is attached and invoked.</p>
</li>
<li>
<p>If the event isn&#8217;t a member of the listener&#8217;s class, use the qualified event name in the form of <code>&lt;owner type&gt;.&lt;event name&gt;</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;StackPanel</span> <span class="na">Button.Click=</span><span class="s">"YesNoCancelButton_Click"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">"YesButton"</span> <span class="na">Click=</span><span class="s">"YesButtonClick"</span><span class="nt">&gt;</span>Yes<span class="nt">&lt;/Button&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">"NoButton"</span> <span class="na">Click=</span><span class="s">"NoButtonClick"</span><span class="nt">&gt;</span>No<span class="nt">&lt;/Button&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">"CancelButton"</span> <span class="na">Click=</span><span class="s">"CancelClick"</span><span class="nt">&gt;</span>Cancel<span class="nt">&lt;/Button&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The signature of the event handler method in code-behind must match the delegate type for the routed event.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">private</span> <span class="k">void</span> <span class="nf">YesNoCancelButtonClick</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>To attach an event handler for a routed event to an element using code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Directly call the <code>AddHandler</code> method.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Routed event handlers can always be attached this way.</span>
<span class="n">Button1</span><span class="p">.</span><span class="nf">AddHandler</span><span class="p">(</span><span class="n">ButtonBase</span><span class="p">.</span><span class="n">ClickEvent</span><span class="p">,</span> <span class="k">new</span> <span class="nf">RoutedEventHandler</span><span class="p">(</span><span class="n">Button_Click</span><span class="p">));</span>
<span class="n">StackPanel1</span><span class="p">.</span><span class="nf">AddHandler</span><span class="p">(</span><span class="n">ButtonBase</span><span class="p">.</span><span class="n">ClickEvent</span><span class="p">,</span> <span class="k">new</span> <span class="nf">RoutedEventHandler</span><span class="p">(</span><span class="n">Button_Click</span><span class="p">));</span></code></pre>
</div>
</div>
</li>
<li>
<p>If the routed event implements a CLR event wrapper, use language-specific event syntax to add event handlers.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">Button1</span><span class="p">.</span><span class="n">Click</span> <span class="p">+=</span> <span class="n">Button_Click</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="attached-events">4.2. Attached events</h3>
<div class="paragraph">
<p>WPF attached events are implemented as routed events backed by a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.routedevent">RoutedEvent</a> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">AquariumFilter</span>
<span class="p">{</span>
    <span class="c1">// Register a custom routed event using the bubble routing strategy.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">RoutedEvent</span> <span class="n">CleanEvent</span> <span class="p">=</span> <span class="n">EventManager</span><span class="p">.</span><span class="nf">RegisterRoutedEvent</span><span class="p">(</span>
        <span class="s">"Clean"</span><span class="p">,</span> <span class="n">RoutingStrategy</span><span class="p">.</span><span class="n">Bubble</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">RoutedEventHandler</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">AquariumFilter</span><span class="p">));</span>

    <span class="c1">// Provide an add handler accessor method for the Clean event.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">AddCleanHandler</span><span class="p">(</span><span class="n">DependencyObject</span> <span class="n">dependencyObject</span><span class="p">,</span> <span class="n">RoutedEventHandler</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dependencyObject</span> <span class="k">is</span> <span class="n">not</span> <span class="n">UIElement</span> <span class="n">uiElement</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">uiElement</span><span class="p">.</span><span class="nf">AddHandler</span><span class="p">(</span><span class="n">CleanEvent</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Provide a remove handler accessor method for the Clean event.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">RemoveCleanHandler</span><span class="p">(</span><span class="n">DependencyObject</span> <span class="n">dependencyObject</span><span class="p">,</span> <span class="n">RoutedEventHandler</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dependencyObject</span> <span class="k">is</span> <span class="n">not</span> <span class="n">UIElement</span> <span class="n">uiElement</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">uiElement</span><span class="p">.</span><span class="nf">RemoveHandler</span><span class="p">(</span><span class="n">CleanEvent</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>Add&lt;event name&gt;Handler</code> method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to add.</p>
<div class="ulist">
<ul>
<li>
<p>The method must be <code>public</code> and <code>static</code>, with no return value.</p>
</li>
<li>
<p>The method calls the <code>AddHandler</code> base class method, passing in the routed event and handler as arguments.</p>
<div class="ulist">
<ul>
<li>
<p>This method supports the XAML attribute syntax for attaching an event handler to an element.</p>
</li>
<li>
<p>This method also enables code access to the event handler store for the attached event.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A <code>Remove&lt;event name&gt;Handler</code> method, with a first parameter that&#8217;s the element on which the event handler is attached, and a second parameter that&#8217;s the event handler to remove.</p>
<div class="ulist">
<ul>
<li>
<p>The method must be <code>public</code> and <code>static</code>, with no return value.</p>
</li>
<li>
<p>The method calls the <code>RemoveHandler</code> base class method, passing in the routed event and handler as arguments.</p>
<div class="ulist">
<ul>
<li>
<p>This method enables code access to the event handler store for the attached event.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>WPF implements attached events as routed events because the identifier for a <code>RoutedEvent</code> is defined by the WPF event system.</p>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.eventmanager.registerroutedevent">RegisterRoutedEvent</a> method that returns the attached event identifier is the same method used to register non-attached routed events.</p>
</li>
<li>
<p>Unlike the CLR event "wrapper" used to back non-attached routed events, the attached event accessor methods can be implemented in classes that don&#8217;t derive from <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.uielement">UIElement</a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.contentelement">ContentElement</a>.</p>
<div class="ulist">
<ul>
<li>
<p>It is possible because the attached event backing code calls the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.uielement.addhandler">UIElement.AddHandler</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.uielement.removehandler">UIElement.RemoveHandler</a> methods on a passed in <code>UIElement</code> instance.</p>
</li>
<li>
<p>In contrast, the CLR wrapper for non-attached routed events calls those methods directly on the owning class, so that class must derive from <code>UIElement</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>When defining a custom attached event using the WPF model of basing attached events on routed events, use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.uielement.raiseevent">UIElement.RaiseEvent</a> method to raise an attached event on any <code>UIElement</code> or <code>ContentElement</code>.</p>
<div class="ulist">
<ul>
<li>
<p>When raising a routed event, whether it&#8217;s attached or not, an element is required to designate in the element tree as the event source.</p>
</li>
<li>
<p>That source is then reported as the <code>RaiseEvent</code> caller. For example, to raise the <code>AquariumFilter.Clean</code> attached routed event on <code>aquarium1</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">aquarium1</span><span class="p">.</span><span class="nf">RaiseEvent</span><span class="p">(</span><span class="k">new</span> <span class="nf">RoutedEventArgs</span><span class="p">(</span><span class="n">AquariumFilter</span><span class="p">.</span><span class="n">CleanEvent</span><span class="p">));</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In XAML syntax, an attached event is specified by its event name and its owner type, in the form of <code>&lt;owner type&gt;.&lt;event name&gt;</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because the event name is qualified with the name of its owner type, the syntax allows the event to be attached to any element that can be instantiated.</p>
</li>
<li>
<p>It is also applicable to handlers for regular routed events that attach to an arbitrary element along the event route.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="c">&lt;!-- attaches the AquariumFilter_Clean handler for the AquariumFilter.Clean attached event
     to the aquarium1 element --&gt;</span>
<span class="nt">&lt;aqua:Aquarium</span> <span class="na">x:Name=</span><span class="s">"aquarium1"</span> <span class="na">Height=</span><span class="s">"300"</span> <span class="na">Width=</span><span class="s">"400"</span> <span class="na">aqua:AquariumFilter.Clean=</span><span class="s">"AquariumFilter_Clean"</span><span class="nt">/&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Event handlers can also be attached for attached events in code behind, by calling the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.uielement.addhandler">AddHandler</a> method on the object that the handler should attach to and pass the event identifier and handler as parameters to the method.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">aquarium1</span><span class="p">.</span><span class="nf">AddHandler</span><span class="p">(</span><span class="n">AquariumFilter</span><span class="p">.</span><span class="n">Clean</span><span class="p">,</span> <span class="k">new</span> <span class="nf">RoutedEventHandler</span><span class="p">(</span><span class="n">AquariumFilter_Clean</span><span class="p">),</span> <span class="k">true</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="wpf-input-events">4.3. WPF input events</h3>
<div class="ulist">
<ul>
<li>
<p>By convention, WPF routed events that follow a tunneling route have a name that&#8217;s prefixed with "Preview".</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/input-overview?view=netframeworkdesktop-4.8&amp;preserve-view=true">Input events</a> often come in pairs, with one being a preview event and the other a bubbling routed event.</p>
</li>
<li>
<p>The <code>Preview</code> prefix signifies that the preview event completes before the paired bubbling event starts.</p>
</li>
<li>
<p>A preview input event that&#8217;s marked as handled won&#8217;t invoke any normally registered event handlers for the remainder of the preview route, and the paired bubbling event won&#8217;t be raised.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/events/media/routed-events-overview/input-event-routing.png?view=netdesktop-8.0" alt="Event routing diagram.">
</div>
</div>
<div class="paragraph">
<p>The order of event processing following a mouse-down action on leaf element #2 is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PreviewMouseDown</code> tunneling event on the root element.</p>
</li>
<li>
<p><code>PreviewMouseDown</code> tunneling event on intermediate element #1.</p>
</li>
<li>
<p><code>PreviewMouseDown</code> tunneling event on leaf element #2, which is the source element.</p>
</li>
<li>
<p><code>MouseDown</code> bubbling event on leaf element #2, which is the source element.</p>
</li>
<li>
<p><code>MouseDown</code> bubbling event on intermediate element #1.</p>
</li>
<li>
<p><code>MouseDown</code> bubbling event on the root element.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="weak-event-patterns">4.4. Weak event patterns</h3>
<div class="paragraph">
<p>Listening for events can lead to memory leaks.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The typical technique for listening to an event is to use the language-specific syntax that attaches a handler to an event on a source.</p>
</li>
<li>
<p>For example, in C#, that syntax is: <code>source.SomeEvent += new SomeEventHandler(MyEventHandler)</code> that creates a strong reference from the event source to the event listener.</p>
</li>
<li>
<p>Ordinarily, attaching an event handler for a listener causes the listener to have an object lifetime that is influenced by the object lifetime of the source (unless the event handler is explicitly removed).</p>
</li>
<li>
<p>Whenever the source object lifetime extends beyond the object lifetime of the listener, the normal event pattern leads to a memory leak: the listener is kept alive longer than intended.</p>
</li>
<li>
<p>The weak event pattern can be used whenever a listener needs to register for an event, but the listener does not explicitly know when to unregister, and can also be used whenever the object lifetime of the source exceeds the useful object lifetime of the listener.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="commands">5. Commands</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A command can be used to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>separate the semantics and the object that invokes a command from the logic that executes the command.</p>
</li>
<li>
<p>indicate whether an action is possible by implementing the <code>CanExecute</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand">routed command model</a> in WPF can be broken up into four main concepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>command</em> is the action to be executed.</p>
</li>
<li>
<p>The <em>command source</em> is the object which invokes the command.</p>
</li>
<li>
<p>The <em>command target</em> is the object that the command is being executed on.</p>
</li>
<li>
<p>The <em>command binding</em> is the object which maps the command logic to the command.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A commands is created by implementing the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.icommand">ICommand</a> interface.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Execute</code> method performs the actions that are associated with the command.</p>
</li>
<li>
<p><code>CanExecute</code> method determines whether the command can execute on the current command target.</p>
</li>
<li>
<p><code>CanExecuteChanged</code> event is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.toolkit.mvvm.input.RelayCommand">RelayCommand</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.toolkit.mvvm.input.RelayCommand-1">RelayCommand&lt;T&gt;</a> are <code>ICommand</code> implementations that can expose a method or delegate to the view. These types act as a way to bind commands between the viewmodel and UI elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They provide a base implementation of the <code>ICommand</code> interface.</p>
</li>
<li>
<p>They also implement the <code>IRelayCommand</code> (and <code>IRelayCommand&lt;T&gt;</code>) interface, which exposes a <code>NotifyCanExecuteChanged</code> method to raise the <code>CanExecuteChanged</code> event.</p>
</li>
<li>
<p>They expose constructors taking delegates like <code>Action</code> and <code>Func&lt;T&gt;</code>, which allow the wrapping of standard methods and lambda expressions.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MyViewModel</span> <span class="p">:</span> <span class="n">ObservableObject</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">MyViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">IncrementCounterCommand</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RelayCommand</span><span class="p">(</span><span class="n">IncrementCounter</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">Counter</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">counter</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="k">ref</span> <span class="n">counter</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">ICommand</span> <span class="n">IncrementCounterCommand</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">IncrementCounter</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Counter</span><span class="p">++;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">x:Class=</span><span class="s">"MyApp.Views.MyPage"</span>
    <span class="na">xmlns:viewModels=</span><span class="s">"using:MyApp.ViewModels"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Page.DataContext&gt;</span>
        <span class="nt">&lt;viewModels:MyViewModel</span> <span class="na">x:Name=</span><span class="s">"ViewModel"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Page.DataContext&gt;</span>

    <span class="nt">&lt;StackPanel</span> <span class="na">Spacing=</span><span class="s">"8"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{x:Bind ViewModel.Counter, Mode=OneWay}"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Button</span>
            <span class="na">Content=</span><span class="s">"Click me!"</span>
            <span class="na">Command=</span><span class="s">"{x:Bind ViewModel.IncrementCounterCommand}"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Page&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A command source is the object that generally implements the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.icommandsource">ICommandSource</a> interface, which invokes the command.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Examples of command sources are <code>MenuItem</code>, <code>Button</code>, and <code>KeyGesture</code>.</p>
</li>
<li>
<p>A command source like a <code>Button</code> can subscribe to the <code>CanExecuteChanged</code> event and be disabled if <code>CanExecute</code> returns <code>false</code> or be enabled if <code>CanExecute</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Command</code> is the command to execute when the command source is invoked.</p>
</li>
<li>
<p><code>CommandTarget</code> is the object on which to execute the command, which is only applicable when the <code>ICommand</code> is a <code>RoutedCommand</code>.</p>
<div class="ulist">
<ul>
<li>
<p>If the <code>CommandTarget</code> is set on an <code>ICommandSource</code> and the corresponding command is not a <code>RoutedCommand</code>, the command target is ignored.</p>
</li>
<li>
<p>If the <code>CommandTarget</code> is not set, the element with keyboard focus will be the command target.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>CommandParameter</code> is a user-defined data type used to pass information to the handlers implementing the command.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.commandbinding">CommandBinding</a> associates a command with the event handlers that implement the command.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>CommandBinding</code> class contains a <code>Command</code> property, and <code>PreviewExecuted</code>, <code>Executed</code>, <code>PreviewCanExecute</code>, and <code>CanExecute</code> events.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window.CommandBindings&gt;</span>
  <span class="nt">&lt;CommandBinding</span> <span class="na">Command=</span><span class="s">"ApplicationCommands.Open"</span>
                  <span class="na">Executed=</span><span class="s">"OpenCmdExecuted"</span>
                  <span class="na">CanExecute=</span><span class="s">"OpenCmdCanExecute"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Window.CommandBindings&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Creating CommandBinding and attaching an Executed and CanExecute handler</span>
<span class="n">CommandBinding</span> <span class="n">OpenCmdBinding</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CommandBinding</span><span class="p">(</span>
    <span class="n">ApplicationCommands</span><span class="p">.</span><span class="n">Open</span><span class="p">,</span>
    <span class="n">OpenCmdExecuted</span><span class="p">,</span>
    <span class="n">OpenCmdCanExecute</span><span class="p">);</span>

<span class="k">this</span><span class="p">.</span><span class="n">CommandBindings</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">OpenCmdBinding</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">void</span> <span class="nf">OpenCmdExecuted</span><span class="p">(</span><span class="kt">object</span> <span class="n">target</span><span class="p">,</span> <span class="n">ExecutedRoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">String</span> <span class="n">command</span><span class="p">,</span> <span class="n">targetobj</span><span class="p">;</span>
    <span class="n">command</span> <span class="p">=</span> <span class="p">((</span><span class="n">RoutedCommand</span><span class="p">)</span><span class="n">e</span><span class="p">.</span><span class="n">Command</span><span class="p">).</span><span class="n">Name</span><span class="p">;</span>
    <span class="n">targetobj</span> <span class="p">=</span> <span class="p">((</span><span class="n">FrameworkElement</span><span class="p">)</span><span class="n">target</span><span class="p">).</span><span class="n">Name</span><span class="p">;</span>
    <span class="n">MessageBox</span><span class="p">.</span><span class="nf">Show</span><span class="p">(</span><span class="s">"The "</span> <span class="p">+</span> <span class="n">command</span> <span class="p">+</span>  <span class="s">" command has been invoked on target object "</span> <span class="p">+</span> <span class="n">targetobj</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">void</span> <span class="nf">OpenCmdCanExecute</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">CanExecuteRoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">e</span><span class="p">.</span><span class="n">CanExecute</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>A command target is the element on which the command is executed. With regards to a <code>RoutedCommand</code>, the command target is the element at which routing of the <code>Executed</code> and <code>CanExecute</code> starts.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The command source can explicitly set the command target. If the command target is not defined, the element with keyboard focus will be used as the command target.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;StackPanel&gt;</span>
  <span class="nt">&lt;Menu&gt;</span>
    <span class="nt">&lt;MenuItem</span> <span class="na">Command=</span><span class="s">"ApplicationCommands.Paste"</span>
              <span class="na">CommandTarget=</span><span class="s">"{Binding ElementName=mainTextBox}"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/Menu&gt;</span>
  <span class="nt">&lt;TextBox</span> <span class="na">Name=</span><span class="s">"mainTextBox"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Creating the UI objects</span>
<span class="n">StackPanel</span> <span class="n">mainStackPanel</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StackPanel</span><span class="p">();</span>
<span class="n">TextBox</span> <span class="n">pasteTextBox</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TextBox</span><span class="p">();</span>
<span class="n">Menu</span> <span class="n">stackPanelMenu</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Menu</span><span class="p">();</span>
<span class="n">MenuItem</span> <span class="n">pasteMenuItem</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MenuItem</span><span class="p">();</span>

<span class="c1">// Adding objects to the panel and the menu</span>
<span class="n">stackPanelMenu</span><span class="p">.</span><span class="n">Items</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">pasteMenuItem</span><span class="p">);</span>
<span class="n">mainStackPanel</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">stackPanelMenu</span><span class="p">);</span>
<span class="n">mainStackPanel</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">pasteTextBox</span><span class="p">);</span>

<span class="c1">// Setting the command to the Paste command</span>
<span class="n">pasteMenuItem</span><span class="p">.</span><span class="n">Command</span> <span class="p">=</span> <span class="n">ApplicationCommands</span><span class="p">.</span><span class="n">Paste</span><span class="p">;</span>

<span class="c1">// Setting the command target to the TextBox</span>
<span class="n">pasteMenuItem</span><span class="p">.</span><span class="n">CommandTarget</span> <span class="p">=</span> <span class="n">pasteTextBox</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager">CommandManager</a> serves a number of command related functions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It provides a set of static methods for adding and removing <code>PreviewExecuted</code>, <code>Executed</code>, <code>PreviewCanExecute</code>, and <code>CanExecute</code> event handlers to and from a specific element.</p>
</li>
<li>
<p>It provides a means to register <code>CommandBinding</code> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.inputbinding"><code>InputBinding</code></a> objects onto a specific class.</p>
</li>
<li>
<p>The <code>CommandManager</code> also provides a means, through the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager.requerysuggested#system-windows-input-commandmanager-requerysuggested">RequerySuggested</a> event, to notify a command when it should raise the <code>CanExecuteChanged</code> event.</p>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager.invalidaterequerysuggested">InvalidateRequerySuggested</a> method forces the <code>CommandManager</code> to raise the <code>RequerySuggested</code> event, which is useful for conditions that should disable/enable a command but are not conditions that the <code>CommandManager</code> is aware of.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="windows">6. Windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In WPF, a window is encapsulated by the Window class that used to do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Display a window.</p>
</li>
<li>
<p>Configure the size, position, and appearance of a window.</p>
</li>
<li>
<p>Host application-specific content.</p>
</li>
<li>
<p>Manage the lifetime of a window.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/windows/media/index/window-parts.png?view=netdesktop-8.0" alt="Screenshot that shows parts of a WPF window.">
</div>
</div>
<div class="paragraph">
<p>A window is divided into two areas: the non-client area and client area.</p>
</div>
<div class="paragraph">
<p>The <em>non-client area</em> of a window is implemented by WPF and includes the parts of a window that are common to most windows, including the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A title bar (1-5).</p>
</li>
<li>
<p>An icon (1).</p>
</li>
<li>
<p>Title (2).</p>
</li>
<li>
<p>Minimize (3), Maximize (4), and Close (5) buttons.</p>
</li>
<li>
<p>System menu (6) with menu items. Appears when clicking on the icon (1).</p>
</li>
<li>
<p>Border (7).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>client area</em> of a window is the area within a window&#8217;s non-client area and is used by developers to add application-specific content, such as menu bars, tool bars, and controls.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Client area (8).</p>
</li>
<li>
<p>Resize grip (9). This is a control added to the Client area (8).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a window that is defined using both XAML markup and code-behind:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XAML markup files are configured as MSBuild <code>Page</code> items.</p>
</li>
<li>
<p>Code-behind files are configured as MSBuild <code>Compile</code> items.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>.NET SDK projects automatically import the correct <code>Page</code> and <code>Compile</code> items. When the project is configured for WPF, the XAML markup files are automatically imported as <code>Page</code> items, and the corresponding code-behind file is imported as <code>Compile</code>.</p>
</div>
<div class="sect2">
<h3 id="lifetime">6.1. Lifetime</h3>
<div class="paragraph">
<p>A window that is opened by using the <code>Show</code> method doesn&#8217;t have an implicit relationship with the window that created it. Users can interact with either window independently of the other, which means that either window can do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cover the other (unless one of the windows has its <code>Topmost</code> property set to <code>true</code>).</p>
</li>
<li>
<p>Be minimized, maximized, and restored without affecting the other.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After ownership by setting the <code>Owner</code> property of the <em>owned window</em> with a reference to the <em>owner window</em> is established:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The owned window can reference its owner window by inspecting the value of its <code>Owner</code> property.</p>
</li>
<li>
<p>The owner window can discover all the windows it owns by inspecting the value of its <code>OwnedWindows</code> property.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A window opened by calling <code>Show</code> is a <em>modeless</em> window, and the application doesn&#8217;t prevent users from interacting with other windows in the application.</p>
</div>
<div class="paragraph">
<p>Opening a window with <code>ShowDialog</code> opens a window as <em>modal</em> and restricts user interaction to the specific window.</p>
</div>
<div class="paragraph">
<p>The life of a window starts coming to an end when a user closes it. Once a window is closed, it can&#8217;t be reopened.</p>
</div>
<div class="paragraph">
<p>A window can be closed by using elements in the non-client area, including the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>Close</code> item of the System menu.</p>
</li>
<li>
<p>Pressing <code>ALT + F4</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">InitializeComponent</span><span class="p">();</span>
    <span class="n">KeyDown</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="c1">// inhibit the ALT + F4</span>
        <span class="n">e</span><span class="p">.</span><span class="n">Handled</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">SystemKey</span> <span class="p">==</span> <span class="n">Key</span><span class="p">.</span><span class="n">F4</span> <span class="p">&amp;&amp;</span> <span class="n">Keyboard</span><span class="p">.</span><span class="n">Modifiers</span> <span class="p">==</span> <span class="n">ModifierKeys</span><span class="p">.</span><span class="n">Alt</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Pressing the <code>Close</code> button.</p>
</li>
<li>
<p>Pressing <code>ESC</code> when a button has the <code>IsCancel</code> property set to <code>true</code> on a modal window.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following illustration shows the sequence of the principal events in the lifetime of a window:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/windows/media/index/window-lifetime-events.png?view=netdesktop-8.0" alt="Diagram that shows events in a window&#8217;s lifetime.">
</div>
</div>
<div class="paragraph">
<p>The following illustration shows the sequence of the principal events in the lifetime of a window that is shown without activation (<code>ShowActivated</code> is set to <code>false</code> before the window is shown):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/windows/media/index/window-lifetime-events.png?view=netdesktop-8.0" alt="Diagram that shows events in a window&#8217;s lifetime without activation.">
</div>
</div>
</div>
<div class="sect2">
<h3 id="appearance">6.2. Appearance</h3>
<div class="paragraph">
<p>To configure the non-client area, Window provides several properties, which include <code>Icon</code> to set a window&#8217;s icon and <code>Title</code> to set its title.</p>
</div>
<div class="paragraph">
<p>The appearance and behavior of non-client area border can also be changed by configuring a window&#8217;s <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.window.resizemode">resize mode</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.window.windowstyle">window style</a>, and whether it appears as a button in the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.window.showintaskbar">desktop task bar</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/windows/media/index/window-transparent.png?view=netdesktop-8.0" alt="Screenshot of a WPF window that has a clipped area and custom shape.">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="c">&lt;!--  Non-rectangular window style  --&gt;</span>
<span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">"WindowsOverview.ClippedWindow"</span>
        <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="na">Title=</span><span class="s">"ClippedWindow"</span> <span class="na">SizeToContent=</span><span class="s">"WidthAndHeight"</span>
        <span class="na">WindowStyle=</span><span class="s">"None"</span> <span class="na">AllowsTransparency=</span><span class="s">"True"</span> <span class="na">Background=</span><span class="s">"Transparent"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid</span> <span class="na">Margin=</span><span class="s">"20"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Grid.RowDefinitions&gt;</span>
            <span class="nt">&lt;RowDefinition</span> <span class="na">Height=</span><span class="s">"*"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;RowDefinition</span> <span class="na">Height=</span><span class="s">"20"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Grid.RowDefinitions&gt;</span>

        <span class="nt">&lt;Rectangle</span> <span class="na">Stroke=</span><span class="s">"#FF000000"</span> <span class="na">RadiusX=</span><span class="s">"10"</span> <span class="na">RadiusY=</span><span class="s">"10"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Path</span> <span class="na">Fill=</span><span class="s">"White"</span> <span class="na">Stretch=</span><span class="s">"Fill"</span> <span class="na">Stroke=</span><span class="s">"#FF000000"</span> <span class="na">HorizontalAlignment=</span><span class="s">"Left"</span> <span class="na">Margin=</span><span class="s">"15,-5.597,0,-0.003"</span> <span class="na">Width=</span><span class="s">"30"</span> <span class="na">Grid.Row=</span><span class="s">"1"</span> <span class="na">Data=</span><span class="s">"M22.166642,154.45381 L29.999666,187.66699 40.791059,154.54395"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Rectangle</span> <span class="na">Fill=</span><span class="s">"White"</span> <span class="na">RadiusX=</span><span class="s">"10"</span> <span class="na">RadiusY=</span><span class="s">"10"</span> <span class="na">Margin=</span><span class="s">"1"</span><span class="nt">/&gt;</span>

        <span class="nt">&lt;TextBlock</span> <span class="na">HorizontalAlignment=</span><span class="s">"Left"</span> <span class="na">VerticalAlignment=</span><span class="s">"Center"</span> <span class="na">FontSize=</span><span class="s">"25"</span> <span class="na">Text=</span><span class="s">"Greetings!"</span> <span class="na">TextWrapping=</span><span class="s">"Wrap"</span> <span class="na">Margin=</span><span class="s">"5,5,50,5"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">HorizontalAlignment=</span><span class="s">"Right"</span> <span class="na">VerticalAlignment=</span><span class="s">"Top"</span> <span class="na">Background=</span><span class="s">"Transparent"</span> <span class="na">BorderBrush=</span><span class="s">"{x:Null}"</span> <span class="na">Foreground=</span><span class="s">"Red"</span> <span class="na">Content=</span><span class="s">"❌"</span> <span class="na">FontSize=</span><span class="s">"15"</span> <span class="nt">/&gt;</span>

        <span class="nt">&lt;Grid.Effect&gt;</span>
            <span class="nt">&lt;DropShadowEffect</span> <span class="na">BlurRadius=</span><span class="s">"10"</span> <span class="na">ShadowDepth=</span><span class="s">"3"</span> <span class="na">Color=</span><span class="s">"LightBlue"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Grid.Effect&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Window&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Hide the Minimize, Maximize, and Close buttons</span>
<span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">InitializeComponent</span><span class="p">();</span>
    <span class="n">SourceInitialized</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">WM_SYSTEM_MENU</span> <span class="p">=</span> <span class="m">0x80000</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">WM_GW_STYLE</span> <span class="p">=</span> <span class="p">-</span><span class="m">16</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">hWnd</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="nf">WindowInteropHelper</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="n">Handle</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hWnd</span> <span class="p">==</span> <span class="n">IntPtr</span><span class="p">.</span><span class="n">Zero</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"The window has not yet been completely initialized"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// Hide the Minimize, Maximize, and Close buttons</span>
        <span class="nf">SetWindow</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="n">WM_GW_STYLE</span><span class="p">,</span> <span class="nf">GetWindow</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="n">WM_GW_STYLE</span><span class="p">)</span> <span class="p">&amp;</span> <span class="p">~</span><span class="n">WM_SYSTEM_MENU</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"user32.dll"</span><span class="p">,</span> <span class="n">EntryPoint</span> <span class="p">=</span> <span class="s">"GetWindowLong"</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">int</span> <span class="nf">GetWindow</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">hWnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nIndex</span><span class="p">);</span>

<span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"user32.dll"</span><span class="p">,</span> <span class="n">EntryPoint</span> <span class="p">=</span> <span class="s">"SetWindowLong"</span><span class="p">,</span> <span class="n">SetLastError</span> <span class="p">=</span> <span class="k">true</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">int</span> <span class="nf">SetWindow</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">hWnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dwNew</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dialog-boxes">6.3. Dialog boxes</h3>
<div class="paragraph">
<p>When designing a dialog box, follow these suggestions to create a good user experience:</p>
</div>
<div class="paragraph">
<p>❌ DON&#8217;T clutter the dialog window. The dialog experience is for the user to enter some data, or to make a choice.</p>
</div>
<div class="paragraph">
<p>✔️ DO provide an <code>OK</code> button to close the window.</p>
</div>
<div class="paragraph">
<p>✔️ DO set the <code>OK</code> button&#8217;s <code>IsDefault</code> property to <code>true</code> to allow the user to press the <code>ENTER</code> key to accept and close the window.</p>
</div>
<div class="paragraph">
<p>✔️ CONSIDER adding a <code>Cancel</code> button so that the user can close the window and indicate that they don&#8217;t want to continue.</p>
</div>
<div class="paragraph">
<p>✔️ DO set the <code>Cancel</code> button&#8217;s <code>IsCancel</code> property to <code>true</code> to allow the user to press the <code>ESC</code> key to close the window.</p>
</div>
<div class="paragraph">
<p>✔️ DO set the title of the window to accurately describe what the dialog represents, or what the user should do with the dialog.</p>
</div>
<div class="paragraph">
<p>✔️ DO set minimum width and height values for the window, preventing the user from resizing the window too small.</p>
</div>
<div class="paragraph">
<p>✔️ CONSIDER disabling the ability to resize the window if <code>ShowInTaskbar</code> is set to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>✔️ DO When a menu item or button runs a function that requires user interaction through a dialog box before the function can continue, the control should use an ellipsis at the end of its header text:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;MenuItem</span> <span class="na">Header=</span><span class="s">"_Open..."</span> <span class="na">Click=</span><span class="s">"openMenuItem_Click"</span> <span class="nt">/&gt;</span>
<span class="c">&lt;!-- or --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Content=</span><span class="s">"_Save As..."</span> <span class="na">Click=</span><span class="s">"saveAsButton_Click"</span> <span class="nt">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>✔️ DO When a menu item or button runs a function that displays a dialog box that does NOT require user interaction, such as an <em>About</em> dialog box, an ellipsis isn&#8217;t required.</p>
</div>
</div>
<div class="sect2">
<h3 id="multiple-windows-multiple-threads">6.4. Multiple windows, multiple threads</h3>
<div class="paragraph">
<p>Typically, WPF applications start with two threads: one for handling rendering and another for managing the UI.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <strong>rendering thread</strong> effectively runs hidden in the background while the <strong>UI thread</strong> receives input, handles events, paints the screen, and runs application code.</p>
</li>
<li>
<p>Most applications use a single UI thread, although in some situations it is best to use several.</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>The UI thread queues work items inside an object called a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a> that selects work items on a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcherpriority">priority</a> basis and runs each one to completion.</p>
</li>
<li>
<p>Every UI thread must have at least one <code>Dispatcher</code>, and each <code>Dispatcher</code> can execute work items in exactly one thread.</p>
</li>
<li>
<p>The trick to building responsive, user-friendly applications is to maximize the <code>Dispatcher</code> throughput by keeping the work items small.</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>Most classes derive from <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcherobject">DispatcherObject</a> that stores a reference to the <code>Dispatcher</code> linked to the currently running thread that creates it at construction.</p>
<div class="ulist">
<ul>
<li>
<p>A <code>DispatcherObject</code> can call its public <code>VerifyAccess</code> method that examines the <code>Dispatcher</code> associated with the current thread and compares it to the <code>Dispatcher</code> reference stored during construction, and if they don&#8217;t match, <code>VerifyAccess</code> throws an exception.</p>
</li>
<li>
<p><code>VerifyAccess</code> is intended to be called at the beginning of every method belonging to a <code>DispatcherObject</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A background thread can ask the UI thread to perform an operation on its behalf by registering a work item with the <code>Dispatcher</code> of the UI thread.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>Dispatcher</code> class provides the methods for registering work items: <code>InvokeAsync</code>, <code>BeginInvoke</code>, and <code>Invoke</code>.</p>
</li>
<li>
<p><code>Invoke</code> is a synchronous call – that is, it doesn&#8217;t return until the UI thread actually finishes executing the delegate.</p>
</li>
<li>
<p><code>InvokeAsync</code> and <code>BeginInvoke</code> are asynchronous and return immediately.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>Dispatcher</code> orders the elements in its queue by priority that maintained in the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcherpriority"><code>DispatcherPriority</code></a> enumeration.</p>
</li>
<li>
<p>WPF application may require multiple top-level windows to do a better job, which is especially true if there&#8217;s any chance that one of the windows will monopolize the thread.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">private</span> <span class="k">void</span> <span class="nf">NewThreadWindow_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Thread</span> <span class="n">newWindowThread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ThreadStartingPoint</span><span class="p">);</span>
    <span class="n">newWindowThread</span><span class="p">.</span><span class="nf">SetApartmentState</span><span class="p">(</span><span class="n">ApartmentState</span><span class="p">.</span><span class="n">STA</span><span class="p">);</span>
    <span class="n">newWindowThread</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">newWindowThread</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">ThreadStartingPoint</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">new</span> <span class="nf">MultiWindow</span><span class="p">().</span><span class="nf">Show</span><span class="p">();</span>

    <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">Run</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Windows Explorer works in multiple top-level windows within multiple threads fashion.</p>
</li>
<li>
<p>Each new Explorer window belongs to the original process, but it&#8217;s created under the control of an independent thread.</p>
</li>
<li>
<p>When Explorer becomes nonresponsive, such as when looking for network resources, other Explorer windows continue to be responsive and usable.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="styles-templates-and-triggers">7. Styles, templates, and triggers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="styles">7.1. Styles</h3>
<div class="paragraph">
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.style">Style</a>, commonly declared as a resource, can apply a set of property values to one or more elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When setting the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.style.targettype">TargetType</a> of a style and omit the <code>x:Key</code> attribute, the style is applied to all the <code>TargetType</code> elements scoped to the style, which is generally the XAML file itself.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="c">&lt;!--A Style that affects all TextBlocks--&gt;</span>
    <span class="nt">&lt;Style</span> <span class="na">TargetType=</span><span class="s">"TextBlock"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"HorizontalAlignment"</span> <span class="na">Value=</span><span class="s">"Center"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontFamily"</span> <span class="na">Value=</span><span class="s">"Comic Sans MS"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontSize"</span> <span class="na">Value=</span><span class="s">"14"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>If adding an <code>x:Key</code> attribute with value to the style, the style is no longer implicitly applied to all elements of <code>TargetType</code>. Only elements that explicitly reference the style will have the style applied to them.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="nt">&lt;Style</span> <span class="na">x:Key=</span><span class="s">"TitleText"</span> <span class="na">TargetType=</span><span class="s">"TextBlock"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"HorizontalAlignment"</span> <span class="na">Value=</span><span class="s">"Center"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontFamily"</span> <span class="na">Value=</span><span class="s">"Comic Sans MS"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontSize"</span> <span class="na">Value=</span><span class="s">"14"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;StackPanel&gt;</span>
    <span class="nt">&lt;TextBlock</span> <span class="na">Style=</span><span class="s">"{StaticResource TitleText}"</span><span class="nt">&gt;</span>My Pictures<span class="nt">&lt;/TextBlock&gt;</span>
    <span class="nt">&lt;TextBlock&gt;</span>Check out my new pictures!<span class="nt">&lt;/TextBlock&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>To assign a named style to an element programmatically, get the style from the resources collection and assign it to the element&#8217;s <code>Style</code> property.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">textblock1</span><span class="p">.</span><span class="n">Style</span> <span class="p">=</span> <span class="p">(</span><span class="n">Style</span><span class="p">)</span><span class="n">Resources</span><span class="p">[</span><span class="s">"TitleText"</span><span class="p">];</span></code></pre>
</div>
</div>
</li>
<li>
<p>A style can extend another style with the <code>BaseOn</code> property.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="c">&lt;!-- .... other resources .... --&gt;</span>

    <span class="c">&lt;!--A Style that affects all TextBlocks--&gt;</span>
    <span class="nt">&lt;Style</span> <span class="na">TargetType=</span><span class="s">"TextBlock"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- x:Key is implicitly set to {x:Type TextBlock} --&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"HorizontalAlignment"</span> <span class="na">Value=</span><span class="s">"Center"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontFamily"</span> <span class="na">Value=</span><span class="s">"Comic Sans MS"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontSize"</span> <span class="na">Value=</span><span class="s">"14"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>

    <span class="c">&lt;!--A Style that extends the previous TextBlock Style with an x:Key of TitleText--&gt;</span>
    <span class="nt">&lt;Style</span> <span class="na">BasedOn=</span><span class="s">"{StaticResource {x:Type TextBlock}}"</span>
           <span class="na">TargetType=</span><span class="s">"TextBlock"</span>
           <span class="na">x:Key=</span><span class="s">"TitleText"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontSize"</span> <span class="na">Value=</span><span class="s">"26"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Foreground"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Setter.Value&gt;</span>
                <span class="nt">&lt;LinearGradientBrush</span> <span class="na">StartPoint=</span><span class="s">"0.5,0"</span> <span class="na">EndPoint=</span><span class="s">"0.5,1"</span><span class="nt">&gt;</span>
                    <span class="nt">&lt;LinearGradientBrush.GradientStops&gt;</span>
                        <span class="nt">&lt;GradientStop</span> <span class="na">Offset=</span><span class="s">"0.0"</span> <span class="na">Color=</span><span class="s">"#90DDDD"</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;GradientStop</span> <span class="na">Offset=</span><span class="s">"1.0"</span> <span class="na">Color=</span><span class="s">"#5BFFFF"</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/LinearGradientBrush.GradientStops&gt;</span>
                <span class="nt">&lt;/LinearGradientBrush&gt;</span>
            <span class="nt">&lt;/Setter.Value&gt;</span>
        <span class="nt">&lt;/Setter&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>x:Key</code> of a style is implicitly set to <code>{x:Type TargetType}</code>.</p>
<div class="paragraph">
<p>It means that if explicitly setting the <code>x:Key</code> value to anything other than <code>{x:Type TargetType}</code>, the <code>Style</code> isn&#8217;t applied to all <code>TargetType</code> elements automatically.</p>
</div>
</li>
<li>
<p>If <code>TargetType</code> isn&#8217;t specified, the properties must be qualified in the <code>Setter</code> objects with a class name by using the syntax <code>Property="ClassName.Property"</code>.</p>
</li>
<li>
<p>Also note that many WPF controls consist of a combination of other WPF controls. If creating a style that applies to all controls of a type, unexpected results might happen.</p>
<div class="paragraph">
<p>For example, if creating a style that targets the <code>TextBlock</code> type in a <code>Window</code>, the style is applied to all <code>TextBlock</code> controls in the window, even if the <code>TextBlock</code> is part of another control, such as a <code>ListBox</code>.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="control-templates">7.2. Control templates</h3>
<div class="paragraph">
<p>In WPF, the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.controltemplate">ControlTemplate</a> of a control, Commonly declared as a resource, defines the appearance of the control.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each control has a default template assigned to the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.control.template#system-windows-controls-control-template">Control.Template</a> property.</p>
</li>
<li>
<p>A control template rewrites the visual appearance of the entire control, while a style simply applies property changes to the existing control.</p>
<div class="paragraph">
<p>However, since the template of a control is applied by setting the <code>Control.Template</code> property, a template can be defined or set using a style.</p>
</div>
</li>
<li>
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/templatebinding-markup-extension?view=netdesktop-8.0">TemplateBinding</a> is an optimized form of a binding for template scenarios, analogous to a binding constructed with <code>{Binding RelativeSource={RelativeSource TemplatedParent}}</code>, such as for binding parts of the template to properties of the control.</p>
</li>
<li>
<p>If a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.contentpresenter">ContentPresenter</a> is declared in the <code>ControlTemplate</code> of a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.contentcontrol">ContentControl</a>, the <code>ContentPresenter</code> will automatically bind to the <code>ContentTemplate</code> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.contentcontrol.content">Content</a> properties.</p>
<div class="paragraph">
<p>Likewise, an <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.itemspresenter">ItemsPresenter</a> that is in the <code>ControlTemplate</code> of an <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.itemscontrol">ItemsControl</a> will automatically bind to the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.itemscontrol.itemtemplate">ItemTemplate</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.itemscontrol.items">Items</a> properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;UserControl&gt;</span>
    <span class="nt">&lt;UserControl.Resources&gt;</span>
        <span class="c">&lt;!--  Defined a ControlTemplate as a resource  --&gt;</span>
        <span class="nt">&lt;ControlTemplate</span> <span class="na">x:Key=</span><span class="s">"roundbutton"</span> <span class="na">TargetType=</span><span class="s">"Button"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Grid&gt;</span>
                <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">"{TemplateBinding Background}"</span> <span class="na">Stroke=</span><span class="s">"{TemplateBinding Foreground}"</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;ContentPresenter</span> <span class="na">HorizontalAlignment=</span><span class="s">"Center"</span> <span class="na">VerticalAlignment=</span><span class="s">"Center"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/Grid&gt;</span>
        <span class="nt">&lt;/ControlTemplate&gt;</span>
    <span class="nt">&lt;/UserControl.Resources&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="c">&lt;!-- Set the button's Template property to the roundbutton resource --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">Template=</span><span class="s">"{StaticResource roundbutton}"</span><span class="nt">&gt;</span>Hello<span class="nt">&lt;/Button&gt;</span>
        <span class="c">&lt;!-- Defined the ControlTemplate inline --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">Background=</span><span class="s">"Red"</span> <span class="na">Foreground=</span><span class="s">"White"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Button.Content&gt;</span>World<span class="nt">&lt;/Button.Content&gt;</span>
            <span class="nt">&lt;Button.Template&gt;</span>
                <span class="nt">&lt;ControlTemplate</span> <span class="na">TargetType=</span><span class="s">"Button"</span><span class="nt">&gt;</span>
                    <span class="nt">&lt;Grid&gt;</span>
                        <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">"{TemplateBinding Background}"</span> <span class="na">Stroke=</span><span class="s">"{TemplateBinding Foreground}"</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;ContentPresenter</span> <span class="na">HorizontalAlignment=</span><span class="s">"Center"</span> <span class="na">VerticalAlignment=</span><span class="s">"Center"</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/Grid&gt;</span>
                <span class="nt">&lt;/ControlTemplate&gt;</span>
            <span class="nt">&lt;/Button.Template&gt;</span>
        <span class="nt">&lt;/Button&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/UserControl&gt;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="data-templates">7.3. Data templates</h3>
<div class="paragraph">
<p>In WPF, the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.datatemplate">DataTemplate</a> is used to custom  the presentation and appearance of the data objects.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In most cases, all other aspects of presentation, such as what an item looks like when it is selected or how a <code>ListBox</code> lays out the items, do not belong in the definition of a <code>DataTemplate</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="c">&lt;!-- Defined the DataTemplate inline --&gt;</span>
<span class="nt">&lt;ListBox</span> <span class="na">Width=</span><span class="s">"400"</span> <span class="na">Margin=</span><span class="s">"10"</span>
         <span class="na">ItemsSource=</span><span class="s">"{Binding Source={StaticResource myTodoList}}"</span><span class="nt">&gt;</span>
   <span class="nt">&lt;ListBox.ItemTemplate&gt;</span>
     <span class="nt">&lt;DataTemplate&gt;</span>
       <span class="nt">&lt;StackPanel&gt;</span>
         <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=TaskName}"</span> <span class="nt">/&gt;</span>
         <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Description}"</span><span class="nt">/&gt;</span>
         <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Priority}"</span><span class="nt">/&gt;</span>
       <span class="nt">&lt;/StackPanel&gt;</span>
     <span class="nt">&lt;/DataTemplate&gt;</span>
   <span class="nt">&lt;/ListBox.ItemTemplate&gt;</span>
<span class="nt">&lt;/ListBox&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="c">&lt;!--  Defined a DataTemplate as a resource  --&gt;</span>
<span class="nt">&lt;UserControl.Resources&gt;</span>
    <span class="nt">&lt;DataTemplate</span> <span class="na">x:Key=</span><span class="s">"myTaskTemplate"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;StackPanel&gt;</span>
            <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=TaskName}"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Description}"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Priority}"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/StackPanel&gt;</span>
    <span class="nt">&lt;/DataTemplate&gt;</span>
<span class="nt">&lt;/UserControl.Resources&gt;</span>
<span class="nt">&lt;StackPanel&gt;</span>
    <span class="nt">&lt;ListBox</span>
        <span class="na">Width=</span><span class="s">"400"</span>
        <span class="na">Margin=</span><span class="s">"10"</span>
        <span class="na">ItemTemplate=</span><span class="s">"{StaticResource myTaskTemplate}"</span>
        <span class="na">ItemsSource=</span><span class="s">"{Binding Source={StaticResource myTodoList}}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>DataTemplate</code> class has a <code>DataType</code> property that is very similar to the <code>TargetType</code> property of the <code>Style</code> class.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;DataTemplate</span> <span class="na">DataType=</span><span class="s">"{x:Type local:Task}"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;StackPanel&gt;</span>
    <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=TaskName}"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Description}"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Priority}"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/DataTemplate&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>To supply logic to choose which <code>DataTemplate</code> to use based on the <code>Priority</code> value of the data object, create a subclass of <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.datatemplateselector">DataTemplateSelector</a> and override the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.datatemplateselector.selecttemplate">SelectTemplate</a> method.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">namespace</span> <span class="nn">SDKSample</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">TaskListDataTemplateSelector</span> <span class="p">:</span> <span class="n">DataTemplateSelector</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">override</span> <span class="n">DataTemplate</span> <span class="nf">SelectTemplate</span><span class="p">(</span><span class="kt">object</span> <span class="n">item</span><span class="p">,</span> <span class="n">DependencyObject</span> <span class="n">container</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FrameworkElement</span> <span class="n">element</span> <span class="p">=</span> <span class="n">container</span> <span class="k">as</span> <span class="n">FrameworkElement</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">item</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">item</span> <span class="k">is</span> <span class="n">Task</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Task</span> <span class="n">taskitem</span> <span class="p">=</span> <span class="n">item</span> <span class="k">as</span> <span class="n">Task</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">taskitem</span><span class="p">.</span><span class="n">Priority</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">element</span><span class="p">.</span><span class="nf">FindResource</span><span class="p">(</span><span class="s">"importantTaskTemplate"</span><span class="p">)</span> <span class="k">as</span> <span class="n">DataTemplate</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="n">element</span><span class="p">.</span><span class="nf">FindResource</span><span class="p">(</span><span class="s">"myTaskTemplate"</span><span class="p">)</span> <span class="k">as</span> <span class="n">DataTemplate</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="nt">&lt;local:TaskListDataTemplateSelector</span> <span class="na">x:Key=</span><span class="s">"myDataTemplateSelector"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;ListBox</span> <span class="na">Width=</span><span class="s">"400"</span> <span class="na">Margin=</span><span class="s">"10"</span>
         <span class="na">ItemsSource=</span><span class="s">"{Binding Source={StaticResource myTodoList}}"</span>
         <span class="na">ItemTemplateSelector=</span><span class="s">"{StaticResource myDataTemplateSelector}"</span>
         <span class="na">HorizontalContentAlignment=</span><span class="s">"Stretch"</span><span class="nt">/&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Styling and Templating an ItemsControl</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;ItemsControl</span> <span class="na">Margin=</span><span class="s">"10"</span>
              <span class="na">ItemsSource=</span><span class="s">"{Binding Source={StaticResource myTodoList}}"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!--The ItemsControl has no default visual appearance.
      Use the Template property to specify a ControlTemplate to define
      the appearance of an ItemsControl. The ItemsPresenter uses the specified
      ItemsPanelTemplate (see below) to layout the items. If an
      ItemsPanelTemplate is not specified, the default is used. (For ItemsControl,
      the default is an ItemsPanelTemplate that specifies a StackPanel.--&gt;</span>
  <span class="nt">&lt;ItemsControl.Template&gt;</span>
    <span class="nt">&lt;ControlTemplate</span> <span class="na">TargetType=</span><span class="s">"ItemsControl"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;Border</span> <span class="na">BorderBrush=</span><span class="s">"Aqua"</span> <span class="na">BorderThickness=</span><span class="s">"1"</span> <span class="na">CornerRadius=</span><span class="s">"15"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;ItemsPresenter/&gt;</span>
      <span class="nt">&lt;/Border&gt;</span>
    <span class="nt">&lt;/ControlTemplate&gt;</span>
  <span class="nt">&lt;/ItemsControl.Template&gt;</span>
  <span class="c">&lt;!--Use the ItemsPanel property to specify an ItemsPanelTemplate
      that defines the panel that is used to hold the generated items.
      In other words, use this property if you want to affect
      how the items are laid out.--&gt;</span>
  <span class="nt">&lt;ItemsControl.ItemsPanel&gt;</span>
    <span class="nt">&lt;ItemsPanelTemplate&gt;</span>
      <span class="nt">&lt;WrapPanel</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/ItemsPanelTemplate&gt;</span>
  <span class="nt">&lt;/ItemsControl.ItemsPanel&gt;</span>
  <span class="c">&lt;!--Use the ItemTemplate to set a DataTemplate to define
      the visualization of the data objects. This DataTemplate
      specifies that each data object appears with the Proriity
      and TaskName on top of a silver ellipse.--&gt;</span>
  <span class="nt">&lt;ItemsControl.ItemTemplate&gt;</span>
    <span class="nt">&lt;DataTemplate&gt;</span>
      <span class="nt">&lt;DataTemplate.Resources&gt;</span>
        <span class="nt">&lt;Style</span> <span class="na">TargetType=</span><span class="s">"TextBlock"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"FontSize"</span> <span class="na">Value=</span><span class="s">"18"</span><span class="nt">/&gt;</span>
          <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"HorizontalAlignment"</span> <span class="na">Value=</span><span class="s">"Center"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Style&gt;</span>
      <span class="nt">&lt;/DataTemplate.Resources&gt;</span>
      <span class="nt">&lt;Grid&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">"Silver"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;StackPanel&gt;</span>
          <span class="nt">&lt;TextBlock</span> <span class="na">Margin=</span><span class="s">"3,3,3,0"</span>
                     <span class="na">Text=</span><span class="s">"{Binding Path=Priority}"</span><span class="nt">/&gt;</span>
          <span class="nt">&lt;TextBlock</span> <span class="na">Margin=</span><span class="s">"3,0,3,7"</span>
                     <span class="na">Text=</span><span class="s">"{Binding Path=TaskName}"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/StackPanel&gt;</span>
      <span class="nt">&lt;/Grid&gt;</span>
    <span class="nt">&lt;/DataTemplate&gt;</span>
  <span class="nt">&lt;/ItemsControl.ItemTemplate&gt;</span>
  <span class="c">&lt;!--Use the ItemContainerStyle property to specify the appearance
      of the element that contains the data. This ItemContainerStyle
      gives each item container a margin and a width. There is also
      a trigger that sets a tooltip that shows the description of
      the data object when the mouse hovers over the item container.--&gt;</span>
  <span class="nt">&lt;ItemsControl.ItemContainerStyle&gt;</span>
    <span class="nt">&lt;Style&gt;</span>
      <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Control.Width"</span> <span class="na">Value=</span><span class="s">"100"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Control.Margin"</span> <span class="na">Value=</span><span class="s">"5"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Style.Triggers&gt;</span>
        <span class="nt">&lt;Trigger</span> <span class="na">Property=</span><span class="s">"Control.IsMouseOver"</span> <span class="na">Value=</span><span class="s">"True"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Control.ToolTip"</span>
                  <span class="na">Value=</span><span class="s">"{Binding RelativeSource={x:Static RelativeSource.Self},
                          Path=Content.Description}"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Trigger&gt;</span>
      <span class="nt">&lt;/Style.Triggers&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>
  <span class="nt">&lt;/ItemsControl.ItemContainerStyle&gt;</span>
<span class="nt">&lt;/ItemsControl&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.hierarchicaldatatemplate">HierarchicalDataTemplate</a> class is designed to be used with <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.headereditemscontrol">HeaderedItemsControl</a> types to display collection data that contains other collections such as a <code>Menu</code> or a <code>TreeView</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window</span>
    <span class="na">x:Class=</span><span class="s">"SDKSample.Window1"</span>
    <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
    <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
    <span class="na">xmlns:src=</span><span class="s">"clr-namespace:SDKSample"</span>
    <span class="na">Title=</span><span class="s">"HierarchicalDataTemplate Sample"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;DockPanel&gt;</span>
        <span class="nt">&lt;DockPanel.Resources&gt;</span>
            <span class="nt">&lt;src:ListLeagueList</span> <span class="na">x:Key=</span><span class="s">"MyList"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;HierarchicalDataTemplate</span> <span class="na">DataType=</span><span class="s">"{x:Type src:League}"</span> <span class="na">ItemsSource=</span><span class="s">"{Binding Path=Divisions}"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Name}"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/HierarchicalDataTemplate&gt;</span>
            <span class="nt">&lt;HierarchicalDataTemplate</span> <span class="na">DataType=</span><span class="s">"{x:Type src:Division}"</span> <span class="na">ItemsSource=</span><span class="s">"{Binding Path=Teams}"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Name}"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/HierarchicalDataTemplate&gt;</span>
            <span class="nt">&lt;DataTemplate</span> <span class="na">DataType=</span><span class="s">"{x:Type src:Team}"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding Path=Name}"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/DataTemplate&gt;</span>
        <span class="nt">&lt;/DockPanel.Resources&gt;</span>
        <span class="nt">&lt;Menu</span>
            <span class="na">Name=</span><span class="s">"menu1"</span>
            <span class="na">Margin=</span><span class="s">"10,10,10,10"</span>
            <span class="na">DockPanel.Dock=</span><span class="s">"Top"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;MenuItem</span> <span class="na">Header=</span><span class="s">"My Soccer Leagues"</span> <span class="na">ItemsSource=</span><span class="s">"{Binding Source={StaticResource MyList}}"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/Menu&gt;</span>
        <span class="nt">&lt;TreeView&gt;</span>
            <span class="nt">&lt;TreeViewItem</span> <span class="na">Header=</span><span class="s">"My Soccer Leagues"</span> <span class="na">ItemsSource=</span><span class="s">"{Binding Source={StaticResource MyList}}"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/TreeView&gt;</span>
    <span class="nt">&lt;/DockPanel&gt;</span>
<span class="nt">&lt;/Window&gt;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="triggers">7.4. Triggers</h3>
<div class="paragraph">
<p>A trigger sets properties or starts actions, such as an animation, when a property value changes or when an event is raised.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Style</code>, <code>ControlTemplate</code>, and <code>DataTemplate</code> all have a <code>Triggers</code> property that can contain a set of triggers.</p>
</li>
<li>
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.trigger">Trigger</a> that sets property values or starts actions based on the value of a property is called a property trigger.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="c">&lt;!-- .... other resources .... --&gt;</span>

    <span class="nt">&lt;Style</span> <span class="na">TargetType=</span><span class="s">"ListBoxItem"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Opacity"</span> <span class="na">Value=</span><span class="s">"0.5"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"MaxHeight"</span> <span class="na">Value=</span><span class="s">"75"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Style.Triggers&gt;</span>
            <span class="nt">&lt;Trigger</span> <span class="na">Property=</span><span class="s">"IsSelected"</span> <span class="na">Value=</span><span class="s">"True"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;Trigger.Setters&gt;</span>
                    <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Opacity"</span> <span class="na">Value=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;/Trigger.Setters&gt;</span>
            <span class="nt">&lt;/Trigger&gt;</span>
        <span class="nt">&lt;/Style.Triggers&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The properties changed by triggers are automatically reset to their previous value when the triggered condition is no longer satisfied.</p>
</li>
<li>
<p>Another type of trigger is the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.eventtrigger">EventTrigger</a>, which starts a set of actions based on the occurrence of an event.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Style.Triggers&gt;</span>
    <span class="nt">&lt;Trigger</span> <span class="na">Property=</span><span class="s">"IsSelected"</span> <span class="na">Value=</span><span class="s">"True"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Trigger.Setters&gt;</span>
            <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Opacity"</span> <span class="na">Value=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/Trigger.Setters&gt;</span>
    <span class="nt">&lt;/Trigger&gt;</span>
    <span class="nt">&lt;EventTrigger</span> <span class="na">RoutedEvent=</span><span class="s">"Mouse.MouseEnter"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;EventTrigger.Actions&gt;</span>
            <span class="nt">&lt;BeginStoryboard&gt;</span>
                <span class="nt">&lt;Storyboard&gt;</span>
                    <span class="nt">&lt;DoubleAnimation</span>
                        <span class="na">Duration=</span><span class="s">"0:0:0.2"</span>
                        <span class="na">Storyboard.TargetProperty=</span><span class="s">"MaxHeight"</span>
                        <span class="na">To=</span><span class="s">"90"</span>  <span class="nt">/&gt;</span>
                <span class="nt">&lt;/Storyboard&gt;</span>
            <span class="nt">&lt;/BeginStoryboard&gt;</span>
        <span class="nt">&lt;/EventTrigger.Actions&gt;</span>
    <span class="nt">&lt;/EventTrigger&gt;</span>
    <span class="nt">&lt;EventTrigger</span> <span class="na">RoutedEvent=</span><span class="s">"Mouse.MouseLeave"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;EventTrigger.Actions&gt;</span>
            <span class="nt">&lt;BeginStoryboard&gt;</span>
                <span class="nt">&lt;Storyboard&gt;</span>
                    <span class="nt">&lt;DoubleAnimation</span>
                        <span class="na">Duration=</span><span class="s">"0:0:1"</span>
                        <span class="na">Storyboard.TargetProperty=</span><span class="s">"MaxHeight"</span>  <span class="nt">/&gt;</span>
                <span class="nt">&lt;/Storyboard&gt;</span>
            <span class="nt">&lt;/BeginStoryboard&gt;</span>
        <span class="nt">&lt;/EventTrigger.Actions&gt;</span>
    <span class="nt">&lt;/EventTrigger&gt;</span>
<span class="nt">&lt;/Style.Triggers&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.multitrigger">MultiTriggers</a> applly property values or performs actions when a set of conditions are satisfied.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Style.Triggers&gt;</span>
  <span class="nt">&lt;Trigger</span> <span class="na">Property=</span><span class="s">"IsEnabled"</span> <span class="na">Value=</span><span class="s">"false"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"Background"</span> <span class="na">Value=</span><span class="s">"#EEEEEE"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/Trigger&gt;</span>

  <span class="nt">&lt;MultiTrigger&gt;</span>
    <span class="nt">&lt;MultiTrigger.Conditions&gt;</span>
      <span class="nt">&lt;Condition</span> <span class="na">Property=</span><span class="s">"HasItems"</span> <span class="na">Value=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;Condition</span> <span class="na">Property=</span><span class="s">"Width"</span> <span class="na">Value=</span><span class="s">"Auto"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/MultiTrigger.Conditions&gt;</span>
    <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"MinWidth"</span> <span class="na">Value=</span><span class="s">"120"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/MultiTrigger&gt;</span>

  <span class="nt">&lt;MultiTrigger&gt;</span>
    <span class="nt">&lt;MultiTrigger.Conditions&gt;</span>
      <span class="nt">&lt;Condition</span> <span class="na">Property=</span><span class="s">"HasItems"</span> <span class="na">Value=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;Condition</span> <span class="na">Property=</span><span class="s">"Height"</span> <span class="na">Value=</span><span class="s">"Auto"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/MultiTrigger.Conditions&gt;</span>
    <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">"MinHeight"</span> <span class="na">Value=</span><span class="s">"95"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/MultiTrigger&gt;</span>
<span class="nt">&lt;/Style.Triggers&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.eventsetter">Event setters</a> invoke the specified event handlers in response to routed events, which apply to all elements that reference the Style rather than requiring to attach instance handlers to each individual element.</p>
<div class="ulist">
<ul>
<li>
<p>Only <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.style.setters?view=windowsdesktop-8.0">Style.Setters</a> support <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.eventsetter?view=windowsdesktop-8.0">EventSetter</a> objects.</p>
</li>
<li>
<p>Handlers attached through event setters are invoked after any class handlers for an event, and also after any instance handlers.</p>
<div class="paragraph">
<p>As a result, if a class handler or instance handler marks an event handled in its arguments, then the handler declared by an event setter is not invoked, unless the event setter specifically sets <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.eventsetter.handledeventstoo?view=windowsdesktop-8.0">HandledEventsToo</a> true.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;StackPanel</span>
  <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
  <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
  <span class="na">x:Class=</span><span class="s">"SDKSample.EventOvw2"</span>
  <span class="na">Name=</span><span class="s">"dpanel2"</span>
  <span class="na">Initialized=</span><span class="s">"PrimeHandledToo"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;StackPanel.Resources&gt;</span>
    <span class="nt">&lt;Style</span> <span class="na">TargetType=</span><span class="s">"{x:Type Button}"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;EventSetter</span> <span class="na">Event=</span><span class="s">"Click"</span> <span class="na">Handler=</span><span class="s">"b1SetColor"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>
  <span class="nt">&lt;/StackPanel.Resources&gt;</span>
  <span class="nt">&lt;Button&gt;</span>Click me<span class="nt">&lt;/Button&gt;</span>
  <span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">"ThisButton"</span> <span class="na">Click=</span><span class="s">"HandleThis"</span><span class="nt">&gt;</span>
    Raise event, handle it, use handled=true handler to get it anyway.
  <span class="nt">&lt;/Button&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">void</span> <span class="nf">b1SetColor</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Button</span> <span class="n">b</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">Source</span> <span class="k">as</span> <span class="n">Button</span><span class="p">;</span>
  <span class="n">b</span><span class="p">.</span><span class="n">Background</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SolidColorBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Azure</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">HandleThis</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">e</span><span class="p">.</span><span class="n">Handled</span><span class="p">=</span><span class="k">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="maui-mvvm-pattern"></a>[1] <a href="https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm" class="bare">https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm</a></p>
</li>
<li>
<p><a id="communitytoolkit"></a>[2] <a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/" class="bare">https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/</a></p>
</li>
<li>
<p><a id="wpf"></a>[3] <a href="https://learn.microsoft.com/en-us/dotnet/desktop/wpf" class="bare">https://learn.microsoft.com/en-us/dotnet/desktop/wpf</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
