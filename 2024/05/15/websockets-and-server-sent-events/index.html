<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>WebSockets and Server-sent events | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="WebSockets and Server-sent events" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. WebSockets 1.1. Date framing 1.2. Opening handshake in HTTP/1.1 1.3. WebSocket and HTTP Protocol [Gemini] 1.4. WebSockets in .NET 1.5. WebSockets in Browser 2. Server-sent events 2.1. Event stream format 2.2. Sending events from the server 2.3. Receiving events from the server 3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini] References 1. WebSockets WebSocket, standardized by the IETF as RFC 6455 in 2011, is a computer communications protocol, providing a simultaneous two-way communication channel over a single Transmission Control Protocol (TCP) connection. [1] The WebSocket is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries on the existing HTTP infrastructure, and could also use a simpler handshake over a dedicated port without reinventing the entire protocol. [2] WebSocket, conceptually, is really just a layer on top of TCP that does the following: [2] adds a web origin-based security model for browsers adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries The protocol has two parts: a handshake and the data transfer. After a successful handshake, clients and servers transfer messages back and forth. [2] On the wire, a message is composed of one or more fragmented frames. A frame has an associated type and broadly speaking, there are types for textual data, binary data, and control frames. WebSocket specification defines two URI schemes: [2] ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ] wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ] The protocol uses the HTTP/1.1 Upgrade mechanism (Section 6.7 of RFC7230) to transition a TCP connection from HTTP into a WebSocket connection, and uses the extended CONNECT method to initiate a WebSocket connection on an HTTP/2 stream. [3] 1.1. Date framing A high-level overview of the framing is given in the following figure. [2] 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ FIN: 1 bit Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment. Opcode: 4 bits Defines the interpretation of the &quot;Payload data&quot;. If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. The following values are defined. * %x0 denotes a continuation frame * %x1 denotes a text frame * %x2 denotes a binary frame * %x3-7 are reserved for further non-control frames * %x8 denotes a connection close * %x9 denotes a ping * %xA denotes a pong * %xB-F are reserved for further control frames Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Control frames are used to communicate state about the WebSocket. Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Data frames carry application-layer and/or extension-layer data. 1.2. Opening handshake in HTTP/1.1 The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. [2] The WebSocket client&#8217;s handshake is an HTTP Upgrade request with the Request-Line [4] format: [2] GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Origin: http://example.com Sec-WebSocket-Protocol: chat, superchat (1) Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== (2) Sec-WebSocket-Version: 13 1 The Sec-WebSocket-Protocol request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client. 2 The server takes the Sec-WebSocket-Key header field and echo the Sec-WebSocket-Accept header field to prove the received handshake. The handshake from the server is much simpler than the client handshake, and looks as follows with the Status-Line [4] format: HTTP/1.1 101 Switching Protocols (1) Upgrade: websocket (2) Connection: Upgrade (2) Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= (3) Sec-WebSocket-Protocol: chat (4) 1 Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. 2 The Connection and Upgrade header fields complete the HTTP Upgrade. 3 The Sec-WebSocket-Accept header field indicates whether the server is willing to accept the connection. 4 The Sec-WebSocket-Protocol is an option field, which indicates the subprotocol that the server has selected. Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake. 1.3. WebSocket and HTTP Protocol [Gemini] While WebSockets leverage the initial HTTP connection for the handshake, proxy servers do typically handle WebSocket traffic and normal HTTP traffic distinctly. WebSocket vs. HTTP Protocol Differences: Purpose: HTTP is designed for request-response interactions, while WebSocket establishes a full-duplex communication channel for real-time data exchange. Data Format: HTTP uses a text-based request-response format with headers and payloads. WebSocket uses a binary frame format for efficient data transfer. Connection State: HTTP connections are typically short-lived, closing after the response is sent. WebSockets maintain persistent connections for bi-directional communication. Proxy Handling: Initial Handshake: For both HTTP and WebSocket traffic, the proxy first establishes a standard HTTP connection with the target server. Handshake Differentiation: The proxy can identify WebSocket traffic by recognizing the specific handshake headers used in the initial HTTP request. Separate Handling: Once a WebSocket handshake is detected, the proxy switches to handling the subsequent frames using the WebSocket protocol. It might involve unmasking/remasking data and forwarding it appropriately. HTTP Traffic Handling: Normal HTTP requests and responses continue to be handled using the standard HTTP protocol by the proxy. Benefits of Separate Handling: Performance: By handling WebSocket traffic differently, the proxy can optimize processing for the specific needs of each protocol. This can improve performance for both WebSocket and HTTP traffic. Security: Some proxies might have specific security mechanisms tailored for HTTP traffic (e.g., content filtering). These wouldn&#8217;t be applicable to the binary data format of WebSockets. Separate handling allows for targeted security measures. Complexity Management: Separating the handling logic simplifies the proxy implementation as it deals with each protocol according to its unique characteristics. In summary: A single proxy server can manage both HTTP and WebSocket traffic. However, it differentiates between the two protocols during the initial handshake and then employs separate handling mechanisms for each to ensure optimal performance and proper data flow. 1.4. WebSockets in .NET Using WebSockets over HTTP/2 takes advantage of new features are available in Kestrel on all HTTP/2 enabled platforms such as: [5] Header compression. Multiplexing, which reduces the time and resources needed when making multiple requests to the server. HTTP/2 WebSockets use CONNECT requests rather than GET. WebSockets Server in ASP.NET Core var webSocketOptions = new WebSocketOptions { KeepAliveInterval = TimeSpan.FromMinutes(2) }; webSocketOptions.AllowedOrigins.Add(&quot;https://client.com&quot;); webSocketOptions.AllowedOrigins.Add(&quot;https://www.client.com&quot;); // Add the WebSockets middleware in `Program.cs`: app.UseWebSockets(webSocketOptions); app.Use(async (context, next) =&gt; { // [Route(&quot;/ws&quot;)] // HTTP/2 WebSockets use CONNECT requests rather than GET. if (context.Request.Path == &quot;/ws&quot;) { // Accept WebSocket requests if (context.WebSockets.IsWebSocketRequest) { using var webSocket = await context.WebSockets.AcceptWebSocketAsync(); await EchoAsync(webSocket); } else { context.Response.StatusCode = StatusCodes.Status400BadRequest; } } else { await next(context); } }); app.Run(); // Send and receive messages static async Task EchoAsync(WebSocket webSocket) { var buffer = new byte[1024 * 4]; var receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); while (!receiveResult.CloseStatus.HasValue) { await webSocket.SendAsync( new ArraySegment&lt;byte&gt;(buffer, 0, receiveResult.Count), receiveResult.MessageType, receiveResult.EndOfMessage, CancellationToken.None); receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); } await webSocket.CloseAsync( receiveResult.CloseStatus.Value, receiveResult.CloseStatusDescription, CancellationToken.None); } WebSockets Client in .NET string[] messages = [ &quot;我们的生命不是消逝于那些重大的事件中，而是流逝在那些日常琐碎的小事里。&quot;, &quot;生活是由无数微不足道的细节构建起来的，而记忆正是这些细节的忠实记录者，它们在某个不经意的瞬间被唤醒，带我们穿越回往昔。&quot;, &quot;人们在追求他们以为是幸福的东西时，常常错过真正的幸福。&quot;, &quot;在失去之后，我们才开始寻找那些曾经拥有但未被珍惜的东西，而记忆，则成了我们找回那些失落时光的唯一线索。&quot; ]; Uri uri = new(&quot;ws://localhost:5000/ws&quot;); using ClientWebSocket ws = new(); var cts = new CancellationTokenSource(); await ws.ConnectAsync(uri, cts.Token); foreach (var message in messages) { var bytes = Encoding.UTF8.GetBytes(message); await ws.SendAsync(bytes, WebSocketMessageType.Text, true, cts.Token); } ThreadPool.QueueUserWorkItem(async _ =&gt; { while (!cts.Token.IsCancellationRequested) { var (echoMessage, _, _, _, _) = await ReadMessageAsync(ws, cts.Token); Console.WriteLine(Encoding.UTF8.GetString(echoMessage.ToArray())); } }); await Task.Delay(1000); await ws.CloseAsync(WebSocketCloseStatus.NormalClosure, &quot;Client closed&quot;, cts.Token); // Read a complete message from a WebSocket. static async Task&lt;(IList&lt;byte&gt;, WebSocketMessageType, bool, WebSocketCloseStatus?, string?)&gt; ReadMessageAsync(WebSocket webSocket, CancellationToken token = default) { var message = new List&lt;byte&gt;(1024 * 2); var buffer = new byte[8 * 4]; var receiveResult = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), token).ConfigureAwait(false); while (true) { message.AddRange(new ArraySegment&lt;byte&gt;(buffer, 0, receiveResult.Count)); if (receiveResult.CloseStatus.HasValue || receiveResult.EndOfMessage) { break; } receiveResult = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), token).ConfigureAwait(false); } return (message.AsReadOnly(), receiveResult.MessageType, receiveResult.EndOfMessage, receiveResult.CloseStatus, receiveResult.CloseStatusDescription); } 1.5. WebSockets in Browser The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between browser and server, which can send messages to a server and receive event-driven responses without having to poll the server for a reply. [7] const excerpts = [ &#39;Grown-ups never understand anything by themselves, and it is tiresome for children to be always and forever explaining things to them.&#39;, &#39;And now here is my secret, a very simple secret: It is only with the heart that one can see rightly; what is essential is invisible to the eye.&#39;, &quot;People have forgotten this truth,&#39; the fox said. &#39;But you mustn’t forget it. You become responsible forever for what you’ve tamed. You’re responsible for your rose.&quot;, &#39;All grown-ups were once children... but only few of them remember it.&#39;, &#39;It is the time you have wasted for your rose that makes your rose so important.&#39;, &#39;One sees clearly only with the heart. Anything essential is invisible to the eyes.&#39;, &#39;You - you alone will have the stars as no one else has them... In one of the stars I shall be living. In one of them I shall be laughing. And so it will be as if all the stars were laughing, when you look at the sky at night... You - only you - will have stars that can laugh.&#39;, &#39;You become responsible, forever, for what you have tamed.&#39; ] // Creating a WebSocket object const ws = new WebSocket(&#39;ws://localhost:5000/ws&#39;) // Listen for possible errors ws.addEventListener(&#39;error&#39;, (event) =&gt; { console.log(&#39;WebSocket error: &#39;, event) }) // Sending data to the server ws.onopen = () =&gt; { for (const excerpt of excerpts) { ws.send(excerpt) } } // Receiving messages from the server ws.onmessage = (e) =&gt; { console.log(e.data) } 2. Server-sent events Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via an HTTP connection, and describes how servers can initiate data transmission towards clients once an initial client connection has been established. [8] 2.1. Event stream format The event stream is a simple stream of text data messages which are separated by a pair of newline characters (\n\n), and must be encoded using UTF-8. [9] A colon (:) as the first character of a line is in essence a comment, and is ignored. Each message consists of one or more lines of text listing the fields for that message. Each field is represented by the field name (event, data, id, and retry), followed by a colon, followed by the text data for that field&#8217;s value. : this is a test stream (1) event: userconnect (2) data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;} data: another message (3) data: with two lines (3) event: usermessage (2) data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;} 1 The first is just a comment, since it starts with a colon character. 2 This sends custom named events. 3 The third message contains a data field with the value &quot;another message\nwith two lines&quot;. Note the newline special character in the value. 2.2. Sending events from the server The server-side that sends events needs to respond using the MIME type text/event-stream. Each notification is sent as a block of text terminated by a pair of newlines. [9] Here is the .NET code for the example: app.UseCors(policy =&gt; policy.AllowAnyOrigin()); // builder.Services.AddCors(); var excerpts = new string[] { &quot;Notre vie ne se gaspille pas dans les grands événements, mais s&#39;écoule dans les petites choses de tous les jours.&quot;, &quot;La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé.&quot;, &quot;En poursuivant ce qu&#39;ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur.&quot;, &quot;Ce n&#39;est qu&#39;après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n&#39;avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus.&quot; }; app.Use(async (context, next) =&gt; { if (context.Request.Path == &quot;/sse&quot;) { if (context.Request.Headers.Accept.Any(x =&gt; x != null &amp;&amp; x.Contains(&quot;text/event-stream&quot;))) { context.Response.Headers.ContentType = &quot;text/event-stream&quot;; context.Response.Headers.CacheControl = &quot;no-cache&quot;; await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes($&quot;event: ping\ndata: pong!\n\n&quot;)); await context.Response.Body.FlushAsync(); foreach (var excerpt in excerpts) { await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes($&quot;data: {excerpt}\n\n&quot;)); await context.Response.Body.FlushAsync(); } // the stream terminated by a data: [DONE] await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes(&quot;data: [DONE]\n\n&quot;)); await context.Response.Body.FlushAsync(); } else { context.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType; } } else { await next(context); } }); app.Run(); $ curl -i localhost:5000/sse -H &#39;accept: text/event-stream&#39; HTTP/1.1 200 OK Content-Type: text/event-stream Date: Thu, 16 May 2024 11:14:26 GMT Server: Kestrel Cache-Control: no-cache Transfer-Encoding: chunked event: ping data: pong! data: Notre vie ne se gaspille pas dans les grands événements, mais s&#39;écoule dans les petites choses de tous les jours. data: La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé. data: En poursuivant ce qu&#39;ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur. data: Ce n&#39;est qu&#39;après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n&#39;avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus. data: [DONE] 2.3. Receiving events from the server The server-sent event API is contained in the EventSource interface. // Creating an EventSource instance const evtSource = new EventSource(&#39;//localhost:5000/sse&#39;, { // withCredentials: true }) // Listening for message events evtSource.onmessage = (event) =&gt; { console.log(`message: ${event.data}`) // the stream terminated by a data: [DONE] if (event.data === &#39;[DONE]&#39;) { // Closing event streams evtSource.close() } } // Listening for custom events evtSource.addEventListener(&#39;ping&#39;, (event) =&gt; { console.log(`ping: ${event.data}`) }) // Error handling evtSource.onerror = (err) =&gt; { console.error(&#39;EventSource failed:&#39;, err) } 3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini] While all three terms involve transferring data from a server to a client, they serve distinct purposes and operate in different contexts. This blog post clarifies the key distinctions to help you choose the right approach for your application. WebSockets: Real-time, Two-Way Communication Imagine a live chat conversation. WebSockets facilitate full-duplex communication, where both the server and client can send and receive messages in real-time. This allows for interactive experiences like chat applications, online games, or collaborative editing tools. A long-lived connection is established, enabling continuous data flow in both directions. Server-Sent Events (SSE): Server Pushes Updates Think of a live news feed. SSE allows the server to proactively push updates or data to connected clients. Clients cannot directly send messages back. This unidirectional approach is ideal for real-time updates where the server needs to broadcast information, like stock tickers, sensor readings, or live sports scores. Similarly to WebSockets, a long-lived connection is maintained between the server and client. HTTP 206 Partial Content: Downloading Large Files in Chunks Imagine downloading a large movie. HTTP 206 Partial Content is part of the standard HTTP protocol for handling partial downloads. The client requests a specific portion of a resource (e.g., a specific chunk of the movie file), the server sends only that part, and the connection closes. This is useful for downloading large files more efficiently, allowing for progress updates and potentially faster perceived download speeds. Choosing the Right Tool: The best approach depends on your application&#8217;s needs: Real-time, two-way communication: Use WebSockets. Server-side updates without client interaction: Use SSE. Downloading large resources in chunks: Use HTTP 206 Partial Content. By understanding these concepts, you can make informed decisions when designing real-time or download functionalities in your web applications. References [1] https://en.wikipedia.org/wiki/WebSocket [2] https://www.rfc-editor.org/rfc/rfc6455 [3] https://www.rfc-editor.org/rfc/rfc8441 [4] https://www.rfc-editor.org/rfc/rfc2616 [5] https://learn.microsoft.com/en-us/aspnet/core/fundamentals/websockets [6] https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/websockets [7] https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API [8] https://en.wikipedia.org/wiki/Server-sent_events [9]https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" />
<meta property="og:description" content="1. WebSockets 1.1. Date framing 1.2. Opening handshake in HTTP/1.1 1.3. WebSocket and HTTP Protocol [Gemini] 1.4. WebSockets in .NET 1.5. WebSockets in Browser 2. Server-sent events 2.1. Event stream format 2.2. Sending events from the server 2.3. Receiving events from the server 3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini] References 1. WebSockets WebSocket, standardized by the IETF as RFC 6455 in 2011, is a computer communications protocol, providing a simultaneous two-way communication channel over a single Transmission Control Protocol (TCP) connection. [1] The WebSocket is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries on the existing HTTP infrastructure, and could also use a simpler handshake over a dedicated port without reinventing the entire protocol. [2] WebSocket, conceptually, is really just a layer on top of TCP that does the following: [2] adds a web origin-based security model for browsers adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries The protocol has two parts: a handshake and the data transfer. After a successful handshake, clients and servers transfer messages back and forth. [2] On the wire, a message is composed of one or more fragmented frames. A frame has an associated type and broadly speaking, there are types for textual data, binary data, and control frames. WebSocket specification defines two URI schemes: [2] ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ] wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ] The protocol uses the HTTP/1.1 Upgrade mechanism (Section 6.7 of RFC7230) to transition a TCP connection from HTTP into a WebSocket connection, and uses the extended CONNECT method to initiate a WebSocket connection on an HTTP/2 stream. [3] 1.1. Date framing A high-level overview of the framing is given in the following figure. [2] 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ FIN: 1 bit Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment. Opcode: 4 bits Defines the interpretation of the &quot;Payload data&quot;. If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. The following values are defined. * %x0 denotes a continuation frame * %x1 denotes a text frame * %x2 denotes a binary frame * %x3-7 are reserved for further non-control frames * %x8 denotes a connection close * %x9 denotes a ping * %xA denotes a pong * %xB-F are reserved for further control frames Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Control frames are used to communicate state about the WebSocket. Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Data frames carry application-layer and/or extension-layer data. 1.2. Opening handshake in HTTP/1.1 The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. [2] The WebSocket client&#8217;s handshake is an HTTP Upgrade request with the Request-Line [4] format: [2] GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Origin: http://example.com Sec-WebSocket-Protocol: chat, superchat (1) Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== (2) Sec-WebSocket-Version: 13 1 The Sec-WebSocket-Protocol request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client. 2 The server takes the Sec-WebSocket-Key header field and echo the Sec-WebSocket-Accept header field to prove the received handshake. The handshake from the server is much simpler than the client handshake, and looks as follows with the Status-Line [4] format: HTTP/1.1 101 Switching Protocols (1) Upgrade: websocket (2) Connection: Upgrade (2) Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= (3) Sec-WebSocket-Protocol: chat (4) 1 Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. 2 The Connection and Upgrade header fields complete the HTTP Upgrade. 3 The Sec-WebSocket-Accept header field indicates whether the server is willing to accept the connection. 4 The Sec-WebSocket-Protocol is an option field, which indicates the subprotocol that the server has selected. Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake. 1.3. WebSocket and HTTP Protocol [Gemini] While WebSockets leverage the initial HTTP connection for the handshake, proxy servers do typically handle WebSocket traffic and normal HTTP traffic distinctly. WebSocket vs. HTTP Protocol Differences: Purpose: HTTP is designed for request-response interactions, while WebSocket establishes a full-duplex communication channel for real-time data exchange. Data Format: HTTP uses a text-based request-response format with headers and payloads. WebSocket uses a binary frame format for efficient data transfer. Connection State: HTTP connections are typically short-lived, closing after the response is sent. WebSockets maintain persistent connections for bi-directional communication. Proxy Handling: Initial Handshake: For both HTTP and WebSocket traffic, the proxy first establishes a standard HTTP connection with the target server. Handshake Differentiation: The proxy can identify WebSocket traffic by recognizing the specific handshake headers used in the initial HTTP request. Separate Handling: Once a WebSocket handshake is detected, the proxy switches to handling the subsequent frames using the WebSocket protocol. It might involve unmasking/remasking data and forwarding it appropriately. HTTP Traffic Handling: Normal HTTP requests and responses continue to be handled using the standard HTTP protocol by the proxy. Benefits of Separate Handling: Performance: By handling WebSocket traffic differently, the proxy can optimize processing for the specific needs of each protocol. This can improve performance for both WebSocket and HTTP traffic. Security: Some proxies might have specific security mechanisms tailored for HTTP traffic (e.g., content filtering). These wouldn&#8217;t be applicable to the binary data format of WebSockets. Separate handling allows for targeted security measures. Complexity Management: Separating the handling logic simplifies the proxy implementation as it deals with each protocol according to its unique characteristics. In summary: A single proxy server can manage both HTTP and WebSocket traffic. However, it differentiates between the two protocols during the initial handshake and then employs separate handling mechanisms for each to ensure optimal performance and proper data flow. 1.4. WebSockets in .NET Using WebSockets over HTTP/2 takes advantage of new features are available in Kestrel on all HTTP/2 enabled platforms such as: [5] Header compression. Multiplexing, which reduces the time and resources needed when making multiple requests to the server. HTTP/2 WebSockets use CONNECT requests rather than GET. WebSockets Server in ASP.NET Core var webSocketOptions = new WebSocketOptions { KeepAliveInterval = TimeSpan.FromMinutes(2) }; webSocketOptions.AllowedOrigins.Add(&quot;https://client.com&quot;); webSocketOptions.AllowedOrigins.Add(&quot;https://www.client.com&quot;); // Add the WebSockets middleware in `Program.cs`: app.UseWebSockets(webSocketOptions); app.Use(async (context, next) =&gt; { // [Route(&quot;/ws&quot;)] // HTTP/2 WebSockets use CONNECT requests rather than GET. if (context.Request.Path == &quot;/ws&quot;) { // Accept WebSocket requests if (context.WebSockets.IsWebSocketRequest) { using var webSocket = await context.WebSockets.AcceptWebSocketAsync(); await EchoAsync(webSocket); } else { context.Response.StatusCode = StatusCodes.Status400BadRequest; } } else { await next(context); } }); app.Run(); // Send and receive messages static async Task EchoAsync(WebSocket webSocket) { var buffer = new byte[1024 * 4]; var receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); while (!receiveResult.CloseStatus.HasValue) { await webSocket.SendAsync( new ArraySegment&lt;byte&gt;(buffer, 0, receiveResult.Count), receiveResult.MessageType, receiveResult.EndOfMessage, CancellationToken.None); receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); } await webSocket.CloseAsync( receiveResult.CloseStatus.Value, receiveResult.CloseStatusDescription, CancellationToken.None); } WebSockets Client in .NET string[] messages = [ &quot;我们的生命不是消逝于那些重大的事件中，而是流逝在那些日常琐碎的小事里。&quot;, &quot;生活是由无数微不足道的细节构建起来的，而记忆正是这些细节的忠实记录者，它们在某个不经意的瞬间被唤醒，带我们穿越回往昔。&quot;, &quot;人们在追求他们以为是幸福的东西时，常常错过真正的幸福。&quot;, &quot;在失去之后，我们才开始寻找那些曾经拥有但未被珍惜的东西，而记忆，则成了我们找回那些失落时光的唯一线索。&quot; ]; Uri uri = new(&quot;ws://localhost:5000/ws&quot;); using ClientWebSocket ws = new(); var cts = new CancellationTokenSource(); await ws.ConnectAsync(uri, cts.Token); foreach (var message in messages) { var bytes = Encoding.UTF8.GetBytes(message); await ws.SendAsync(bytes, WebSocketMessageType.Text, true, cts.Token); } ThreadPool.QueueUserWorkItem(async _ =&gt; { while (!cts.Token.IsCancellationRequested) { var (echoMessage, _, _, _, _) = await ReadMessageAsync(ws, cts.Token); Console.WriteLine(Encoding.UTF8.GetString(echoMessage.ToArray())); } }); await Task.Delay(1000); await ws.CloseAsync(WebSocketCloseStatus.NormalClosure, &quot;Client closed&quot;, cts.Token); // Read a complete message from a WebSocket. static async Task&lt;(IList&lt;byte&gt;, WebSocketMessageType, bool, WebSocketCloseStatus?, string?)&gt; ReadMessageAsync(WebSocket webSocket, CancellationToken token = default) { var message = new List&lt;byte&gt;(1024 * 2); var buffer = new byte[8 * 4]; var receiveResult = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), token).ConfigureAwait(false); while (true) { message.AddRange(new ArraySegment&lt;byte&gt;(buffer, 0, receiveResult.Count)); if (receiveResult.CloseStatus.HasValue || receiveResult.EndOfMessage) { break; } receiveResult = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), token).ConfigureAwait(false); } return (message.AsReadOnly(), receiveResult.MessageType, receiveResult.EndOfMessage, receiveResult.CloseStatus, receiveResult.CloseStatusDescription); } 1.5. WebSockets in Browser The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between browser and server, which can send messages to a server and receive event-driven responses without having to poll the server for a reply. [7] const excerpts = [ &#39;Grown-ups never understand anything by themselves, and it is tiresome for children to be always and forever explaining things to them.&#39;, &#39;And now here is my secret, a very simple secret: It is only with the heart that one can see rightly; what is essential is invisible to the eye.&#39;, &quot;People have forgotten this truth,&#39; the fox said. &#39;But you mustn’t forget it. You become responsible forever for what you’ve tamed. You’re responsible for your rose.&quot;, &#39;All grown-ups were once children... but only few of them remember it.&#39;, &#39;It is the time you have wasted for your rose that makes your rose so important.&#39;, &#39;One sees clearly only with the heart. Anything essential is invisible to the eyes.&#39;, &#39;You - you alone will have the stars as no one else has them... In one of the stars I shall be living. In one of them I shall be laughing. And so it will be as if all the stars were laughing, when you look at the sky at night... You - only you - will have stars that can laugh.&#39;, &#39;You become responsible, forever, for what you have tamed.&#39; ] // Creating a WebSocket object const ws = new WebSocket(&#39;ws://localhost:5000/ws&#39;) // Listen for possible errors ws.addEventListener(&#39;error&#39;, (event) =&gt; { console.log(&#39;WebSocket error: &#39;, event) }) // Sending data to the server ws.onopen = () =&gt; { for (const excerpt of excerpts) { ws.send(excerpt) } } // Receiving messages from the server ws.onmessage = (e) =&gt; { console.log(e.data) } 2. Server-sent events Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via an HTTP connection, and describes how servers can initiate data transmission towards clients once an initial client connection has been established. [8] 2.1. Event stream format The event stream is a simple stream of text data messages which are separated by a pair of newline characters (\n\n), and must be encoded using UTF-8. [9] A colon (:) as the first character of a line is in essence a comment, and is ignored. Each message consists of one or more lines of text listing the fields for that message. Each field is represented by the field name (event, data, id, and retry), followed by a colon, followed by the text data for that field&#8217;s value. : this is a test stream (1) event: userconnect (2) data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;} data: another message (3) data: with two lines (3) event: usermessage (2) data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;} 1 The first is just a comment, since it starts with a colon character. 2 This sends custom named events. 3 The third message contains a data field with the value &quot;another message\nwith two lines&quot;. Note the newline special character in the value. 2.2. Sending events from the server The server-side that sends events needs to respond using the MIME type text/event-stream. Each notification is sent as a block of text terminated by a pair of newlines. [9] Here is the .NET code for the example: app.UseCors(policy =&gt; policy.AllowAnyOrigin()); // builder.Services.AddCors(); var excerpts = new string[] { &quot;Notre vie ne se gaspille pas dans les grands événements, mais s&#39;écoule dans les petites choses de tous les jours.&quot;, &quot;La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé.&quot;, &quot;En poursuivant ce qu&#39;ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur.&quot;, &quot;Ce n&#39;est qu&#39;après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n&#39;avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus.&quot; }; app.Use(async (context, next) =&gt; { if (context.Request.Path == &quot;/sse&quot;) { if (context.Request.Headers.Accept.Any(x =&gt; x != null &amp;&amp; x.Contains(&quot;text/event-stream&quot;))) { context.Response.Headers.ContentType = &quot;text/event-stream&quot;; context.Response.Headers.CacheControl = &quot;no-cache&quot;; await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes($&quot;event: ping\ndata: pong!\n\n&quot;)); await context.Response.Body.FlushAsync(); foreach (var excerpt in excerpts) { await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes($&quot;data: {excerpt}\n\n&quot;)); await context.Response.Body.FlushAsync(); } // the stream terminated by a data: [DONE] await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes(&quot;data: [DONE]\n\n&quot;)); await context.Response.Body.FlushAsync(); } else { context.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType; } } else { await next(context); } }); app.Run(); $ curl -i localhost:5000/sse -H &#39;accept: text/event-stream&#39; HTTP/1.1 200 OK Content-Type: text/event-stream Date: Thu, 16 May 2024 11:14:26 GMT Server: Kestrel Cache-Control: no-cache Transfer-Encoding: chunked event: ping data: pong! data: Notre vie ne se gaspille pas dans les grands événements, mais s&#39;écoule dans les petites choses de tous les jours. data: La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé. data: En poursuivant ce qu&#39;ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur. data: Ce n&#39;est qu&#39;après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n&#39;avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus. data: [DONE] 2.3. Receiving events from the server The server-sent event API is contained in the EventSource interface. // Creating an EventSource instance const evtSource = new EventSource(&#39;//localhost:5000/sse&#39;, { // withCredentials: true }) // Listening for message events evtSource.onmessage = (event) =&gt; { console.log(`message: ${event.data}`) // the stream terminated by a data: [DONE] if (event.data === &#39;[DONE]&#39;) { // Closing event streams evtSource.close() } } // Listening for custom events evtSource.addEventListener(&#39;ping&#39;, (event) =&gt; { console.log(`ping: ${event.data}`) }) // Error handling evtSource.onerror = (err) =&gt; { console.error(&#39;EventSource failed:&#39;, err) } 3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini] While all three terms involve transferring data from a server to a client, they serve distinct purposes and operate in different contexts. This blog post clarifies the key distinctions to help you choose the right approach for your application. WebSockets: Real-time, Two-Way Communication Imagine a live chat conversation. WebSockets facilitate full-duplex communication, where both the server and client can send and receive messages in real-time. This allows for interactive experiences like chat applications, online games, or collaborative editing tools. A long-lived connection is established, enabling continuous data flow in both directions. Server-Sent Events (SSE): Server Pushes Updates Think of a live news feed. SSE allows the server to proactively push updates or data to connected clients. Clients cannot directly send messages back. This unidirectional approach is ideal for real-time updates where the server needs to broadcast information, like stock tickers, sensor readings, or live sports scores. Similarly to WebSockets, a long-lived connection is maintained between the server and client. HTTP 206 Partial Content: Downloading Large Files in Chunks Imagine downloading a large movie. HTTP 206 Partial Content is part of the standard HTTP protocol for handling partial downloads. The client requests a specific portion of a resource (e.g., a specific chunk of the movie file), the server sends only that part, and the connection closes. This is useful for downloading large files more efficiently, allowing for progress updates and potentially faster perceived download speeds. Choosing the Right Tool: The best approach depends on your application&#8217;s needs: Real-time, two-way communication: Use WebSockets. Server-side updates without client interaction: Use SSE. Downloading large resources in chunks: Use HTTP 206 Partial Content. By understanding these concepts, you can make informed decisions when designing real-time or download functionalities in your web applications. References [1] https://en.wikipedia.org/wiki/WebSocket [2] https://www.rfc-editor.org/rfc/rfc6455 [3] https://www.rfc-editor.org/rfc/rfc8441 [4] https://www.rfc-editor.org/rfc/rfc2616 [5] https://learn.microsoft.com/en-us/aspnet/core/fundamentals/websockets [6] https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/websockets [7] https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API [8] https://en.wikipedia.org/wiki/Server-sent_events [9]https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" />
<link rel="canonical" href="https://blog.codefarm.me/2024/05/15/websockets-and-server-sent-events/" />
<meta property="og:url" content="https://blog.codefarm.me/2024/05/15/websockets-and-server-sent-events/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-05-15T15:00:40+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="WebSockets and Server-sent events" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-05-15T15:00:40+08:00","datePublished":"2024-05-15T15:00:40+08:00","description":"1. WebSockets 1.1. Date framing 1.2. Opening handshake in HTTP/1.1 1.3. WebSocket and HTTP Protocol [Gemini] 1.4. WebSockets in .NET 1.5. WebSockets in Browser 2. Server-sent events 2.1. Event stream format 2.2. Sending events from the server 2.3. Receiving events from the server 3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini] References 1. WebSockets WebSocket, standardized by the IETF as RFC 6455 in 2011, is a computer communications protocol, providing a simultaneous two-way communication channel over a single Transmission Control Protocol (TCP) connection. [1] The WebSocket is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries on the existing HTTP infrastructure, and could also use a simpler handshake over a dedicated port without reinventing the entire protocol. [2] WebSocket, conceptually, is really just a layer on top of TCP that does the following: [2] adds a web origin-based security model for browsers adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries The protocol has two parts: a handshake and the data transfer. After a successful handshake, clients and servers transfer messages back and forth. [2] On the wire, a message is composed of one or more fragmented frames. A frame has an associated type and broadly speaking, there are types for textual data, binary data, and control frames. WebSocket specification defines two URI schemes: [2] ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ] wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ] The protocol uses the HTTP/1.1 Upgrade mechanism (Section 6.7 of RFC7230) to transition a TCP connection from HTTP into a WebSocket connection, and uses the extended CONNECT method to initiate a WebSocket connection on an HTTP/2 stream. [3] 1.1. Date framing A high-level overview of the framing is given in the following figure. [2] 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ FIN: 1 bit Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment. Opcode: 4 bits Defines the interpretation of the &quot;Payload data&quot;. If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. The following values are defined. * %x0 denotes a continuation frame * %x1 denotes a text frame * %x2 denotes a binary frame * %x3-7 are reserved for further non-control frames * %x8 denotes a connection close * %x9 denotes a ping * %xA denotes a pong * %xB-F are reserved for further control frames Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Control frames are used to communicate state about the WebSocket. Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Data frames carry application-layer and/or extension-layer data. 1.2. Opening handshake in HTTP/1.1 The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. [2] The WebSocket client&#8217;s handshake is an HTTP Upgrade request with the Request-Line [4] format: [2] GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Origin: http://example.com Sec-WebSocket-Protocol: chat, superchat (1) Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== (2) Sec-WebSocket-Version: 13 1 The Sec-WebSocket-Protocol request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client. 2 The server takes the Sec-WebSocket-Key header field and echo the Sec-WebSocket-Accept header field to prove the received handshake. The handshake from the server is much simpler than the client handshake, and looks as follows with the Status-Line [4] format: HTTP/1.1 101 Switching Protocols (1) Upgrade: websocket (2) Connection: Upgrade (2) Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= (3) Sec-WebSocket-Protocol: chat (4) 1 Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. 2 The Connection and Upgrade header fields complete the HTTP Upgrade. 3 The Sec-WebSocket-Accept header field indicates whether the server is willing to accept the connection. 4 The Sec-WebSocket-Protocol is an option field, which indicates the subprotocol that the server has selected. Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake. 1.3. WebSocket and HTTP Protocol [Gemini] While WebSockets leverage the initial HTTP connection for the handshake, proxy servers do typically handle WebSocket traffic and normal HTTP traffic distinctly. WebSocket vs. HTTP Protocol Differences: Purpose: HTTP is designed for request-response interactions, while WebSocket establishes a full-duplex communication channel for real-time data exchange. Data Format: HTTP uses a text-based request-response format with headers and payloads. WebSocket uses a binary frame format for efficient data transfer. Connection State: HTTP connections are typically short-lived, closing after the response is sent. WebSockets maintain persistent connections for bi-directional communication. Proxy Handling: Initial Handshake: For both HTTP and WebSocket traffic, the proxy first establishes a standard HTTP connection with the target server. Handshake Differentiation: The proxy can identify WebSocket traffic by recognizing the specific handshake headers used in the initial HTTP request. Separate Handling: Once a WebSocket handshake is detected, the proxy switches to handling the subsequent frames using the WebSocket protocol. It might involve unmasking/remasking data and forwarding it appropriately. HTTP Traffic Handling: Normal HTTP requests and responses continue to be handled using the standard HTTP protocol by the proxy. Benefits of Separate Handling: Performance: By handling WebSocket traffic differently, the proxy can optimize processing for the specific needs of each protocol. This can improve performance for both WebSocket and HTTP traffic. Security: Some proxies might have specific security mechanisms tailored for HTTP traffic (e.g., content filtering). These wouldn&#8217;t be applicable to the binary data format of WebSockets. Separate handling allows for targeted security measures. Complexity Management: Separating the handling logic simplifies the proxy implementation as it deals with each protocol according to its unique characteristics. In summary: A single proxy server can manage both HTTP and WebSocket traffic. However, it differentiates between the two protocols during the initial handshake and then employs separate handling mechanisms for each to ensure optimal performance and proper data flow. 1.4. WebSockets in .NET Using WebSockets over HTTP/2 takes advantage of new features are available in Kestrel on all HTTP/2 enabled platforms such as: [5] Header compression. Multiplexing, which reduces the time and resources needed when making multiple requests to the server. HTTP/2 WebSockets use CONNECT requests rather than GET. WebSockets Server in ASP.NET Core var webSocketOptions = new WebSocketOptions { KeepAliveInterval = TimeSpan.FromMinutes(2) }; webSocketOptions.AllowedOrigins.Add(&quot;https://client.com&quot;); webSocketOptions.AllowedOrigins.Add(&quot;https://www.client.com&quot;); // Add the WebSockets middleware in `Program.cs`: app.UseWebSockets(webSocketOptions); app.Use(async (context, next) =&gt; { // [Route(&quot;/ws&quot;)] // HTTP/2 WebSockets use CONNECT requests rather than GET. if (context.Request.Path == &quot;/ws&quot;) { // Accept WebSocket requests if (context.WebSockets.IsWebSocketRequest) { using var webSocket = await context.WebSockets.AcceptWebSocketAsync(); await EchoAsync(webSocket); } else { context.Response.StatusCode = StatusCodes.Status400BadRequest; } } else { await next(context); } }); app.Run(); // Send and receive messages static async Task EchoAsync(WebSocket webSocket) { var buffer = new byte[1024 * 4]; var receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); while (!receiveResult.CloseStatus.HasValue) { await webSocket.SendAsync( new ArraySegment&lt;byte&gt;(buffer, 0, receiveResult.Count), receiveResult.MessageType, receiveResult.EndOfMessage, CancellationToken.None); receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); } await webSocket.CloseAsync( receiveResult.CloseStatus.Value, receiveResult.CloseStatusDescription, CancellationToken.None); } WebSockets Client in .NET string[] messages = [ &quot;我们的生命不是消逝于那些重大的事件中，而是流逝在那些日常琐碎的小事里。&quot;, &quot;生活是由无数微不足道的细节构建起来的，而记忆正是这些细节的忠实记录者，它们在某个不经意的瞬间被唤醒，带我们穿越回往昔。&quot;, &quot;人们在追求他们以为是幸福的东西时，常常错过真正的幸福。&quot;, &quot;在失去之后，我们才开始寻找那些曾经拥有但未被珍惜的东西，而记忆，则成了我们找回那些失落时光的唯一线索。&quot; ]; Uri uri = new(&quot;ws://localhost:5000/ws&quot;); using ClientWebSocket ws = new(); var cts = new CancellationTokenSource(); await ws.ConnectAsync(uri, cts.Token); foreach (var message in messages) { var bytes = Encoding.UTF8.GetBytes(message); await ws.SendAsync(bytes, WebSocketMessageType.Text, true, cts.Token); } ThreadPool.QueueUserWorkItem(async _ =&gt; { while (!cts.Token.IsCancellationRequested) { var (echoMessage, _, _, _, _) = await ReadMessageAsync(ws, cts.Token); Console.WriteLine(Encoding.UTF8.GetString(echoMessage.ToArray())); } }); await Task.Delay(1000); await ws.CloseAsync(WebSocketCloseStatus.NormalClosure, &quot;Client closed&quot;, cts.Token); // Read a complete message from a WebSocket. static async Task&lt;(IList&lt;byte&gt;, WebSocketMessageType, bool, WebSocketCloseStatus?, string?)&gt; ReadMessageAsync(WebSocket webSocket, CancellationToken token = default) { var message = new List&lt;byte&gt;(1024 * 2); var buffer = new byte[8 * 4]; var receiveResult = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), token).ConfigureAwait(false); while (true) { message.AddRange(new ArraySegment&lt;byte&gt;(buffer, 0, receiveResult.Count)); if (receiveResult.CloseStatus.HasValue || receiveResult.EndOfMessage) { break; } receiveResult = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), token).ConfigureAwait(false); } return (message.AsReadOnly(), receiveResult.MessageType, receiveResult.EndOfMessage, receiveResult.CloseStatus, receiveResult.CloseStatusDescription); } 1.5. WebSockets in Browser The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between browser and server, which can send messages to a server and receive event-driven responses without having to poll the server for a reply. [7] const excerpts = [ &#39;Grown-ups never understand anything by themselves, and it is tiresome for children to be always and forever explaining things to them.&#39;, &#39;And now here is my secret, a very simple secret: It is only with the heart that one can see rightly; what is essential is invisible to the eye.&#39;, &quot;People have forgotten this truth,&#39; the fox said. &#39;But you mustn’t forget it. You become responsible forever for what you’ve tamed. You’re responsible for your rose.&quot;, &#39;All grown-ups were once children... but only few of them remember it.&#39;, &#39;It is the time you have wasted for your rose that makes your rose so important.&#39;, &#39;One sees clearly only with the heart. Anything essential is invisible to the eyes.&#39;, &#39;You - you alone will have the stars as no one else has them... In one of the stars I shall be living. In one of them I shall be laughing. And so it will be as if all the stars were laughing, when you look at the sky at night... You - only you - will have stars that can laugh.&#39;, &#39;You become responsible, forever, for what you have tamed.&#39; ] // Creating a WebSocket object const ws = new WebSocket(&#39;ws://localhost:5000/ws&#39;) // Listen for possible errors ws.addEventListener(&#39;error&#39;, (event) =&gt; { console.log(&#39;WebSocket error: &#39;, event) }) // Sending data to the server ws.onopen = () =&gt; { for (const excerpt of excerpts) { ws.send(excerpt) } } // Receiving messages from the server ws.onmessage = (e) =&gt; { console.log(e.data) } 2. Server-sent events Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via an HTTP connection, and describes how servers can initiate data transmission towards clients once an initial client connection has been established. [8] 2.1. Event stream format The event stream is a simple stream of text data messages which are separated by a pair of newline characters (\\n\\n), and must be encoded using UTF-8. [9] A colon (:) as the first character of a line is in essence a comment, and is ignored. Each message consists of one or more lines of text listing the fields for that message. Each field is represented by the field name (event, data, id, and retry), followed by a colon, followed by the text data for that field&#8217;s value. : this is a test stream (1) event: userconnect (2) data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;} data: another message (3) data: with two lines (3) event: usermessage (2) data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;} 1 The first is just a comment, since it starts with a colon character. 2 This sends custom named events. 3 The third message contains a data field with the value &quot;another message\\nwith two lines&quot;. Note the newline special character in the value. 2.2. Sending events from the server The server-side that sends events needs to respond using the MIME type text/event-stream. Each notification is sent as a block of text terminated by a pair of newlines. [9] Here is the .NET code for the example: app.UseCors(policy =&gt; policy.AllowAnyOrigin()); // builder.Services.AddCors(); var excerpts = new string[] { &quot;Notre vie ne se gaspille pas dans les grands événements, mais s&#39;écoule dans les petites choses de tous les jours.&quot;, &quot;La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé.&quot;, &quot;En poursuivant ce qu&#39;ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur.&quot;, &quot;Ce n&#39;est qu&#39;après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n&#39;avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus.&quot; }; app.Use(async (context, next) =&gt; { if (context.Request.Path == &quot;/sse&quot;) { if (context.Request.Headers.Accept.Any(x =&gt; x != null &amp;&amp; x.Contains(&quot;text/event-stream&quot;))) { context.Response.Headers.ContentType = &quot;text/event-stream&quot;; context.Response.Headers.CacheControl = &quot;no-cache&quot;; await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes($&quot;event: ping\\ndata: pong!\\n\\n&quot;)); await context.Response.Body.FlushAsync(); foreach (var excerpt in excerpts) { await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes($&quot;data: {excerpt}\\n\\n&quot;)); await context.Response.Body.FlushAsync(); } // the stream terminated by a data: [DONE] await context.Response.Body.WriteAsync(System.Text.Encoding.UTF8.GetBytes(&quot;data: [DONE]\\n\\n&quot;)); await context.Response.Body.FlushAsync(); } else { context.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType; } } else { await next(context); } }); app.Run(); $ curl -i localhost:5000/sse -H &#39;accept: text/event-stream&#39; HTTP/1.1 200 OK Content-Type: text/event-stream Date: Thu, 16 May 2024 11:14:26 GMT Server: Kestrel Cache-Control: no-cache Transfer-Encoding: chunked event: ping data: pong! data: Notre vie ne se gaspille pas dans les grands événements, mais s&#39;écoule dans les petites choses de tous les jours. data: La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé. data: En poursuivant ce qu&#39;ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur. data: Ce n&#39;est qu&#39;après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n&#39;avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus. data: [DONE] 2.3. Receiving events from the server The server-sent event API is contained in the EventSource interface. // Creating an EventSource instance const evtSource = new EventSource(&#39;//localhost:5000/sse&#39;, { // withCredentials: true }) // Listening for message events evtSource.onmessage = (event) =&gt; { console.log(`message: ${event.data}`) // the stream terminated by a data: [DONE] if (event.data === &#39;[DONE]&#39;) { // Closing event streams evtSource.close() } } // Listening for custom events evtSource.addEventListener(&#39;ping&#39;, (event) =&gt; { console.log(`ping: ${event.data}`) }) // Error handling evtSource.onerror = (err) =&gt; { console.error(&#39;EventSource failed:&#39;, err) } 3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini] While all three terms involve transferring data from a server to a client, they serve distinct purposes and operate in different contexts. This blog post clarifies the key distinctions to help you choose the right approach for your application. WebSockets: Real-time, Two-Way Communication Imagine a live chat conversation. WebSockets facilitate full-duplex communication, where both the server and client can send and receive messages in real-time. This allows for interactive experiences like chat applications, online games, or collaborative editing tools. A long-lived connection is established, enabling continuous data flow in both directions. Server-Sent Events (SSE): Server Pushes Updates Think of a live news feed. SSE allows the server to proactively push updates or data to connected clients. Clients cannot directly send messages back. This unidirectional approach is ideal for real-time updates where the server needs to broadcast information, like stock tickers, sensor readings, or live sports scores. Similarly to WebSockets, a long-lived connection is maintained between the server and client. HTTP 206 Partial Content: Downloading Large Files in Chunks Imagine downloading a large movie. HTTP 206 Partial Content is part of the standard HTTP protocol for handling partial downloads. The client requests a specific portion of a resource (e.g., a specific chunk of the movie file), the server sends only that part, and the connection closes. This is useful for downloading large files more efficiently, allowing for progress updates and potentially faster perceived download speeds. Choosing the Right Tool: The best approach depends on your application&#8217;s needs: Real-time, two-way communication: Use WebSockets. Server-side updates without client interaction: Use SSE. Downloading large resources in chunks: Use HTTP 206 Partial Content. By understanding these concepts, you can make informed decisions when designing real-time or download functionalities in your web applications. References [1] https://en.wikipedia.org/wiki/WebSocket [2] https://www.rfc-editor.org/rfc/rfc6455 [3] https://www.rfc-editor.org/rfc/rfc8441 [4] https://www.rfc-editor.org/rfc/rfc2616 [5] https://learn.microsoft.com/en-us/aspnet/core/fundamentals/websockets [6] https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/websockets [7] https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API [8] https://en.wikipedia.org/wiki/Server-sent_events [9]https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events","headline":"WebSockets and Server-sent events","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2024/05/15/websockets-and-server-sent-events/"},"url":"https://blog.codefarm.me/2024/05/15/websockets-and-server-sent-events/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">WebSockets and Server-sent events</h1><p class="c-post-meta">15 May 2024</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#websockets">1. WebSockets</a>
<ul class="sectlevel2">
<li><a href="#date-framing">1.1. Date framing</a></li>
<li><a href="#opening-handshake-in-http1-1">1.2. Opening handshake in HTTP/1.1</a></li>
<li><a href="#websocket-and-http-protocol-gemini">1.3. WebSocket and HTTP Protocol [Gemini]</a></li>
<li><a href="#websockets-in-net">1.4. WebSockets in .NET</a></li>
<li><a href="#websockets-in-browser">1.5. WebSockets in Browser</a></li>
</ul>
</li>
<li><a href="#server-sent-events">2. Server-sent events</a>
<ul class="sectlevel2">
<li><a href="#event-stream-format">2.1. Event stream format</a></li>
<li><a href="#sending-events-from-the-server">2.2. Sending events from the server</a></li>
<li><a href="#receiving-events-from-the-server">2.3. Receiving events from the server</a></li>
</ul>
</li>
<li><a href="#websocket-server-sent-events-sse-and-http-206-partial-content-gemini">3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini]</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="websockets">1. WebSockets</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a>, standardized by the IETF as <a href="https://www.rfc-editor.org/rfc/rfc6455">RFC 6455</a> in 2011, is a computer communications protocol, providing a simultaneous two-way communication channel over a single Transmission Control Protocol (TCP) connection. <a href="#wiki-WebSocket">[1]</a></p>
</div>
<div class="paragraph">
<p>The WebSocket is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries on the existing HTTP infrastructure, and could also use a simpler handshake over a dedicated port without reinventing the entire protocol. <a href="#rfc6455">[2]</a></p>
</div>
<div class="paragraph">
<p>WebSocket, conceptually, is really just a layer on top of TCP that does the following: <a href="#rfc6455">[2]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>adds a web origin-based security model for browsers</p>
</li>
<li>
<p>adds an addressing and protocol naming mechanism to support
multiple services on one port and multiple host names on one IP
address</p>
</li>
<li>
<p>layers a framing mechanism on top of TCP to get back to the IP
packet mechanism that TCP is built on, but without length limits</p>
</li>
<li>
<p>includes an additional closing handshake in-band that is designed
to work in the presence of proxies and other intermediaries</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The protocol has two parts: a handshake and the data transfer. After a successful handshake, clients and servers transfer <em>messages</em> back and forth. <a href="#rfc6455">[2]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>On the wire, a message is composed of one or more <em>fragmented</em> frames.</p>
</li>
<li>
<p>A frame has an associated type and broadly speaking, there are types for <em>textual data</em>, <em>binary data</em>, and <em>control frames</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>WebSocket specification defines two URI schemes: <a href="#rfc6455">[2]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]</code></p>
</li>
<li>
<p><code>wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The protocol uses the HTTP/1.1 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade">Upgrade</a> mechanism (Section 6.7 of <a href="https://www.rfc-editor.org/rfc/rfc7230#section-6.7">RFC7230</a>) to transition a TCP connection from HTTP into a WebSocket connection, and uses the extended CONNECT method to initiate a WebSocket connection on an HTTP/2 stream. <a href="#rfc8441">[3]</a></p>
</div>
<div class="sect2">
<h3 id="date-framing">1.1. Date framing</h3>
<div class="paragraph">
<p>A high-level overview of the framing is given in the following figure. <a href="#rfc6455">[2]</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

FIN:  1 bit

   Indicates that this is the final fragment in a message.  The first
   fragment MAY also be the final fragment.

Opcode:  4 bits

   Defines the interpretation of the "Payload data".  If an unknown
   opcode is received, the receiving endpoint MUST _Fail the
   WebSocket Connection_.  The following values are defined.

   *  %x0 denotes a continuation frame

   *  %x1 denotes a text frame

   *  %x2 denotes a binary frame

   *  %x3-7 are reserved for further non-control frames

   *  %x8 denotes a connection close

   *  %x9 denotes a ping

   *  %xA denotes a pong

   *  %xB-F are reserved for further control frames</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Control frames</em> are identified by opcodes where the most significant bit of the opcode is <code>1</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Currently defined opcodes for control frames include <code>0x8</code> (Close), <code>0x9</code> (Ping), and <code>0xA</code> (Pong).</p>
</li>
<li>
<p>Control frames are used to communicate state about the WebSocket.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Data frames</em> (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is <code>0</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Currently defined opcodes for data frames include <code>0x1</code> (Text), <code>0x2</code> (Binary).</p>
</li>
<li>
<p>Data frames carry application-layer and/or extension-layer data.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="opening-handshake-in-http1-1">1.2. Opening handshake in HTTP/1.1</h3>
<div class="paragraph">
<p>The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. <a href="#rfc6455">[2]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The WebSocket client&#8217;s handshake is an HTTP Upgrade request with the Request-Line <a href="#rfc2616">[4]</a> format: <a href="#rfc6455">[2]</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat <i class="conum" data-value="1"></i><b>(1)</b>
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== <i class="conum" data-value="2"></i><b>(2)</b>
Sec-WebSocket-Version: 13</code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Sec-WebSocket-Protocol</code> request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The server takes the <code>Sec-WebSocket-Key</code> header field and echo the <code>Sec-WebSocket-Accept</code> header field to prove the received handshake.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>The handshake from the server is much simpler than the client handshake, and looks as follows with the Status-Line <a href="#rfc2616">[4]</a> format:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">HTTP/1.1 101 Switching Protocols <i class="conum" data-value="1"></i><b>(1)</b>
Upgrade: websocket <i class="conum" data-value="2"></i><b>(2)</b>
Connection: Upgrade <i class="conum" data-value="2"></i><b>(2)</b>
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= <i class="conum" data-value="3"></i><b>(3)</b>
Sec-WebSocket-Protocol: chat <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>Connection</code> and <code>Upgrade</code> header fields complete the HTTP Upgrade.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>Sec-WebSocket-Accept</code> header field indicates whether the server is willing to accept the connection.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>Sec-WebSocket-Protocol</code> is an option field, which indicates the subprotocol that the server has selected.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Either peer can send a <em>control frame</em> with data containing a specified control sequence to begin the closing handshake.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-and-http-protocol-gemini">1.3. WebSocket and HTTP Protocol [Gemini]</h3>
<div class="paragraph">
<p>While WebSockets leverage the initial HTTP connection for the handshake, proxy servers do typically handle WebSocket traffic and normal HTTP traffic distinctly.</p>
</div>
<div class="paragraph">
<p><strong>WebSocket vs. HTTP Protocol Differences:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Purpose</strong>: HTTP is designed for request-response interactions, while WebSocket establishes a full-duplex communication channel for real-time data exchange.</p>
</li>
<li>
<p><strong>Data Format</strong>: HTTP uses a text-based request-response format with headers and payloads. WebSocket uses a binary frame format for efficient data transfer.</p>
</li>
<li>
<p><strong>Connection State</strong>: HTTP connections are typically short-lived, closing after the response is sent. WebSockets maintain persistent connections for bi-directional communication.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Proxy Handling:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Initial Handshake</strong>: For both HTTP and WebSocket traffic, the proxy first establishes a standard HTTP connection with the target server.</p>
</li>
<li>
<p><strong>Handshake Differentiation</strong>: The proxy can identify WebSocket traffic by recognizing the specific handshake headers used in the initial HTTP request.</p>
</li>
<li>
<p><strong>Separate Handling</strong>: Once a WebSocket handshake is detected, the proxy switches to handling the subsequent frames using the WebSocket protocol. It might involve unmasking/remasking data and forwarding it appropriately.</p>
</li>
<li>
<p><strong>HTTP Traffic Handling</strong>: Normal HTTP requests and responses continue to be handled using the standard HTTP protocol by the proxy.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Benefits of Separate Handling:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Performance</strong>: By handling WebSocket traffic differently, the proxy can optimize processing for the specific needs of each protocol. This can improve performance for both WebSocket and HTTP traffic.</p>
</li>
<li>
<p><strong>Security</strong>: Some proxies might have specific security mechanisms tailored for HTTP traffic (e.g., content filtering). These wouldn&#8217;t be applicable to the binary data format of WebSockets. Separate handling allows for targeted security measures.</p>
</li>
<li>
<p><strong>Complexity Management</strong>: Separating the handling logic simplifies the proxy implementation as it deals with each protocol according to its unique characteristics.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>In summary:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A single proxy server can manage both HTTP and WebSocket traffic.</p>
</li>
<li>
<p>However, it differentiates between the two protocols during the initial handshake and then employs separate handling mechanisms for each to ensure optimal performance and proper data flow.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="websockets-in-net">1.4. WebSockets in .NET</h3>
<div class="paragraph">
<p>Using WebSockets over HTTP/2 takes advantage of new features are available in Kestrel on all HTTP/2 enabled platforms such as: <a href="#aspnet-websockets">[5]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Header compression.</p>
</li>
<li>
<p>Multiplexing, which reduces the time and resources needed when making multiple requests to the server.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
HTTP/2 WebSockets use <code>CONNECT</code> requests rather than <code>GET</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>WebSockets Server in ASP.NET Core</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">webSocketOptions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebSocketOptions</span>
<span class="p">{</span>
    <span class="n">KeepAliveInterval</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMinutes</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
<span class="p">};</span>

<span class="n">webSocketOptions</span><span class="p">.</span><span class="n">AllowedOrigins</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"https://client.com"</span><span class="p">);</span>
<span class="n">webSocketOptions</span><span class="p">.</span><span class="n">AllowedOrigins</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"https://www.client.com"</span><span class="p">);</span>

<span class="c1">// Add the WebSockets middleware in `Program.cs`:</span>
<span class="n">app</span><span class="p">.</span><span class="nf">UseWebSockets</span><span class="p">(</span><span class="n">webSocketOptions</span><span class="p">);</span>

<span class="n">app</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// [Route("/ws")] // HTTP/2 WebSockets use CONNECT requests rather than GET.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Path</span> <span class="p">==</span> <span class="s">"/ws"</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Accept WebSocket requests</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">WebSockets</span><span class="p">.</span><span class="n">IsWebSocketRequest</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="nn">var</span> <span class="n">webSocket</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">WebSockets</span><span class="p">.</span><span class="nf">AcceptWebSocketAsync</span><span class="p">();</span>
            <span class="k">await</span> <span class="nf">EchoAsync</span><span class="p">(</span><span class="n">webSocket</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">StatusCode</span> <span class="p">=</span> <span class="n">StatusCodes</span><span class="p">.</span><span class="n">Status400BadRequest</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="nf">next</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">});</span>

<span class="n">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">();</span>

<span class="c1">// Send and receive messages</span>
<span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">EchoAsync</span><span class="p">(</span><span class="n">WebSocket</span> <span class="n">webSocket</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">1024</span> <span class="p">*</span> <span class="m">4</span><span class="p">];</span>
    <span class="kt">var</span> <span class="n">receiveResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">webSocket</span><span class="p">.</span><span class="nf">ReceiveAsync</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">ArraySegment</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(!</span><span class="n">receiveResult</span><span class="p">.</span><span class="n">CloseStatus</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">webSocket</span><span class="p">.</span><span class="nf">SendAsync</span><span class="p">(</span>
            <span class="k">new</span> <span class="n">ArraySegment</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;(</span><span class="n">buffer</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">receiveResult</span><span class="p">.</span><span class="n">Count</span><span class="p">),</span>
            <span class="n">receiveResult</span><span class="p">.</span><span class="n">MessageType</span><span class="p">,</span>
            <span class="n">receiveResult</span><span class="p">.</span><span class="n">EndOfMessage</span><span class="p">,</span>
            <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>

        <span class="n">receiveResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">webSocket</span><span class="p">.</span><span class="nf">ReceiveAsync</span><span class="p">(</span>
            <span class="k">new</span> <span class="n">ArraySegment</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">await</span> <span class="n">webSocket</span><span class="p">.</span><span class="nf">CloseAsync</span><span class="p">(</span>
        <span class="n">receiveResult</span><span class="p">.</span><span class="n">CloseStatus</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span>
        <span class="n">receiveResult</span><span class="p">.</span><span class="n">CloseStatusDescription</span><span class="p">,</span>
        <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>WebSockets Client in .NET</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">string</span><span class="p">[]</span> <span class="n">messages</span> <span class="p">=</span> <span class="p">[</span>
    <span class="s">"我们的生命不是消逝于那些重大的事件中，而是流逝在那些日常琐碎的小事里。"</span><span class="p">,</span>
    <span class="s">"生活是由无数微不足道的细节构建起来的，而记忆正是这些细节的忠实记录者，它们在某个不经意的瞬间被唤醒，带我们穿越回往昔。"</span><span class="p">,</span>
    <span class="s">"人们在追求他们以为是幸福的东西时，常常错过真正的幸福。"</span><span class="p">,</span>
    <span class="s">"在失去之后，我们才开始寻找那些曾经拥有但未被珍惜的东西，而记忆，则成了我们找回那些失落时光的唯一线索。"</span>
    <span class="p">];</span>

<span class="n">Uri</span> <span class="n">uri</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="s">"ws://localhost:5000/ws"</span><span class="p">);</span>
<span class="k">using</span> <span class="nn">ClientWebSocket</span> <span class="n">ws</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="k">await</span> <span class="n">ws</span><span class="p">.</span><span class="nf">ConnectAsync</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>

<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">message</span> <span class="k">in</span> <span class="n">messages</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="k">await</span> <span class="n">ws</span><span class="p">.</span><span class="nf">SendAsync</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">WebSocketMessageType</span><span class="p">.</span><span class="n">Text</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="k">async</span> <span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="p">(</span><span class="n">echoMessage</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ReadMessageAsync</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">echoMessage</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>

<span class="k">await</span> <span class="n">ws</span><span class="p">.</span><span class="nf">CloseAsync</span><span class="p">(</span><span class="n">WebSocketCloseStatus</span><span class="p">.</span><span class="n">NormalClosure</span><span class="p">,</span> <span class="s">"Client closed"</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>

<span class="c1">// Read a complete message from a WebSocket.</span>
<span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;(</span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;,</span> <span class="n">WebSocketMessageType</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">WebSocketCloseStatus</span><span class="p">?,</span> <span class="kt">string</span><span class="p">?)&gt;</span> <span class="nf">ReadMessageAsync</span><span class="p">(</span><span class="n">WebSocket</span> <span class="n">webSocket</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">token</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;(</span><span class="m">1024</span> <span class="p">*</span> <span class="m">2</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">8</span> <span class="p">*</span> <span class="m">4</span><span class="p">];</span>
    <span class="kt">var</span> <span class="n">receiveResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">webSocket</span><span class="p">.</span><span class="nf">ReceiveAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">ArraySegment</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">token</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">message</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="k">new</span> <span class="n">ArraySegment</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;(</span><span class="n">buffer</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">receiveResult</span><span class="p">.</span><span class="n">Count</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">receiveResult</span><span class="p">.</span><span class="n">CloseStatus</span><span class="p">.</span><span class="n">HasValue</span> <span class="p">||</span> <span class="n">receiveResult</span><span class="p">.</span><span class="n">EndOfMessage</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">receiveResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">webSocket</span><span class="p">.</span><span class="nf">ReceiveAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">ArraySegment</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">token</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="nf">AsReadOnly</span><span class="p">(),</span> <span class="n">receiveResult</span><span class="p">.</span><span class="n">MessageType</span><span class="p">,</span> <span class="n">receiveResult</span><span class="p">.</span><span class="n">EndOfMessage</span><span class="p">,</span> <span class="n">receiveResult</span><span class="p">.</span><span class="n">CloseStatus</span><span class="p">,</span> <span class="n">receiveResult</span><span class="p">.</span><span class="n">CloseStatusDescription</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websockets-in-browser">1.5. WebSockets in Browser</h3>
<div class="paragraph">
<p>The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between browser and server, which can send messages to a server and receive event-driven responses without having to poll the server for a reply. <a href="#mdn-websockets-api">[7]</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="js"><span class="kd">const</span> <span class="nx">excerpts</span> <span class="o">=</span> <span class="p">[</span>
  <span class="dl">'</span><span class="s1">Grown-ups never understand anything by themselves, and it is tiresome for children to be always and forever explaining things to them.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">And now here is my secret, a very simple secret: It is only with the heart that one can see rightly; what is essential is invisible to the eye.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">People have forgotten this truth,' the fox said. 'But you mustn’t forget it. You become responsible forever for what you’ve tamed. You’re responsible for your rose.</span><span class="dl">"</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">All grown-ups were once children... but only few of them remember it.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">It is the time you have wasted for your rose that makes your rose so important.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">One sees clearly only with the heart. Anything essential is invisible to the eyes.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">You - you alone will have the stars as no one else has them... In one of the stars I shall be living. In one of them I shall be laughing. And so it will be as if all the stars were laughing, when you look at the sky at night... You - only you - will have stars that can laugh.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">You become responsible, forever, for what you have tamed.</span><span class="dl">'</span>
<span class="p">]</span>

<span class="c1">// Creating a WebSocket object</span>
<span class="kd">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://localhost:5000/ws</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Listen for possible errors</span>
<span class="nx">ws</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">WebSocket error: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">event</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// Sending data to the server</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">excerpt</span> <span class="k">of</span> <span class="nx">excerpts</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">excerpt</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Receiving messages from the server</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="server-sent-events">2. Server-sent events</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Server-sent_events">Server-Sent Events (SSE)</a> is a server push technology enabling a client to receive automatic updates from a server via an HTTP connection, and describes how servers can initiate data transmission towards clients once an initial client connection has been established. <a href="#wiki-Server-sent_events">[8]</a></p>
</div>
<div class="sect2">
<h3 id="event-stream-format">2.1. Event stream format</h3>
<div class="paragraph">
<p>The event stream is a simple stream of text data messages which are separated by a pair of newline characters (<code>\n\n</code>), and must be encoded using UTF-8. <a href="#mdn-Using_server-sent_events">[9]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A colon (<code>:</code>) as the first character of a line is in essence a comment, and is ignored.</p>
</li>
<li>
<p>Each message consists of one or more lines of text listing the fields for that message.</p>
</li>
<li>
<p>Each field is represented by the field name (<code>event</code>, <code>data</code>, <code>id</code>, and <code>retry</code>), followed by a colon, followed by the text data for that field&#8217;s value.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">: this is a test stream <i class="conum" data-value="1"></i><b>(1)</b>


event: userconnect <i class="conum" data-value="2"></i><b>(2)</b>
data: {"username": "bobby", "time": "02:33:48"}


data: another message <i class="conum" data-value="3"></i><b>(3)</b>
data: with two lines <i class="conum" data-value="3"></i><b>(3)</b>


event: usermessage <i class="conum" data-value="2"></i><b>(2)</b>
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}</code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first is just a comment, since it starts with a colon character.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This sends custom named events.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The third message contains a data field with the value "another message\nwith two lines". Note the newline special character in the value.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="sending-events-from-the-server">2.2. Sending events from the server</h3>
<div class="paragraph">
<p>The server-side that sends events needs to respond using the MIME type <code>text/event-stream</code>. Each notification is sent as a block of text terminated by a pair of newlines. <a href="#mdn-Using_server-sent_events">[9]</a></p>
</div>
<div class="paragraph">
<p>Here is the .NET code for the example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">app</span><span class="p">.</span><span class="nf">UseCors</span><span class="p">(</span><span class="n">policy</span> <span class="p">=&gt;</span> <span class="n">policy</span><span class="p">.</span><span class="nf">AllowAnyOrigin</span><span class="p">());</span> <span class="c1">// builder.Services.AddCors();</span>

<span class="kt">var</span> <span class="n">excerpts</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
<span class="p">{</span>
  <span class="s">"Notre vie ne se gaspille pas dans les grands événements, mais s'écoule dans les petites choses de tous les jours."</span><span class="p">,</span>
  <span class="s">"La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé."</span><span class="p">,</span>
  <span class="s">"En poursuivant ce qu'ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur."</span><span class="p">,</span>
  <span class="s">"Ce n'est qu'après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n'avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus."</span>
<span class="p">};</span>

<span class="n">app</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Path</span> <span class="p">==</span> <span class="s">"/sse"</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Headers</span><span class="p">.</span><span class="n">Accept</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">x</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">"text/event-stream"</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Headers</span><span class="p">.</span><span class="n">ContentType</span> <span class="p">=</span> <span class="s">"text/event-stream"</span><span class="p">;</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Headers</span><span class="p">.</span><span class="n">CacheControl</span> <span class="p">=</span> <span class="s">"no-cache"</span><span class="p">;</span>

            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="s">$"event: ping\ndata: pong!\n\n"</span><span class="p">));</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="nf">FlushAsync</span><span class="p">();</span>

            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">excerpt</span> <span class="k">in</span> <span class="n">excerpts</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="s">$"data: </span><span class="p">{</span><span class="n">excerpt</span><span class="p">}</span><span class="s">\n\n"</span><span class="p">));</span>
                <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="nf">FlushAsync</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="c1">// the stream terminated by a data: [DONE]</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="s">"data: [DONE]\n\n"</span><span class="p">));</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="nf">FlushAsync</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">StatusCode</span> <span class="p">=</span> <span class="n">StatusCodes</span><span class="p">.</span><span class="n">Status415UnsupportedMediaType</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="nf">next</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="n">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>curl <span class="nt">-i</span> localhost:5000/sse <span class="nt">-H</span> <span class="s1">'accept: text/event-stream'</span>
<span class="go">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Thu, 16 May 2024 11:14:26 GMT
Server: Kestrel
Cache-Control: no-cache
Transfer-Encoding: chunked

event: ping
data: pong!

data: Notre vie ne se gaspille pas dans les grands événements, mais s'écoule dans les petites choses de tous les jours.

data: La vie est faite de millions de détails insignifiants, et la mémoire est le fidèle enregistreur de ces détails, qui se réveillent à un moment inattendu et nous transportent dans le passé.

data: En poursuivant ce qu'ils croient être le bonheur, les gens passent souvent à côté du vrai bonheur.

data: Ce n'est qu'après avoir perdu quelque chose que nous commençons à chercher ce que nous avions et que nous n'avons pas chéri, et la mémoire devient alors le seul fil conducteur pour retrouver ces moments perdus.

data: [DONE]

</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="receiving-events-from-the-server">2.3. Receiving events from the server</h3>
<div class="paragraph">
<p>The server-sent event API is contained in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource">EventSource</a> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="js"><span class="c1">// Creating an EventSource instance</span>
<span class="kd">const</span> <span class="nx">evtSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventSource</span><span class="p">(</span><span class="dl">'</span><span class="s1">//localhost:5000/sse</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// withCredentials: true</span>
<span class="p">})</span>
<span class="c1">// Listening for message events</span>
<span class="nx">evtSource</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`message: </span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="c1">// the stream terminated by a data: [DONE]</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">[DONE]</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Closing event streams</span>
    <span class="nx">evtSource</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Listening for custom events</span>
<span class="nx">evtSource</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">ping</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`ping: </span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// Error handling</span>
<span class="nx">evtSource</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="dl">'</span><span class="s1">EventSource failed:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-server-sent-events-sse-and-http-206-partial-content-gemini">3. Websocket, Server-Sent Events (SSE), and HTTP 206 Partial Content [Gemini]</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While all three terms involve transferring data from a server to a client, they serve distinct purposes and operate in different contexts. This blog post clarifies the key distinctions to help you choose the right approach for your application.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>WebSockets: Real-time, Two-Way Communication</strong></p>
<div class="paragraph">
<p>Imagine a live chat conversation. WebSockets facilitate full-duplex communication, where both the server and client can send and receive messages in real-time. This allows for interactive experiences like chat applications, online games, or collaborative editing tools. A long-lived connection is established, enabling continuous data flow in both directions.</p>
</div>
</li>
<li>
<p><strong>Server-Sent Events (SSE): Server Pushes Updates</strong></p>
<div class="paragraph">
<p>Think of a live news feed. SSE allows the server to proactively push updates or data to connected clients. Clients cannot directly send messages back. This unidirectional approach is ideal for real-time updates where the server needs to broadcast information, like stock tickers, sensor readings, or live sports scores. Similarly to WebSockets, a long-lived connection is maintained between the server and client.</p>
</div>
</li>
<li>
<p><strong>HTTP 206 Partial Content: Downloading Large Files in Chunks</strong></p>
<div class="paragraph">
<p>Imagine downloading a large movie. HTTP 206 Partial Content is part of the standard HTTP protocol for handling partial downloads. The client requests a specific portion of a resource (e.g., a specific chunk of the movie file), the server sends only that part, and the connection closes. This is useful for downloading large files more efficiently, allowing for progress updates and potentially faster perceived download speeds.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Choosing the Right Tool:</strong></p>
</div>
<div class="paragraph">
<p>The best approach depends on your application&#8217;s needs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Real-time, two-way communication: Use WebSockets.</p>
</li>
<li>
<p>Server-side updates without client interaction: Use SSE.</p>
</li>
<li>
<p>Downloading large resources in chunks: Use HTTP 206 Partial Content.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By understanding these concepts, you can make informed decisions when designing real-time or download functionalities in your web applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="wiki-WebSocket"></a>[1] <a href="https://en.wikipedia.org/wiki/WebSocket" class="bare">https://en.wikipedia.org/wiki/WebSocket</a></p>
</li>
<li>
<p><a id="rfc6455"></a>[2] <a href="https://www.rfc-editor.org/rfc/rfc6455" class="bare">https://www.rfc-editor.org/rfc/rfc6455</a></p>
</li>
<li>
<p><a id="rfc8441"></a>[3] <a href="https://www.rfc-editor.org/rfc/rfc8441" class="bare">https://www.rfc-editor.org/rfc/rfc8441</a></p>
</li>
<li>
<p><a id="rfc2616"></a>[4] <a href="https://www.rfc-editor.org/rfc/rfc2616" class="bare">https://www.rfc-editor.org/rfc/rfc2616</a></p>
</li>
<li>
<p><a id="aspnet-websockets"></a>[5] <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/websockets" class="bare">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/websockets</a></p>
</li>
<li>
<p><a id="dotnet-websockets"></a>[6] <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/websockets" class="bare">https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/websockets</a></p>
</li>
<li>
<p><a id="mdn-websockets-api"></a>[7] <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" class="bare">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API</a></p>
</li>
<li>
<p><a id="wiki-Server-sent_events"></a>[8] <a href="https://en.wikipedia.org/wiki/Server-sent_events" class="bare">https://en.wikipedia.org/wiki/Server-sent_events</a></p>
</li>
<li>
<p><a id="mdn-Using_server-sent_events"></a>[9]<a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" class="bare">https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
