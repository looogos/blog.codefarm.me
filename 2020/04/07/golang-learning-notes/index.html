<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Golang Learning Notes | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Golang Learning Notes" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. Foramtting 2. Commentary 3. Names 3.1. Package names 3.2. Getters 3.3. Interface names 3.4. MixedCaps 4. Semicolons 5. Control structures 5.1. If 5.2. For 5.3. Switch 5.4. Type Switch 5.5. Select 5.6. Break, Continue and Goto 5.7. Fallthrough 5.8. Defer 6. Data types 6.1. Type 6.2. Variables 6.3. Strings, bytes, runes and characters 6.4. Pointers 6.5. Structs 6.6. Arrays 6.7. Slices 6.8. Maps 6.9. Functions 6.10. Methods 6.11. Interfaces 6.12. Embedding: interfaces and structs 6.13. Channels 6.14. Type conversions 6.15. Generics 7. Initialization 7.1. Constants 7.2. Allocation: new and make 7.3. The init function 7.4. Zero values 8. Concurrency 8.1. Race Conditions 8.2. Race Detector 8.3. Happen before 8.4. Share by communicating 8.5. Goroutines 8.6. Channels 8.7. Parallelization 8.8. Synchronization 8.8.1. Channels 8.8.2. sync.Mutex 8.8.3. sync.RWMutex 8.8.4. sync.WaitGroup 8.8.5. sync.Cond 8.8.6. sync.Once 8.8.7. sync.Map 8.8.8. sync/atomic 9. Errors 10. Testing 11. Modules 12. Printf 12.1. The Printing verbs 12.2. Width and Precision 12.3. Stringer References 1. Foramtting With Go we take an unusual approach and let the machine take care of most formatting issues. The gofmt program (also available as go fmt, which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments. $ cat formatting.go package formatting type T struct { name string // name of the object value int // its value } $ go fmt formatting.go # or gofmt -w formatting.go formatting.go $ cat formatting.go package formatting type T struct { name string // name of the object value int // its value } 2. Commentary Go provides C-style /* */ block comments and C&#43;&#43;-style // line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. // Println formats using the default formats for its operands and writes to standard output. // Spaces are always added between operands and a newline is appended. // It returns the number of bytes written and any write error encountered. func Println(a ...any) (n int, err error) { return Fprintln(os.Stdout, a...) } The command go doc is used to display documentation for Go packages, functions, or types directly in the terminal. When run with one argument, the argument is treated as a Go-syntax-like representation of the item to be documented. go doc &lt;pkg&gt; # go doc net/http go doc &lt;sym&gt;[.&lt;methodOrField&gt;] # go doc http.Request.Write go doc [&lt;pkg&gt;.]&lt;sym&gt;[.&lt;methodOrField&gt;] # go doc net/http.Request.Write go doc [&lt;pkg&gt;.][&lt;sym&gt;.]&lt;methodOrField&gt; # go doc net/http.Write $ go doc builtin.new package builtin // import &quot;builtin&quot; func new(Type) *Type The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. When run with two arguments, the first is a package path (full path or suffix), and the second is a symbol, or symbol with method or struct field: go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;methodOrField&gt;] # go doc net/http Request.Write $ go doc sync Mutex package sync // import &quot;sync&quot; type Mutex struct { // Has unexported fields. } A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex. A Mutex must not be copied after first use. func (m *Mutex) Lock() func (m *Mutex) Unlock() The godoc is a tool used to either generate HTML documentation or serve it through a local web server. godoc -http=:6060 3. Names The visibility of a name outside a package is determined by whether its first character is upper case. 3.1. Package names By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as &quot;encoding/base64&quot; but has name base64, not encoding_base64 and not encodingBase64. Use the package structure to help you choose good names. The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter. For instance, the buffered reader type in the bufio package is called Reader, not BufReader, because users see it as bufio.Reader, which is a clear, concise name. Moreover, because imported entities are always addressed with their package name, bufio.Reader does not conflict with io.Reader. Similarly, the function to make new instances of ring.Ring—which is the definition of a constructor in Go—would normally be called NewRing, but since Ring is the only type exported by the package, and since the package is called ring, it&#8217;s called just New, which clients of the package see as ring.New. 3.2. Getters Go doesn&#8217;t provide automatic support for getters and setters. There&#8217;s nothing wrong with providing getters and setters yourself, and it&#8217;s often appropriate to do so, but it&#8217;s neither idiomatic nor necessary to put Get into the getter&#8217;s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner. A setter function, if needed, will likely be called SetOwner. Both names read well in practice: owner := obj.Owner() if owner != user { obj.SetOwner(user) } 3.3. Interface names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc. type Writer interface { Write(p []byte) (n int, err error) } type ReadWriter interface { Reader Writer } There are a number of such names and it&#8217;s productive to honor them and the function names they capture. Read, Write, Close, Flush, String and so on have canonical signatures and meanings. To avoid confusion, don&#8217;t give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method String not ToString. 3.4. MixedCaps Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names. 4. Semicolons Like C, Go&#8217;s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. If the newline comes after a token that could end a statement, insert a semicolon. Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the initializer, condition, and continuation elements. for i := 0; i &lt; 5; i++ { } They are also necessary to separate multiple statements on a line, should you write code that way. 5. Control structures There is no do or while loop, only a slightly generalized for; switch is more flexible; if and switch accept an optional initialization statement like that of for; break and continue statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, select. There are no parentheses and the bodies must always be brace-delimited. 5.1. If if x &gt; 0 { return y } if f, err: = os.Open(name); err != nil { return err } 5.2. For // Like a C for for init; condition; post { } // Like a C while for condition { } // Like a C for(;;) for { } // Like a C do-while for { // do something if condition; { break } } If you&#8217;re looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop. for key, value := range map { } // If you only need the second item in the range (the value), // use the blank identifier, an underscore, to discard the first: for _, value := range map { } for index, value := range array { } for value := range channel { } For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. The name (with associated builtin type) rune is Go terminology for a single Unicode code point. for pos, char := range &quot;日本\x80語&quot; { // \x80 is an illegal UTF-8 encoding fmt.Printf(&quot;character %#U starts at byte position %d\n&quot;, char, pos) } // Output: // character U+65E5 &#39;日&#39; starts at byte position 0 // character U+672C &#39;本&#39; starts at byte position 3 // character U+FFFD &#39;�&#39; starts at byte position 6 // character U+8A9E &#39;語&#39; starts at byte position 7 Go has no comma operator and ++ and -- are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes &#43;&#43; and --). // Reverse a for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] } 5.3. Switch Go&#8217;s switch is more general than C&#8217;s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true. It&#8217;s therefore possible&#8212;&#8203;and idiomatic&#8212;&#8203;to write an if-else-if-else chain as a switch. There is no automatic fall through, but cases can be presented in comma-separated lists. Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early. Sometimes, though, it&#8217;s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and &quot;breaking&quot; to that label. Of course, the continue statement also accepts an optional label but it applies only to loops. switch os := runtime.GOOS; os { case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.\n&quot;, os) } Loop: for n := 0; n &lt; len(src); n += size { switch { case src[n] &lt; sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] &lt; sizeTwo: if n+1 &gt;= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]&lt;&lt;shift) } } 5.4. Type Switch A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It&#8217;s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(&quot;unexpected type %T\n&quot;, t) // %T prints whatever type t has case bool: fmt.Printf(&quot;boolean %t\n&quot;, t) // t has type bool case int: fmt.Printf(&quot;integer %d\n&quot;, t) // t has type int case *bool: fmt.Printf(&quot;pointer to boolean %t\n&quot;, *t) // t has type *bool case *int: fmt.Printf(&quot;pointer to integer %d\n&quot;, *t) // t has type *int } 5.5. Select The select statement lets a goroutine wait on multiple communication operations. A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready. The default case in a select is run if no other case is ready. Use a default case to try a send or receive without blocking: func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case &lt;-tick: fmt.Println(&quot;tick.&quot;) case &lt;-boom: fmt.Println(&quot;BOOM!&quot;) return default: fmt.Println(&quot; .&quot;) time.Sleep(50 * time.Millisecond) } } } 5.6. Break, Continue and Goto A break statement terminates execution of the innermost for, switch, or select statement within the same function. A continue statement begins the next iteration of the innermost for loop at its post statement within the same function. A goto statement transfers control to the statement with the corresponding label within the same function. func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) RawLoop: for { select { case &lt;-tick: fmt.Println(&quot;tick.&quot;) continue RawLoop // go to the next iteration case &lt;-boom: fmt.Println(&quot;BOOM!&quot;) break RawLoop // exit default: fmt.Println(&quot;. .&quot;) time.Sleep(50 * time.Millisecond) goto RawLoop // go back to the very beginning } } } 5.7. Fallthrough A fallthrough statement transfers control to the first statement of the next case clause in an expression switch statement. It may be used only as the final non-empty statement in such a clause. switch { case 10 &gt; 11: fmt.Println(&quot;10 &gt; 11&quot;) case 1 &lt; 5: fmt.Println(&quot;1 &lt; 5&quot;) fallthrough case 1 &gt; 10: fmt.Println(&quot;1 &gt; 10 ?&quot;) } // Output: // 1 &lt; 5 // 1 &gt; 10 ? 5.8. Defer A defer statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, godir, err := os.Open(&quot;/usr/local/go&quot;) if err != nil { log.Printf(&quot;%s\n&quot;, err) defer godir.Close() } or because the corresponding goroutine is panicking. defer func() { e := recover() fmt.Printf(&quot;recover: %s\n&quot;, e) }() defer func() { fmt.Println(&quot;. . .&quot;) }() panic(fmt.Sprintf(&quot;Oops, I&#39;m NOT myself.&quot;)) // Output: // . . . // recover: Oops, I&#39;m NOT myself. Go&#8217;s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns. // The arguments to the deferred function (which include the receiver if the function is a method) // are evaluated when the _defer_ executes, not when the _call_ executes. func main() { v := 10 defer fmt.Println(3 * v) // 30 defer func() { fmt.Println(v) // 20 }() defer func(x int) { fmt.Println(x) // 10 }(v) v = 20 _ = v } // Output: // 10 // 20 // 30 It&#8217;s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. func ReadFile(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() return ReadAll(f) } Deferred functions are executed in LIFO order (stacking style). for i := 0; i &lt; 5; i++ { defer fmt.Printf(&quot;%d &quot;, i) } // Output: // 4 3 2 1 0 // All function values created by this loop &quot;capture&quot; // and share the same variable—an addressable storage location, // not its value at that particular moment. for i := 0; i &lt; 5; i++ { defer func() { fmt.Print(i, &quot; &quot;) }() } // Output: // 5 5 5 5 5 for i := 0; i &lt; 5; i++ { // declares inner i, intialized to outer i i := i defer func() { fmt.Print(i, &quot; &quot;) }() } // Output: // 4 3 2 1 0 6. Data types // any is an alias for interface{} and is equivalent to interface{} in all ways. // (go1.18) any // comparable is an interface that is implemented by all comparable types // (booleans, numbers, strings, pointers, channels, arrays of comparable types, // structs whose fields are all comparable types). The comparable interface may // only be used as a type parameter constraint, not as the type of a variable. // (go1.18) comparable bool // true false string int8 int16 int32 int64 uint8 uint16 uint32 uint64 uintptr int uint // either 32 or 64 bits byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 // more types pointers structs array slices maps functions interfaces channels 6.1. Type The type keyword in Go is used to define new types or create aliases for existing types. Type definitions create a completely new type that is distinct from the base type, which can be added methods to it. // new named type type Celsius float64 type Fahrenheit float64 // new type method func (c Celsius) ToF() Fahrenheit { return Fahrenheit((c * 9.0 / 5.0) + 32.0) } func cToF(c Celsius) Fahrenheit { return c.ToF() } func main() { var tempC Celsius = 25.0 tempF := cToF(tempC) fmt.Println(tempF) // 77 // Error: cannot use tempC (variable of float64 type Celsius) as float64 value in variable declaration // var tempFloat float64 = tempC // fmt.Println(tempFloat) } type Reader interface { Read() (int, bool) } type Writer interface { Write(item int) } type ReadWriter interface { Reader Writer } type MyChannel struct { channel chan int } func (my MyChannel) Read() (v int, ok bool) { v, ok = &lt;-my.channel return } func (my MyChannel) Write(item int) { my.channel &lt;- item } func (my MyChannel) Close() { close(my.channel) } func New(size int) MyChannel { return MyChannel{channel: make(chan int, size)} } func main() { my := New(5) go func() { for { v, ok := my.Read() if !ok { break } fmt.Println(v) } }() go func() { defer my.Close() for i := 0; i &lt; 10; i++ { my.Write(i) } }() time.Sleep(10 * time.Millisecond) } Type aliases provide a different name for an existing type but don&#8217;t create a new type; they just give a new identifier. // type alias type Celsius = float64 type Fahrenheit = float64 func cToF(c Celsius) Fahrenheit { return Fahrenheit((c * 9.0 / 5.0) + 32.0) } func main() { var tempC Celsius = 25.0 tempF := cToF(tempC) fmt.Println(tempF) // 77 // because Celsius and float64 are the same, this is legal: var tempFloat float64 = tempC fmt.Println(tempFloat) // 25 } 6.2. Variables A var statement can be at package or function level to declare a list of variables; as in function argument lists, the type is last. var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } A var declaration can include initializers, one per variable. var c, python, java = true, false, &quot;no!&quot; Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type. func main() { var i, j int = 1, 2 k := 3 c, python, java := true, false, &quot;no!&quot; fmt.Println(i, j, k, c, python, java) } 6.3. Strings, bytes, runes and characters Go source code is always UTF-8. A string holds arbitrary bytes. A string literal, absent byte-level escapes, always holds valid UTF-8 sequences. Those sequences represent Unicode code points, called runes. A code point is a unique numerical value assigned to a character in the Unicode standard, that represents a character, regardless of how that character is stored or encoded. A code unit is the actual bit sequence used to represent a code point in a specific encoding scheme. No guarantee is made in Go that characters in strings are normalized. const nihongo = &quot;日本語&quot; for _, runeValue := range nihongo { // for-range: iterate over the Unicode code points (runes) fmt.Printf(&quot;%#U &quot;, runeValue) } fmt.Println() // U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39; for _, cp := range []rune(nihongo) { // convert a string to a slice of runes fmt.Printf(&quot;%#U &quot;, cp) } fmt.Println() // U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39; for i := 0; i &lt; len(nihongo); i++ { // for-loop: iterate over the UTF-8 encoded units or bytes fmt.Printf(&quot;%x &quot;, nihongo[i]) } fmt.Println() // e6 97 a5 e6 9c ac e8 aa 9e for i := 0; i &lt; len(nihongo); i++ { fmt.Printf(&quot;%q &quot;, nihongo[i]) } fmt.Println() // &#39;æ&#39; &#39;\u0097&#39; &#39;¥&#39; &#39;æ&#39; &#39;\u009c&#39; &#39;¬&#39; &#39;è&#39; &#39;ª&#39; &#39;\u009e&#39; for i := 0; i &lt; len(nihongo); i++ { fmt.Printf(&quot;%+q &quot;, nihongo[i]) } fmt.Println() // &#39;\u00e6&#39; &#39;\u0097&#39; &#39;\u00a5&#39; &#39;\u00e6&#39; &#39;\u009c&#39; &#39;\u00ac&#39; &#39;\u00e8&#39; &#39;\u00aa&#39; &#39;\u009e&#39; 6.4. Pointers // A pointer holds the memory address of a value. // Unlike C, Go has no pointer arithmetic. // The type `*T` is a pointer to a `T` value. Its zero value is `nil`. var p *int i := 42 // The `&amp;` operator generates a pointer to its operand. p = &amp;i // The `*` operator (&quot;dereferencing&quot; or &quot;indirecting&quot;) denotes the pointer&#39;s underlying value. *p = 21 6.5. Structs // A struct is a collection of fields. type Vertex struct { X, Y int } var ( // A struct literal denotes a newly allocated struct value by listing the values of its fields. v1 = Vertex{1, 2} // has type Vertex // You can list just a subset of fields by using the Name: syntax. // (And the order of named fields is irrelevant.) v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 // The special prefix &amp; returns a pointer to the struct value p = &amp;Vertex{1, 2} // has type *Vertex ) func main() { // Struct fields are accessed using a dot. p.X = 1e9 fmt.Println(v1, p, v2, v3) } 6.6. Arrays The type [n]T is an array of n values of type T. Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct, so arrays cannot be resized. var a [2]string a[0] = &quot;Hello&quot; a[1] = &quot;World&quot; // an array literal primes := [6]int{2, 3, 5, 7, 11, 13} 6.7. Slices A slice, on the other hand, is a dynamically-sized, flexible view into the elements of an array. The type []T is a slice with elements of type T. A slice is formed by specifying two indices, a low and high bound, separated by a colon: // This selects a half-open range which includes the first element, but excludes the last one. a[low : high] The following expression creates a slice which includes elements 1 through 3 of a: a[1:4] Slices are like references to arrays A slice does not store any data, it just describes a section of an underlying array. A slice hold references to an underlying array, and if you assign one slice to another, both refer to the same array. Changing the elements of a slice modifies the corresponding elements of its underlying array. Other slices that share the same underlying array will see those changes. Slice literals A slice literal is like an array literal without the length. []bool{true, true, false} Slice defaults When slicing, you may omit the high or low bounds to use their defaults instead. The default is zero for the low bound and the length of the slice for the high bound. // For the array var a [10]int // these slice expressions are equivalent: a[0:10] a[:10] a[0:] a[:] Slice length and capacity A slice has both a length and a capacity. The length of a slice is the number of elements it contains. The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice. The length and capacity of a slice s can be obtained using the expressions len(s) and cap(s). You can extend a slice&#8217;s length by re-slicing it, provided it has sufficient capacity. Nil slices The zero value of a slice is nil. A nil slice has a length and capacity of 0 and has no underlying array. Appending to a slice It is common to append new elements to a slice, and so Go provides a built-in append function. func append(s []T, vs ...T) []T The resulting value of append is a slice containing all the elements of the original slice plus the provided values. If the backing array of s is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array. var s []int // append works on nil slices. s = append(s, 0) // The slice grows as needed. s = append(s, 1) // We can add more than one element at a time. s = append(s, 2, 3, 4) 6.8. Maps Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value). The key can be of any type that is comparable for which the equality operator is defined. The language spec defines the Comparison operators precisely, in short, comparable types are boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types.[1] Notably absent from the list are slices, maps, and functions; these types cannot be compared using ==, and may not be used as map keys. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller. The zero value of a map is nil. A nil map has no keys, nor can keys be added. Map literals are like struct literals, but the keys are required. var m map[string]int // &lt;nil&gt; m = map[string]int{ &quot;hello&quot;: 100, &quot;world&quot;: 200, } The make function returns a map of the given type with an optional capacity hint as arguments, initialized and ready for use. // m := make(map[string]int, 100) m := make(map[string]int) // insert or update an element m[&quot;Answer&quot;] = 42 // delete an element: // The delete function doesn’t return anything, and will do nothing if the specified key doesn’t exist. delete(m, &quot;Answer&quot;) // retrieve an element // If the requested key doesn’t exist, we get the value type’s zero value. v := m[&quot;Answer&quot;] // test that a key is present with a two-value assignment v, ok := m[&quot;Answer&quot;] 6.9. Functions A function can return any number of results. func (file *File) Write(b []byte) (n int, err error) The return or result &quot;parameters&quot; of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values. Functions are values too. They can be passed around just like other values. Function values may be used as function arguments and return values. Go functions may be closures, that is a function value that references (i.e. bounds to) variables from outside its body. func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func wrapper(f func(int) int, i int) int { return f(i) } func main() { pos, neg := adder(), adder() for i := 1; i &lt;= 3; i++ { fmt.Printf(&quot;%+d, %+2d\t&quot;, wrapper(pos, i), neg(-i)) } } // Output: // +1, -1 +3, -3 +6, -6 A function literal represents an anonymous function and cannot declare type parameters, and it can be assigned to a variable or invoked directly. Function literals are closures: they may refer to variables defined in a surrounding function, which are then shared between the surrounding function and the function literal, and they survive as long as they are accessible. func main() { var sum int var add = func() { sum += 1 } add() fmt.Printf(&quot;%d\n&quot;, sum) } // Output: // 1 6.10. Methods A method is a function with a special receiver argument, defined on any named type (except a pointer or an interface) in the same package. type MyInt int func (mi *MyInt) String() string { return fmt.Sprintf(&quot;Hi %d!&quot;, *mi) } func (mi *MyInt) Add(delta int) { *mi = *mi + MyInt(delta) } func main() { var mi MyInt = 1_024 mi.Add(1_024) fmt.Println(&amp;mi) } // Output: // Hi 2048! Choosing a value or pointer receiver There are two reasons to use a pointer receiver. The first is so that the method can modify the value that its receiver points to. The second is to avoid copying the value on each method call, that can be more efficient if the receiver is a large struct, for example. In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers. Value methods can be called on both values and pointers (automatically using * on pointers), while pointer methods can only be called on pointers (automatically using &amp; on values). Nil is a valid receiver value Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices. When you define a type whose methods allow nil as a receiver value, it&#8217;s worth pointing this out explicitly in its documentation comment. package bytes // import &quot;bytes&quot; type Buffer struct { // Has unexported fields. } A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use. 6.11. Interfaces An interface type defines a type set, that is the set of all concrete types that implement that interface. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil. An interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type. Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. Interfaces are implemented implicitly A type implements an interface by implementing its methods. There is no explicit declaration of intent, no &quot;implements&quot; keyword. Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement. Interface values Under the hood, interface values can be thought of as a tuple of a value and a concrete type: An interface value holds a value of a specific underlying concrete type. (value, type) Calling a method on an interface value executes the method of the same name on its underlying type. Interface values with nil underlying values If the concrete value inside the interface itself is nil, the method will be called with a nil receiver. In some languages this would trigger a null pointer exception, but in Go it is common to write methods that gracefully handle being called with a nil receiver. Note that an interface value that holds a nil concrete value is itself non-nil. type I interface { M() } type T struct{} func (t *T) M() { if t == nil { fmt.Println(&quot;&lt;nil receiver&gt;&quot;) return } } func main() { var i I // `i` is nil // i.M() // runtime error: invalid memory address or nil pointer dereference var t *T i = t // `i` is not nil, but the concrete type `t` is nil i.M() fmt.Printf(&quot;%v, %T\n&quot;, i, i) i = &amp;T{} // the concrete type `t` is not nil i.M() fmt.Printf(&quot;%v, %T\n&quot;, i, i) } // Output: // &lt;nil receiver&gt; // &lt;nil&gt;, *main.T // &amp;{}, *main.T Nil interface values A nil interface value holds neither value nor concrete type. Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call. var i I fmt.Printf(&quot;(%v, %T)\n&quot;, i, i) i.M() // (&lt;nil&gt;, &lt;nil&gt;) // panic: runtime error: invalid memory address or nil pointer dereference The empty interface The interface type that specifies zero methods is known as the empty interface: interface{} An empty interface may hold values of any type. (Every type implements at least zero methods.) Empty interfaces are used by code that handles values of unknown type. For convenience, the predeclared type any is an alias for the empty interface. $ go doc builtin.any package builtin // import &quot;builtin&quot; type any = interface{} any is an alias for interface{} and is equivalent to interface{} in all ways. Basic interfaces Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces. // A simple File interface. interface { Read([]byte) (int, error) Write([]byte) (int, error) Close() error } Embedded interfaces In a slightly more general form an interface T may use a (possibly qualified) interface type name E as an interface element, which is called embedding interface E in T. The type set of T is the intersection of the type sets defined by T&#8217;s explicitly declared methods and the type sets of T’s embedded interfaces. In other words, the type set of T is the set of all types that implement all the explicitly declared methods of T and also all the methods of E. type Reader interface { Read(p []byte) (n int, err error) Close() error } type Writer interface { Write(p []byte) (n int, err error) Close() error } // ReadWriter&#39;s methods are Read, Write, and Close. type ReadWriter interface { Reader // includes methods of Reader in ReadWriter&#39;s method set Writer // includes methods of Writer in ReadWriter&#39;s method set } When embedding interfaces, methods with the same names must have identical signatures. type ReadCloser interface { Reader // includes methods of Reader in ReadCloser&#39;s method set Close() // illegal: signatures of Reader.Close and Close are different } General interfaces Azure AI | ChatGPT 4 In Go, general interfaces are used to define type constraints for type parameters in generic functions and data structures. [GPT 4] // Comparable is an interface that defines a type constraint using // a union of types (int, float64, and string). This means that a // type parameter satisfying the Comparable constraint must be one // of these types. type Comparable interface { int | float64 | string } // The Max function is defined as a generic function using the type // parameter T. The type parameter is specified within square brackets // ([T Comparable]). It means that the function can work with any type // T that satisfies the Comparable constraint. func Max[T Comparable](a, b T) T { if a &gt; b { return a } return b } // The Max function is called with different types of arguments (int, // float64, and string). The type parameter T is replaced with the actual // type of the arguments at each call, allowing the function to work with // different types while maintaining type safety. func main() { fmt.Println(Max(3, 4)) // int fmt.Println(Max(2.5, 3.7)) // float64 fmt.Println(Max(&quot;apple&quot;, &quot;cat&quot;)) // string } In summary, while you can&#8217;t assign a concrete type to a general interface, general interfaces are used to specify what types can be used with a generic function or data structure. These type constraints allow you to create flexible and reusable generic code while maintaining type safety. In their most general form, an interface element may also be an arbitrary type term T, or a term of the form ~T specifying the underlying type T, or a union of terms t1|t2| . . . |tn. By construction, an interface&#8217;s type set never contains an interface type. // An interface representing only the type int. interface { int } // An interface representing all types with underlying type int. interface { ~int } // An interface representing all types with underlying type int that implement the String method. interface { ~int String() string } // An interface representing an empty type set: there is no type that is both an int and a string. // // This code defines an interface that no concrete type satisfies because there is no type that is // both an int and a string. It is not the same as an empty interface (interface{}), which any type // can satisfy. This code snippet is used to illustrate the concept of an unsatisfiable interface // in the Go language specification. (Azure AI | ChatGPT 4) // // While this interface can be compiled, it cannot be used in practical terms because no type can // satisfy the constraints. It&#39;s a theoretical construct to show the capabilities and limitations of // the type constraint system in Go. (Azure AI | ChatGPT 4) interface { int string } In a term of the form ~T, the underlying type of T must be itself, and T cannot be an interface. Azure AI | ChatGPT 4 The tilde symbol ~ defines a type set constraint that includes the underlying type of T as well as any other types whose underlying type is the same as T. In this context, &quot;underlying type&quot; refers to the actual type without any type aliases or defined types based on it. &quot;The underlying type of T must be itself&quot;: This means that when defining a type set constraint using ~T, the type T must not be a type alias or a defined type based on another type. Instead, T must be a &quot;base&quot; type, such as int, float64, or a struct type. &quot;T cannot be an interface&quot;: This condition states that the type T in a type set constraint using ~T should not be an interface type. This is because interface types don&#8217;t have a specific underlying type that can be used in the type set definition. type MyInt int type MyI interface { ~[]byte // the underlying type of []byte is itself ~MyInt // illegal: the underlying type of MyInt is not MyInt ~error // illegal: error is an interface } Union elements denote unions of type sets: // The Float interface represents all floating-point types // (including any named types whose underlying types are // either float32 or float64). type Float interface { ~float32 | ~float64 } Generality If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method. In such cases, the constructor should return an interface value rather than the implementing type. // unexported type type myString struct { s string } func (ms myString) String() string { return ms.s } // constructor function (exported) that returns the interface func NewString(s string) fmt.Stringer { return myString{s: s} } Interface conversions and type assertions A type assertion provides access to an interface value&#8217;s underlying concrete value. t := i.(T) This statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t. If i does not hold a T, the statement will trigger a panic. To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded. t, ok := i.(T) If i holds a T, then t will be the underlying value and ok will be true. If not, ok will be false and t will be the zero value of type T, and no panic occurs. Type switches The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type. switch v := i.(type) { case T: // here v has type T case S: // here v has type S default: // no match; here v has the same type as i } 6.12. Embedding: interfaces and structs Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to &#8220;borrow&#8221; pieces of an implementation by embedding types within a struct or interface. package io // import &quot;io&quot; type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // ReadWriter is the interface that combines the Reader and Writer interfaces. type ReadWriter interface { Reader Writer } package bufio // import &quot;bufio&quot; type Reader struct { // Has unexported fields. } func (b *Reader) Read(p []byte) (n int, err error) type Writer struct { // Has unexported fields. } func (b *Writer) Write(p []byte) (nn int, err error) // ReadWriter stores pointers to a Reader and a Writer. // It implements io.ReadWriter. type ReadWriter struct { *Reader *Writer } For the embedded type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. For example, when the Read method of a bufio.ReadWriter is invoked, the receiver is the Reader field of the ReadWriter, not the ReadWriter itself. type Reader struct { } func (r *Reader) Read() { fmt.Println(&quot;Read&quot;) } type Writer struct { } func (r *Writer) Write() { fmt.Println(&quot;Write&quot;) } type ReadWriter struct { *Reader *Writer } func main() { rw := ReadWriter{} rw.Read() // same as rw.Reader.Read() // Output: // Read } Embedding types introduces the problem of name conflicts but the rules to resolve them are simple. First, a field or method X hides any other item X in a more deeply nested part of the type. Second, if the same name appears at the same nesting level, it is usually an error. However, if the duplicate name is never mentioned in the program outside the type definition, it is OK. type Inner1 struct { Name string } type Inner2 struct { Name string } type Outer struct { Inner1 Inner2 } func main() { o := Outer{ Inner1: Inner1{Name: &quot;Inner 1 Name&quot;}, Inner2: Inner2{Name: &quot;Inner 2 Name&quot;}, } fmt.Println(o.Inner1.Name) fmt.Println(o.Inner2.Name) // Compile error: ambiguous selector o.Name // fmt.Println(o.Name) } // Output // Inner 1 Name // Inner 2 Name Embedding: Provides an &quot;is-a&quot; relationship where the outer struct or interface directly inherits the fields and methods of the embedded struct or interface. Allows for easier and more direct access to the fields and methods of the embedded struct or interface, as they become part of the outer struct or interface. Enhances code reuse and polymorphism by making the fields and methods of the embedded struct or interface available directly in the outer struct or interface. Not Embedding (Composing): Provides a &quot;has-a&quot; relationship where the outer struct or interface holds instances of other structs or interfaces as separate fields. Requires explicitly accessing the fields and methods of the inner structs or interfaces through the composed fields. Keeps a clear separation between the fields and methods of the outer struct or interface and the inner structs or interfaces it holds. type Reader struct { } type Writer struct { } type ReadWriter struct { reader Reader writer Writer } func (r *Reader) Read() { fmt.Println(&quot;Read.&quot;) } func (w *Writer) Write() { fmt.Println(&quot;Write.&quot;) } func main() { rw := &amp;ReadWriter{} rw.reader.Read() // rw.Read undefined (type *ReadWriter has no field or method Read) rw.Read() } 6.13. Channels Channels are a typed conduit through which you can send and receive values with the channel operator, &lt;-. ch &lt;- v // Send v to channel ch. v := &lt;-ch // Receive from ch, and assign value to v. // (The data flows in the direction of the arrow.) Like maps and slices, channels must be created before use: // By default, sends and receives block until the other side is ready. // This allows goroutines to synchronize without explicit locks or condition variables. blockChan := make(chan int) // Sends to a buffered channel block only when the buffer is full. // Receives block when the buffer is empty. bufChan := make(chan int, 100) A sender can close a channel to indicate that no more values will be sent. After calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel&#8217;s type without blocking. Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed. // ok is false if there are no more values to receive and the channel is closed. v, ok := &lt;-ch The loop for v := range c receives values from the channel repeatedly until it is closed. Attempting to close an already-closed channel causes a panic, as does closing a nil channel. Sending to a closed channel causes a run-time panic. Only the sender should close a channel, never the receiver. Channels aren&#8217;t like files; you don&#8217;t usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop. A channel may be constrained only to send or only to receive by assignment or explicit conversion. func main() { var ( _ = make(chan int) // bidirectional _ = make(&lt;-chan int) // receive-only _ = make(chan&lt;- int) // send-only ) ch := make(chan int) // send-only go func(ch chan&lt;- int) { for i := 0; i &lt; 3; i++ { ch &lt;- i } close(ch) }(ch) // receive-only go func(ch &lt;-chan int) { for v := range ch { fmt.Println(v) } }(ch) time.Sleep(time.Millisecond) // Output: // 0 // 1 // 2 } func main() { ch1 := make(chan int) ch2 := make(chan int, 2) // buffering channel quit := make(chan int) go func() { for i := 1; ; i++ { ch1 &lt;- 2 * i time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) } }() go func(ch chan&lt;- int) { for i := 1; ; i++ { ch &lt;- 2*i + 1 time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) } }(ch2) go func() { &lt;-time.After(time.Duration(5e3) * time.Millisecond) quit &lt;- 0 }() // The select statement lets a goroutine wait on multiple communication operations. // A select blocks until one of its cases can run, then it executes that case. // It chooses one at random if multiple are ready. ch3 := make(chan int) timeout := time.After(500 * time.Millisecond) go func() { defer close(ch3) for { // multiplexing: ch1 + ch2 =&gt; ch3 select { case ch3 &lt;- &lt;-ch1: case ch3 &lt;- &lt;-ch2: case &lt;-timeout: fmt.Println(&quot;You&#39;re too slow.&quot;) return case &lt;-quit: fmt.Println(&quot;Quit.&quot;) return } } }() for v := range ch3 { fmt.Println(v) } } 6.14. Type conversions The expression T(v) converts the value v to the type T. // Some numeric conversions: var i int = 42 var f float64 = float64(i) var u uint = uint(f) // Or, put more simply: i := 42 f := float64(i) u := uint(f) 6.15. Generics Go functions can be written to work on multiple types using type parameters. The type parameters of a function appear between brackets, before the function&#8217;s arguments. func Index[T comparable](s []T, x T) int This declaration means that s is a slice of any type T that fulfills the built-in constraint comparable. x is also a value of the same type. comparable is a useful constraint that makes it possible to use the == and != operators on values of the type. package builtin // import &quot;builtin&quot; type comparable interface{ comparable } comparable is an interface that is implemented by all comparable types (booleans, numbers, strings, pointers, channels, arrays of comparable types, structs whose fields are all comparable types). The comparable interface may only be used as a type parameter constraint, not as the type of a variable. In addition to generic functions, Go also supports generic types. A type can be parameterized with a type parameter, which could be useful for implementing generic data structures. type ComparableOrdered interface { comparable constraints.Ordered // &quot;golang.org/x/exp/constraints&quot; } // List represents a singly-linked list that holds values of `ComparableOrdered` type. type List[T ComparableOrdered] struct { next *List[T] val T } func (head *List[T]) append(vals ...T) { var a = func(val T) { tail := head for tail.next != nil { tail = tail.next } tail.next = &amp;List[T]{val: val} } for _, val := range vals { a(val) } } func (head *List[T]) max() T { max := head.val node := head.next for node != nil { if node.val &gt; max { max = node.val } node = node.next } return max } func (head *List[T]) String() string { var b strings.Builder node := head for node != nil { fmt.Fprintf(&amp;b, &quot;%v&quot;, node.val) node = node.next if node != nil { fmt.Fprint(&amp;b, &quot; -&gt; &quot;) } } return b.String() } func main() { list := &amp;List[int]{val: 20} list.append(10, 30, 60) list.append(40) fmt.Printf(&quot;list: %v\n&quot;, list) fmt.Printf(&quot;max: %v&quot;, list.max()) // Output: // list: 20 -&gt; 60 -&gt; 30 -&gt; 10 -&gt; 40 // max: 60 } Type constraint and type parameter A type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter. If the constraint is an interface literal of the form interface{E} where E is an embedded type element (not a method), in a type parameter list the enclosing interface{ … } may be omitted for convenience: [T []P] // = [T interface{[]P}] [T ~int] // = [T interface{~int}] [T int|string] // = [T interface{int|string}] type Constraint ~int // illegal: ~int is not in a type parameter list A type argument T satisfies a type constraint C if T is an element of the type set defined by C; i.e., if T implements C. As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument. More precisely: A type T satisfies a constraint C if T implements C; or C can be written in the form interface{ comparable; E }, where E is a basic interface and T is comparable and implements E. type argument type constraint // constraint satisfaction int interface{ ~int } // satisfied: int implements interface{ ~int } string comparable // satisfied: string implements comparable (string is strictly comparable) []byte comparable // not satisfied: slices are not comparable any interface{ comparable; int } // not satisfied: any does not implement interface{ int } any comparable // satisfied: any is comparable and implements the basic interface any struct{f any} comparable // satisfied: struct{f any} is comparable and implements the basic interface any any interface{ comparable; m() } // not satisfied: any does not implement the basic interface interface{ m() } interface{ m() } interface{ comparable; m() } // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() } Because of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable). A type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses. TypeParameters = &quot;[&quot; TypeParamList [ &quot;,&quot; ] &quot;]&quot; . TypeParamList = TypeParamDecl { &quot;,&quot; TypeParamDecl } . TypeParamDecl = IdentifierList TypeConstraint . All non-blank names in the type parameter list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type. [P any] [S interface{ ~[]byte|string }] [S ~[]E, E any] [P Constraint[int]] [_ any] As the ordinary function parameter has a parameter type, the type parameter has a (meta-)type which is called its type constraint. 7. Initialization 7.1. Constants Constants are declared like variables, but with the const keyword. Constants cannot be declared using the := syntax. Constants are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. In Go, enumerated constants are created using the iota enumerator. type Weekday int const ( Sunday Weekday = iota + 1 // iota: 0 ~ Sunday : 1 _ // iota: 1 ~ iota increased // comments // iota: 1 ~ skip: comment // iota: 1 ~ skip: empty line Monday // iota: 2 ~ Monday : 3 Tuesday // iota: 3 ~ Monday : 4 Wednesday // iota: 4 ~ Monday : 5 Thursday // iota: 5 ~ Monday : 6 Friday // iota: 6 ~ Monday : 7 Saturday // iota: 7 ~ Monday : 8 ) iota (noun) /aɪˈəʊtə/ /aɪˈəʊtə/ 1. [singular] (usually used in negative sentences) an extremely small amount There is not one iota of truth (= no truth at all) in the story. I don&#39;t think that would help one iota. 2. the 9th letter of the Greek alphabet (I, ι) ref: https://www.oxfordlearnersdictionaries.com/us/definition/english/iota 7.2. Allocation: new and make Go has two allocation primitives, the built-in functions new and make. The new built-in function allocates memory of a type, return a pointer to a newly allocated zero value of that type. package builtin // import &quot;builtin&quot; func new(Type) *Type The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. The memory returned by new is zeroed is helpful to arrange when designing a data structures that the zero value of each type can be used without further initialization. var ptr *bytes.Buffer // nil // panic: runtime error: invalid memory address or nil pointer dereference // ptr.WriteString(&quot;Hello, world!&quot;) ptr = new(bytes.Buffer) // points to a zerod bytes.Buffer instance ptr.WriteString(&quot;Hello, world!&quot;) The make built-in function allocates and initializes an object of type slice, map, or chan (only). package builtin // import &quot;builtin&quot; func make(t Type, size ...IntegerType) Type The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make&#39;s return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type: Slice: The size specifies the length. The capacity of the slice is equal to its length. A second integer argument may be provided to specify a different capacity; it must be no smaller than the length. For example, make([]int, 0, 10) allocates an underlying array of size 10 and returns a slice of length 0 and capacity 10 that is backed by this underlying array. Map: An empty map is allocated with enough space to hold the specified number of elements. The size may be omitted, in which case a small starting size is allocated. Channel: The channel&#39;s buffer is initialized with the specified buffer capacity. If zero, or the size is omitted, the channel is unbuffered. It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. var p *[]int = new([]int) // allocates slice structure; *p == nil; rarely useful var v []int = make([]int, 100) // the slice v now refers to a new array of 100 ints // Unnecessarily complex: var p *[]int = new([]int) *p = make([]int, 100, 100) // Idiomatic: v := make([]int, 100) 7.3. The init function Each source file can define its own niladic init function to set up whatever state is required. Actually each file can have multiple init functions, which called in the order they appear in the source. The init function is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. // init.go var ( hello = &quot;Hello&quot; world = &quot;世界&quot; ) func init() { fmt.Print(hello) } func init() { fmt.Print(&quot;, &quot;) } func init() { fmt.Printf(&quot;%s\n&quot;, world) } func main() { } $ go run init.go Hello, 世界 7.4. Zero values Variables declared without an explicit initial value are given their zero value: 0 for numeric types, false for the boolean type, &quot;&quot; (the empty string) for strings, nil for the pointers, slices, maps, functions, interfaces, channels, 8. Concurrency 8.1. Race Conditions A race condition is a situation in which the program does not give the correct result for some interleaving of the operations of multiple goroutines. A data race, that is, a particular kind of race condition, occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race. The first way is not to write the variable. The second way (channels: share memory by communication) to avoid a data race is to avoid accessing the variable from multiple goroutines. The third way (mutual exclusion: sync.Mutex, sync.RWMutex) to avoid a data race is to allow many goroutines to access the variable, but only one at a time. Synchronization is about more than just the order of execution of multiple goroutines; synchronization also affets memory. Azure Open AI | ChatGPT4 Other race conditions include deadlocks, livelocks, and starvation. Deadlocks occur when two or more processes are waiting for each other to release resources that they need to continue executing. Livelocks occur when two or more processes are constantly changing their state in response to the actions of the other process, without making any progress towards their goal. A livelock is a situation where two or more processes or threads are actively trying to resolve a conflict but end up repeatedly yielding to each other, resulting in no progress being made. Livelocks are similar to deadlocks in that they both involve processes being stuck, but livelocks involve active, ongoing attempts to resolve the problem, whereas deadlocks involve processes waiting for resources. Here&#8217;s an example of a livelock: Imagine two people, Alice and Bob, walking in a narrow corridor towards each other. When they meet in the middle, they both step aside to let the other person pass. However, they both step in the same direction. Realizing this, they both step back to their original positions and try again, but they continue to step in the same direction each time. This results in a livelock, as they are both actively trying to resolve the situation but end up yielding to each other without making progress. Starvation occurs when a process is prevented from accessing the resources it needs to execute, either because other processes are monopolizing those resources or because the system is not allocating resources fairly. 8.2. Race Detector The race detector (add the -race flag to the go build, go run, or go test command) studies the steam of events, looking for cases in which one goroutine reads or writes a shared variables that was most recently written by a different goroutine without an intervening synchronization operation. The race detector reports all data races that were actually executed. However, it can only detect race conditions that occur during a run; it cannot prove that none will ever occur. 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func main() { var wg sync.WaitGroup var x, y int wg.Add(1) go func() { defer wg.Done() x = 1 fmt.Printf(&quot;y = %d\n&quot;, y) }() wg.Add(1) go func() { defer wg.Done() y = 1 fmt.Printf(&quot;x = %d\n&quot;, x) }() wg.Wait() } $ go run -race race.go x = 0 ================== WARNING: DATA RACE Write at 0x00c0000160c8 by goroutine 7: main.main.func1() /home/x/learn/go/race.go:15 +0xaa Previous read at 0x00c0000160c8 by goroutine 8: main.main.func2() /home/x/learn/go/race.go:23 +0xcf ... ================== ================== WARNING: DATA RACE Read at 0x00c0000160d8 by goroutine 7: main.main.func1() /home/x/learn/go/race.go:16 +0xcf Previous write at 0x00c0000160d8 by goroutine 8: main.main.func2() /home/x/learn/go/race.go:22 +0xaa ================== y = 1 Found 2 data race(s) exit status 66 Azure Open AI | ChatGPT4 When you run a Go program with the -race flag, the Go race detector instruments the code to monitor concurrent access to shared variables. If it detects a race condition, it generates a report with detailed information about the issue. The output of the -race flag typically consists of the following parts: A summary of the data race, indicating that it is a &quot;DATA RACE.&quot; A description of the current operation (read or write) that caused the race, including the memory address, the source code file, and the line number. The current goroutine involved in the race, including its number and the stack trace. A description of the previous conflicting operation (read or write) on the same memory address, including the source code file and the line number. The previous goroutine involved in the race, including its number and the stack trace. For example, consider the following output: WARNING: DATA RACE Write at 0x00c0000160c8 by goroutine 7: main.main.func1() /path/to/your/code/main.go:16 +0x6a Previous read at 0x00c0000160c8 by goroutine 8: main.main.func2() /path/to/your/code/main.go:22 +0x3e This output can be interpreted as follows: The race detector has identified a data race. A write operation occurred at memory address 0x00c0000160c8 by goroutine 7. The operation happened in the function main.main.func1() in the source code file main.go at line 16. The current goroutine 7 is shown along with the stack trace. A previous read operation occurred at the same memory address 0x00c0000160c8 by goroutine 8. The operation happened in the function main.main.func2() in the source code file main.go at line 22. The previous goroutine 8 is shown along with the stack trace. Using this information, you can identify the source code lines and goroutines involved in the race condition and take appropriate action to fix the issue, such as adding proper synchronization mechanisms like mutexes or channels. 8.3. Happen before Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification. Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another. For example, if one goroutine executes a = 1; b = 2;, another might observe the updated value of b before the updated value of a. To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event e1 happens before event e2, then we say that e2 happens after e1. Also, if e1 does not happen before e2 and does not happen after e2, then we say that e1 and e2 happen concurrently. Within a single goroutine, the happens-before order is the order expressed by the program. Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access. To serialize access, protect the data with channel operations or other synchronization primitives such as those in the sync and sync/atomic packages. 8.4. Share by communicating Do not communicate by sharing memory; instead, share memory by communicating. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there&#8217;s still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go&#8217;s approach to concurrency originates in Hoare&#8217;s Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes. 8.5. Goroutines A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. [20] And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required. Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management. Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. The evaluation of f, x, y, and z of go f(x, y, z) happens in the current goroutine and the execution of f happens in the new goroutine. func main() { // All function values created by this loop “capture” // and share the same variable—an addressable storage location, // not its value at that particular moment. for i := 0; i &lt; 5; i++ { go func() { fmt.Print(i, &quot; &quot;) }() } time.Sleep(time.Millisecond) fmt.Println() for i := 0; i &lt; 5; i++ { i := i go func() { fmt.Print(i, &quot; &quot;) }() } time.Sleep(time.Millisecond) // Output: // 5 5 5 5 5 // 4 0 1 2 3 // ignore the order } Best number of goroutines in a process There is no one-size-fits-all answer to the best number of goroutines in a process, as it depends on various factors such as the nature of your application, the resources available on your system, and the level of parallelism your program can achieve. However, here are some general guidelines to help you determine the optimal number of goroutines: [Azure Open AI | ChatGPT4] I/O-bound tasks: If your application performs tasks that are primarily I/O-bound, such as reading from or writing to disk, network, or other external resources, you can benefit from a higher number of goroutines. Since I/O-bound tasks often involve waiting for external resources, having more goroutines can help keep your application busy and utilize available CPU resources effectively. In this case, the optimal number of goroutines might be several times the number of available CPU cores. CPU-bound tasks: If your application performs tasks that are primarily CPU-bound, such as complex calculations or data processing, you may not benefit from a higher number of goroutines than the number of available CPU cores. Having more goroutines than CPU cores can lead to frequent context switching, which can hurt performance. In this case, the optimal number of goroutines might be close to the number of available CPU cores. Workload characteristics: The best number of goroutines also depends on the specific characteristics of your application&#8217;s workload. For example, if your application has a mix of I/O-bound and CPU-bound tasks, or if it has varying resource requirements over time, you might need to experiment with different numbers of goroutines to find the optimal balance. Resource availability: The optimal number of goroutines also depends on the resources available on your system, such as CPU, memory, and I/O capacity. If your system is constrained in terms of resources, you may need to limit the number of goroutines to avoid exhausting system resources and causing performance issues. When there are many Go processes running on the same operating system, it is essential to consider the overall resource usage of the entire system. Running multiple Go processes with a large number of goroutines can lead to contention for system resources, such as CPU, memory, and I/O capacity. In this case, it might be necessary to limit the number of goroutines per process or to distribute the processes across multiple machines to ensure optimal performance. Ultimately, the best way to determine the optimal number of goroutines for your application is through benchmarking, monitoring, and profiling. By measuring the performance of your application under different conditions and configurations, you can make informed decisions about the appropriate number of goroutines and resource allocation. 8.6. Channels Like maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel. ci := make(chan int) // unbuffered channel of integers cj := make(chan int, 0) // unbuffered channel of integers cs := make(chan *os.File, 100) // buffered channel of pointers to Files Receivers always block until there is data to receive. The sender blocks only until the value has been copied to the buffer. A buffered channel can be used like a semaphore, for instance to limit throughput. ch := make(chan int, 1) // create a buffered channel with capacity 1 ch &lt;- 1 // send 1 to the channel (non-blocking because of buffer) fmt.Println(&lt;-ch) // receive 1 from the channel ch = make(chan int) // create an unbuffered (blocking) channel stop := make(chan int) // create a channel to synchronize the goroutine&#39;s completion go func() { ch &lt;- 2 // send 2 to the channel (blocks until received) time.Sleep(time.Millisecond) // simulate some work fmt.Println(3) // print 3 after the send stop &lt;- 0 // signal that the goroutine is finished }() fmt.Println(&lt;-ch) // receive 2 from the channel (unblocks the goroutine) &lt;-stop // wait for the goroutine to signal completion // Output: // 1 // 2 // 3 The assembly line metaphor (pipeline) is useful one for channels and goroutines. ref http://golang.org/s/prime-sieve // A concurrent prime sieve // Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;. func Generate(ch chan&lt;- int) { for i := 2; ; i++ { ch &lt;- i // Send &#39;i&#39; to channel &#39;ch&#39;. } } // Copy the values from channel &#39;in&#39; to channel &#39;out&#39;, // removing those divisible by &#39;prime&#39;. func Filter(in &lt;-chan int, out chan&lt;- int, prime int) { for { i := &lt;-in // Receive value from &#39;in&#39;. if i%prime != 0 { out &lt;- i // Send &#39;i&#39; to &#39;out&#39;. } } } // The prime sieve: Daisy-chain Filter processes. func main() { ch := make(chan int) // Create a new channel. go Generate(ch) // Launch Generate goroutine. for i := 0; i &lt; 10; i++ { prime := &lt;-ch print(prime, &quot;\n&quot;) ch1 := make(chan int) go Filter(ch, ch1, prime) ch = ch1 } } 8.7. Parallelization Be sure not to confuse the ideas of concurrency&#8212;&#8203;structuring a program as independently executing components&#8212;&#8203;and parallelism&#8212;&#8203;executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go&#8217;s model. package runtime // import &quot;runtime&quot; func NumCPU() int NumCPU returns the number of logical CPUs usable by the current process. The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected. func GOMAXPROCS(n int) int GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves. 8.8. Synchronization In Go, synchronization is essential for ensuring safe concurrent execution of code and coordinating the activities of multiple goroutines. Go provides various synchronization primitives and constructs to facilitate communication between goroutines, protect access to shared resources, and manage concurrent execution. Here&#8217;s a comprehensive introduction to synchronization in Go: [Azure Open AI | ChatGPT4] 8.8.1. Channels Channels are the primary synchronization mechanism in Go and are used for communication between goroutines. They allow goroutines to send and receive values, which can be used for signaling or passing data. Channels provide a way to synchronize the execution of goroutines and ensure that data is safely shared without race conditions. // Creating a channel ch := make(chan int) // Sending a value to a channel ch &lt;- 42 // Receiving a value from a channel value := &lt;-ch Semaphores in Go? Go does not provide semaphores as a dedicated primitive like sync.Mutex . Instead, they can be implemented using buffered channels. Semaphores are used to control access to a limited number of resources or to limit the degree of concurrency for a group of goroutines. Here&#8217;s an example of how to implement a semaphore using a buffered channel in Go: const maxConcurrent = 3 func main() { var wg sync.WaitGroup // Create a buffered channel to act as a semaphore semaphore := make(chan struct{}, maxConcurrent) // Simulate 10 tasks that need to be executed concurrently for i := 1; i &lt;= 10; i++ { wg.Add(1) go func(taskID int) { defer wg.Done() // Acquire the semaphore semaphore &lt;- struct{}{} // Execute the task fmt.Printf(&quot;Task %d started\n&quot;, taskID) time.Sleep(1 * time.Second) fmt.Printf(&quot;Task %d completed\n&quot;, taskID) // Release the semaphore &lt;-semaphore }(i) } wg.Wait() } 8.8.2. sync.Mutex A Mutex (short for &quot;mutual exclusion&quot;, /ˈmjuːtɛks/) is a synchronization primitive used to protect access to shared resources and ensure that only one goroutine can access the resource at a time. Mutexes help prevent race conditions when multiple goroutines attempt to modify shared state concurrently. num := 0 var mu sync.Mutex var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() mu.Lock() defer mu.Unlock() for i := 0; i &lt; 100_000; i++ { num += 1 } }() go func() { defer wg.Done() mu.Lock() defer mu.Unlock() locked := mu.TryLock() if locked { defer mu.Unlock() fmt.Println(&quot;recursive lock!&quot;) } else { fmt.Println(&quot;not recursive lock!&quot;) } for i := 0; i &lt; 100_000; i++ { num += 1 } }() wg.Wait() fmt.Println(num) // 200000 // Output: // not recursive lock! // 200000 8.8.3. sync.RWMutex An RWMutex (short for &quot;read-write mutex&quot;) is similar to a Mutex but allows multiple readers to access a shared resource simultaneously, as long as no writer is accessing it. It provides two separate locks: a read lock and a write lock. Multiple goroutines can acquire read locks at the same time, but only one can acquire a write lock, and it must wait for all read locks to be released. type ConcurrentMap[TKey comparable, TValue any] struct { m map[TKey]TValue rwMu sync.RWMutex } func New[TKey comparable, TValue any]() *ConcurrentMap[TKey, TValue] { return &amp;ConcurrentMap[TKey, TValue]{m: make(map[TKey]TValue)} } func (q *ConcurrentMap[TKey, TValue]) Add(key TKey, value TValue) { q.rwMu.Lock() defer q.rwMu.Unlock() q.m[key] = value } func (q *ConcurrentMap[TKey, TValue]) Remove(key TKey) { q.rwMu.Lock() defer q.rwMu.Unlock() delete(q.m, key) } func (q *ConcurrentMap[TKey, TValue]) TryGet(key TKey) (item TValue, ok bool) { q.rwMu.RLock() defer q.rwMu.RUnlock() item, ok = q.m[key] return } 8.8.4. sync.WaitGroup A WaitGroup is a synchronization construct used to wait for a collection of goroutines to finish execution, that is often used when you start multiple goroutines to perform tasks concurrently and need to wait for all of them to complete before proceeding. var num int32 var wg sync.WaitGroup // define a WaitGroup wg.Add(2) // add delta, which may be negative, to the WaitGroup counter. go func() { defer wg.Done() // decrement the WaitGroup counter by one. for i := 0; i &lt; 10_000; i++ { if i%2 == 0 { atomic.AddInt32(&amp;num, 1) } } }() go func() { defer wg.Done() for i := 0; i &lt; 10_000; i++ { if i%2 == 1 { atomic.AddInt32(&amp;num, 1) } } }() wg.Wait() // block until the WaitGroup counter is zero. fmt.Println(num) // 10_000 8.8.5. sync.Cond A Cond (short for &quot;condition&quot;) is a synchronization primitive used to wait for or signal conditions. It is useful when one or more goroutines need to wait for a specific condition to be met before they can proceed. Conds are often used with a Mutex or RWMutex to protect access to the shared state being tested in the condition. type BlockingChannel[T any] struct { items []T c *sync.Cond mu *sync.Mutex // explicit mutex for clarity } func New[T any](capacity int) *BlockingChannel[T] { mu := &amp;sync.Mutex{} return &amp;BlockingChannel[T]{ items: make([]T, 0, capacity), c: sync.NewCond(mu), // create a new condition variable associated with the mutex mu: mu, // store the mutex } } func (bc *BlockingChannel[T]) Write(item T) { bc.c.L.Lock() // acquire the lock before accessing shared resources defer bc.c.L.Unlock() // ensure the lock is released when the function returns for len(bc.items) == cap(bc.items) { // wait if the channel is full bc.c.Wait() // release the lock and wait for a signal } bc.items = append(bc.items, item) // add the item to the channel bc.c.Signal() // Signal a waiting reader that an item is available. } func (bc *BlockingChannel[T]) Read() T { bc.c.L.Lock() defer bc.c.L.Unlock() for len(bc.items) == 0 { // wait if the channel is empty bc.c.Wait() // release the lock and wait for a signal } n := len(bc.items) item := bc.items[n-1] bc.items = bc.items[:n-1] bc.c.Broadcast() // Signal all waiting writers that space is available return item } 8.8.6. sync.Once A Once is a synchronization construct used to ensure that a function is only executed once, regardless of how many goroutines attempt to call it, that is useful for initializing shared resources, such as global variables or singletons, in a concurrent environment. // Defining a Once var once sync.Once // Executing a function only once, regardless of how many goroutines call it once.Do(func() { // initialize shared resource }) 8.8.7. sync.Map A Map is a concurrent, thread-safe map implementation provided by the sync package. It is designed for cases where the number of keys is large and their lifetimes are mostly unknown. Unlike the built-in map type, sync.Map provides safe concurrent access without requiring an additional synchronization mechanism like a Mutex. // Defining a sync.Map var m sync.Map // Storing a value in sync.Map m.Store(&quot;key&quot;, &quot;value&quot;) // Loading a value from sync.Map value, ok := m.Load(&quot;key&quot;) // Deleting a value from sync.Map m.Delete(&quot;key&quot;) // Iterating over sync.Map m.Range(func(key, value interface{}) bool { fmt.Printf(&quot;key: %v, value: %v\n&quot;, key, value) return true }) 8.8.8. sync/atomic package atomic // import &quot;sync/atomic&quot; Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don&#39;t communicate by sharing memory. BUG: On 386, the 64-bit functions use instructions unavailable before the Pentium MMX. On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. On ARM, 386, and 32-bit MIPS, it is the caller&#39;s responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically via the primitive atomic functions (types [Int64] and [Uint64] are automatically aligned). The first word in an allocated struct, array, or slice; in a global variable; or in a local variable (because on 32-bit architectures, the subject of 64-bit atomic operations will escape to the heap) can be relied upon to be 64-bit aligned. Share memory by communicating; don&#8217;t communicate by sharing memory. For most synchronization needs, Go&#8217;s channels and the sync package (e.g., sync.Mutex, sync.WaitGroup, sync.Cond) provide safer and easier-to-use abstractions. Channels provide a more structured and less error-prone way to synchronize concurrent operations. 9. Errors Library routines must often return some sort of error indication to the caller. Go&#8217;s multi-value return makes it a good style to easily return a detailed error description alongside the normal return value. The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error, typically created using fmt.Errorf or errors.New. When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. func main() { defer func() { if r := recover(); r != nil { fmt.Printf(&quot;recoverd: %v\n&quot;, r) err := r.(error) foo := errors.Unwrap(err) fmt.Printf(&quot;inner error: %v\n&quot;, foo) } }() fi, err := os.Open(&quot;hello.txt&quot;) if err != nil { if pe, ok := err.(*os.PathError); ok { fmt.Printf(&quot;path error: %v\n&quot;, pe) } else { fmt.Printf(&quot;unknown error: %v\n&quot;, pe) } } defer fi.Close() err = errors.New(&quot;bar&quot;) err = fmt.Errorf(&quot;foo: %w&quot;, err) // wrap an inner error panic(err) } // path error: open hello.txt: no such file or directory // recoverd: foo: bar // inner error: bar The panic built-in function stops normal execution of the current goroutine, and the recover built-in function allows a program to manage behavior of a panicking goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G&#8217;s execution and running any deferred functions, until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. func F() { err := errors.New(&quot;F: panic&quot;) panic(err) } func G() { defer func() { if r := recover(); r != nil { err := fmt.Errorf(&quot;G: %w&quot;, r) panic(err) } }() F() } func main() { defer func() { if r := recover(); r != nil { fmt.Println(r) } }() G() } // G: F: panic 10. Testing The go test subcommand is a test driver for Go packages that are organized according to certain conventions. In a package directory, files whose names end with _test.go are not part of the package ordinarily built by go build but are a part of it when built by go test. Within _test.go files, four kinds of functions are treated specially: tests, fuzzs, benchmarks, and examples. A test function, which is a function whose name begins with Test exercises some program logic for correct behavior; go test calls the test function and report the result, which is either PASS or FAIL. With fuzzing, random data is run against your test in an attempt to find vulnerabilities or crash-causing inputs. A benchmark function has a name beginning with Benchmark and measures the performance of some operation; go test reports the mean execution time of the operation. And an example function, whose name starts with Example, provides machine-checked documentation. func Foo(s string) string { return s } func TestFoo(t *testing.T) { var tests = []struct { s string want string }{ {&quot;Hello&quot;, &quot;Hello&quot;}, {&quot;世界!&quot;, &quot;世界!&quot;}, } for _, test := range tests { if got := Foo(test.s); got != test.want { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, test.s, got, test.want) } } } // Fuzz test func FuzzFoo(f *testing.F) { // Seed corpus addition f.Add(&quot;hello&quot;) // Fuzz target f.Fuzz(func(t *testing.T, s string) { // s string // Fuzzing arguments if got := Foo(s); got != s { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, s, got, s) } }) } func BenchmarkFoo(b *testing.B) { for n := 0; n &lt; b.N; n++ { } } func ExampleFoo() { fmt.Println(&quot;BAR&quot;) // Output: // BAR } $ GO111MODULE=off go test PASS ok _/tmp/learn-notes 0.003s $ GO111MODULE=off go test -fuzz=Fuzz -fuzztime=3s fuzz: elapsed: 0s, gathering baseline coverage: 0/1 completed fuzz: elapsed: 0s, gathering baseline coverage: 1/1 completed, now fuzzing with 4 workers fuzz: elapsed: 3s, execs: 226192 (75387/sec), new interesting: 0 (total: 1) fuzz: elapsed: 3s, execs: 226192 (0/sec), new interesting: 0 (total: 1) PASS ok _/tmp/learn-notes 3.127s $ GO111MODULE=off go test -bench=.* goos: linux goarch: amd64 cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz BenchmarkFoo-4 1000000000 0.5349 ns/op PASS ok _/tmp/learn-notes 0.605s 11. Modules Go 1.11 and 1.12 include preliminary support for modules, Go’s new dependency management system that makes dependency version information explicit and easier to manage.[2] GOPATH and GO111MODULE: New module changes in Go 1.16 The go command now builds packages in module-aware mode by default, even when no go.mod is present. This is a big step toward using modules in all projects. It’s still possible to build packages in GOPATH mode by setting the GO111MODULE environment variable to off. You can also set GO111MODULE to auto to enable module-aware mode only when a go.mod file is present in the current directory or any parent directory. This was previously the default. Note that you can set GO111MODULE and other variables permanently with go env -w: go env -w GO111MODULE=auto We plan to drop support for GOPATH mode in Go 1.17. In other words, Go 1.17 will ignore GO111MODULE. If you have projects that do not build in module-aware mode, now is the time to migrate. In Go, if an old package and a new package have the same import path, the new package must be backwards compatible with the old package. There is certainly a cost to needing to introduce a new name for each backwards-incompatible API change, but as the semver FAQ says, that cost should encourage authors to more clearly consider the impact of such changes and whether they are truly necessary. A module path is the canonical name for a module, declared with the module directive in the module’s go.mod file. A module’s path is the prefix for package paths within the module. A module path should describe both what the module does and where to find it. Typically, a module path consists of a repository root path, a directory within the repository (usually empty), and a major version suffix (only for major version 2 or higher). [4] A module is a collection of related Go packages that are versioned together as a single unit. Modules record precise dependency requirements and create reproducible builds. Most often, a version control repository contains exactly one module defined in the repository root. Summarizing the relationship between repositories, modules, and packages: A repository contains one or more Go modules. Each module contains one or more Go packages. Each package consists of one or more Go source files in a single directory. Modules must be semantically versioned according to semver, usually in the form v(major).(minor).(patch), such as v0.1.0, v1.2.3, or v1.5.0-rc.1. The leading v is required. If using Git, tag released commits with their versions. A module is defined by a tree of Go source files with a go.mod file in the tree&#8217;s root directory. A module declares its identity in its go.mod via the module directive, which provides the module path. The import paths for all packages in a module share the module path as a common prefix. The module path and the relative path from the go.mod to a package&#8217;s directory together determine a package&#8217;s import path. In Go source code, packages are imported using the full path including the module path. go help modules go help go.mod go help module-private go help goproxy go env GOPROXY # https://proxy.golang.org,direct go env -w GOPROXY=https://goproxy.cn,direct go env GOPROXY # https://goproxy.cn,direct go help gopath 12. Printf Package fmt implements formatted I/O with functions analogous to C&#8217;s printf and scanf.[16] 12.1. The Printing verbs General: %v the value in a default format when printing structs, the plus flag (%+v) adds field names %#v a Go-syntax representation of the value %T a Go-syntax representation of the type of the value %% a literal percent sign; consumes no value type Pointer struct { X int Y int } func main() { p := Pointer{3, 4} fmt.Printf(&quot;%%v: %v\n&quot;, p) fmt.Printf(&quot;%%+v: %+v\n&quot;, p) fmt.Printf(&quot;%%#v: %#v\n&quot;, p) fmt.Printf(&quot;%%T: %T\n&quot;, p) } // Output: // %v: {3 4} // %+v: {X:3 Y:4} // %#v: main.Pointer{X:3, Y:4} // %T: main.Pointer Boolean: %t the word true or false Integer: %b base 2 %c the character represented by the corresponding Unicode code point %d base 10 %o base 8 %O base 8 with 0o prefix %q a single-quoted character literal safely escaped with Go syntax. %x base 16, with lower-case letters for a-f %X base 16, with upper-case letters for A-F %U Unicode format: U+1234; same as &quot;U+%04X&quot; func main() { n := 1234 fmt.Printf(&quot;%%b: %b\n&quot;, n) fmt.Printf(&quot;%%c: %c\n&quot;, n) fmt.Printf(&quot;%%d: %d\n&quot;, n) fmt.Printf(&quot;%%o: %o\n&quot;, n) fmt.Printf(&quot;%%O: %O\n&quot;, n) fmt.Printf(&quot;%%q: %q\n&quot;, n) fmt.Printf(&quot;%%x: %x\n&quot;, n) fmt.Printf(&quot;%%X: %X\n&quot;, n) fmt.Printf(&quot;%%U: %U\n&quot;, n) } // Output: // %b: 10011010010 // %c: Ӓ // %d: 1234 // %o: 2322 // %O: 0o2322 // %q: &#39;Ӓ&#39; // %x: 4d2 // %X: 4D2 // %U: U+04D2 Floating-point and complex constituents: %b decimalless scientific notation with exponent a power of two, in the manner of strconv.FormatFloat with the &#39;b&#39; format, e.g. -123456p-78 %e scientific notation, e.g. -1.234456e+78 %E scientific notation, e.g. -1.234456E+78 %f decimal point but no exponent, e.g. 123.456 %F synonym for %f %g %e for large exponents, %f otherwise. Precision is discussed below. %G %E for large exponents, %F otherwise %x hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20 %X upper-case hexadecimal notation, e.g. -0X1.23ABCP+20 func main() { n := -123456.789 fmt.Printf(&quot;%%b: %b\n&quot;, n) fmt.Printf(&quot;%%e: %e\n&quot;, n) fmt.Printf(&quot;%%E: %E\n&quot;, n) fmt.Printf(&quot;%%f: %f\n&quot;, n) fmt.Printf(&quot;%%F: %F\n&quot;, n) fmt.Printf(&quot;%%g: %g\n&quot;, n) fmt.Printf(&quot;%%G: %G\n&quot;, n) fmt.Printf(&quot;%%x: %x\n&quot;, n) fmt.Printf(&quot;%%X: %X\n&quot;, n) } // Output: // %b: -8483885939586761p-36 // %e: -1.234568e+05 // %E: -1.234568E+05 // %f: -123456.789000 // %F: -123456.789000 // %g: -123456.789 // %G: -123456.789 // %x: -0x1.e240c9fbe76c9p+16 // %X: -0X1.E240C9FBE76C9P+16 String and slice of bytes (treated equivalently with these verbs): %s the uninterpreted bytes of the string or slice %q a double-quoted string safely escaped with Go syntax %x base 16, lower-case, two characters per byte %X base 16, upper-case, two characters per byte Slice: %p address of 0th element in base 16 notation, with leading 0x Pointer: %p base 16 notation, with leading 0x The %b, %d, %o, %x and %X verbs also work with pointers, formatting the value exactly as if it were an integer. The default format for %v is: bool: %t int, int8 etc.: %d uint, uint8 etc.: %d, %#x if printed with %#v float32, complex64, etc: %g string: %s chan: %p pointer: %p For compound objects, the elements are printed using these rules, recursively, laid out like this: struct: {field0 field1 ...} array, slice: [elem0 elem1 ...] maps: map[key1:value1 key2:value2 ...] pointer to above: &amp;{}, &amp;[], &amp;map[] Other flags: &#39;+&#39; always print a sign for numeric values; guarantee ASCII-only output for %q (%+q) &#39;-&#39; pad with spaces on the right rather than the left (left-justify the field) &#39;#&#39; alternate format: add leading 0b for binary (%#b), 0 for octal (%#o), 0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p); for %q, print a raw (backquoted) string if strconv.CanBackquote returns true; always print a decimal point for %e, %E, %f, %F, %g and %G; do not remove trailing zeros for %g and %G; write e.g. U+0078 &#39;x&#39; if the character is printable for %U (%#U). &#39; &#39; (space) leave a space for elided sign in numbers (% d); put spaces between bytes printing strings or slices in hex (% x, % X) &#39;0&#39; pad with leading zeros rather than spaces; for numbers, this moves the padding after the sign; ignored for strings, byte slices and byte arrays func main() { n := 123 fmt.Printf(&quot;%+06d\n&quot;, n) } // Output: // +00123 12.2. Width and Precision Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. %f default width, default precision %9f width 9, default precision %.2f default width, precision 2 %9.2f width 9, precision 2 %9.f width 9, precision 0 12.3. Stringer type Stringer interface { String() string } Stringer is implemented by any value that has a String method, which defines the &quot;native&quot; format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. // Animal has a Name and an Age to represent an animal. type Animal struct { Name string Age uint } // String makes Animal satisfy the Stringer interface. func (a Animal) String() string { return fmt.Sprintf(&quot;%v (%d)&quot;, a.Name, a.Age) } func main() { a := Animal{ Name: &quot;Gopher&quot;, Age: 2, } fmt.Println(a) // Output: // Gopher (2) } References [1] https://go.dev/blog/maps [2] https://go.dev/blog/using-go-modules [3] https://go.dev/blog/strings [4] https://go.dev/ref/mod [5] Capturing Iteration Variables in Go Language [6] https://groups.google.com/g/golang-nuts/c/pZwdYRGxCIk/m/qpbHxRRPJdUJ [7] Practical Go: Real world advice for writing maintainable Go programs [8] https://go.dev/doc/effective_go.html [9] Errors in Go language [10] Goroutines and Channels in Go Language [11] Object-oriented Programming in Go Language [12] Testing in Go Language [13] https://semver.org/ [14] https://stackoverflow.com/questions/24790175/when-is-the-init-function-run [15] https://medium.com/@adiach3nko/package-management-with-go-modules-the-pragmatic-guide-c831b4eaaf31 [16] https://pkg.go.dev/fmt [17] https://go.dev/ref/mem [18] Concurrency with Shared Variables in Go Language [19] https://go.dev/ref/spec#Iota [20] https://talks.golang.org/2012/concurrency.slide [21] https://go.dev/tour/generics/1 [22] https://research.swtch.com/vgo-import [23] https://research.swtch.com/vgo-module [24] https://research.swtch.com/vgo-mvs [25] https://github.com/golang/go/wiki/Iota [26] https://github.com/golang/go/wiki/Modules" />
<meta property="og:description" content="1. Foramtting 2. Commentary 3. Names 3.1. Package names 3.2. Getters 3.3. Interface names 3.4. MixedCaps 4. Semicolons 5. Control structures 5.1. If 5.2. For 5.3. Switch 5.4. Type Switch 5.5. Select 5.6. Break, Continue and Goto 5.7. Fallthrough 5.8. Defer 6. Data types 6.1. Type 6.2. Variables 6.3. Strings, bytes, runes and characters 6.4. Pointers 6.5. Structs 6.6. Arrays 6.7. Slices 6.8. Maps 6.9. Functions 6.10. Methods 6.11. Interfaces 6.12. Embedding: interfaces and structs 6.13. Channels 6.14. Type conversions 6.15. Generics 7. Initialization 7.1. Constants 7.2. Allocation: new and make 7.3. The init function 7.4. Zero values 8. Concurrency 8.1. Race Conditions 8.2. Race Detector 8.3. Happen before 8.4. Share by communicating 8.5. Goroutines 8.6. Channels 8.7. Parallelization 8.8. Synchronization 8.8.1. Channels 8.8.2. sync.Mutex 8.8.3. sync.RWMutex 8.8.4. sync.WaitGroup 8.8.5. sync.Cond 8.8.6. sync.Once 8.8.7. sync.Map 8.8.8. sync/atomic 9. Errors 10. Testing 11. Modules 12. Printf 12.1. The Printing verbs 12.2. Width and Precision 12.3. Stringer References 1. Foramtting With Go we take an unusual approach and let the machine take care of most formatting issues. The gofmt program (also available as go fmt, which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments. $ cat formatting.go package formatting type T struct { name string // name of the object value int // its value } $ go fmt formatting.go # or gofmt -w formatting.go formatting.go $ cat formatting.go package formatting type T struct { name string // name of the object value int // its value } 2. Commentary Go provides C-style /* */ block comments and C&#43;&#43;-style // line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. // Println formats using the default formats for its operands and writes to standard output. // Spaces are always added between operands and a newline is appended. // It returns the number of bytes written and any write error encountered. func Println(a ...any) (n int, err error) { return Fprintln(os.Stdout, a...) } The command go doc is used to display documentation for Go packages, functions, or types directly in the terminal. When run with one argument, the argument is treated as a Go-syntax-like representation of the item to be documented. go doc &lt;pkg&gt; # go doc net/http go doc &lt;sym&gt;[.&lt;methodOrField&gt;] # go doc http.Request.Write go doc [&lt;pkg&gt;.]&lt;sym&gt;[.&lt;methodOrField&gt;] # go doc net/http.Request.Write go doc [&lt;pkg&gt;.][&lt;sym&gt;.]&lt;methodOrField&gt; # go doc net/http.Write $ go doc builtin.new package builtin // import &quot;builtin&quot; func new(Type) *Type The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. When run with two arguments, the first is a package path (full path or suffix), and the second is a symbol, or symbol with method or struct field: go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;methodOrField&gt;] # go doc net/http Request.Write $ go doc sync Mutex package sync // import &quot;sync&quot; type Mutex struct { // Has unexported fields. } A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex. A Mutex must not be copied after first use. func (m *Mutex) Lock() func (m *Mutex) Unlock() The godoc is a tool used to either generate HTML documentation or serve it through a local web server. godoc -http=:6060 3. Names The visibility of a name outside a package is determined by whether its first character is upper case. 3.1. Package names By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as &quot;encoding/base64&quot; but has name base64, not encoding_base64 and not encodingBase64. Use the package structure to help you choose good names. The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter. For instance, the buffered reader type in the bufio package is called Reader, not BufReader, because users see it as bufio.Reader, which is a clear, concise name. Moreover, because imported entities are always addressed with their package name, bufio.Reader does not conflict with io.Reader. Similarly, the function to make new instances of ring.Ring—which is the definition of a constructor in Go—would normally be called NewRing, but since Ring is the only type exported by the package, and since the package is called ring, it&#8217;s called just New, which clients of the package see as ring.New. 3.2. Getters Go doesn&#8217;t provide automatic support for getters and setters. There&#8217;s nothing wrong with providing getters and setters yourself, and it&#8217;s often appropriate to do so, but it&#8217;s neither idiomatic nor necessary to put Get into the getter&#8217;s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner. A setter function, if needed, will likely be called SetOwner. Both names read well in practice: owner := obj.Owner() if owner != user { obj.SetOwner(user) } 3.3. Interface names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc. type Writer interface { Write(p []byte) (n int, err error) } type ReadWriter interface { Reader Writer } There are a number of such names and it&#8217;s productive to honor them and the function names they capture. Read, Write, Close, Flush, String and so on have canonical signatures and meanings. To avoid confusion, don&#8217;t give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method String not ToString. 3.4. MixedCaps Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names. 4. Semicolons Like C, Go&#8217;s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. If the newline comes after a token that could end a statement, insert a semicolon. Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the initializer, condition, and continuation elements. for i := 0; i &lt; 5; i++ { } They are also necessary to separate multiple statements on a line, should you write code that way. 5. Control structures There is no do or while loop, only a slightly generalized for; switch is more flexible; if and switch accept an optional initialization statement like that of for; break and continue statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, select. There are no parentheses and the bodies must always be brace-delimited. 5.1. If if x &gt; 0 { return y } if f, err: = os.Open(name); err != nil { return err } 5.2. For // Like a C for for init; condition; post { } // Like a C while for condition { } // Like a C for(;;) for { } // Like a C do-while for { // do something if condition; { break } } If you&#8217;re looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop. for key, value := range map { } // If you only need the second item in the range (the value), // use the blank identifier, an underscore, to discard the first: for _, value := range map { } for index, value := range array { } for value := range channel { } For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. The name (with associated builtin type) rune is Go terminology for a single Unicode code point. for pos, char := range &quot;日本\x80語&quot; { // \x80 is an illegal UTF-8 encoding fmt.Printf(&quot;character %#U starts at byte position %d\n&quot;, char, pos) } // Output: // character U+65E5 &#39;日&#39; starts at byte position 0 // character U+672C &#39;本&#39; starts at byte position 3 // character U+FFFD &#39;�&#39; starts at byte position 6 // character U+8A9E &#39;語&#39; starts at byte position 7 Go has no comma operator and ++ and -- are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes &#43;&#43; and --). // Reverse a for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] } 5.3. Switch Go&#8217;s switch is more general than C&#8217;s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true. It&#8217;s therefore possible&#8212;&#8203;and idiomatic&#8212;&#8203;to write an if-else-if-else chain as a switch. There is no automatic fall through, but cases can be presented in comma-separated lists. Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early. Sometimes, though, it&#8217;s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and &quot;breaking&quot; to that label. Of course, the continue statement also accepts an optional label but it applies only to loops. switch os := runtime.GOOS; os { case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.\n&quot;, os) } Loop: for n := 0; n &lt; len(src); n += size { switch { case src[n] &lt; sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] &lt; sizeTwo: if n+1 &gt;= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]&lt;&lt;shift) } } 5.4. Type Switch A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It&#8217;s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(&quot;unexpected type %T\n&quot;, t) // %T prints whatever type t has case bool: fmt.Printf(&quot;boolean %t\n&quot;, t) // t has type bool case int: fmt.Printf(&quot;integer %d\n&quot;, t) // t has type int case *bool: fmt.Printf(&quot;pointer to boolean %t\n&quot;, *t) // t has type *bool case *int: fmt.Printf(&quot;pointer to integer %d\n&quot;, *t) // t has type *int } 5.5. Select The select statement lets a goroutine wait on multiple communication operations. A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready. The default case in a select is run if no other case is ready. Use a default case to try a send or receive without blocking: func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case &lt;-tick: fmt.Println(&quot;tick.&quot;) case &lt;-boom: fmt.Println(&quot;BOOM!&quot;) return default: fmt.Println(&quot; .&quot;) time.Sleep(50 * time.Millisecond) } } } 5.6. Break, Continue and Goto A break statement terminates execution of the innermost for, switch, or select statement within the same function. A continue statement begins the next iteration of the innermost for loop at its post statement within the same function. A goto statement transfers control to the statement with the corresponding label within the same function. func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) RawLoop: for { select { case &lt;-tick: fmt.Println(&quot;tick.&quot;) continue RawLoop // go to the next iteration case &lt;-boom: fmt.Println(&quot;BOOM!&quot;) break RawLoop // exit default: fmt.Println(&quot;. .&quot;) time.Sleep(50 * time.Millisecond) goto RawLoop // go back to the very beginning } } } 5.7. Fallthrough A fallthrough statement transfers control to the first statement of the next case clause in an expression switch statement. It may be used only as the final non-empty statement in such a clause. switch { case 10 &gt; 11: fmt.Println(&quot;10 &gt; 11&quot;) case 1 &lt; 5: fmt.Println(&quot;1 &lt; 5&quot;) fallthrough case 1 &gt; 10: fmt.Println(&quot;1 &gt; 10 ?&quot;) } // Output: // 1 &lt; 5 // 1 &gt; 10 ? 5.8. Defer A defer statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, godir, err := os.Open(&quot;/usr/local/go&quot;) if err != nil { log.Printf(&quot;%s\n&quot;, err) defer godir.Close() } or because the corresponding goroutine is panicking. defer func() { e := recover() fmt.Printf(&quot;recover: %s\n&quot;, e) }() defer func() { fmt.Println(&quot;. . .&quot;) }() panic(fmt.Sprintf(&quot;Oops, I&#39;m NOT myself.&quot;)) // Output: // . . . // recover: Oops, I&#39;m NOT myself. Go&#8217;s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns. // The arguments to the deferred function (which include the receiver if the function is a method) // are evaluated when the _defer_ executes, not when the _call_ executes. func main() { v := 10 defer fmt.Println(3 * v) // 30 defer func() { fmt.Println(v) // 20 }() defer func(x int) { fmt.Println(x) // 10 }(v) v = 20 _ = v } // Output: // 10 // 20 // 30 It&#8217;s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. func ReadFile(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() return ReadAll(f) } Deferred functions are executed in LIFO order (stacking style). for i := 0; i &lt; 5; i++ { defer fmt.Printf(&quot;%d &quot;, i) } // Output: // 4 3 2 1 0 // All function values created by this loop &quot;capture&quot; // and share the same variable—an addressable storage location, // not its value at that particular moment. for i := 0; i &lt; 5; i++ { defer func() { fmt.Print(i, &quot; &quot;) }() } // Output: // 5 5 5 5 5 for i := 0; i &lt; 5; i++ { // declares inner i, intialized to outer i i := i defer func() { fmt.Print(i, &quot; &quot;) }() } // Output: // 4 3 2 1 0 6. Data types // any is an alias for interface{} and is equivalent to interface{} in all ways. // (go1.18) any // comparable is an interface that is implemented by all comparable types // (booleans, numbers, strings, pointers, channels, arrays of comparable types, // structs whose fields are all comparable types). The comparable interface may // only be used as a type parameter constraint, not as the type of a variable. // (go1.18) comparable bool // true false string int8 int16 int32 int64 uint8 uint16 uint32 uint64 uintptr int uint // either 32 or 64 bits byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 // more types pointers structs array slices maps functions interfaces channels 6.1. Type The type keyword in Go is used to define new types or create aliases for existing types. Type definitions create a completely new type that is distinct from the base type, which can be added methods to it. // new named type type Celsius float64 type Fahrenheit float64 // new type method func (c Celsius) ToF() Fahrenheit { return Fahrenheit((c * 9.0 / 5.0) + 32.0) } func cToF(c Celsius) Fahrenheit { return c.ToF() } func main() { var tempC Celsius = 25.0 tempF := cToF(tempC) fmt.Println(tempF) // 77 // Error: cannot use tempC (variable of float64 type Celsius) as float64 value in variable declaration // var tempFloat float64 = tempC // fmt.Println(tempFloat) } type Reader interface { Read() (int, bool) } type Writer interface { Write(item int) } type ReadWriter interface { Reader Writer } type MyChannel struct { channel chan int } func (my MyChannel) Read() (v int, ok bool) { v, ok = &lt;-my.channel return } func (my MyChannel) Write(item int) { my.channel &lt;- item } func (my MyChannel) Close() { close(my.channel) } func New(size int) MyChannel { return MyChannel{channel: make(chan int, size)} } func main() { my := New(5) go func() { for { v, ok := my.Read() if !ok { break } fmt.Println(v) } }() go func() { defer my.Close() for i := 0; i &lt; 10; i++ { my.Write(i) } }() time.Sleep(10 * time.Millisecond) } Type aliases provide a different name for an existing type but don&#8217;t create a new type; they just give a new identifier. // type alias type Celsius = float64 type Fahrenheit = float64 func cToF(c Celsius) Fahrenheit { return Fahrenheit((c * 9.0 / 5.0) + 32.0) } func main() { var tempC Celsius = 25.0 tempF := cToF(tempC) fmt.Println(tempF) // 77 // because Celsius and float64 are the same, this is legal: var tempFloat float64 = tempC fmt.Println(tempFloat) // 25 } 6.2. Variables A var statement can be at package or function level to declare a list of variables; as in function argument lists, the type is last. var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } A var declaration can include initializers, one per variable. var c, python, java = true, false, &quot;no!&quot; Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type. func main() { var i, j int = 1, 2 k := 3 c, python, java := true, false, &quot;no!&quot; fmt.Println(i, j, k, c, python, java) } 6.3. Strings, bytes, runes and characters Go source code is always UTF-8. A string holds arbitrary bytes. A string literal, absent byte-level escapes, always holds valid UTF-8 sequences. Those sequences represent Unicode code points, called runes. A code point is a unique numerical value assigned to a character in the Unicode standard, that represents a character, regardless of how that character is stored or encoded. A code unit is the actual bit sequence used to represent a code point in a specific encoding scheme. No guarantee is made in Go that characters in strings are normalized. const nihongo = &quot;日本語&quot; for _, runeValue := range nihongo { // for-range: iterate over the Unicode code points (runes) fmt.Printf(&quot;%#U &quot;, runeValue) } fmt.Println() // U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39; for _, cp := range []rune(nihongo) { // convert a string to a slice of runes fmt.Printf(&quot;%#U &quot;, cp) } fmt.Println() // U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39; for i := 0; i &lt; len(nihongo); i++ { // for-loop: iterate over the UTF-8 encoded units or bytes fmt.Printf(&quot;%x &quot;, nihongo[i]) } fmt.Println() // e6 97 a5 e6 9c ac e8 aa 9e for i := 0; i &lt; len(nihongo); i++ { fmt.Printf(&quot;%q &quot;, nihongo[i]) } fmt.Println() // &#39;æ&#39; &#39;\u0097&#39; &#39;¥&#39; &#39;æ&#39; &#39;\u009c&#39; &#39;¬&#39; &#39;è&#39; &#39;ª&#39; &#39;\u009e&#39; for i := 0; i &lt; len(nihongo); i++ { fmt.Printf(&quot;%+q &quot;, nihongo[i]) } fmt.Println() // &#39;\u00e6&#39; &#39;\u0097&#39; &#39;\u00a5&#39; &#39;\u00e6&#39; &#39;\u009c&#39; &#39;\u00ac&#39; &#39;\u00e8&#39; &#39;\u00aa&#39; &#39;\u009e&#39; 6.4. Pointers // A pointer holds the memory address of a value. // Unlike C, Go has no pointer arithmetic. // The type `*T` is a pointer to a `T` value. Its zero value is `nil`. var p *int i := 42 // The `&amp;` operator generates a pointer to its operand. p = &amp;i // The `*` operator (&quot;dereferencing&quot; or &quot;indirecting&quot;) denotes the pointer&#39;s underlying value. *p = 21 6.5. Structs // A struct is a collection of fields. type Vertex struct { X, Y int } var ( // A struct literal denotes a newly allocated struct value by listing the values of its fields. v1 = Vertex{1, 2} // has type Vertex // You can list just a subset of fields by using the Name: syntax. // (And the order of named fields is irrelevant.) v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 // The special prefix &amp; returns a pointer to the struct value p = &amp;Vertex{1, 2} // has type *Vertex ) func main() { // Struct fields are accessed using a dot. p.X = 1e9 fmt.Println(v1, p, v2, v3) } 6.6. Arrays The type [n]T is an array of n values of type T. Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct, so arrays cannot be resized. var a [2]string a[0] = &quot;Hello&quot; a[1] = &quot;World&quot; // an array literal primes := [6]int{2, 3, 5, 7, 11, 13} 6.7. Slices A slice, on the other hand, is a dynamically-sized, flexible view into the elements of an array. The type []T is a slice with elements of type T. A slice is formed by specifying two indices, a low and high bound, separated by a colon: // This selects a half-open range which includes the first element, but excludes the last one. a[low : high] The following expression creates a slice which includes elements 1 through 3 of a: a[1:4] Slices are like references to arrays A slice does not store any data, it just describes a section of an underlying array. A slice hold references to an underlying array, and if you assign one slice to another, both refer to the same array. Changing the elements of a slice modifies the corresponding elements of its underlying array. Other slices that share the same underlying array will see those changes. Slice literals A slice literal is like an array literal without the length. []bool{true, true, false} Slice defaults When slicing, you may omit the high or low bounds to use their defaults instead. The default is zero for the low bound and the length of the slice for the high bound. // For the array var a [10]int // these slice expressions are equivalent: a[0:10] a[:10] a[0:] a[:] Slice length and capacity A slice has both a length and a capacity. The length of a slice is the number of elements it contains. The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice. The length and capacity of a slice s can be obtained using the expressions len(s) and cap(s). You can extend a slice&#8217;s length by re-slicing it, provided it has sufficient capacity. Nil slices The zero value of a slice is nil. A nil slice has a length and capacity of 0 and has no underlying array. Appending to a slice It is common to append new elements to a slice, and so Go provides a built-in append function. func append(s []T, vs ...T) []T The resulting value of append is a slice containing all the elements of the original slice plus the provided values. If the backing array of s is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array. var s []int // append works on nil slices. s = append(s, 0) // The slice grows as needed. s = append(s, 1) // We can add more than one element at a time. s = append(s, 2, 3, 4) 6.8. Maps Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value). The key can be of any type that is comparable for which the equality operator is defined. The language spec defines the Comparison operators precisely, in short, comparable types are boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types.[1] Notably absent from the list are slices, maps, and functions; these types cannot be compared using ==, and may not be used as map keys. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller. The zero value of a map is nil. A nil map has no keys, nor can keys be added. Map literals are like struct literals, but the keys are required. var m map[string]int // &lt;nil&gt; m = map[string]int{ &quot;hello&quot;: 100, &quot;world&quot;: 200, } The make function returns a map of the given type with an optional capacity hint as arguments, initialized and ready for use. // m := make(map[string]int, 100) m := make(map[string]int) // insert or update an element m[&quot;Answer&quot;] = 42 // delete an element: // The delete function doesn’t return anything, and will do nothing if the specified key doesn’t exist. delete(m, &quot;Answer&quot;) // retrieve an element // If the requested key doesn’t exist, we get the value type’s zero value. v := m[&quot;Answer&quot;] // test that a key is present with a two-value assignment v, ok := m[&quot;Answer&quot;] 6.9. Functions A function can return any number of results. func (file *File) Write(b []byte) (n int, err error) The return or result &quot;parameters&quot; of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values. Functions are values too. They can be passed around just like other values. Function values may be used as function arguments and return values. Go functions may be closures, that is a function value that references (i.e. bounds to) variables from outside its body. func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func wrapper(f func(int) int, i int) int { return f(i) } func main() { pos, neg := adder(), adder() for i := 1; i &lt;= 3; i++ { fmt.Printf(&quot;%+d, %+2d\t&quot;, wrapper(pos, i), neg(-i)) } } // Output: // +1, -1 +3, -3 +6, -6 A function literal represents an anonymous function and cannot declare type parameters, and it can be assigned to a variable or invoked directly. Function literals are closures: they may refer to variables defined in a surrounding function, which are then shared between the surrounding function and the function literal, and they survive as long as they are accessible. func main() { var sum int var add = func() { sum += 1 } add() fmt.Printf(&quot;%d\n&quot;, sum) } // Output: // 1 6.10. Methods A method is a function with a special receiver argument, defined on any named type (except a pointer or an interface) in the same package. type MyInt int func (mi *MyInt) String() string { return fmt.Sprintf(&quot;Hi %d!&quot;, *mi) } func (mi *MyInt) Add(delta int) { *mi = *mi + MyInt(delta) } func main() { var mi MyInt = 1_024 mi.Add(1_024) fmt.Println(&amp;mi) } // Output: // Hi 2048! Choosing a value or pointer receiver There are two reasons to use a pointer receiver. The first is so that the method can modify the value that its receiver points to. The second is to avoid copying the value on each method call, that can be more efficient if the receiver is a large struct, for example. In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers. Value methods can be called on both values and pointers (automatically using * on pointers), while pointer methods can only be called on pointers (automatically using &amp; on values). Nil is a valid receiver value Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices. When you define a type whose methods allow nil as a receiver value, it&#8217;s worth pointing this out explicitly in its documentation comment. package bytes // import &quot;bytes&quot; type Buffer struct { // Has unexported fields. } A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use. 6.11. Interfaces An interface type defines a type set, that is the set of all concrete types that implement that interface. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil. An interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type. Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. Interfaces are implemented implicitly A type implements an interface by implementing its methods. There is no explicit declaration of intent, no &quot;implements&quot; keyword. Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement. Interface values Under the hood, interface values can be thought of as a tuple of a value and a concrete type: An interface value holds a value of a specific underlying concrete type. (value, type) Calling a method on an interface value executes the method of the same name on its underlying type. Interface values with nil underlying values If the concrete value inside the interface itself is nil, the method will be called with a nil receiver. In some languages this would trigger a null pointer exception, but in Go it is common to write methods that gracefully handle being called with a nil receiver. Note that an interface value that holds a nil concrete value is itself non-nil. type I interface { M() } type T struct{} func (t *T) M() { if t == nil { fmt.Println(&quot;&lt;nil receiver&gt;&quot;) return } } func main() { var i I // `i` is nil // i.M() // runtime error: invalid memory address or nil pointer dereference var t *T i = t // `i` is not nil, but the concrete type `t` is nil i.M() fmt.Printf(&quot;%v, %T\n&quot;, i, i) i = &amp;T{} // the concrete type `t` is not nil i.M() fmt.Printf(&quot;%v, %T\n&quot;, i, i) } // Output: // &lt;nil receiver&gt; // &lt;nil&gt;, *main.T // &amp;{}, *main.T Nil interface values A nil interface value holds neither value nor concrete type. Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call. var i I fmt.Printf(&quot;(%v, %T)\n&quot;, i, i) i.M() // (&lt;nil&gt;, &lt;nil&gt;) // panic: runtime error: invalid memory address or nil pointer dereference The empty interface The interface type that specifies zero methods is known as the empty interface: interface{} An empty interface may hold values of any type. (Every type implements at least zero methods.) Empty interfaces are used by code that handles values of unknown type. For convenience, the predeclared type any is an alias for the empty interface. $ go doc builtin.any package builtin // import &quot;builtin&quot; type any = interface{} any is an alias for interface{} and is equivalent to interface{} in all ways. Basic interfaces Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces. // A simple File interface. interface { Read([]byte) (int, error) Write([]byte) (int, error) Close() error } Embedded interfaces In a slightly more general form an interface T may use a (possibly qualified) interface type name E as an interface element, which is called embedding interface E in T. The type set of T is the intersection of the type sets defined by T&#8217;s explicitly declared methods and the type sets of T’s embedded interfaces. In other words, the type set of T is the set of all types that implement all the explicitly declared methods of T and also all the methods of E. type Reader interface { Read(p []byte) (n int, err error) Close() error } type Writer interface { Write(p []byte) (n int, err error) Close() error } // ReadWriter&#39;s methods are Read, Write, and Close. type ReadWriter interface { Reader // includes methods of Reader in ReadWriter&#39;s method set Writer // includes methods of Writer in ReadWriter&#39;s method set } When embedding interfaces, methods with the same names must have identical signatures. type ReadCloser interface { Reader // includes methods of Reader in ReadCloser&#39;s method set Close() // illegal: signatures of Reader.Close and Close are different } General interfaces Azure AI | ChatGPT 4 In Go, general interfaces are used to define type constraints for type parameters in generic functions and data structures. [GPT 4] // Comparable is an interface that defines a type constraint using // a union of types (int, float64, and string). This means that a // type parameter satisfying the Comparable constraint must be one // of these types. type Comparable interface { int | float64 | string } // The Max function is defined as a generic function using the type // parameter T. The type parameter is specified within square brackets // ([T Comparable]). It means that the function can work with any type // T that satisfies the Comparable constraint. func Max[T Comparable](a, b T) T { if a &gt; b { return a } return b } // The Max function is called with different types of arguments (int, // float64, and string). The type parameter T is replaced with the actual // type of the arguments at each call, allowing the function to work with // different types while maintaining type safety. func main() { fmt.Println(Max(3, 4)) // int fmt.Println(Max(2.5, 3.7)) // float64 fmt.Println(Max(&quot;apple&quot;, &quot;cat&quot;)) // string } In summary, while you can&#8217;t assign a concrete type to a general interface, general interfaces are used to specify what types can be used with a generic function or data structure. These type constraints allow you to create flexible and reusable generic code while maintaining type safety. In their most general form, an interface element may also be an arbitrary type term T, or a term of the form ~T specifying the underlying type T, or a union of terms t1|t2| . . . |tn. By construction, an interface&#8217;s type set never contains an interface type. // An interface representing only the type int. interface { int } // An interface representing all types with underlying type int. interface { ~int } // An interface representing all types with underlying type int that implement the String method. interface { ~int String() string } // An interface representing an empty type set: there is no type that is both an int and a string. // // This code defines an interface that no concrete type satisfies because there is no type that is // both an int and a string. It is not the same as an empty interface (interface{}), which any type // can satisfy. This code snippet is used to illustrate the concept of an unsatisfiable interface // in the Go language specification. (Azure AI | ChatGPT 4) // // While this interface can be compiled, it cannot be used in practical terms because no type can // satisfy the constraints. It&#39;s a theoretical construct to show the capabilities and limitations of // the type constraint system in Go. (Azure AI | ChatGPT 4) interface { int string } In a term of the form ~T, the underlying type of T must be itself, and T cannot be an interface. Azure AI | ChatGPT 4 The tilde symbol ~ defines a type set constraint that includes the underlying type of T as well as any other types whose underlying type is the same as T. In this context, &quot;underlying type&quot; refers to the actual type without any type aliases or defined types based on it. &quot;The underlying type of T must be itself&quot;: This means that when defining a type set constraint using ~T, the type T must not be a type alias or a defined type based on another type. Instead, T must be a &quot;base&quot; type, such as int, float64, or a struct type. &quot;T cannot be an interface&quot;: This condition states that the type T in a type set constraint using ~T should not be an interface type. This is because interface types don&#8217;t have a specific underlying type that can be used in the type set definition. type MyInt int type MyI interface { ~[]byte // the underlying type of []byte is itself ~MyInt // illegal: the underlying type of MyInt is not MyInt ~error // illegal: error is an interface } Union elements denote unions of type sets: // The Float interface represents all floating-point types // (including any named types whose underlying types are // either float32 or float64). type Float interface { ~float32 | ~float64 } Generality If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method. In such cases, the constructor should return an interface value rather than the implementing type. // unexported type type myString struct { s string } func (ms myString) String() string { return ms.s } // constructor function (exported) that returns the interface func NewString(s string) fmt.Stringer { return myString{s: s} } Interface conversions and type assertions A type assertion provides access to an interface value&#8217;s underlying concrete value. t := i.(T) This statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t. If i does not hold a T, the statement will trigger a panic. To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded. t, ok := i.(T) If i holds a T, then t will be the underlying value and ok will be true. If not, ok will be false and t will be the zero value of type T, and no panic occurs. Type switches The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type. switch v := i.(type) { case T: // here v has type T case S: // here v has type S default: // no match; here v has the same type as i } 6.12. Embedding: interfaces and structs Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to &#8220;borrow&#8221; pieces of an implementation by embedding types within a struct or interface. package io // import &quot;io&quot; type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // ReadWriter is the interface that combines the Reader and Writer interfaces. type ReadWriter interface { Reader Writer } package bufio // import &quot;bufio&quot; type Reader struct { // Has unexported fields. } func (b *Reader) Read(p []byte) (n int, err error) type Writer struct { // Has unexported fields. } func (b *Writer) Write(p []byte) (nn int, err error) // ReadWriter stores pointers to a Reader and a Writer. // It implements io.ReadWriter. type ReadWriter struct { *Reader *Writer } For the embedded type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. For example, when the Read method of a bufio.ReadWriter is invoked, the receiver is the Reader field of the ReadWriter, not the ReadWriter itself. type Reader struct { } func (r *Reader) Read() { fmt.Println(&quot;Read&quot;) } type Writer struct { } func (r *Writer) Write() { fmt.Println(&quot;Write&quot;) } type ReadWriter struct { *Reader *Writer } func main() { rw := ReadWriter{} rw.Read() // same as rw.Reader.Read() // Output: // Read } Embedding types introduces the problem of name conflicts but the rules to resolve them are simple. First, a field or method X hides any other item X in a more deeply nested part of the type. Second, if the same name appears at the same nesting level, it is usually an error. However, if the duplicate name is never mentioned in the program outside the type definition, it is OK. type Inner1 struct { Name string } type Inner2 struct { Name string } type Outer struct { Inner1 Inner2 } func main() { o := Outer{ Inner1: Inner1{Name: &quot;Inner 1 Name&quot;}, Inner2: Inner2{Name: &quot;Inner 2 Name&quot;}, } fmt.Println(o.Inner1.Name) fmt.Println(o.Inner2.Name) // Compile error: ambiguous selector o.Name // fmt.Println(o.Name) } // Output // Inner 1 Name // Inner 2 Name Embedding: Provides an &quot;is-a&quot; relationship where the outer struct or interface directly inherits the fields and methods of the embedded struct or interface. Allows for easier and more direct access to the fields and methods of the embedded struct or interface, as they become part of the outer struct or interface. Enhances code reuse and polymorphism by making the fields and methods of the embedded struct or interface available directly in the outer struct or interface. Not Embedding (Composing): Provides a &quot;has-a&quot; relationship where the outer struct or interface holds instances of other structs or interfaces as separate fields. Requires explicitly accessing the fields and methods of the inner structs or interfaces through the composed fields. Keeps a clear separation between the fields and methods of the outer struct or interface and the inner structs or interfaces it holds. type Reader struct { } type Writer struct { } type ReadWriter struct { reader Reader writer Writer } func (r *Reader) Read() { fmt.Println(&quot;Read.&quot;) } func (w *Writer) Write() { fmt.Println(&quot;Write.&quot;) } func main() { rw := &amp;ReadWriter{} rw.reader.Read() // rw.Read undefined (type *ReadWriter has no field or method Read) rw.Read() } 6.13. Channels Channels are a typed conduit through which you can send and receive values with the channel operator, &lt;-. ch &lt;- v // Send v to channel ch. v := &lt;-ch // Receive from ch, and assign value to v. // (The data flows in the direction of the arrow.) Like maps and slices, channels must be created before use: // By default, sends and receives block until the other side is ready. // This allows goroutines to synchronize without explicit locks or condition variables. blockChan := make(chan int) // Sends to a buffered channel block only when the buffer is full. // Receives block when the buffer is empty. bufChan := make(chan int, 100) A sender can close a channel to indicate that no more values will be sent. After calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel&#8217;s type without blocking. Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed. // ok is false if there are no more values to receive and the channel is closed. v, ok := &lt;-ch The loop for v := range c receives values from the channel repeatedly until it is closed. Attempting to close an already-closed channel causes a panic, as does closing a nil channel. Sending to a closed channel causes a run-time panic. Only the sender should close a channel, never the receiver. Channels aren&#8217;t like files; you don&#8217;t usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop. A channel may be constrained only to send or only to receive by assignment or explicit conversion. func main() { var ( _ = make(chan int) // bidirectional _ = make(&lt;-chan int) // receive-only _ = make(chan&lt;- int) // send-only ) ch := make(chan int) // send-only go func(ch chan&lt;- int) { for i := 0; i &lt; 3; i++ { ch &lt;- i } close(ch) }(ch) // receive-only go func(ch &lt;-chan int) { for v := range ch { fmt.Println(v) } }(ch) time.Sleep(time.Millisecond) // Output: // 0 // 1 // 2 } func main() { ch1 := make(chan int) ch2 := make(chan int, 2) // buffering channel quit := make(chan int) go func() { for i := 1; ; i++ { ch1 &lt;- 2 * i time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) } }() go func(ch chan&lt;- int) { for i := 1; ; i++ { ch &lt;- 2*i + 1 time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) } }(ch2) go func() { &lt;-time.After(time.Duration(5e3) * time.Millisecond) quit &lt;- 0 }() // The select statement lets a goroutine wait on multiple communication operations. // A select blocks until one of its cases can run, then it executes that case. // It chooses one at random if multiple are ready. ch3 := make(chan int) timeout := time.After(500 * time.Millisecond) go func() { defer close(ch3) for { // multiplexing: ch1 + ch2 =&gt; ch3 select { case ch3 &lt;- &lt;-ch1: case ch3 &lt;- &lt;-ch2: case &lt;-timeout: fmt.Println(&quot;You&#39;re too slow.&quot;) return case &lt;-quit: fmt.Println(&quot;Quit.&quot;) return } } }() for v := range ch3 { fmt.Println(v) } } 6.14. Type conversions The expression T(v) converts the value v to the type T. // Some numeric conversions: var i int = 42 var f float64 = float64(i) var u uint = uint(f) // Or, put more simply: i := 42 f := float64(i) u := uint(f) 6.15. Generics Go functions can be written to work on multiple types using type parameters. The type parameters of a function appear between brackets, before the function&#8217;s arguments. func Index[T comparable](s []T, x T) int This declaration means that s is a slice of any type T that fulfills the built-in constraint comparable. x is also a value of the same type. comparable is a useful constraint that makes it possible to use the == and != operators on values of the type. package builtin // import &quot;builtin&quot; type comparable interface{ comparable } comparable is an interface that is implemented by all comparable types (booleans, numbers, strings, pointers, channels, arrays of comparable types, structs whose fields are all comparable types). The comparable interface may only be used as a type parameter constraint, not as the type of a variable. In addition to generic functions, Go also supports generic types. A type can be parameterized with a type parameter, which could be useful for implementing generic data structures. type ComparableOrdered interface { comparable constraints.Ordered // &quot;golang.org/x/exp/constraints&quot; } // List represents a singly-linked list that holds values of `ComparableOrdered` type. type List[T ComparableOrdered] struct { next *List[T] val T } func (head *List[T]) append(vals ...T) { var a = func(val T) { tail := head for tail.next != nil { tail = tail.next } tail.next = &amp;List[T]{val: val} } for _, val := range vals { a(val) } } func (head *List[T]) max() T { max := head.val node := head.next for node != nil { if node.val &gt; max { max = node.val } node = node.next } return max } func (head *List[T]) String() string { var b strings.Builder node := head for node != nil { fmt.Fprintf(&amp;b, &quot;%v&quot;, node.val) node = node.next if node != nil { fmt.Fprint(&amp;b, &quot; -&gt; &quot;) } } return b.String() } func main() { list := &amp;List[int]{val: 20} list.append(10, 30, 60) list.append(40) fmt.Printf(&quot;list: %v\n&quot;, list) fmt.Printf(&quot;max: %v&quot;, list.max()) // Output: // list: 20 -&gt; 60 -&gt; 30 -&gt; 10 -&gt; 40 // max: 60 } Type constraint and type parameter A type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter. If the constraint is an interface literal of the form interface{E} where E is an embedded type element (not a method), in a type parameter list the enclosing interface{ … } may be omitted for convenience: [T []P] // = [T interface{[]P}] [T ~int] // = [T interface{~int}] [T int|string] // = [T interface{int|string}] type Constraint ~int // illegal: ~int is not in a type parameter list A type argument T satisfies a type constraint C if T is an element of the type set defined by C; i.e., if T implements C. As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument. More precisely: A type T satisfies a constraint C if T implements C; or C can be written in the form interface{ comparable; E }, where E is a basic interface and T is comparable and implements E. type argument type constraint // constraint satisfaction int interface{ ~int } // satisfied: int implements interface{ ~int } string comparable // satisfied: string implements comparable (string is strictly comparable) []byte comparable // not satisfied: slices are not comparable any interface{ comparable; int } // not satisfied: any does not implement interface{ int } any comparable // satisfied: any is comparable and implements the basic interface any struct{f any} comparable // satisfied: struct{f any} is comparable and implements the basic interface any any interface{ comparable; m() } // not satisfied: any does not implement the basic interface interface{ m() } interface{ m() } interface{ comparable; m() } // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() } Because of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable). A type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses. TypeParameters = &quot;[&quot; TypeParamList [ &quot;,&quot; ] &quot;]&quot; . TypeParamList = TypeParamDecl { &quot;,&quot; TypeParamDecl } . TypeParamDecl = IdentifierList TypeConstraint . All non-blank names in the type parameter list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type. [P any] [S interface{ ~[]byte|string }] [S ~[]E, E any] [P Constraint[int]] [_ any] As the ordinary function parameter has a parameter type, the type parameter has a (meta-)type which is called its type constraint. 7. Initialization 7.1. Constants Constants are declared like variables, but with the const keyword. Constants cannot be declared using the := syntax. Constants are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. In Go, enumerated constants are created using the iota enumerator. type Weekday int const ( Sunday Weekday = iota + 1 // iota: 0 ~ Sunday : 1 _ // iota: 1 ~ iota increased // comments // iota: 1 ~ skip: comment // iota: 1 ~ skip: empty line Monday // iota: 2 ~ Monday : 3 Tuesday // iota: 3 ~ Monday : 4 Wednesday // iota: 4 ~ Monday : 5 Thursday // iota: 5 ~ Monday : 6 Friday // iota: 6 ~ Monday : 7 Saturday // iota: 7 ~ Monday : 8 ) iota (noun) /aɪˈəʊtə/ /aɪˈəʊtə/ 1. [singular] (usually used in negative sentences) an extremely small amount There is not one iota of truth (= no truth at all) in the story. I don&#39;t think that would help one iota. 2. the 9th letter of the Greek alphabet (I, ι) ref: https://www.oxfordlearnersdictionaries.com/us/definition/english/iota 7.2. Allocation: new and make Go has two allocation primitives, the built-in functions new and make. The new built-in function allocates memory of a type, return a pointer to a newly allocated zero value of that type. package builtin // import &quot;builtin&quot; func new(Type) *Type The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. The memory returned by new is zeroed is helpful to arrange when designing a data structures that the zero value of each type can be used without further initialization. var ptr *bytes.Buffer // nil // panic: runtime error: invalid memory address or nil pointer dereference // ptr.WriteString(&quot;Hello, world!&quot;) ptr = new(bytes.Buffer) // points to a zerod bytes.Buffer instance ptr.WriteString(&quot;Hello, world!&quot;) The make built-in function allocates and initializes an object of type slice, map, or chan (only). package builtin // import &quot;builtin&quot; func make(t Type, size ...IntegerType) Type The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make&#39;s return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type: Slice: The size specifies the length. The capacity of the slice is equal to its length. A second integer argument may be provided to specify a different capacity; it must be no smaller than the length. For example, make([]int, 0, 10) allocates an underlying array of size 10 and returns a slice of length 0 and capacity 10 that is backed by this underlying array. Map: An empty map is allocated with enough space to hold the specified number of elements. The size may be omitted, in which case a small starting size is allocated. Channel: The channel&#39;s buffer is initialized with the specified buffer capacity. If zero, or the size is omitted, the channel is unbuffered. It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. var p *[]int = new([]int) // allocates slice structure; *p == nil; rarely useful var v []int = make([]int, 100) // the slice v now refers to a new array of 100 ints // Unnecessarily complex: var p *[]int = new([]int) *p = make([]int, 100, 100) // Idiomatic: v := make([]int, 100) 7.3. The init function Each source file can define its own niladic init function to set up whatever state is required. Actually each file can have multiple init functions, which called in the order they appear in the source. The init function is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. // init.go var ( hello = &quot;Hello&quot; world = &quot;世界&quot; ) func init() { fmt.Print(hello) } func init() { fmt.Print(&quot;, &quot;) } func init() { fmt.Printf(&quot;%s\n&quot;, world) } func main() { } $ go run init.go Hello, 世界 7.4. Zero values Variables declared without an explicit initial value are given their zero value: 0 for numeric types, false for the boolean type, &quot;&quot; (the empty string) for strings, nil for the pointers, slices, maps, functions, interfaces, channels, 8. Concurrency 8.1. Race Conditions A race condition is a situation in which the program does not give the correct result for some interleaving of the operations of multiple goroutines. A data race, that is, a particular kind of race condition, occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race. The first way is not to write the variable. The second way (channels: share memory by communication) to avoid a data race is to avoid accessing the variable from multiple goroutines. The third way (mutual exclusion: sync.Mutex, sync.RWMutex) to avoid a data race is to allow many goroutines to access the variable, but only one at a time. Synchronization is about more than just the order of execution of multiple goroutines; synchronization also affets memory. Azure Open AI | ChatGPT4 Other race conditions include deadlocks, livelocks, and starvation. Deadlocks occur when two or more processes are waiting for each other to release resources that they need to continue executing. Livelocks occur when two or more processes are constantly changing their state in response to the actions of the other process, without making any progress towards their goal. A livelock is a situation where two or more processes or threads are actively trying to resolve a conflict but end up repeatedly yielding to each other, resulting in no progress being made. Livelocks are similar to deadlocks in that they both involve processes being stuck, but livelocks involve active, ongoing attempts to resolve the problem, whereas deadlocks involve processes waiting for resources. Here&#8217;s an example of a livelock: Imagine two people, Alice and Bob, walking in a narrow corridor towards each other. When they meet in the middle, they both step aside to let the other person pass. However, they both step in the same direction. Realizing this, they both step back to their original positions and try again, but they continue to step in the same direction each time. This results in a livelock, as they are both actively trying to resolve the situation but end up yielding to each other without making progress. Starvation occurs when a process is prevented from accessing the resources it needs to execute, either because other processes are monopolizing those resources or because the system is not allocating resources fairly. 8.2. Race Detector The race detector (add the -race flag to the go build, go run, or go test command) studies the steam of events, looking for cases in which one goroutine reads or writes a shared variables that was most recently written by a different goroutine without an intervening synchronization operation. The race detector reports all data races that were actually executed. However, it can only detect race conditions that occur during a run; it cannot prove that none will ever occur. 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func main() { var wg sync.WaitGroup var x, y int wg.Add(1) go func() { defer wg.Done() x = 1 fmt.Printf(&quot;y = %d\n&quot;, y) }() wg.Add(1) go func() { defer wg.Done() y = 1 fmt.Printf(&quot;x = %d\n&quot;, x) }() wg.Wait() } $ go run -race race.go x = 0 ================== WARNING: DATA RACE Write at 0x00c0000160c8 by goroutine 7: main.main.func1() /home/x/learn/go/race.go:15 +0xaa Previous read at 0x00c0000160c8 by goroutine 8: main.main.func2() /home/x/learn/go/race.go:23 +0xcf ... ================== ================== WARNING: DATA RACE Read at 0x00c0000160d8 by goroutine 7: main.main.func1() /home/x/learn/go/race.go:16 +0xcf Previous write at 0x00c0000160d8 by goroutine 8: main.main.func2() /home/x/learn/go/race.go:22 +0xaa ================== y = 1 Found 2 data race(s) exit status 66 Azure Open AI | ChatGPT4 When you run a Go program with the -race flag, the Go race detector instruments the code to monitor concurrent access to shared variables. If it detects a race condition, it generates a report with detailed information about the issue. The output of the -race flag typically consists of the following parts: A summary of the data race, indicating that it is a &quot;DATA RACE.&quot; A description of the current operation (read or write) that caused the race, including the memory address, the source code file, and the line number. The current goroutine involved in the race, including its number and the stack trace. A description of the previous conflicting operation (read or write) on the same memory address, including the source code file and the line number. The previous goroutine involved in the race, including its number and the stack trace. For example, consider the following output: WARNING: DATA RACE Write at 0x00c0000160c8 by goroutine 7: main.main.func1() /path/to/your/code/main.go:16 +0x6a Previous read at 0x00c0000160c8 by goroutine 8: main.main.func2() /path/to/your/code/main.go:22 +0x3e This output can be interpreted as follows: The race detector has identified a data race. A write operation occurred at memory address 0x00c0000160c8 by goroutine 7. The operation happened in the function main.main.func1() in the source code file main.go at line 16. The current goroutine 7 is shown along with the stack trace. A previous read operation occurred at the same memory address 0x00c0000160c8 by goroutine 8. The operation happened in the function main.main.func2() in the source code file main.go at line 22. The previous goroutine 8 is shown along with the stack trace. Using this information, you can identify the source code lines and goroutines involved in the race condition and take appropriate action to fix the issue, such as adding proper synchronization mechanisms like mutexes or channels. 8.3. Happen before Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification. Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another. For example, if one goroutine executes a = 1; b = 2;, another might observe the updated value of b before the updated value of a. To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event e1 happens before event e2, then we say that e2 happens after e1. Also, if e1 does not happen before e2 and does not happen after e2, then we say that e1 and e2 happen concurrently. Within a single goroutine, the happens-before order is the order expressed by the program. Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access. To serialize access, protect the data with channel operations or other synchronization primitives such as those in the sync and sync/atomic packages. 8.4. Share by communicating Do not communicate by sharing memory; instead, share memory by communicating. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there&#8217;s still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go&#8217;s approach to concurrency originates in Hoare&#8217;s Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes. 8.5. Goroutines A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. [20] And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required. Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management. Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. The evaluation of f, x, y, and z of go f(x, y, z) happens in the current goroutine and the execution of f happens in the new goroutine. func main() { // All function values created by this loop “capture” // and share the same variable—an addressable storage location, // not its value at that particular moment. for i := 0; i &lt; 5; i++ { go func() { fmt.Print(i, &quot; &quot;) }() } time.Sleep(time.Millisecond) fmt.Println() for i := 0; i &lt; 5; i++ { i := i go func() { fmt.Print(i, &quot; &quot;) }() } time.Sleep(time.Millisecond) // Output: // 5 5 5 5 5 // 4 0 1 2 3 // ignore the order } Best number of goroutines in a process There is no one-size-fits-all answer to the best number of goroutines in a process, as it depends on various factors such as the nature of your application, the resources available on your system, and the level of parallelism your program can achieve. However, here are some general guidelines to help you determine the optimal number of goroutines: [Azure Open AI | ChatGPT4] I/O-bound tasks: If your application performs tasks that are primarily I/O-bound, such as reading from or writing to disk, network, or other external resources, you can benefit from a higher number of goroutines. Since I/O-bound tasks often involve waiting for external resources, having more goroutines can help keep your application busy and utilize available CPU resources effectively. In this case, the optimal number of goroutines might be several times the number of available CPU cores. CPU-bound tasks: If your application performs tasks that are primarily CPU-bound, such as complex calculations or data processing, you may not benefit from a higher number of goroutines than the number of available CPU cores. Having more goroutines than CPU cores can lead to frequent context switching, which can hurt performance. In this case, the optimal number of goroutines might be close to the number of available CPU cores. Workload characteristics: The best number of goroutines also depends on the specific characteristics of your application&#8217;s workload. For example, if your application has a mix of I/O-bound and CPU-bound tasks, or if it has varying resource requirements over time, you might need to experiment with different numbers of goroutines to find the optimal balance. Resource availability: The optimal number of goroutines also depends on the resources available on your system, such as CPU, memory, and I/O capacity. If your system is constrained in terms of resources, you may need to limit the number of goroutines to avoid exhausting system resources and causing performance issues. When there are many Go processes running on the same operating system, it is essential to consider the overall resource usage of the entire system. Running multiple Go processes with a large number of goroutines can lead to contention for system resources, such as CPU, memory, and I/O capacity. In this case, it might be necessary to limit the number of goroutines per process or to distribute the processes across multiple machines to ensure optimal performance. Ultimately, the best way to determine the optimal number of goroutines for your application is through benchmarking, monitoring, and profiling. By measuring the performance of your application under different conditions and configurations, you can make informed decisions about the appropriate number of goroutines and resource allocation. 8.6. Channels Like maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel. ci := make(chan int) // unbuffered channel of integers cj := make(chan int, 0) // unbuffered channel of integers cs := make(chan *os.File, 100) // buffered channel of pointers to Files Receivers always block until there is data to receive. The sender blocks only until the value has been copied to the buffer. A buffered channel can be used like a semaphore, for instance to limit throughput. ch := make(chan int, 1) // create a buffered channel with capacity 1 ch &lt;- 1 // send 1 to the channel (non-blocking because of buffer) fmt.Println(&lt;-ch) // receive 1 from the channel ch = make(chan int) // create an unbuffered (blocking) channel stop := make(chan int) // create a channel to synchronize the goroutine&#39;s completion go func() { ch &lt;- 2 // send 2 to the channel (blocks until received) time.Sleep(time.Millisecond) // simulate some work fmt.Println(3) // print 3 after the send stop &lt;- 0 // signal that the goroutine is finished }() fmt.Println(&lt;-ch) // receive 2 from the channel (unblocks the goroutine) &lt;-stop // wait for the goroutine to signal completion // Output: // 1 // 2 // 3 The assembly line metaphor (pipeline) is useful one for channels and goroutines. ref http://golang.org/s/prime-sieve // A concurrent prime sieve // Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;. func Generate(ch chan&lt;- int) { for i := 2; ; i++ { ch &lt;- i // Send &#39;i&#39; to channel &#39;ch&#39;. } } // Copy the values from channel &#39;in&#39; to channel &#39;out&#39;, // removing those divisible by &#39;prime&#39;. func Filter(in &lt;-chan int, out chan&lt;- int, prime int) { for { i := &lt;-in // Receive value from &#39;in&#39;. if i%prime != 0 { out &lt;- i // Send &#39;i&#39; to &#39;out&#39;. } } } // The prime sieve: Daisy-chain Filter processes. func main() { ch := make(chan int) // Create a new channel. go Generate(ch) // Launch Generate goroutine. for i := 0; i &lt; 10; i++ { prime := &lt;-ch print(prime, &quot;\n&quot;) ch1 := make(chan int) go Filter(ch, ch1, prime) ch = ch1 } } 8.7. Parallelization Be sure not to confuse the ideas of concurrency&#8212;&#8203;structuring a program as independently executing components&#8212;&#8203;and parallelism&#8212;&#8203;executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go&#8217;s model. package runtime // import &quot;runtime&quot; func NumCPU() int NumCPU returns the number of logical CPUs usable by the current process. The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected. func GOMAXPROCS(n int) int GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves. 8.8. Synchronization In Go, synchronization is essential for ensuring safe concurrent execution of code and coordinating the activities of multiple goroutines. Go provides various synchronization primitives and constructs to facilitate communication between goroutines, protect access to shared resources, and manage concurrent execution. Here&#8217;s a comprehensive introduction to synchronization in Go: [Azure Open AI | ChatGPT4] 8.8.1. Channels Channels are the primary synchronization mechanism in Go and are used for communication between goroutines. They allow goroutines to send and receive values, which can be used for signaling or passing data. Channels provide a way to synchronize the execution of goroutines and ensure that data is safely shared without race conditions. // Creating a channel ch := make(chan int) // Sending a value to a channel ch &lt;- 42 // Receiving a value from a channel value := &lt;-ch Semaphores in Go? Go does not provide semaphores as a dedicated primitive like sync.Mutex . Instead, they can be implemented using buffered channels. Semaphores are used to control access to a limited number of resources or to limit the degree of concurrency for a group of goroutines. Here&#8217;s an example of how to implement a semaphore using a buffered channel in Go: const maxConcurrent = 3 func main() { var wg sync.WaitGroup // Create a buffered channel to act as a semaphore semaphore := make(chan struct{}, maxConcurrent) // Simulate 10 tasks that need to be executed concurrently for i := 1; i &lt;= 10; i++ { wg.Add(1) go func(taskID int) { defer wg.Done() // Acquire the semaphore semaphore &lt;- struct{}{} // Execute the task fmt.Printf(&quot;Task %d started\n&quot;, taskID) time.Sleep(1 * time.Second) fmt.Printf(&quot;Task %d completed\n&quot;, taskID) // Release the semaphore &lt;-semaphore }(i) } wg.Wait() } 8.8.2. sync.Mutex A Mutex (short for &quot;mutual exclusion&quot;, /ˈmjuːtɛks/) is a synchronization primitive used to protect access to shared resources and ensure that only one goroutine can access the resource at a time. Mutexes help prevent race conditions when multiple goroutines attempt to modify shared state concurrently. num := 0 var mu sync.Mutex var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() mu.Lock() defer mu.Unlock() for i := 0; i &lt; 100_000; i++ { num += 1 } }() go func() { defer wg.Done() mu.Lock() defer mu.Unlock() locked := mu.TryLock() if locked { defer mu.Unlock() fmt.Println(&quot;recursive lock!&quot;) } else { fmt.Println(&quot;not recursive lock!&quot;) } for i := 0; i &lt; 100_000; i++ { num += 1 } }() wg.Wait() fmt.Println(num) // 200000 // Output: // not recursive lock! // 200000 8.8.3. sync.RWMutex An RWMutex (short for &quot;read-write mutex&quot;) is similar to a Mutex but allows multiple readers to access a shared resource simultaneously, as long as no writer is accessing it. It provides two separate locks: a read lock and a write lock. Multiple goroutines can acquire read locks at the same time, but only one can acquire a write lock, and it must wait for all read locks to be released. type ConcurrentMap[TKey comparable, TValue any] struct { m map[TKey]TValue rwMu sync.RWMutex } func New[TKey comparable, TValue any]() *ConcurrentMap[TKey, TValue] { return &amp;ConcurrentMap[TKey, TValue]{m: make(map[TKey]TValue)} } func (q *ConcurrentMap[TKey, TValue]) Add(key TKey, value TValue) { q.rwMu.Lock() defer q.rwMu.Unlock() q.m[key] = value } func (q *ConcurrentMap[TKey, TValue]) Remove(key TKey) { q.rwMu.Lock() defer q.rwMu.Unlock() delete(q.m, key) } func (q *ConcurrentMap[TKey, TValue]) TryGet(key TKey) (item TValue, ok bool) { q.rwMu.RLock() defer q.rwMu.RUnlock() item, ok = q.m[key] return } 8.8.4. sync.WaitGroup A WaitGroup is a synchronization construct used to wait for a collection of goroutines to finish execution, that is often used when you start multiple goroutines to perform tasks concurrently and need to wait for all of them to complete before proceeding. var num int32 var wg sync.WaitGroup // define a WaitGroup wg.Add(2) // add delta, which may be negative, to the WaitGroup counter. go func() { defer wg.Done() // decrement the WaitGroup counter by one. for i := 0; i &lt; 10_000; i++ { if i%2 == 0 { atomic.AddInt32(&amp;num, 1) } } }() go func() { defer wg.Done() for i := 0; i &lt; 10_000; i++ { if i%2 == 1 { atomic.AddInt32(&amp;num, 1) } } }() wg.Wait() // block until the WaitGroup counter is zero. fmt.Println(num) // 10_000 8.8.5. sync.Cond A Cond (short for &quot;condition&quot;) is a synchronization primitive used to wait for or signal conditions. It is useful when one or more goroutines need to wait for a specific condition to be met before they can proceed. Conds are often used with a Mutex or RWMutex to protect access to the shared state being tested in the condition. type BlockingChannel[T any] struct { items []T c *sync.Cond mu *sync.Mutex // explicit mutex for clarity } func New[T any](capacity int) *BlockingChannel[T] { mu := &amp;sync.Mutex{} return &amp;BlockingChannel[T]{ items: make([]T, 0, capacity), c: sync.NewCond(mu), // create a new condition variable associated with the mutex mu: mu, // store the mutex } } func (bc *BlockingChannel[T]) Write(item T) { bc.c.L.Lock() // acquire the lock before accessing shared resources defer bc.c.L.Unlock() // ensure the lock is released when the function returns for len(bc.items) == cap(bc.items) { // wait if the channel is full bc.c.Wait() // release the lock and wait for a signal } bc.items = append(bc.items, item) // add the item to the channel bc.c.Signal() // Signal a waiting reader that an item is available. } func (bc *BlockingChannel[T]) Read() T { bc.c.L.Lock() defer bc.c.L.Unlock() for len(bc.items) == 0 { // wait if the channel is empty bc.c.Wait() // release the lock and wait for a signal } n := len(bc.items) item := bc.items[n-1] bc.items = bc.items[:n-1] bc.c.Broadcast() // Signal all waiting writers that space is available return item } 8.8.6. sync.Once A Once is a synchronization construct used to ensure that a function is only executed once, regardless of how many goroutines attempt to call it, that is useful for initializing shared resources, such as global variables or singletons, in a concurrent environment. // Defining a Once var once sync.Once // Executing a function only once, regardless of how many goroutines call it once.Do(func() { // initialize shared resource }) 8.8.7. sync.Map A Map is a concurrent, thread-safe map implementation provided by the sync package. It is designed for cases where the number of keys is large and their lifetimes are mostly unknown. Unlike the built-in map type, sync.Map provides safe concurrent access without requiring an additional synchronization mechanism like a Mutex. // Defining a sync.Map var m sync.Map // Storing a value in sync.Map m.Store(&quot;key&quot;, &quot;value&quot;) // Loading a value from sync.Map value, ok := m.Load(&quot;key&quot;) // Deleting a value from sync.Map m.Delete(&quot;key&quot;) // Iterating over sync.Map m.Range(func(key, value interface{}) bool { fmt.Printf(&quot;key: %v, value: %v\n&quot;, key, value) return true }) 8.8.8. sync/atomic package atomic // import &quot;sync/atomic&quot; Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don&#39;t communicate by sharing memory. BUG: On 386, the 64-bit functions use instructions unavailable before the Pentium MMX. On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. On ARM, 386, and 32-bit MIPS, it is the caller&#39;s responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically via the primitive atomic functions (types [Int64] and [Uint64] are automatically aligned). The first word in an allocated struct, array, or slice; in a global variable; or in a local variable (because on 32-bit architectures, the subject of 64-bit atomic operations will escape to the heap) can be relied upon to be 64-bit aligned. Share memory by communicating; don&#8217;t communicate by sharing memory. For most synchronization needs, Go&#8217;s channels and the sync package (e.g., sync.Mutex, sync.WaitGroup, sync.Cond) provide safer and easier-to-use abstractions. Channels provide a more structured and less error-prone way to synchronize concurrent operations. 9. Errors Library routines must often return some sort of error indication to the caller. Go&#8217;s multi-value return makes it a good style to easily return a detailed error description alongside the normal return value. The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error, typically created using fmt.Errorf or errors.New. When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. func main() { defer func() { if r := recover(); r != nil { fmt.Printf(&quot;recoverd: %v\n&quot;, r) err := r.(error) foo := errors.Unwrap(err) fmt.Printf(&quot;inner error: %v\n&quot;, foo) } }() fi, err := os.Open(&quot;hello.txt&quot;) if err != nil { if pe, ok := err.(*os.PathError); ok { fmt.Printf(&quot;path error: %v\n&quot;, pe) } else { fmt.Printf(&quot;unknown error: %v\n&quot;, pe) } } defer fi.Close() err = errors.New(&quot;bar&quot;) err = fmt.Errorf(&quot;foo: %w&quot;, err) // wrap an inner error panic(err) } // path error: open hello.txt: no such file or directory // recoverd: foo: bar // inner error: bar The panic built-in function stops normal execution of the current goroutine, and the recover built-in function allows a program to manage behavior of a panicking goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G&#8217;s execution and running any deferred functions, until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. func F() { err := errors.New(&quot;F: panic&quot;) panic(err) } func G() { defer func() { if r := recover(); r != nil { err := fmt.Errorf(&quot;G: %w&quot;, r) panic(err) } }() F() } func main() { defer func() { if r := recover(); r != nil { fmt.Println(r) } }() G() } // G: F: panic 10. Testing The go test subcommand is a test driver for Go packages that are organized according to certain conventions. In a package directory, files whose names end with _test.go are not part of the package ordinarily built by go build but are a part of it when built by go test. Within _test.go files, four kinds of functions are treated specially: tests, fuzzs, benchmarks, and examples. A test function, which is a function whose name begins with Test exercises some program logic for correct behavior; go test calls the test function and report the result, which is either PASS or FAIL. With fuzzing, random data is run against your test in an attempt to find vulnerabilities or crash-causing inputs. A benchmark function has a name beginning with Benchmark and measures the performance of some operation; go test reports the mean execution time of the operation. And an example function, whose name starts with Example, provides machine-checked documentation. func Foo(s string) string { return s } func TestFoo(t *testing.T) { var tests = []struct { s string want string }{ {&quot;Hello&quot;, &quot;Hello&quot;}, {&quot;世界!&quot;, &quot;世界!&quot;}, } for _, test := range tests { if got := Foo(test.s); got != test.want { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, test.s, got, test.want) } } } // Fuzz test func FuzzFoo(f *testing.F) { // Seed corpus addition f.Add(&quot;hello&quot;) // Fuzz target f.Fuzz(func(t *testing.T, s string) { // s string // Fuzzing arguments if got := Foo(s); got != s { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, s, got, s) } }) } func BenchmarkFoo(b *testing.B) { for n := 0; n &lt; b.N; n++ { } } func ExampleFoo() { fmt.Println(&quot;BAR&quot;) // Output: // BAR } $ GO111MODULE=off go test PASS ok _/tmp/learn-notes 0.003s $ GO111MODULE=off go test -fuzz=Fuzz -fuzztime=3s fuzz: elapsed: 0s, gathering baseline coverage: 0/1 completed fuzz: elapsed: 0s, gathering baseline coverage: 1/1 completed, now fuzzing with 4 workers fuzz: elapsed: 3s, execs: 226192 (75387/sec), new interesting: 0 (total: 1) fuzz: elapsed: 3s, execs: 226192 (0/sec), new interesting: 0 (total: 1) PASS ok _/tmp/learn-notes 3.127s $ GO111MODULE=off go test -bench=.* goos: linux goarch: amd64 cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz BenchmarkFoo-4 1000000000 0.5349 ns/op PASS ok _/tmp/learn-notes 0.605s 11. Modules Go 1.11 and 1.12 include preliminary support for modules, Go’s new dependency management system that makes dependency version information explicit and easier to manage.[2] GOPATH and GO111MODULE: New module changes in Go 1.16 The go command now builds packages in module-aware mode by default, even when no go.mod is present. This is a big step toward using modules in all projects. It’s still possible to build packages in GOPATH mode by setting the GO111MODULE environment variable to off. You can also set GO111MODULE to auto to enable module-aware mode only when a go.mod file is present in the current directory or any parent directory. This was previously the default. Note that you can set GO111MODULE and other variables permanently with go env -w: go env -w GO111MODULE=auto We plan to drop support for GOPATH mode in Go 1.17. In other words, Go 1.17 will ignore GO111MODULE. If you have projects that do not build in module-aware mode, now is the time to migrate. In Go, if an old package and a new package have the same import path, the new package must be backwards compatible with the old package. There is certainly a cost to needing to introduce a new name for each backwards-incompatible API change, but as the semver FAQ says, that cost should encourage authors to more clearly consider the impact of such changes and whether they are truly necessary. A module path is the canonical name for a module, declared with the module directive in the module’s go.mod file. A module’s path is the prefix for package paths within the module. A module path should describe both what the module does and where to find it. Typically, a module path consists of a repository root path, a directory within the repository (usually empty), and a major version suffix (only for major version 2 or higher). [4] A module is a collection of related Go packages that are versioned together as a single unit. Modules record precise dependency requirements and create reproducible builds. Most often, a version control repository contains exactly one module defined in the repository root. Summarizing the relationship between repositories, modules, and packages: A repository contains one or more Go modules. Each module contains one or more Go packages. Each package consists of one or more Go source files in a single directory. Modules must be semantically versioned according to semver, usually in the form v(major).(minor).(patch), such as v0.1.0, v1.2.3, or v1.5.0-rc.1. The leading v is required. If using Git, tag released commits with their versions. A module is defined by a tree of Go source files with a go.mod file in the tree&#8217;s root directory. A module declares its identity in its go.mod via the module directive, which provides the module path. The import paths for all packages in a module share the module path as a common prefix. The module path and the relative path from the go.mod to a package&#8217;s directory together determine a package&#8217;s import path. In Go source code, packages are imported using the full path including the module path. go help modules go help go.mod go help module-private go help goproxy go env GOPROXY # https://proxy.golang.org,direct go env -w GOPROXY=https://goproxy.cn,direct go env GOPROXY # https://goproxy.cn,direct go help gopath 12. Printf Package fmt implements formatted I/O with functions analogous to C&#8217;s printf and scanf.[16] 12.1. The Printing verbs General: %v the value in a default format when printing structs, the plus flag (%+v) adds field names %#v a Go-syntax representation of the value %T a Go-syntax representation of the type of the value %% a literal percent sign; consumes no value type Pointer struct { X int Y int } func main() { p := Pointer{3, 4} fmt.Printf(&quot;%%v: %v\n&quot;, p) fmt.Printf(&quot;%%+v: %+v\n&quot;, p) fmt.Printf(&quot;%%#v: %#v\n&quot;, p) fmt.Printf(&quot;%%T: %T\n&quot;, p) } // Output: // %v: {3 4} // %+v: {X:3 Y:4} // %#v: main.Pointer{X:3, Y:4} // %T: main.Pointer Boolean: %t the word true or false Integer: %b base 2 %c the character represented by the corresponding Unicode code point %d base 10 %o base 8 %O base 8 with 0o prefix %q a single-quoted character literal safely escaped with Go syntax. %x base 16, with lower-case letters for a-f %X base 16, with upper-case letters for A-F %U Unicode format: U+1234; same as &quot;U+%04X&quot; func main() { n := 1234 fmt.Printf(&quot;%%b: %b\n&quot;, n) fmt.Printf(&quot;%%c: %c\n&quot;, n) fmt.Printf(&quot;%%d: %d\n&quot;, n) fmt.Printf(&quot;%%o: %o\n&quot;, n) fmt.Printf(&quot;%%O: %O\n&quot;, n) fmt.Printf(&quot;%%q: %q\n&quot;, n) fmt.Printf(&quot;%%x: %x\n&quot;, n) fmt.Printf(&quot;%%X: %X\n&quot;, n) fmt.Printf(&quot;%%U: %U\n&quot;, n) } // Output: // %b: 10011010010 // %c: Ӓ // %d: 1234 // %o: 2322 // %O: 0o2322 // %q: &#39;Ӓ&#39; // %x: 4d2 // %X: 4D2 // %U: U+04D2 Floating-point and complex constituents: %b decimalless scientific notation with exponent a power of two, in the manner of strconv.FormatFloat with the &#39;b&#39; format, e.g. -123456p-78 %e scientific notation, e.g. -1.234456e+78 %E scientific notation, e.g. -1.234456E+78 %f decimal point but no exponent, e.g. 123.456 %F synonym for %f %g %e for large exponents, %f otherwise. Precision is discussed below. %G %E for large exponents, %F otherwise %x hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20 %X upper-case hexadecimal notation, e.g. -0X1.23ABCP+20 func main() { n := -123456.789 fmt.Printf(&quot;%%b: %b\n&quot;, n) fmt.Printf(&quot;%%e: %e\n&quot;, n) fmt.Printf(&quot;%%E: %E\n&quot;, n) fmt.Printf(&quot;%%f: %f\n&quot;, n) fmt.Printf(&quot;%%F: %F\n&quot;, n) fmt.Printf(&quot;%%g: %g\n&quot;, n) fmt.Printf(&quot;%%G: %G\n&quot;, n) fmt.Printf(&quot;%%x: %x\n&quot;, n) fmt.Printf(&quot;%%X: %X\n&quot;, n) } // Output: // %b: -8483885939586761p-36 // %e: -1.234568e+05 // %E: -1.234568E+05 // %f: -123456.789000 // %F: -123456.789000 // %g: -123456.789 // %G: -123456.789 // %x: -0x1.e240c9fbe76c9p+16 // %X: -0X1.E240C9FBE76C9P+16 String and slice of bytes (treated equivalently with these verbs): %s the uninterpreted bytes of the string or slice %q a double-quoted string safely escaped with Go syntax %x base 16, lower-case, two characters per byte %X base 16, upper-case, two characters per byte Slice: %p address of 0th element in base 16 notation, with leading 0x Pointer: %p base 16 notation, with leading 0x The %b, %d, %o, %x and %X verbs also work with pointers, formatting the value exactly as if it were an integer. The default format for %v is: bool: %t int, int8 etc.: %d uint, uint8 etc.: %d, %#x if printed with %#v float32, complex64, etc: %g string: %s chan: %p pointer: %p For compound objects, the elements are printed using these rules, recursively, laid out like this: struct: {field0 field1 ...} array, slice: [elem0 elem1 ...] maps: map[key1:value1 key2:value2 ...] pointer to above: &amp;{}, &amp;[], &amp;map[] Other flags: &#39;+&#39; always print a sign for numeric values; guarantee ASCII-only output for %q (%+q) &#39;-&#39; pad with spaces on the right rather than the left (left-justify the field) &#39;#&#39; alternate format: add leading 0b for binary (%#b), 0 for octal (%#o), 0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p); for %q, print a raw (backquoted) string if strconv.CanBackquote returns true; always print a decimal point for %e, %E, %f, %F, %g and %G; do not remove trailing zeros for %g and %G; write e.g. U+0078 &#39;x&#39; if the character is printable for %U (%#U). &#39; &#39; (space) leave a space for elided sign in numbers (% d); put spaces between bytes printing strings or slices in hex (% x, % X) &#39;0&#39; pad with leading zeros rather than spaces; for numbers, this moves the padding after the sign; ignored for strings, byte slices and byte arrays func main() { n := 123 fmt.Printf(&quot;%+06d\n&quot;, n) } // Output: // +00123 12.2. Width and Precision Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. %f default width, default precision %9f width 9, default precision %.2f default width, precision 2 %9.2f width 9, precision 2 %9.f width 9, precision 0 12.3. Stringer type Stringer interface { String() string } Stringer is implemented by any value that has a String method, which defines the &quot;native&quot; format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. // Animal has a Name and an Age to represent an animal. type Animal struct { Name string Age uint } // String makes Animal satisfy the Stringer interface. func (a Animal) String() string { return fmt.Sprintf(&quot;%v (%d)&quot;, a.Name, a.Age) } func main() { a := Animal{ Name: &quot;Gopher&quot;, Age: 2, } fmt.Println(a) // Output: // Gopher (2) } References [1] https://go.dev/blog/maps [2] https://go.dev/blog/using-go-modules [3] https://go.dev/blog/strings [4] https://go.dev/ref/mod [5] Capturing Iteration Variables in Go Language [6] https://groups.google.com/g/golang-nuts/c/pZwdYRGxCIk/m/qpbHxRRPJdUJ [7] Practical Go: Real world advice for writing maintainable Go programs [8] https://go.dev/doc/effective_go.html [9] Errors in Go language [10] Goroutines and Channels in Go Language [11] Object-oriented Programming in Go Language [12] Testing in Go Language [13] https://semver.org/ [14] https://stackoverflow.com/questions/24790175/when-is-the-init-function-run [15] https://medium.com/@adiach3nko/package-management-with-go-modules-the-pragmatic-guide-c831b4eaaf31 [16] https://pkg.go.dev/fmt [17] https://go.dev/ref/mem [18] Concurrency with Shared Variables in Go Language [19] https://go.dev/ref/spec#Iota [20] https://talks.golang.org/2012/concurrency.slide [21] https://go.dev/tour/generics/1 [22] https://research.swtch.com/vgo-import [23] https://research.swtch.com/vgo-module [24] https://research.swtch.com/vgo-mvs [25] https://github.com/golang/go/wiki/Iota [26] https://github.com/golang/go/wiki/Modules" />
<link rel="canonical" href="https://blog.codefarm.me/2020/04/07/golang-learning-notes/" />
<meta property="og:url" content="https://blog.codefarm.me/2020/04/07/golang-learning-notes/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-07T09:24:39+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Golang Learning Notes" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-04-07T09:24:39+08:00","datePublished":"2020-04-07T09:24:39+08:00","description":"1. Foramtting 2. Commentary 3. Names 3.1. Package names 3.2. Getters 3.3. Interface names 3.4. MixedCaps 4. Semicolons 5. Control structures 5.1. If 5.2. For 5.3. Switch 5.4. Type Switch 5.5. Select 5.6. Break, Continue and Goto 5.7. Fallthrough 5.8. Defer 6. Data types 6.1. Type 6.2. Variables 6.3. Strings, bytes, runes and characters 6.4. Pointers 6.5. Structs 6.6. Arrays 6.7. Slices 6.8. Maps 6.9. Functions 6.10. Methods 6.11. Interfaces 6.12. Embedding: interfaces and structs 6.13. Channels 6.14. Type conversions 6.15. Generics 7. Initialization 7.1. Constants 7.2. Allocation: new and make 7.3. The init function 7.4. Zero values 8. Concurrency 8.1. Race Conditions 8.2. Race Detector 8.3. Happen before 8.4. Share by communicating 8.5. Goroutines 8.6. Channels 8.7. Parallelization 8.8. Synchronization 8.8.1. Channels 8.8.2. sync.Mutex 8.8.3. sync.RWMutex 8.8.4. sync.WaitGroup 8.8.5. sync.Cond 8.8.6. sync.Once 8.8.7. sync.Map 8.8.8. sync/atomic 9. Errors 10. Testing 11. Modules 12. Printf 12.1. The Printing verbs 12.2. Width and Precision 12.3. Stringer References 1. Foramtting With Go we take an unusual approach and let the machine take care of most formatting issues. The gofmt program (also available as go fmt, which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments. $ cat formatting.go package formatting type T struct { name string // name of the object value int // its value } $ go fmt formatting.go # or gofmt -w formatting.go formatting.go $ cat formatting.go package formatting type T struct { name string // name of the object value int // its value } 2. Commentary Go provides C-style /* */ block comments and C&#43;&#43;-style // line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. // Println formats using the default formats for its operands and writes to standard output. // Spaces are always added between operands and a newline is appended. // It returns the number of bytes written and any write error encountered. func Println(a ...any) (n int, err error) { return Fprintln(os.Stdout, a...) } The command go doc is used to display documentation for Go packages, functions, or types directly in the terminal. When run with one argument, the argument is treated as a Go-syntax-like representation of the item to be documented. go doc &lt;pkg&gt; # go doc net/http go doc &lt;sym&gt;[.&lt;methodOrField&gt;] # go doc http.Request.Write go doc [&lt;pkg&gt;.]&lt;sym&gt;[.&lt;methodOrField&gt;] # go doc net/http.Request.Write go doc [&lt;pkg&gt;.][&lt;sym&gt;.]&lt;methodOrField&gt; # go doc net/http.Write $ go doc builtin.new package builtin // import &quot;builtin&quot; func new(Type) *Type The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. When run with two arguments, the first is a package path (full path or suffix), and the second is a symbol, or symbol with method or struct field: go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;methodOrField&gt;] # go doc net/http Request.Write $ go doc sync Mutex package sync // import &quot;sync&quot; type Mutex struct { // Has unexported fields. } A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex. A Mutex must not be copied after first use. func (m *Mutex) Lock() func (m *Mutex) Unlock() The godoc is a tool used to either generate HTML documentation or serve it through a local web server. godoc -http=:6060 3. Names The visibility of a name outside a package is determined by whether its first character is upper case. 3.1. Package names By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as &quot;encoding/base64&quot; but has name base64, not encoding_base64 and not encodingBase64. Use the package structure to help you choose good names. The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter. For instance, the buffered reader type in the bufio package is called Reader, not BufReader, because users see it as bufio.Reader, which is a clear, concise name. Moreover, because imported entities are always addressed with their package name, bufio.Reader does not conflict with io.Reader. Similarly, the function to make new instances of ring.Ring—which is the definition of a constructor in Go—would normally be called NewRing, but since Ring is the only type exported by the package, and since the package is called ring, it&#8217;s called just New, which clients of the package see as ring.New. 3.2. Getters Go doesn&#8217;t provide automatic support for getters and setters. There&#8217;s nothing wrong with providing getters and setters yourself, and it&#8217;s often appropriate to do so, but it&#8217;s neither idiomatic nor necessary to put Get into the getter&#8217;s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner. A setter function, if needed, will likely be called SetOwner. Both names read well in practice: owner := obj.Owner() if owner != user { obj.SetOwner(user) } 3.3. Interface names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc. type Writer interface { Write(p []byte) (n int, err error) } type ReadWriter interface { Reader Writer } There are a number of such names and it&#8217;s productive to honor them and the function names they capture. Read, Write, Close, Flush, String and so on have canonical signatures and meanings. To avoid confusion, don&#8217;t give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method String not ToString. 3.4. MixedCaps Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names. 4. Semicolons Like C, Go&#8217;s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. If the newline comes after a token that could end a statement, insert a semicolon. Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the initializer, condition, and continuation elements. for i := 0; i &lt; 5; i++ { } They are also necessary to separate multiple statements on a line, should you write code that way. 5. Control structures There is no do or while loop, only a slightly generalized for; switch is more flexible; if and switch accept an optional initialization statement like that of for; break and continue statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, select. There are no parentheses and the bodies must always be brace-delimited. 5.1. If if x &gt; 0 { return y } if f, err: = os.Open(name); err != nil { return err } 5.2. For // Like a C for for init; condition; post { } // Like a C while for condition { } // Like a C for(;;) for { } // Like a C do-while for { // do something if condition; { break } } If you&#8217;re looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop. for key, value := range map { } // If you only need the second item in the range (the value), // use the blank identifier, an underscore, to discard the first: for _, value := range map { } for index, value := range array { } for value := range channel { } For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. The name (with associated builtin type) rune is Go terminology for a single Unicode code point. for pos, char := range &quot;日本\\x80語&quot; { // \\x80 is an illegal UTF-8 encoding fmt.Printf(&quot;character %#U starts at byte position %d\\n&quot;, char, pos) } // Output: // character U+65E5 &#39;日&#39; starts at byte position 0 // character U+672C &#39;本&#39; starts at byte position 3 // character U+FFFD &#39;�&#39; starts at byte position 6 // character U+8A9E &#39;語&#39; starts at byte position 7 Go has no comma operator and ++ and -- are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes &#43;&#43; and --). // Reverse a for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] } 5.3. Switch Go&#8217;s switch is more general than C&#8217;s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true. It&#8217;s therefore possible&#8212;&#8203;and idiomatic&#8212;&#8203;to write an if-else-if-else chain as a switch. There is no automatic fall through, but cases can be presented in comma-separated lists. Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early. Sometimes, though, it&#8217;s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and &quot;breaking&quot; to that label. Of course, the continue statement also accepts an optional label but it applies only to loops. switch os := runtime.GOOS; os { case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.\\n&quot;, os) } Loop: for n := 0; n &lt; len(src); n += size { switch { case src[n] &lt; sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] &lt; sizeTwo: if n+1 &gt;= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]&lt;&lt;shift) } } 5.4. Type Switch A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It&#8217;s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(&quot;unexpected type %T\\n&quot;, t) // %T prints whatever type t has case bool: fmt.Printf(&quot;boolean %t\\n&quot;, t) // t has type bool case int: fmt.Printf(&quot;integer %d\\n&quot;, t) // t has type int case *bool: fmt.Printf(&quot;pointer to boolean %t\\n&quot;, *t) // t has type *bool case *int: fmt.Printf(&quot;pointer to integer %d\\n&quot;, *t) // t has type *int } 5.5. Select The select statement lets a goroutine wait on multiple communication operations. A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready. The default case in a select is run if no other case is ready. Use a default case to try a send or receive without blocking: func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case &lt;-tick: fmt.Println(&quot;tick.&quot;) case &lt;-boom: fmt.Println(&quot;BOOM!&quot;) return default: fmt.Println(&quot; .&quot;) time.Sleep(50 * time.Millisecond) } } } 5.6. Break, Continue and Goto A break statement terminates execution of the innermost for, switch, or select statement within the same function. A continue statement begins the next iteration of the innermost for loop at its post statement within the same function. A goto statement transfers control to the statement with the corresponding label within the same function. func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) RawLoop: for { select { case &lt;-tick: fmt.Println(&quot;tick.&quot;) continue RawLoop // go to the next iteration case &lt;-boom: fmt.Println(&quot;BOOM!&quot;) break RawLoop // exit default: fmt.Println(&quot;. .&quot;) time.Sleep(50 * time.Millisecond) goto RawLoop // go back to the very beginning } } } 5.7. Fallthrough A fallthrough statement transfers control to the first statement of the next case clause in an expression switch statement. It may be used only as the final non-empty statement in such a clause. switch { case 10 &gt; 11: fmt.Println(&quot;10 &gt; 11&quot;) case 1 &lt; 5: fmt.Println(&quot;1 &lt; 5&quot;) fallthrough case 1 &gt; 10: fmt.Println(&quot;1 &gt; 10 ?&quot;) } // Output: // 1 &lt; 5 // 1 &gt; 10 ? 5.8. Defer A defer statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, godir, err := os.Open(&quot;/usr/local/go&quot;) if err != nil { log.Printf(&quot;%s\\n&quot;, err) defer godir.Close() } or because the corresponding goroutine is panicking. defer func() { e := recover() fmt.Printf(&quot;recover: %s\\n&quot;, e) }() defer func() { fmt.Println(&quot;. . .&quot;) }() panic(fmt.Sprintf(&quot;Oops, I&#39;m NOT myself.&quot;)) // Output: // . . . // recover: Oops, I&#39;m NOT myself. Go&#8217;s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns. // The arguments to the deferred function (which include the receiver if the function is a method) // are evaluated when the _defer_ executes, not when the _call_ executes. func main() { v := 10 defer fmt.Println(3 * v) // 30 defer func() { fmt.Println(v) // 20 }() defer func(x int) { fmt.Println(x) // 10 }(v) v = 20 _ = v } // Output: // 10 // 20 // 30 It&#8217;s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. func ReadFile(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() return ReadAll(f) } Deferred functions are executed in LIFO order (stacking style). for i := 0; i &lt; 5; i++ { defer fmt.Printf(&quot;%d &quot;, i) } // Output: // 4 3 2 1 0 // All function values created by this loop &quot;capture&quot; // and share the same variable—an addressable storage location, // not its value at that particular moment. for i := 0; i &lt; 5; i++ { defer func() { fmt.Print(i, &quot; &quot;) }() } // Output: // 5 5 5 5 5 for i := 0; i &lt; 5; i++ { // declares inner i, intialized to outer i i := i defer func() { fmt.Print(i, &quot; &quot;) }() } // Output: // 4 3 2 1 0 6. Data types // any is an alias for interface{} and is equivalent to interface{} in all ways. // (go1.18) any // comparable is an interface that is implemented by all comparable types // (booleans, numbers, strings, pointers, channels, arrays of comparable types, // structs whose fields are all comparable types). The comparable interface may // only be used as a type parameter constraint, not as the type of a variable. // (go1.18) comparable bool // true false string int8 int16 int32 int64 uint8 uint16 uint32 uint64 uintptr int uint // either 32 or 64 bits byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 // more types pointers structs array slices maps functions interfaces channels 6.1. Type The type keyword in Go is used to define new types or create aliases for existing types. Type definitions create a completely new type that is distinct from the base type, which can be added methods to it. // new named type type Celsius float64 type Fahrenheit float64 // new type method func (c Celsius) ToF() Fahrenheit { return Fahrenheit((c * 9.0 / 5.0) + 32.0) } func cToF(c Celsius) Fahrenheit { return c.ToF() } func main() { var tempC Celsius = 25.0 tempF := cToF(tempC) fmt.Println(tempF) // 77 // Error: cannot use tempC (variable of float64 type Celsius) as float64 value in variable declaration // var tempFloat float64 = tempC // fmt.Println(tempFloat) } type Reader interface { Read() (int, bool) } type Writer interface { Write(item int) } type ReadWriter interface { Reader Writer } type MyChannel struct { channel chan int } func (my MyChannel) Read() (v int, ok bool) { v, ok = &lt;-my.channel return } func (my MyChannel) Write(item int) { my.channel &lt;- item } func (my MyChannel) Close() { close(my.channel) } func New(size int) MyChannel { return MyChannel{channel: make(chan int, size)} } func main() { my := New(5) go func() { for { v, ok := my.Read() if !ok { break } fmt.Println(v) } }() go func() { defer my.Close() for i := 0; i &lt; 10; i++ { my.Write(i) } }() time.Sleep(10 * time.Millisecond) } Type aliases provide a different name for an existing type but don&#8217;t create a new type; they just give a new identifier. // type alias type Celsius = float64 type Fahrenheit = float64 func cToF(c Celsius) Fahrenheit { return Fahrenheit((c * 9.0 / 5.0) + 32.0) } func main() { var tempC Celsius = 25.0 tempF := cToF(tempC) fmt.Println(tempF) // 77 // because Celsius and float64 are the same, this is legal: var tempFloat float64 = tempC fmt.Println(tempFloat) // 25 } 6.2. Variables A var statement can be at package or function level to declare a list of variables; as in function argument lists, the type is last. var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } A var declaration can include initializers, one per variable. var c, python, java = true, false, &quot;no!&quot; Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type. func main() { var i, j int = 1, 2 k := 3 c, python, java := true, false, &quot;no!&quot; fmt.Println(i, j, k, c, python, java) } 6.3. Strings, bytes, runes and characters Go source code is always UTF-8. A string holds arbitrary bytes. A string literal, absent byte-level escapes, always holds valid UTF-8 sequences. Those sequences represent Unicode code points, called runes. A code point is a unique numerical value assigned to a character in the Unicode standard, that represents a character, regardless of how that character is stored or encoded. A code unit is the actual bit sequence used to represent a code point in a specific encoding scheme. No guarantee is made in Go that characters in strings are normalized. const nihongo = &quot;日本語&quot; for _, runeValue := range nihongo { // for-range: iterate over the Unicode code points (runes) fmt.Printf(&quot;%#U &quot;, runeValue) } fmt.Println() // U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39; for _, cp := range []rune(nihongo) { // convert a string to a slice of runes fmt.Printf(&quot;%#U &quot;, cp) } fmt.Println() // U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39; for i := 0; i &lt; len(nihongo); i++ { // for-loop: iterate over the UTF-8 encoded units or bytes fmt.Printf(&quot;%x &quot;, nihongo[i]) } fmt.Println() // e6 97 a5 e6 9c ac e8 aa 9e for i := 0; i &lt; len(nihongo); i++ { fmt.Printf(&quot;%q &quot;, nihongo[i]) } fmt.Println() // &#39;æ&#39; &#39;\\u0097&#39; &#39;¥&#39; &#39;æ&#39; &#39;\\u009c&#39; &#39;¬&#39; &#39;è&#39; &#39;ª&#39; &#39;\\u009e&#39; for i := 0; i &lt; len(nihongo); i++ { fmt.Printf(&quot;%+q &quot;, nihongo[i]) } fmt.Println() // &#39;\\u00e6&#39; &#39;\\u0097&#39; &#39;\\u00a5&#39; &#39;\\u00e6&#39; &#39;\\u009c&#39; &#39;\\u00ac&#39; &#39;\\u00e8&#39; &#39;\\u00aa&#39; &#39;\\u009e&#39; 6.4. Pointers // A pointer holds the memory address of a value. // Unlike C, Go has no pointer arithmetic. // The type `*T` is a pointer to a `T` value. Its zero value is `nil`. var p *int i := 42 // The `&amp;` operator generates a pointer to its operand. p = &amp;i // The `*` operator (&quot;dereferencing&quot; or &quot;indirecting&quot;) denotes the pointer&#39;s underlying value. *p = 21 6.5. Structs // A struct is a collection of fields. type Vertex struct { X, Y int } var ( // A struct literal denotes a newly allocated struct value by listing the values of its fields. v1 = Vertex{1, 2} // has type Vertex // You can list just a subset of fields by using the Name: syntax. // (And the order of named fields is irrelevant.) v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 // The special prefix &amp; returns a pointer to the struct value p = &amp;Vertex{1, 2} // has type *Vertex ) func main() { // Struct fields are accessed using a dot. p.X = 1e9 fmt.Println(v1, p, v2, v3) } 6.6. Arrays The type [n]T is an array of n values of type T. Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct, so arrays cannot be resized. var a [2]string a[0] = &quot;Hello&quot; a[1] = &quot;World&quot; // an array literal primes := [6]int{2, 3, 5, 7, 11, 13} 6.7. Slices A slice, on the other hand, is a dynamically-sized, flexible view into the elements of an array. The type []T is a slice with elements of type T. A slice is formed by specifying two indices, a low and high bound, separated by a colon: // This selects a half-open range which includes the first element, but excludes the last one. a[low : high] The following expression creates a slice which includes elements 1 through 3 of a: a[1:4] Slices are like references to arrays A slice does not store any data, it just describes a section of an underlying array. A slice hold references to an underlying array, and if you assign one slice to another, both refer to the same array. Changing the elements of a slice modifies the corresponding elements of its underlying array. Other slices that share the same underlying array will see those changes. Slice literals A slice literal is like an array literal without the length. []bool{true, true, false} Slice defaults When slicing, you may omit the high or low bounds to use their defaults instead. The default is zero for the low bound and the length of the slice for the high bound. // For the array var a [10]int // these slice expressions are equivalent: a[0:10] a[:10] a[0:] a[:] Slice length and capacity A slice has both a length and a capacity. The length of a slice is the number of elements it contains. The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice. The length and capacity of a slice s can be obtained using the expressions len(s) and cap(s). You can extend a slice&#8217;s length by re-slicing it, provided it has sufficient capacity. Nil slices The zero value of a slice is nil. A nil slice has a length and capacity of 0 and has no underlying array. Appending to a slice It is common to append new elements to a slice, and so Go provides a built-in append function. func append(s []T, vs ...T) []T The resulting value of append is a slice containing all the elements of the original slice plus the provided values. If the backing array of s is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array. var s []int // append works on nil slices. s = append(s, 0) // The slice grows as needed. s = append(s, 1) // We can add more than one element at a time. s = append(s, 2, 3, 4) 6.8. Maps Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value). The key can be of any type that is comparable for which the equality operator is defined. The language spec defines the Comparison operators precisely, in short, comparable types are boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types.[1] Notably absent from the list are slices, maps, and functions; these types cannot be compared using ==, and may not be used as map keys. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller. The zero value of a map is nil. A nil map has no keys, nor can keys be added. Map literals are like struct literals, but the keys are required. var m map[string]int // &lt;nil&gt; m = map[string]int{ &quot;hello&quot;: 100, &quot;world&quot;: 200, } The make function returns a map of the given type with an optional capacity hint as arguments, initialized and ready for use. // m := make(map[string]int, 100) m := make(map[string]int) // insert or update an element m[&quot;Answer&quot;] = 42 // delete an element: // The delete function doesn’t return anything, and will do nothing if the specified key doesn’t exist. delete(m, &quot;Answer&quot;) // retrieve an element // If the requested key doesn’t exist, we get the value type’s zero value. v := m[&quot;Answer&quot;] // test that a key is present with a two-value assignment v, ok := m[&quot;Answer&quot;] 6.9. Functions A function can return any number of results. func (file *File) Write(b []byte) (n int, err error) The return or result &quot;parameters&quot; of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values. Functions are values too. They can be passed around just like other values. Function values may be used as function arguments and return values. Go functions may be closures, that is a function value that references (i.e. bounds to) variables from outside its body. func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func wrapper(f func(int) int, i int) int { return f(i) } func main() { pos, neg := adder(), adder() for i := 1; i &lt;= 3; i++ { fmt.Printf(&quot;%+d, %+2d\\t&quot;, wrapper(pos, i), neg(-i)) } } // Output: // +1, -1 +3, -3 +6, -6 A function literal represents an anonymous function and cannot declare type parameters, and it can be assigned to a variable or invoked directly. Function literals are closures: they may refer to variables defined in a surrounding function, which are then shared between the surrounding function and the function literal, and they survive as long as they are accessible. func main() { var sum int var add = func() { sum += 1 } add() fmt.Printf(&quot;%d\\n&quot;, sum) } // Output: // 1 6.10. Methods A method is a function with a special receiver argument, defined on any named type (except a pointer or an interface) in the same package. type MyInt int func (mi *MyInt) String() string { return fmt.Sprintf(&quot;Hi %d!&quot;, *mi) } func (mi *MyInt) Add(delta int) { *mi = *mi + MyInt(delta) } func main() { var mi MyInt = 1_024 mi.Add(1_024) fmt.Println(&amp;mi) } // Output: // Hi 2048! Choosing a value or pointer receiver There are two reasons to use a pointer receiver. The first is so that the method can modify the value that its receiver points to. The second is to avoid copying the value on each method call, that can be more efficient if the receiver is a large struct, for example. In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers. Value methods can be called on both values and pointers (automatically using * on pointers), while pointer methods can only be called on pointers (automatically using &amp; on values). Nil is a valid receiver value Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices. When you define a type whose methods allow nil as a receiver value, it&#8217;s worth pointing this out explicitly in its documentation comment. package bytes // import &quot;bytes&quot; type Buffer struct { // Has unexported fields. } A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use. 6.11. Interfaces An interface type defines a type set, that is the set of all concrete types that implement that interface. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil. An interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type. Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. Interfaces are implemented implicitly A type implements an interface by implementing its methods. There is no explicit declaration of intent, no &quot;implements&quot; keyword. Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement. Interface values Under the hood, interface values can be thought of as a tuple of a value and a concrete type: An interface value holds a value of a specific underlying concrete type. (value, type) Calling a method on an interface value executes the method of the same name on its underlying type. Interface values with nil underlying values If the concrete value inside the interface itself is nil, the method will be called with a nil receiver. In some languages this would trigger a null pointer exception, but in Go it is common to write methods that gracefully handle being called with a nil receiver. Note that an interface value that holds a nil concrete value is itself non-nil. type I interface { M() } type T struct{} func (t *T) M() { if t == nil { fmt.Println(&quot;&lt;nil receiver&gt;&quot;) return } } func main() { var i I // `i` is nil // i.M() // runtime error: invalid memory address or nil pointer dereference var t *T i = t // `i` is not nil, but the concrete type `t` is nil i.M() fmt.Printf(&quot;%v, %T\\n&quot;, i, i) i = &amp;T{} // the concrete type `t` is not nil i.M() fmt.Printf(&quot;%v, %T\\n&quot;, i, i) } // Output: // &lt;nil receiver&gt; // &lt;nil&gt;, *main.T // &amp;{}, *main.T Nil interface values A nil interface value holds neither value nor concrete type. Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call. var i I fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i) i.M() // (&lt;nil&gt;, &lt;nil&gt;) // panic: runtime error: invalid memory address or nil pointer dereference The empty interface The interface type that specifies zero methods is known as the empty interface: interface{} An empty interface may hold values of any type. (Every type implements at least zero methods.) Empty interfaces are used by code that handles values of unknown type. For convenience, the predeclared type any is an alias for the empty interface. $ go doc builtin.any package builtin // import &quot;builtin&quot; type any = interface{} any is an alias for interface{} and is equivalent to interface{} in all ways. Basic interfaces Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces. // A simple File interface. interface { Read([]byte) (int, error) Write([]byte) (int, error) Close() error } Embedded interfaces In a slightly more general form an interface T may use a (possibly qualified) interface type name E as an interface element, which is called embedding interface E in T. The type set of T is the intersection of the type sets defined by T&#8217;s explicitly declared methods and the type sets of T’s embedded interfaces. In other words, the type set of T is the set of all types that implement all the explicitly declared methods of T and also all the methods of E. type Reader interface { Read(p []byte) (n int, err error) Close() error } type Writer interface { Write(p []byte) (n int, err error) Close() error } // ReadWriter&#39;s methods are Read, Write, and Close. type ReadWriter interface { Reader // includes methods of Reader in ReadWriter&#39;s method set Writer // includes methods of Writer in ReadWriter&#39;s method set } When embedding interfaces, methods with the same names must have identical signatures. type ReadCloser interface { Reader // includes methods of Reader in ReadCloser&#39;s method set Close() // illegal: signatures of Reader.Close and Close are different } General interfaces Azure AI | ChatGPT 4 In Go, general interfaces are used to define type constraints for type parameters in generic functions and data structures. [GPT 4] // Comparable is an interface that defines a type constraint using // a union of types (int, float64, and string). This means that a // type parameter satisfying the Comparable constraint must be one // of these types. type Comparable interface { int | float64 | string } // The Max function is defined as a generic function using the type // parameter T. The type parameter is specified within square brackets // ([T Comparable]). It means that the function can work with any type // T that satisfies the Comparable constraint. func Max[T Comparable](a, b T) T { if a &gt; b { return a } return b } // The Max function is called with different types of arguments (int, // float64, and string). The type parameter T is replaced with the actual // type of the arguments at each call, allowing the function to work with // different types while maintaining type safety. func main() { fmt.Println(Max(3, 4)) // int fmt.Println(Max(2.5, 3.7)) // float64 fmt.Println(Max(&quot;apple&quot;, &quot;cat&quot;)) // string } In summary, while you can&#8217;t assign a concrete type to a general interface, general interfaces are used to specify what types can be used with a generic function or data structure. These type constraints allow you to create flexible and reusable generic code while maintaining type safety. In their most general form, an interface element may also be an arbitrary type term T, or a term of the form ~T specifying the underlying type T, or a union of terms t1|t2| . . . |tn. By construction, an interface&#8217;s type set never contains an interface type. // An interface representing only the type int. interface { int } // An interface representing all types with underlying type int. interface { ~int } // An interface representing all types with underlying type int that implement the String method. interface { ~int String() string } // An interface representing an empty type set: there is no type that is both an int and a string. // // This code defines an interface that no concrete type satisfies because there is no type that is // both an int and a string. It is not the same as an empty interface (interface{}), which any type // can satisfy. This code snippet is used to illustrate the concept of an unsatisfiable interface // in the Go language specification. (Azure AI | ChatGPT 4) // // While this interface can be compiled, it cannot be used in practical terms because no type can // satisfy the constraints. It&#39;s a theoretical construct to show the capabilities and limitations of // the type constraint system in Go. (Azure AI | ChatGPT 4) interface { int string } In a term of the form ~T, the underlying type of T must be itself, and T cannot be an interface. Azure AI | ChatGPT 4 The tilde symbol ~ defines a type set constraint that includes the underlying type of T as well as any other types whose underlying type is the same as T. In this context, &quot;underlying type&quot; refers to the actual type without any type aliases or defined types based on it. &quot;The underlying type of T must be itself&quot;: This means that when defining a type set constraint using ~T, the type T must not be a type alias or a defined type based on another type. Instead, T must be a &quot;base&quot; type, such as int, float64, or a struct type. &quot;T cannot be an interface&quot;: This condition states that the type T in a type set constraint using ~T should not be an interface type. This is because interface types don&#8217;t have a specific underlying type that can be used in the type set definition. type MyInt int type MyI interface { ~[]byte // the underlying type of []byte is itself ~MyInt // illegal: the underlying type of MyInt is not MyInt ~error // illegal: error is an interface } Union elements denote unions of type sets: // The Float interface represents all floating-point types // (including any named types whose underlying types are // either float32 or float64). type Float interface { ~float32 | ~float64 } Generality If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method. In such cases, the constructor should return an interface value rather than the implementing type. // unexported type type myString struct { s string } func (ms myString) String() string { return ms.s } // constructor function (exported) that returns the interface func NewString(s string) fmt.Stringer { return myString{s: s} } Interface conversions and type assertions A type assertion provides access to an interface value&#8217;s underlying concrete value. t := i.(T) This statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t. If i does not hold a T, the statement will trigger a panic. To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded. t, ok := i.(T) If i holds a T, then t will be the underlying value and ok will be true. If not, ok will be false and t will be the zero value of type T, and no panic occurs. Type switches The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type. switch v := i.(type) { case T: // here v has type T case S: // here v has type S default: // no match; here v has the same type as i } 6.12. Embedding: interfaces and structs Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to &#8220;borrow&#8221; pieces of an implementation by embedding types within a struct or interface. package io // import &quot;io&quot; type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // ReadWriter is the interface that combines the Reader and Writer interfaces. type ReadWriter interface { Reader Writer } package bufio // import &quot;bufio&quot; type Reader struct { // Has unexported fields. } func (b *Reader) Read(p []byte) (n int, err error) type Writer struct { // Has unexported fields. } func (b *Writer) Write(p []byte) (nn int, err error) // ReadWriter stores pointers to a Reader and a Writer. // It implements io.ReadWriter. type ReadWriter struct { *Reader *Writer } For the embedded type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. For example, when the Read method of a bufio.ReadWriter is invoked, the receiver is the Reader field of the ReadWriter, not the ReadWriter itself. type Reader struct { } func (r *Reader) Read() { fmt.Println(&quot;Read&quot;) } type Writer struct { } func (r *Writer) Write() { fmt.Println(&quot;Write&quot;) } type ReadWriter struct { *Reader *Writer } func main() { rw := ReadWriter{} rw.Read() // same as rw.Reader.Read() // Output: // Read } Embedding types introduces the problem of name conflicts but the rules to resolve them are simple. First, a field or method X hides any other item X in a more deeply nested part of the type. Second, if the same name appears at the same nesting level, it is usually an error. However, if the duplicate name is never mentioned in the program outside the type definition, it is OK. type Inner1 struct { Name string } type Inner2 struct { Name string } type Outer struct { Inner1 Inner2 } func main() { o := Outer{ Inner1: Inner1{Name: &quot;Inner 1 Name&quot;}, Inner2: Inner2{Name: &quot;Inner 2 Name&quot;}, } fmt.Println(o.Inner1.Name) fmt.Println(o.Inner2.Name) // Compile error: ambiguous selector o.Name // fmt.Println(o.Name) } // Output // Inner 1 Name // Inner 2 Name Embedding: Provides an &quot;is-a&quot; relationship where the outer struct or interface directly inherits the fields and methods of the embedded struct or interface. Allows for easier and more direct access to the fields and methods of the embedded struct or interface, as they become part of the outer struct or interface. Enhances code reuse and polymorphism by making the fields and methods of the embedded struct or interface available directly in the outer struct or interface. Not Embedding (Composing): Provides a &quot;has-a&quot; relationship where the outer struct or interface holds instances of other structs or interfaces as separate fields. Requires explicitly accessing the fields and methods of the inner structs or interfaces through the composed fields. Keeps a clear separation between the fields and methods of the outer struct or interface and the inner structs or interfaces it holds. type Reader struct { } type Writer struct { } type ReadWriter struct { reader Reader writer Writer } func (r *Reader) Read() { fmt.Println(&quot;Read.&quot;) } func (w *Writer) Write() { fmt.Println(&quot;Write.&quot;) } func main() { rw := &amp;ReadWriter{} rw.reader.Read() // rw.Read undefined (type *ReadWriter has no field or method Read) rw.Read() } 6.13. Channels Channels are a typed conduit through which you can send and receive values with the channel operator, &lt;-. ch &lt;- v // Send v to channel ch. v := &lt;-ch // Receive from ch, and assign value to v. // (The data flows in the direction of the arrow.) Like maps and slices, channels must be created before use: // By default, sends and receives block until the other side is ready. // This allows goroutines to synchronize without explicit locks or condition variables. blockChan := make(chan int) // Sends to a buffered channel block only when the buffer is full. // Receives block when the buffer is empty. bufChan := make(chan int, 100) A sender can close a channel to indicate that no more values will be sent. After calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel&#8217;s type without blocking. Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed. // ok is false if there are no more values to receive and the channel is closed. v, ok := &lt;-ch The loop for v := range c receives values from the channel repeatedly until it is closed. Attempting to close an already-closed channel causes a panic, as does closing a nil channel. Sending to a closed channel causes a run-time panic. Only the sender should close a channel, never the receiver. Channels aren&#8217;t like files; you don&#8217;t usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop. A channel may be constrained only to send or only to receive by assignment or explicit conversion. func main() { var ( _ = make(chan int) // bidirectional _ = make(&lt;-chan int) // receive-only _ = make(chan&lt;- int) // send-only ) ch := make(chan int) // send-only go func(ch chan&lt;- int) { for i := 0; i &lt; 3; i++ { ch &lt;- i } close(ch) }(ch) // receive-only go func(ch &lt;-chan int) { for v := range ch { fmt.Println(v) } }(ch) time.Sleep(time.Millisecond) // Output: // 0 // 1 // 2 } func main() { ch1 := make(chan int) ch2 := make(chan int, 2) // buffering channel quit := make(chan int) go func() { for i := 1; ; i++ { ch1 &lt;- 2 * i time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) } }() go func(ch chan&lt;- int) { for i := 1; ; i++ { ch &lt;- 2*i + 1 time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) } }(ch2) go func() { &lt;-time.After(time.Duration(5e3) * time.Millisecond) quit &lt;- 0 }() // The select statement lets a goroutine wait on multiple communication operations. // A select blocks until one of its cases can run, then it executes that case. // It chooses one at random if multiple are ready. ch3 := make(chan int) timeout := time.After(500 * time.Millisecond) go func() { defer close(ch3) for { // multiplexing: ch1 + ch2 =&gt; ch3 select { case ch3 &lt;- &lt;-ch1: case ch3 &lt;- &lt;-ch2: case &lt;-timeout: fmt.Println(&quot;You&#39;re too slow.&quot;) return case &lt;-quit: fmt.Println(&quot;Quit.&quot;) return } } }() for v := range ch3 { fmt.Println(v) } } 6.14. Type conversions The expression T(v) converts the value v to the type T. // Some numeric conversions: var i int = 42 var f float64 = float64(i) var u uint = uint(f) // Or, put more simply: i := 42 f := float64(i) u := uint(f) 6.15. Generics Go functions can be written to work on multiple types using type parameters. The type parameters of a function appear between brackets, before the function&#8217;s arguments. func Index[T comparable](s []T, x T) int This declaration means that s is a slice of any type T that fulfills the built-in constraint comparable. x is also a value of the same type. comparable is a useful constraint that makes it possible to use the == and != operators on values of the type. package builtin // import &quot;builtin&quot; type comparable interface{ comparable } comparable is an interface that is implemented by all comparable types (booleans, numbers, strings, pointers, channels, arrays of comparable types, structs whose fields are all comparable types). The comparable interface may only be used as a type parameter constraint, not as the type of a variable. In addition to generic functions, Go also supports generic types. A type can be parameterized with a type parameter, which could be useful for implementing generic data structures. type ComparableOrdered interface { comparable constraints.Ordered // &quot;golang.org/x/exp/constraints&quot; } // List represents a singly-linked list that holds values of `ComparableOrdered` type. type List[T ComparableOrdered] struct { next *List[T] val T } func (head *List[T]) append(vals ...T) { var a = func(val T) { tail := head for tail.next != nil { tail = tail.next } tail.next = &amp;List[T]{val: val} } for _, val := range vals { a(val) } } func (head *List[T]) max() T { max := head.val node := head.next for node != nil { if node.val &gt; max { max = node.val } node = node.next } return max } func (head *List[T]) String() string { var b strings.Builder node := head for node != nil { fmt.Fprintf(&amp;b, &quot;%v&quot;, node.val) node = node.next if node != nil { fmt.Fprint(&amp;b, &quot; -&gt; &quot;) } } return b.String() } func main() { list := &amp;List[int]{val: 20} list.append(10, 30, 60) list.append(40) fmt.Printf(&quot;list: %v\\n&quot;, list) fmt.Printf(&quot;max: %v&quot;, list.max()) // Output: // list: 20 -&gt; 60 -&gt; 30 -&gt; 10 -&gt; 40 // max: 60 } Type constraint and type parameter A type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter. If the constraint is an interface literal of the form interface{E} where E is an embedded type element (not a method), in a type parameter list the enclosing interface{ … } may be omitted for convenience: [T []P] // = [T interface{[]P}] [T ~int] // = [T interface{~int}] [T int|string] // = [T interface{int|string}] type Constraint ~int // illegal: ~int is not in a type parameter list A type argument T satisfies a type constraint C if T is an element of the type set defined by C; i.e., if T implements C. As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument. More precisely: A type T satisfies a constraint C if T implements C; or C can be written in the form interface{ comparable; E }, where E is a basic interface and T is comparable and implements E. type argument type constraint // constraint satisfaction int interface{ ~int } // satisfied: int implements interface{ ~int } string comparable // satisfied: string implements comparable (string is strictly comparable) []byte comparable // not satisfied: slices are not comparable any interface{ comparable; int } // not satisfied: any does not implement interface{ int } any comparable // satisfied: any is comparable and implements the basic interface any struct{f any} comparable // satisfied: struct{f any} is comparable and implements the basic interface any any interface{ comparable; m() } // not satisfied: any does not implement the basic interface interface{ m() } interface{ m() } interface{ comparable; m() } // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() } Because of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable). A type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses. TypeParameters = &quot;[&quot; TypeParamList [ &quot;,&quot; ] &quot;]&quot; . TypeParamList = TypeParamDecl { &quot;,&quot; TypeParamDecl } . TypeParamDecl = IdentifierList TypeConstraint . All non-blank names in the type parameter list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type. [P any] [S interface{ ~[]byte|string }] [S ~[]E, E any] [P Constraint[int]] [_ any] As the ordinary function parameter has a parameter type, the type parameter has a (meta-)type which is called its type constraint. 7. Initialization 7.1. Constants Constants are declared like variables, but with the const keyword. Constants cannot be declared using the := syntax. Constants are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. In Go, enumerated constants are created using the iota enumerator. type Weekday int const ( Sunday Weekday = iota + 1 // iota: 0 ~ Sunday : 1 _ // iota: 1 ~ iota increased // comments // iota: 1 ~ skip: comment // iota: 1 ~ skip: empty line Monday // iota: 2 ~ Monday : 3 Tuesday // iota: 3 ~ Monday : 4 Wednesday // iota: 4 ~ Monday : 5 Thursday // iota: 5 ~ Monday : 6 Friday // iota: 6 ~ Monday : 7 Saturday // iota: 7 ~ Monday : 8 ) iota (noun) /aɪˈəʊtə/ /aɪˈəʊtə/ 1. [singular] (usually used in negative sentences) an extremely small amount There is not one iota of truth (= no truth at all) in the story. I don&#39;t think that would help one iota. 2. the 9th letter of the Greek alphabet (I, ι) ref: https://www.oxfordlearnersdictionaries.com/us/definition/english/iota 7.2. Allocation: new and make Go has two allocation primitives, the built-in functions new and make. The new built-in function allocates memory of a type, return a pointer to a newly allocated zero value of that type. package builtin // import &quot;builtin&quot; func new(Type) *Type The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. The memory returned by new is zeroed is helpful to arrange when designing a data structures that the zero value of each type can be used without further initialization. var ptr *bytes.Buffer // nil // panic: runtime error: invalid memory address or nil pointer dereference // ptr.WriteString(&quot;Hello, world!&quot;) ptr = new(bytes.Buffer) // points to a zerod bytes.Buffer instance ptr.WriteString(&quot;Hello, world!&quot;) The make built-in function allocates and initializes an object of type slice, map, or chan (only). package builtin // import &quot;builtin&quot; func make(t Type, size ...IntegerType) Type The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make&#39;s return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type: Slice: The size specifies the length. The capacity of the slice is equal to its length. A second integer argument may be provided to specify a different capacity; it must be no smaller than the length. For example, make([]int, 0, 10) allocates an underlying array of size 10 and returns a slice of length 0 and capacity 10 that is backed by this underlying array. Map: An empty map is allocated with enough space to hold the specified number of elements. The size may be omitted, in which case a small starting size is allocated. Channel: The channel&#39;s buffer is initialized with the specified buffer capacity. If zero, or the size is omitted, the channel is unbuffered. It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. var p *[]int = new([]int) // allocates slice structure; *p == nil; rarely useful var v []int = make([]int, 100) // the slice v now refers to a new array of 100 ints // Unnecessarily complex: var p *[]int = new([]int) *p = make([]int, 100, 100) // Idiomatic: v := make([]int, 100) 7.3. The init function Each source file can define its own niladic init function to set up whatever state is required. Actually each file can have multiple init functions, which called in the order they appear in the source. The init function is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. // init.go var ( hello = &quot;Hello&quot; world = &quot;世界&quot; ) func init() { fmt.Print(hello) } func init() { fmt.Print(&quot;, &quot;) } func init() { fmt.Printf(&quot;%s\\n&quot;, world) } func main() { } $ go run init.go Hello, 世界 7.4. Zero values Variables declared without an explicit initial value are given their zero value: 0 for numeric types, false for the boolean type, &quot;&quot; (the empty string) for strings, nil for the pointers, slices, maps, functions, interfaces, channels, 8. Concurrency 8.1. Race Conditions A race condition is a situation in which the program does not give the correct result for some interleaving of the operations of multiple goroutines. A data race, that is, a particular kind of race condition, occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race. The first way is not to write the variable. The second way (channels: share memory by communication) to avoid a data race is to avoid accessing the variable from multiple goroutines. The third way (mutual exclusion: sync.Mutex, sync.RWMutex) to avoid a data race is to allow many goroutines to access the variable, but only one at a time. Synchronization is about more than just the order of execution of multiple goroutines; synchronization also affets memory. Azure Open AI | ChatGPT4 Other race conditions include deadlocks, livelocks, and starvation. Deadlocks occur when two or more processes are waiting for each other to release resources that they need to continue executing. Livelocks occur when two or more processes are constantly changing their state in response to the actions of the other process, without making any progress towards their goal. A livelock is a situation where two or more processes or threads are actively trying to resolve a conflict but end up repeatedly yielding to each other, resulting in no progress being made. Livelocks are similar to deadlocks in that they both involve processes being stuck, but livelocks involve active, ongoing attempts to resolve the problem, whereas deadlocks involve processes waiting for resources. Here&#8217;s an example of a livelock: Imagine two people, Alice and Bob, walking in a narrow corridor towards each other. When they meet in the middle, they both step aside to let the other person pass. However, they both step in the same direction. Realizing this, they both step back to their original positions and try again, but they continue to step in the same direction each time. This results in a livelock, as they are both actively trying to resolve the situation but end up yielding to each other without making progress. Starvation occurs when a process is prevented from accessing the resources it needs to execute, either because other processes are monopolizing those resources or because the system is not allocating resources fairly. 8.2. Race Detector The race detector (add the -race flag to the go build, go run, or go test command) studies the steam of events, looking for cases in which one goroutine reads or writes a shared variables that was most recently written by a different goroutine without an intervening synchronization operation. The race detector reports all data races that were actually executed. However, it can only detect race conditions that occur during a run; it cannot prove that none will ever occur. 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func main() { var wg sync.WaitGroup var x, y int wg.Add(1) go func() { defer wg.Done() x = 1 fmt.Printf(&quot;y = %d\\n&quot;, y) }() wg.Add(1) go func() { defer wg.Done() y = 1 fmt.Printf(&quot;x = %d\\n&quot;, x) }() wg.Wait() } $ go run -race race.go x = 0 ================== WARNING: DATA RACE Write at 0x00c0000160c8 by goroutine 7: main.main.func1() /home/x/learn/go/race.go:15 +0xaa Previous read at 0x00c0000160c8 by goroutine 8: main.main.func2() /home/x/learn/go/race.go:23 +0xcf ... ================== ================== WARNING: DATA RACE Read at 0x00c0000160d8 by goroutine 7: main.main.func1() /home/x/learn/go/race.go:16 +0xcf Previous write at 0x00c0000160d8 by goroutine 8: main.main.func2() /home/x/learn/go/race.go:22 +0xaa ================== y = 1 Found 2 data race(s) exit status 66 Azure Open AI | ChatGPT4 When you run a Go program with the -race flag, the Go race detector instruments the code to monitor concurrent access to shared variables. If it detects a race condition, it generates a report with detailed information about the issue. The output of the -race flag typically consists of the following parts: A summary of the data race, indicating that it is a &quot;DATA RACE.&quot; A description of the current operation (read or write) that caused the race, including the memory address, the source code file, and the line number. The current goroutine involved in the race, including its number and the stack trace. A description of the previous conflicting operation (read or write) on the same memory address, including the source code file and the line number. The previous goroutine involved in the race, including its number and the stack trace. For example, consider the following output: WARNING: DATA RACE Write at 0x00c0000160c8 by goroutine 7: main.main.func1() /path/to/your/code/main.go:16 +0x6a Previous read at 0x00c0000160c8 by goroutine 8: main.main.func2() /path/to/your/code/main.go:22 +0x3e This output can be interpreted as follows: The race detector has identified a data race. A write operation occurred at memory address 0x00c0000160c8 by goroutine 7. The operation happened in the function main.main.func1() in the source code file main.go at line 16. The current goroutine 7 is shown along with the stack trace. A previous read operation occurred at the same memory address 0x00c0000160c8 by goroutine 8. The operation happened in the function main.main.func2() in the source code file main.go at line 22. The previous goroutine 8 is shown along with the stack trace. Using this information, you can identify the source code lines and goroutines involved in the race condition and take appropriate action to fix the issue, such as adding proper synchronization mechanisms like mutexes or channels. 8.3. Happen before Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification. Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another. For example, if one goroutine executes a = 1; b = 2;, another might observe the updated value of b before the updated value of a. To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event e1 happens before event e2, then we say that e2 happens after e1. Also, if e1 does not happen before e2 and does not happen after e2, then we say that e1 and e2 happen concurrently. Within a single goroutine, the happens-before order is the order expressed by the program. Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access. To serialize access, protect the data with channel operations or other synchronization primitives such as those in the sync and sync/atomic packages. 8.4. Share by communicating Do not communicate by sharing memory; instead, share memory by communicating. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there&#8217;s still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go&#8217;s approach to concurrency originates in Hoare&#8217;s Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes. 8.5. Goroutines A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. [20] And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required. Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management. Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. The evaluation of f, x, y, and z of go f(x, y, z) happens in the current goroutine and the execution of f happens in the new goroutine. func main() { // All function values created by this loop “capture” // and share the same variable—an addressable storage location, // not its value at that particular moment. for i := 0; i &lt; 5; i++ { go func() { fmt.Print(i, &quot; &quot;) }() } time.Sleep(time.Millisecond) fmt.Println() for i := 0; i &lt; 5; i++ { i := i go func() { fmt.Print(i, &quot; &quot;) }() } time.Sleep(time.Millisecond) // Output: // 5 5 5 5 5 // 4 0 1 2 3 // ignore the order } Best number of goroutines in a process There is no one-size-fits-all answer to the best number of goroutines in a process, as it depends on various factors such as the nature of your application, the resources available on your system, and the level of parallelism your program can achieve. However, here are some general guidelines to help you determine the optimal number of goroutines: [Azure Open AI | ChatGPT4] I/O-bound tasks: If your application performs tasks that are primarily I/O-bound, such as reading from or writing to disk, network, or other external resources, you can benefit from a higher number of goroutines. Since I/O-bound tasks often involve waiting for external resources, having more goroutines can help keep your application busy and utilize available CPU resources effectively. In this case, the optimal number of goroutines might be several times the number of available CPU cores. CPU-bound tasks: If your application performs tasks that are primarily CPU-bound, such as complex calculations or data processing, you may not benefit from a higher number of goroutines than the number of available CPU cores. Having more goroutines than CPU cores can lead to frequent context switching, which can hurt performance. In this case, the optimal number of goroutines might be close to the number of available CPU cores. Workload characteristics: The best number of goroutines also depends on the specific characteristics of your application&#8217;s workload. For example, if your application has a mix of I/O-bound and CPU-bound tasks, or if it has varying resource requirements over time, you might need to experiment with different numbers of goroutines to find the optimal balance. Resource availability: The optimal number of goroutines also depends on the resources available on your system, such as CPU, memory, and I/O capacity. If your system is constrained in terms of resources, you may need to limit the number of goroutines to avoid exhausting system resources and causing performance issues. When there are many Go processes running on the same operating system, it is essential to consider the overall resource usage of the entire system. Running multiple Go processes with a large number of goroutines can lead to contention for system resources, such as CPU, memory, and I/O capacity. In this case, it might be necessary to limit the number of goroutines per process or to distribute the processes across multiple machines to ensure optimal performance. Ultimately, the best way to determine the optimal number of goroutines for your application is through benchmarking, monitoring, and profiling. By measuring the performance of your application under different conditions and configurations, you can make informed decisions about the appropriate number of goroutines and resource allocation. 8.6. Channels Like maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel. ci := make(chan int) // unbuffered channel of integers cj := make(chan int, 0) // unbuffered channel of integers cs := make(chan *os.File, 100) // buffered channel of pointers to Files Receivers always block until there is data to receive. The sender blocks only until the value has been copied to the buffer. A buffered channel can be used like a semaphore, for instance to limit throughput. ch := make(chan int, 1) // create a buffered channel with capacity 1 ch &lt;- 1 // send 1 to the channel (non-blocking because of buffer) fmt.Println(&lt;-ch) // receive 1 from the channel ch = make(chan int) // create an unbuffered (blocking) channel stop := make(chan int) // create a channel to synchronize the goroutine&#39;s completion go func() { ch &lt;- 2 // send 2 to the channel (blocks until received) time.Sleep(time.Millisecond) // simulate some work fmt.Println(3) // print 3 after the send stop &lt;- 0 // signal that the goroutine is finished }() fmt.Println(&lt;-ch) // receive 2 from the channel (unblocks the goroutine) &lt;-stop // wait for the goroutine to signal completion // Output: // 1 // 2 // 3 The assembly line metaphor (pipeline) is useful one for channels and goroutines. ref http://golang.org/s/prime-sieve // A concurrent prime sieve // Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;. func Generate(ch chan&lt;- int) { for i := 2; ; i++ { ch &lt;- i // Send &#39;i&#39; to channel &#39;ch&#39;. } } // Copy the values from channel &#39;in&#39; to channel &#39;out&#39;, // removing those divisible by &#39;prime&#39;. func Filter(in &lt;-chan int, out chan&lt;- int, prime int) { for { i := &lt;-in // Receive value from &#39;in&#39;. if i%prime != 0 { out &lt;- i // Send &#39;i&#39; to &#39;out&#39;. } } } // The prime sieve: Daisy-chain Filter processes. func main() { ch := make(chan int) // Create a new channel. go Generate(ch) // Launch Generate goroutine. for i := 0; i &lt; 10; i++ { prime := &lt;-ch print(prime, &quot;\\n&quot;) ch1 := make(chan int) go Filter(ch, ch1, prime) ch = ch1 } } 8.7. Parallelization Be sure not to confuse the ideas of concurrency&#8212;&#8203;structuring a program as independently executing components&#8212;&#8203;and parallelism&#8212;&#8203;executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go&#8217;s model. package runtime // import &quot;runtime&quot; func NumCPU() int NumCPU returns the number of logical CPUs usable by the current process. The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected. func GOMAXPROCS(n int) int GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves. 8.8. Synchronization In Go, synchronization is essential for ensuring safe concurrent execution of code and coordinating the activities of multiple goroutines. Go provides various synchronization primitives and constructs to facilitate communication between goroutines, protect access to shared resources, and manage concurrent execution. Here&#8217;s a comprehensive introduction to synchronization in Go: [Azure Open AI | ChatGPT4] 8.8.1. Channels Channels are the primary synchronization mechanism in Go and are used for communication between goroutines. They allow goroutines to send and receive values, which can be used for signaling or passing data. Channels provide a way to synchronize the execution of goroutines and ensure that data is safely shared without race conditions. // Creating a channel ch := make(chan int) // Sending a value to a channel ch &lt;- 42 // Receiving a value from a channel value := &lt;-ch Semaphores in Go? Go does not provide semaphores as a dedicated primitive like sync.Mutex . Instead, they can be implemented using buffered channels. Semaphores are used to control access to a limited number of resources or to limit the degree of concurrency for a group of goroutines. Here&#8217;s an example of how to implement a semaphore using a buffered channel in Go: const maxConcurrent = 3 func main() { var wg sync.WaitGroup // Create a buffered channel to act as a semaphore semaphore := make(chan struct{}, maxConcurrent) // Simulate 10 tasks that need to be executed concurrently for i := 1; i &lt;= 10; i++ { wg.Add(1) go func(taskID int) { defer wg.Done() // Acquire the semaphore semaphore &lt;- struct{}{} // Execute the task fmt.Printf(&quot;Task %d started\\n&quot;, taskID) time.Sleep(1 * time.Second) fmt.Printf(&quot;Task %d completed\\n&quot;, taskID) // Release the semaphore &lt;-semaphore }(i) } wg.Wait() } 8.8.2. sync.Mutex A Mutex (short for &quot;mutual exclusion&quot;, /ˈmjuːtɛks/) is a synchronization primitive used to protect access to shared resources and ensure that only one goroutine can access the resource at a time. Mutexes help prevent race conditions when multiple goroutines attempt to modify shared state concurrently. num := 0 var mu sync.Mutex var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() mu.Lock() defer mu.Unlock() for i := 0; i &lt; 100_000; i++ { num += 1 } }() go func() { defer wg.Done() mu.Lock() defer mu.Unlock() locked := mu.TryLock() if locked { defer mu.Unlock() fmt.Println(&quot;recursive lock!&quot;) } else { fmt.Println(&quot;not recursive lock!&quot;) } for i := 0; i &lt; 100_000; i++ { num += 1 } }() wg.Wait() fmt.Println(num) // 200000 // Output: // not recursive lock! // 200000 8.8.3. sync.RWMutex An RWMutex (short for &quot;read-write mutex&quot;) is similar to a Mutex but allows multiple readers to access a shared resource simultaneously, as long as no writer is accessing it. It provides two separate locks: a read lock and a write lock. Multiple goroutines can acquire read locks at the same time, but only one can acquire a write lock, and it must wait for all read locks to be released. type ConcurrentMap[TKey comparable, TValue any] struct { m map[TKey]TValue rwMu sync.RWMutex } func New[TKey comparable, TValue any]() *ConcurrentMap[TKey, TValue] { return &amp;ConcurrentMap[TKey, TValue]{m: make(map[TKey]TValue)} } func (q *ConcurrentMap[TKey, TValue]) Add(key TKey, value TValue) { q.rwMu.Lock() defer q.rwMu.Unlock() q.m[key] = value } func (q *ConcurrentMap[TKey, TValue]) Remove(key TKey) { q.rwMu.Lock() defer q.rwMu.Unlock() delete(q.m, key) } func (q *ConcurrentMap[TKey, TValue]) TryGet(key TKey) (item TValue, ok bool) { q.rwMu.RLock() defer q.rwMu.RUnlock() item, ok = q.m[key] return } 8.8.4. sync.WaitGroup A WaitGroup is a synchronization construct used to wait for a collection of goroutines to finish execution, that is often used when you start multiple goroutines to perform tasks concurrently and need to wait for all of them to complete before proceeding. var num int32 var wg sync.WaitGroup // define a WaitGroup wg.Add(2) // add delta, which may be negative, to the WaitGroup counter. go func() { defer wg.Done() // decrement the WaitGroup counter by one. for i := 0; i &lt; 10_000; i++ { if i%2 == 0 { atomic.AddInt32(&amp;num, 1) } } }() go func() { defer wg.Done() for i := 0; i &lt; 10_000; i++ { if i%2 == 1 { atomic.AddInt32(&amp;num, 1) } } }() wg.Wait() // block until the WaitGroup counter is zero. fmt.Println(num) // 10_000 8.8.5. sync.Cond A Cond (short for &quot;condition&quot;) is a synchronization primitive used to wait for or signal conditions. It is useful when one or more goroutines need to wait for a specific condition to be met before they can proceed. Conds are often used with a Mutex or RWMutex to protect access to the shared state being tested in the condition. type BlockingChannel[T any] struct { items []T c *sync.Cond mu *sync.Mutex // explicit mutex for clarity } func New[T any](capacity int) *BlockingChannel[T] { mu := &amp;sync.Mutex{} return &amp;BlockingChannel[T]{ items: make([]T, 0, capacity), c: sync.NewCond(mu), // create a new condition variable associated with the mutex mu: mu, // store the mutex } } func (bc *BlockingChannel[T]) Write(item T) { bc.c.L.Lock() // acquire the lock before accessing shared resources defer bc.c.L.Unlock() // ensure the lock is released when the function returns for len(bc.items) == cap(bc.items) { // wait if the channel is full bc.c.Wait() // release the lock and wait for a signal } bc.items = append(bc.items, item) // add the item to the channel bc.c.Signal() // Signal a waiting reader that an item is available. } func (bc *BlockingChannel[T]) Read() T { bc.c.L.Lock() defer bc.c.L.Unlock() for len(bc.items) == 0 { // wait if the channel is empty bc.c.Wait() // release the lock and wait for a signal } n := len(bc.items) item := bc.items[n-1] bc.items = bc.items[:n-1] bc.c.Broadcast() // Signal all waiting writers that space is available return item } 8.8.6. sync.Once A Once is a synchronization construct used to ensure that a function is only executed once, regardless of how many goroutines attempt to call it, that is useful for initializing shared resources, such as global variables or singletons, in a concurrent environment. // Defining a Once var once sync.Once // Executing a function only once, regardless of how many goroutines call it once.Do(func() { // initialize shared resource }) 8.8.7. sync.Map A Map is a concurrent, thread-safe map implementation provided by the sync package. It is designed for cases where the number of keys is large and their lifetimes are mostly unknown. Unlike the built-in map type, sync.Map provides safe concurrent access without requiring an additional synchronization mechanism like a Mutex. // Defining a sync.Map var m sync.Map // Storing a value in sync.Map m.Store(&quot;key&quot;, &quot;value&quot;) // Loading a value from sync.Map value, ok := m.Load(&quot;key&quot;) // Deleting a value from sync.Map m.Delete(&quot;key&quot;) // Iterating over sync.Map m.Range(func(key, value interface{}) bool { fmt.Printf(&quot;key: %v, value: %v\\n&quot;, key, value) return true }) 8.8.8. sync/atomic package atomic // import &quot;sync/atomic&quot; Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don&#39;t communicate by sharing memory. BUG: On 386, the 64-bit functions use instructions unavailable before the Pentium MMX. On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. On ARM, 386, and 32-bit MIPS, it is the caller&#39;s responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically via the primitive atomic functions (types [Int64] and [Uint64] are automatically aligned). The first word in an allocated struct, array, or slice; in a global variable; or in a local variable (because on 32-bit architectures, the subject of 64-bit atomic operations will escape to the heap) can be relied upon to be 64-bit aligned. Share memory by communicating; don&#8217;t communicate by sharing memory. For most synchronization needs, Go&#8217;s channels and the sync package (e.g., sync.Mutex, sync.WaitGroup, sync.Cond) provide safer and easier-to-use abstractions. Channels provide a more structured and less error-prone way to synchronize concurrent operations. 9. Errors Library routines must often return some sort of error indication to the caller. Go&#8217;s multi-value return makes it a good style to easily return a detailed error description alongside the normal return value. The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error, typically created using fmt.Errorf or errors.New. When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. func main() { defer func() { if r := recover(); r != nil { fmt.Printf(&quot;recoverd: %v\\n&quot;, r) err := r.(error) foo := errors.Unwrap(err) fmt.Printf(&quot;inner error: %v\\n&quot;, foo) } }() fi, err := os.Open(&quot;hello.txt&quot;) if err != nil { if pe, ok := err.(*os.PathError); ok { fmt.Printf(&quot;path error: %v\\n&quot;, pe) } else { fmt.Printf(&quot;unknown error: %v\\n&quot;, pe) } } defer fi.Close() err = errors.New(&quot;bar&quot;) err = fmt.Errorf(&quot;foo: %w&quot;, err) // wrap an inner error panic(err) } // path error: open hello.txt: no such file or directory // recoverd: foo: bar // inner error: bar The panic built-in function stops normal execution of the current goroutine, and the recover built-in function allows a program to manage behavior of a panicking goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G&#8217;s execution and running any deferred functions, until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. func F() { err := errors.New(&quot;F: panic&quot;) panic(err) } func G() { defer func() { if r := recover(); r != nil { err := fmt.Errorf(&quot;G: %w&quot;, r) panic(err) } }() F() } func main() { defer func() { if r := recover(); r != nil { fmt.Println(r) } }() G() } // G: F: panic 10. Testing The go test subcommand is a test driver for Go packages that are organized according to certain conventions. In a package directory, files whose names end with _test.go are not part of the package ordinarily built by go build but are a part of it when built by go test. Within _test.go files, four kinds of functions are treated specially: tests, fuzzs, benchmarks, and examples. A test function, which is a function whose name begins with Test exercises some program logic for correct behavior; go test calls the test function and report the result, which is either PASS or FAIL. With fuzzing, random data is run against your test in an attempt to find vulnerabilities or crash-causing inputs. A benchmark function has a name beginning with Benchmark and measures the performance of some operation; go test reports the mean execution time of the operation. And an example function, whose name starts with Example, provides machine-checked documentation. func Foo(s string) string { return s } func TestFoo(t *testing.T) { var tests = []struct { s string want string }{ {&quot;Hello&quot;, &quot;Hello&quot;}, {&quot;世界!&quot;, &quot;世界!&quot;}, } for _, test := range tests { if got := Foo(test.s); got != test.want { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, test.s, got, test.want) } } } // Fuzz test func FuzzFoo(f *testing.F) { // Seed corpus addition f.Add(&quot;hello&quot;) // Fuzz target f.Fuzz(func(t *testing.T, s string) { // s string // Fuzzing arguments if got := Foo(s); got != s { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, s, got, s) } }) } func BenchmarkFoo(b *testing.B) { for n := 0; n &lt; b.N; n++ { } } func ExampleFoo() { fmt.Println(&quot;BAR&quot;) // Output: // BAR } $ GO111MODULE=off go test PASS ok _/tmp/learn-notes 0.003s $ GO111MODULE=off go test -fuzz=Fuzz -fuzztime=3s fuzz: elapsed: 0s, gathering baseline coverage: 0/1 completed fuzz: elapsed: 0s, gathering baseline coverage: 1/1 completed, now fuzzing with 4 workers fuzz: elapsed: 3s, execs: 226192 (75387/sec), new interesting: 0 (total: 1) fuzz: elapsed: 3s, execs: 226192 (0/sec), new interesting: 0 (total: 1) PASS ok _/tmp/learn-notes 3.127s $ GO111MODULE=off go test -bench=.* goos: linux goarch: amd64 cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz BenchmarkFoo-4 1000000000 0.5349 ns/op PASS ok _/tmp/learn-notes 0.605s 11. Modules Go 1.11 and 1.12 include preliminary support for modules, Go’s new dependency management system that makes dependency version information explicit and easier to manage.[2] GOPATH and GO111MODULE: New module changes in Go 1.16 The go command now builds packages in module-aware mode by default, even when no go.mod is present. This is a big step toward using modules in all projects. It’s still possible to build packages in GOPATH mode by setting the GO111MODULE environment variable to off. You can also set GO111MODULE to auto to enable module-aware mode only when a go.mod file is present in the current directory or any parent directory. This was previously the default. Note that you can set GO111MODULE and other variables permanently with go env -w: go env -w GO111MODULE=auto We plan to drop support for GOPATH mode in Go 1.17. In other words, Go 1.17 will ignore GO111MODULE. If you have projects that do not build in module-aware mode, now is the time to migrate. In Go, if an old package and a new package have the same import path, the new package must be backwards compatible with the old package. There is certainly a cost to needing to introduce a new name for each backwards-incompatible API change, but as the semver FAQ says, that cost should encourage authors to more clearly consider the impact of such changes and whether they are truly necessary. A module path is the canonical name for a module, declared with the module directive in the module’s go.mod file. A module’s path is the prefix for package paths within the module. A module path should describe both what the module does and where to find it. Typically, a module path consists of a repository root path, a directory within the repository (usually empty), and a major version suffix (only for major version 2 or higher). [4] A module is a collection of related Go packages that are versioned together as a single unit. Modules record precise dependency requirements and create reproducible builds. Most often, a version control repository contains exactly one module defined in the repository root. Summarizing the relationship between repositories, modules, and packages: A repository contains one or more Go modules. Each module contains one or more Go packages. Each package consists of one or more Go source files in a single directory. Modules must be semantically versioned according to semver, usually in the form v(major).(minor).(patch), such as v0.1.0, v1.2.3, or v1.5.0-rc.1. The leading v is required. If using Git, tag released commits with their versions. A module is defined by a tree of Go source files with a go.mod file in the tree&#8217;s root directory. A module declares its identity in its go.mod via the module directive, which provides the module path. The import paths for all packages in a module share the module path as a common prefix. The module path and the relative path from the go.mod to a package&#8217;s directory together determine a package&#8217;s import path. In Go source code, packages are imported using the full path including the module path. go help modules go help go.mod go help module-private go help goproxy go env GOPROXY # https://proxy.golang.org,direct go env -w GOPROXY=https://goproxy.cn,direct go env GOPROXY # https://goproxy.cn,direct go help gopath 12. Printf Package fmt implements formatted I/O with functions analogous to C&#8217;s printf and scanf.[16] 12.1. The Printing verbs General: %v the value in a default format when printing structs, the plus flag (%+v) adds field names %#v a Go-syntax representation of the value %T a Go-syntax representation of the type of the value %% a literal percent sign; consumes no value type Pointer struct { X int Y int } func main() { p := Pointer{3, 4} fmt.Printf(&quot;%%v: %v\\n&quot;, p) fmt.Printf(&quot;%%+v: %+v\\n&quot;, p) fmt.Printf(&quot;%%#v: %#v\\n&quot;, p) fmt.Printf(&quot;%%T: %T\\n&quot;, p) } // Output: // %v: {3 4} // %+v: {X:3 Y:4} // %#v: main.Pointer{X:3, Y:4} // %T: main.Pointer Boolean: %t the word true or false Integer: %b base 2 %c the character represented by the corresponding Unicode code point %d base 10 %o base 8 %O base 8 with 0o prefix %q a single-quoted character literal safely escaped with Go syntax. %x base 16, with lower-case letters for a-f %X base 16, with upper-case letters for A-F %U Unicode format: U+1234; same as &quot;U+%04X&quot; func main() { n := 1234 fmt.Printf(&quot;%%b: %b\\n&quot;, n) fmt.Printf(&quot;%%c: %c\\n&quot;, n) fmt.Printf(&quot;%%d: %d\\n&quot;, n) fmt.Printf(&quot;%%o: %o\\n&quot;, n) fmt.Printf(&quot;%%O: %O\\n&quot;, n) fmt.Printf(&quot;%%q: %q\\n&quot;, n) fmt.Printf(&quot;%%x: %x\\n&quot;, n) fmt.Printf(&quot;%%X: %X\\n&quot;, n) fmt.Printf(&quot;%%U: %U\\n&quot;, n) } // Output: // %b: 10011010010 // %c: Ӓ // %d: 1234 // %o: 2322 // %O: 0o2322 // %q: &#39;Ӓ&#39; // %x: 4d2 // %X: 4D2 // %U: U+04D2 Floating-point and complex constituents: %b decimalless scientific notation with exponent a power of two, in the manner of strconv.FormatFloat with the &#39;b&#39; format, e.g. -123456p-78 %e scientific notation, e.g. -1.234456e+78 %E scientific notation, e.g. -1.234456E+78 %f decimal point but no exponent, e.g. 123.456 %F synonym for %f %g %e for large exponents, %f otherwise. Precision is discussed below. %G %E for large exponents, %F otherwise %x hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20 %X upper-case hexadecimal notation, e.g. -0X1.23ABCP+20 func main() { n := -123456.789 fmt.Printf(&quot;%%b: %b\\n&quot;, n) fmt.Printf(&quot;%%e: %e\\n&quot;, n) fmt.Printf(&quot;%%E: %E\\n&quot;, n) fmt.Printf(&quot;%%f: %f\\n&quot;, n) fmt.Printf(&quot;%%F: %F\\n&quot;, n) fmt.Printf(&quot;%%g: %g\\n&quot;, n) fmt.Printf(&quot;%%G: %G\\n&quot;, n) fmt.Printf(&quot;%%x: %x\\n&quot;, n) fmt.Printf(&quot;%%X: %X\\n&quot;, n) } // Output: // %b: -8483885939586761p-36 // %e: -1.234568e+05 // %E: -1.234568E+05 // %f: -123456.789000 // %F: -123456.789000 // %g: -123456.789 // %G: -123456.789 // %x: -0x1.e240c9fbe76c9p+16 // %X: -0X1.E240C9FBE76C9P+16 String and slice of bytes (treated equivalently with these verbs): %s the uninterpreted bytes of the string or slice %q a double-quoted string safely escaped with Go syntax %x base 16, lower-case, two characters per byte %X base 16, upper-case, two characters per byte Slice: %p address of 0th element in base 16 notation, with leading 0x Pointer: %p base 16 notation, with leading 0x The %b, %d, %o, %x and %X verbs also work with pointers, formatting the value exactly as if it were an integer. The default format for %v is: bool: %t int, int8 etc.: %d uint, uint8 etc.: %d, %#x if printed with %#v float32, complex64, etc: %g string: %s chan: %p pointer: %p For compound objects, the elements are printed using these rules, recursively, laid out like this: struct: {field0 field1 ...} array, slice: [elem0 elem1 ...] maps: map[key1:value1 key2:value2 ...] pointer to above: &amp;{}, &amp;[], &amp;map[] Other flags: &#39;+&#39; always print a sign for numeric values; guarantee ASCII-only output for %q (%+q) &#39;-&#39; pad with spaces on the right rather than the left (left-justify the field) &#39;#&#39; alternate format: add leading 0b for binary (%#b), 0 for octal (%#o), 0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p); for %q, print a raw (backquoted) string if strconv.CanBackquote returns true; always print a decimal point for %e, %E, %f, %F, %g and %G; do not remove trailing zeros for %g and %G; write e.g. U+0078 &#39;x&#39; if the character is printable for %U (%#U). &#39; &#39; (space) leave a space for elided sign in numbers (% d); put spaces between bytes printing strings or slices in hex (% x, % X) &#39;0&#39; pad with leading zeros rather than spaces; for numbers, this moves the padding after the sign; ignored for strings, byte slices and byte arrays func main() { n := 123 fmt.Printf(&quot;%+06d\\n&quot;, n) } // Output: // +00123 12.2. Width and Precision Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. %f default width, default precision %9f width 9, default precision %.2f default width, precision 2 %9.2f width 9, precision 2 %9.f width 9, precision 0 12.3. Stringer type Stringer interface { String() string } Stringer is implemented by any value that has a String method, which defines the &quot;native&quot; format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. // Animal has a Name and an Age to represent an animal. type Animal struct { Name string Age uint } // String makes Animal satisfy the Stringer interface. func (a Animal) String() string { return fmt.Sprintf(&quot;%v (%d)&quot;, a.Name, a.Age) } func main() { a := Animal{ Name: &quot;Gopher&quot;, Age: 2, } fmt.Println(a) // Output: // Gopher (2) } References [1] https://go.dev/blog/maps [2] https://go.dev/blog/using-go-modules [3] https://go.dev/blog/strings [4] https://go.dev/ref/mod [5] Capturing Iteration Variables in Go Language [6] https://groups.google.com/g/golang-nuts/c/pZwdYRGxCIk/m/qpbHxRRPJdUJ [7] Practical Go: Real world advice for writing maintainable Go programs [8] https://go.dev/doc/effective_go.html [9] Errors in Go language [10] Goroutines and Channels in Go Language [11] Object-oriented Programming in Go Language [12] Testing in Go Language [13] https://semver.org/ [14] https://stackoverflow.com/questions/24790175/when-is-the-init-function-run [15] https://medium.com/@adiach3nko/package-management-with-go-modules-the-pragmatic-guide-c831b4eaaf31 [16] https://pkg.go.dev/fmt [17] https://go.dev/ref/mem [18] Concurrency with Shared Variables in Go Language [19] https://go.dev/ref/spec#Iota [20] https://talks.golang.org/2012/concurrency.slide [21] https://go.dev/tour/generics/1 [22] https://research.swtch.com/vgo-import [23] https://research.swtch.com/vgo-module [24] https://research.swtch.com/vgo-mvs [25] https://github.com/golang/go/wiki/Iota [26] https://github.com/golang/go/wiki/Modules","headline":"Golang Learning Notes","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2020/04/07/golang-learning-notes/"},"url":"https://blog.codefarm.me/2020/04/07/golang-learning-notes/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Golang Learning Notes</h1><p class="c-post-meta">17 Aug 2023</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#foramtting">1. Foramtting</a></li>
<li><a href="#commentary">2. Commentary</a></li>
<li><a href="#names">3. Names</a>
<ul class="sectlevel2">
<li><a href="#package-names">3.1. Package names</a></li>
<li><a href="#getters">3.2. Getters</a></li>
<li><a href="#interface-names">3.3. Interface names</a></li>
<li><a href="#mixedcaps">3.4. MixedCaps</a></li>
</ul>
</li>
<li><a href="#semicolons">4. Semicolons</a></li>
<li><a href="#control-structures">5. Control structures</a>
<ul class="sectlevel2">
<li><a href="#if">5.1. If</a></li>
<li><a href="#for">5.2. For</a></li>
<li><a href="#switch">5.3. Switch</a></li>
<li><a href="#type-switch">5.4. Type Switch</a></li>
<li><a href="#select">5.5. Select</a></li>
<li><a href="#break-continue-and-goto">5.6. Break, Continue and Goto</a></li>
<li><a href="#fallthrough">5.7. Fallthrough</a></li>
<li><a href="#defer">5.8. Defer</a></li>
</ul>
</li>
<li><a href="#data-types">6. Data types</a>
<ul class="sectlevel2">
<li><a href="#type">6.1. Type</a></li>
<li><a href="#variables">6.2. Variables</a></li>
<li><a href="#strings-bytes-runes-and-characters">6.3. Strings, bytes, runes and characters</a></li>
<li><a href="#pointers">6.4. Pointers</a></li>
<li><a href="#structs">6.5. Structs</a></li>
<li><a href="#arrays">6.6. Arrays</a></li>
<li><a href="#slices">6.7. Slices</a></li>
<li><a href="#maps">6.8. Maps</a></li>
<li><a href="#functions">6.9. Functions</a></li>
<li><a href="#methods">6.10. Methods</a></li>
<li><a href="#interfaces">6.11. Interfaces</a></li>
<li><a href="#embedding-interfaces-and-structs">6.12. Embedding: interfaces and structs</a></li>
<li><a href="#channels">6.13. Channels</a></li>
<li><a href="#type-conversions">6.14. Type conversions</a></li>
<li><a href="#generics">6.15. Generics</a></li>
</ul>
</li>
<li><a href="#initialization">7. Initialization</a>
<ul class="sectlevel2">
<li><a href="#constants">7.1. Constants</a></li>
<li><a href="#allocation-new-and-make">7.2. Allocation: new and make</a></li>
<li><a href="#the-init-function">7.3. The init function</a></li>
<li><a href="#zero-values">7.4. Zero values</a></li>
</ul>
</li>
<li><a href="#concurrency">8. Concurrency</a>
<ul class="sectlevel2">
<li><a href="#race-conditions">8.1. Race Conditions</a></li>
<li><a href="#race-detector">8.2. Race Detector</a></li>
<li><a href="#happen-before">8.3. Happen before</a></li>
<li><a href="#share-by-communicating">8.4. Share by communicating</a></li>
<li><a href="#goroutines">8.5. Goroutines</a></li>
<li><a href="#channels-2">8.6. Channels</a></li>
<li><a href="#parallelization">8.7. Parallelization</a></li>
<li><a href="#synchronization">8.8. Synchronization</a>
<ul class="sectlevel3">
<li><a href="#channels-3">8.8.1. Channels</a></li>
<li><a href="#sync-mutex">8.8.2. sync.Mutex</a></li>
<li><a href="#sync-rwmutex">8.8.3. sync.RWMutex</a></li>
<li><a href="#sync-waitgroup">8.8.4. sync.WaitGroup</a></li>
<li><a href="#sync-cond">8.8.5. sync.Cond</a></li>
<li><a href="#sync-once">8.8.6. sync.Once</a></li>
<li><a href="#sync-map">8.8.7. sync.Map</a></li>
<li><a href="#syncatomic">8.8.8. sync/atomic</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#errors">9. Errors</a></li>
<li><a href="#testing">10. Testing</a></li>
<li><a href="#modules">11. Modules</a></li>
<li><a href="#printf">12. Printf</a>
<ul class="sectlevel2">
<li><a href="#the-printing-verbs">12.1. The Printing verbs</a></li>
<li><a href="#width-and-precision">12.2. Width and Precision</a></li>
<li><a href="#stringer">12.3. Stringer</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="foramtting">1. Foramtting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With Go we take an unusual approach and let the machine take care of most formatting issues. The <code>gofmt</code> program (also available as <code>go fmt</code>, which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>formatting.go
<span class="go">package formatting
type T struct {

        name string // name of the object
            value int // its value
        }</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go <span class="nb">fmt </span>formatting.go <span class="c"># or gofmt -w formatting.go</span>
formatting.go</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>formatting.go
<span class="go">package formatting

type T struct {
    name  string // name of the object
    value int    // its value
}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="commentary">2. Commentary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Go provides C-style <code>/* */</code> block comments and C&#43;&#43;-style <code>//</code> line comments.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code.</p>
</li>
<li>
<p>Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Println formats using the default formats for its operands and writes to standard output.</span>
<span class="c">// Spaces are always added between operands and a newline is appended.</span>
<span class="c">// It returns the number of bytes written and any write error encountered.</span>
<span class="k">func</span> <span class="n">Println</span><span class="p">(</span><span class="n">a</span> <span class="o">...</span><span class="n">any</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Fprintln</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="n">a</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The command <code>go doc</code> is used to display documentation for Go packages, functions, or types directly in the terminal.</p>
<div class="ulist">
<ul>
<li>
<p>When run with one argument, the argument is treated as a Go-syntax-like representation of the item to be documented.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">go doc &lt;pkg&gt;                            <span class="c"># go doc net/http</span>
go doc &lt;sym&gt;[.&lt;methodOrField&gt;]          <span class="c"># go doc http.Request.Write</span>
go doc <span class="o">[</span>&lt;pkg&gt;.]&lt;sym&gt;[.&lt;methodOrField&gt;]  <span class="c"># go doc net/http.Request.Write</span>
go doc <span class="o">[</span>&lt;pkg&gt;.][&lt;sym&gt;.]&lt;methodOrField&gt;  <span class="c"># go doc net/http.Write</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go doc builtin.new
<span class="go">package builtin // import "builtin"

func new(Type) *Type
    The new built-in function allocates memory. The first argument is a type,
    not a value, and the value returned is a pointer to a newly allocated zero
    value of that type.</span></code></pre>
</div>
</div>
</li>
<li>
<p>When run with two arguments, the first is a package path (full path or suffix), and the second is a symbol, or symbol with method or struct field:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;methodOrField&gt;]    <span class="c"># go doc net/http Request.Write</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go doc <span class="nb">sync </span>Mutex
<span class="go">package sync // import "sync"

type Mutex struct {
    // Has unexported fields.
}
    A Mutex is a mutual exclusion lock. The zero value for a Mutex is an
    unlocked mutex.

    A Mutex must not be copied after first use.

func (m *Mutex) Lock()
func (m *Mutex) Unlock()</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>godoc</code> is a tool used to either generate HTML documentation or serve it through a local web server.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">godoc <span class="nt">-http</span><span class="o">=</span>:6060</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="names">3. Names</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The visibility of a name outside a package is determined by whether its first character is upper case.</p>
</div>
<div class="sect2">
<h3 id="package-names">3.1. Package names</h3>
<div class="ulist">
<ul>
<li>
<p>By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps.</p>
</li>
<li>
<p>Another convention is that the package name is the base name of its source directory; the package in <code>src/encoding/base64</code> is imported as "<code class="code">encoding/base64</code>" but has name <code>base64</code>, not <code>encoding_base64</code> and not <code>encodingBase64</code>.</p>
</li>
<li>
<p>Use the package structure to help you choose good names.</p>
<div class="ulist">
<ul>
<li>
<p>The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter.</p>
<div class="paragraph">
<p>For instance, the buffered reader type in the <code>bufio</code> package is called <code>Reader</code>, not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>, which is a clear, concise name.</p>
</div>
</li>
<li>
<p>Moreover, because imported entities are always addressed with their package name, <code>bufio.Reader</code> does not conflict with <code>io.Reader</code>.</p>
</li>
<li>
<p>Similarly, the function to make new instances of <code>ring.Ring</code>—which is the definition of a constructor in Go—would normally be called <code>NewRing</code>, but since <code>Ring</code> is the only type exported by the package, and since the package is called <code>ring</code>, it&#8217;s called just <code>New</code>, which clients of the package see as <code>ring.New</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="getters">3.2. Getters</h3>
<div class="ulist">
<ul>
<li>
<p>Go doesn&#8217;t provide automatic support for getters and setters.</p>
</li>
<li>
<p>There&#8217;s nothing wrong with providing getters and setters yourself, and it&#8217;s often appropriate to do so, but it&#8217;s neither idiomatic nor necessary to put <code>Get</code> into the getter&#8217;s name.</p>
</li>
<li>
<p>If you have a field called <code>owner</code> (lower case, unexported), the getter method should be called <code>Owner</code> (upper case, exported), not <code>GetOwner</code>.</p>
</li>
<li>
<p>A setter function, if needed, will likely be called <code>SetOwner</code>.</p>
</li>
<li>
<p>Both names read well in practice:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">owner</span> <span class="o">:=</span> <span class="n">obj</span><span class="o">.</span><span class="n">Owner</span><span class="p">()</span>
<span class="k">if</span> <span class="n">owner</span> <span class="o">!=</span> <span class="n">user</span> <span class="p">{</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="interface-names">3.3. Interface names</h3>
<div class="ulist">
<ul>
<li>
<p>By convention, one-method interfaces are named by the method name plus an <code>-er</code> suffix or similar modification to construct an agent noun: <code>Reader</code>, <code>Writer</code>, <code>Formatter</code>, <code>CloseNotifier</code> etc.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>type ReadWriter interface {
	Reader
	Writer
}</code></pre>
</div>
</div>
</li>
<li>
<p>There are a number of such names and it&#8217;s productive to honor them and the function names they capture.</p>
</li>
<li>
<p><code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>, <code>String</code> and so on have canonical signatures and meanings.</p>
<div class="ulist">
<ul>
<li>
<p>To avoid confusion, don&#8217;t give your method one of those names unless it has the same signature and meaning.</p>
</li>
<li>
<p>Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method <code>String</code> not <code>ToString</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="mixedcaps">3.4. MixedCaps</h3>
<div class="paragraph">
<p>Finally, the convention in Go is to use <code>MixedCaps</code> or <code>mixedCaps</code> rather than underscores to write multiword names.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="semicolons">4. Semicolons</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Like C, Go&#8217;s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source.</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>If the newline comes after a token that could end a statement, insert a semicolon.</p>
</div>
</blockquote>
</div>
</li>
<li>
<p>Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the initializer, condition, and continuation elements.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>They are also necessary to separate multiple statements on a line, should you write code that way.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="control-structures">5. Control structures</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>There is no <code>do</code> or <code>while</code> loop, only a slightly generalized <code>for</code>; <code>switch</code> is more flexible;</p>
</li>
<li>
<p><code>if</code> and <code>switch</code> accept an optional initialization statement like that of <code>for</code>;</p>
</li>
<li>
<p><code>break</code> and <code>continue</code> statements take an optional label to identify what to break or continue;</p>
</li>
<li>
<p>and there are new control structures including a <em>type switch</em> and a <em>multiway communications multiplexer</em>, <code>select</code>.</p>
</li>
<li>
<p>There are no parentheses and the bodies must always be brace-delimited.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="if">5.1. If</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">y</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">err</span><span class="o">:</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="for">5.2. For</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Like a C for</span>
<span class="k">for</span> <span class="n">init</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">post</span> <span class="p">{</span> <span class="p">}</span>

<span class="c">// Like a C while</span>
<span class="k">for</span> <span class="n">condition</span> <span class="p">{</span> <span class="p">}</span>

<span class="c">// Like a C for(;;)</span>
<span class="k">for</span> <span class="p">{</span> <span class="p">}</span>

<span class="c">// Like a C do-while</span>
<span class="k">for</span> <span class="p">{</span>
    <span class="c">// do something</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">;</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re looping over an array, slice, string, or map, or reading from a channel, a <code>range</code> clause can manage the loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="k">map</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c">// If you only need the second item in the range (the value),</span>
<span class="c">// use the blank identifier, an underscore, to discard the first:</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="k">map</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">array</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">channel</span> <span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For strings, the <code>range</code> does more work for you, breaking out individual Unicode code points by parsing the UTF-8.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Erroneous encodings consume one byte and produce the replacement rune U+FFFD.</p>
</li>
<li>
<p>The name (with associated builtin type) <code>rune</code> is Go terminology for a single Unicode code point.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">"日本</span><span class="se">\x80</span><span class="s">語"</span> <span class="p">{</span> <span class="c">// \x80 is an illegal UTF-8 encoding</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"character %#U starts at byte position %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">char</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// Output:</span>
<span class="c">// character U+65E5 '日' starts at byte position 0</span>
<span class="c">// character U+672C '本' starts at byte position 3</span>
<span class="c">// character U+FFFD '�' starts at byte position 6</span>
<span class="c">// character U+8A9E '語' starts at byte position 7</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Go has no comma operator and <code>++</code> and <code>--</code> are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes &#43;&#43; and --).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Reverse a</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="switch">5.3. Switch</h3>
<div class="paragraph">
<p>Go&#8217;s switch is more general than C&#8217;s.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The expressions need not be constants or even integers,</p>
</li>
<li>
<p>the cases are evaluated top to bottom until a match is found,</p>
</li>
<li>
<p>and if the <code>switch</code> has no expression it switches on <code>true</code>.</p>
</li>
<li>
<p>It&#8217;s therefore possible&#8212;&#8203;and idiomatic&#8212;&#8203;to write an <code>if-else-if-else</code> chain as a <code>switch</code>.</p>
</li>
<li>
<p>There is no automatic fall through, but cases can be presented in comma-separated lists.</p>
</li>
<li>
<p>Although they are not nearly as common in Go as some other C-like languages, <code>break</code> statements can be used to terminate a <code>switch</code> early.</p>
</li>
<li>
<p>Sometimes, though, it&#8217;s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and "breaking" to that label.</p>
</li>
<li>
<p>Of course, the <code>continue</code> statement also accepts an optional label but it applies only to loops.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">switch</span> <span class="n">os</span> <span class="o">:=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOOS</span><span class="p">;</span> <span class="n">os</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">"darwin"</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"OS X."</span><span class="p">)</span>
<span class="k">case</span> <span class="s">"linux"</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Linux."</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
	<span class="c">// freebsd, openbsd,</span>
	<span class="c">// plan9, windows...</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">os</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">Loop</span><span class="o">:</span>
    <span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">);</span> <span class="n">n</span> <span class="o">+=</span> <span class="n">size</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sizeOne</span><span class="o">:</span>
            <span class="k">if</span> <span class="n">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">size</span> <span class="o">=</span> <span class="m">1</span>
            <span class="n">update</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">case</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sizeTwo</span><span class="o">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="m">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">errShortInput</span>
                <span class="k">break</span> <span class="n">Loop</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">size</span> <span class="o">=</span> <span class="m">2</span>
            <span class="n">update</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="type-switch">5.4. Type Switch</h3>
<div class="paragraph">
<p>A switch can also be used to discover the dynamic type of an interface variable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Such a <em>type switch</em> uses the syntax of a <em>type assertion</em> with the keyword <code>type</code> inside the parentheses.</p>
</li>
<li>
<p>If the switch declares a variable in the expression, the variable will have the corresponding type in each clause.</p>
</li>
<li>
<p>It&#8217;s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">t</span> <span class="k">interface</span><span class="p">{}</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">functionOfSomeType</span><span class="p">()</span>
<span class="k">switch</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">default</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"unexpected type %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c">// %T prints whatever type t has</span>
<span class="k">case</span> <span class="kt">bool</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"boolean %t</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c">// t has type bool</span>
<span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"integer %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c">// t has type int</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">bool</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"pointer to boolean %t</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c">// t has type *bool</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">int</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"pointer to integer %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c">// t has type *int</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="select">5.5. Select</h3>
<div class="paragraph">
<p>The <code>select</code> statement lets a goroutine wait on multiple communication operations.</p>
</div>
<div class="paragraph">
<p>A <code>select</code> blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.</p>
</div>
<div class="paragraph">
<p>The <code>default</code> case in a <code>select</code> is run if no other case is ready.</p>
</div>
<div class="paragraph">
<p>Use a <code>default</code> case to try a send or receive without blocking:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">tick</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Tick</span><span class="p">(</span><span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="n">boom</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">500</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">tick</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"tick."</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">boom</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"    ."</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">50</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="break-continue-and-goto">5.6. Break, Continue and Goto</h3>
<div class="paragraph">
<p>A <code>break</code> statement terminates execution of the <strong>innermost</strong> <code>for</code>, <code>switch</code>, or <code>select</code> statement within the same function.</p>
</div>
<div class="paragraph">
<p>A <code>continue</code> statement begins the next iteration of the <strong>innermost</strong> <code>for</code> loop at its post statement within the same function.</p>
</div>
<div class="paragraph">
<p>A <code>goto</code> statement transfers control to the statement with the corresponding <strong>label</strong> within the same function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">tick</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Tick</span><span class="p">(</span><span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="n">boom</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">500</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>

<span class="n">RawLoop</span><span class="o">:</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">tick</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"tick."</span><span class="p">)</span>
			<span class="k">continue</span> <span class="n">RawLoop</span> <span class="c">// go to the next iteration</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">boom</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span>
			<span class="k">break</span> <span class="n">RawLoop</span> <span class="c">// exit</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">".   ."</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">50</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">RawLoop</span> <span class="c">// go back to the very beginning</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fallthrough">5.7. Fallthrough</h3>
<div class="paragraph">
<p>A <code>fallthrough</code> statement transfers control to the first statement of the next case clause in an expression <code>switch</code> statement. It may be used only as the final non-empty statement in such a clause.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">switch</span> <span class="p">{</span>
<span class="k">case</span> <span class="m">10</span> <span class="o">&gt;</span> <span class="m">11</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"10 &gt; 11"</span><span class="p">)</span>
<span class="k">case</span> <span class="m">1</span> <span class="o">&lt;</span> <span class="m">5</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"1 &lt; 5"</span><span class="p">)</span>
	<span class="k">fallthrough</span>
<span class="k">case</span> <span class="m">1</span> <span class="o">&gt;</span> <span class="m">10</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"1 &gt; 10 ?"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// Output:</span>
<span class="c">// 1 &lt; 5</span>
<span class="c">// 1 &gt; 10 ?</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defer">5.8. Defer</h3>
<div class="paragraph">
<p>A <code>defer</code> statement invokes a function whose execution is deferred to the moment the surrounding function returns,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>either because the surrounding function executed a return statement, reached the end of its function body,</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">godir</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"/usr/local/go"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="k">defer</span> <span class="n">godir</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>or because the corresponding goroutine is panicking.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">e</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"recover: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">". . ."</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nb">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"Oops, I'm NOT myself."</span><span class="p">))</span>
	<span class="c">// Output:</span>
	<span class="c">// . . .</span>
	<span class="c">// recover: Oops, I'm NOT myself.</span></code></pre>
</div>
</div>
</li>
<li>
<p>Go&#8217;s <code>defer</code> statement schedules a function call (the <em>deferred</em> function) to be run immediately before the function executing the <code>defer</code> returns.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// The arguments to the deferred function (which include the receiver if the function is a method)</span>
<span class="c">// are evaluated when the _defer_ executes, not when the _call_ executes.</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">v</span> <span class="o">:=</span> <span class="m">10</span>
	<span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="c">// 30</span>

	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c">// 20</span>
	<span class="p">}()</span>

	<span class="k">defer</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// 10</span>
	<span class="p">}(</span><span class="n">v</span><span class="p">)</span>

	<span class="n">v</span> <span class="o">=</span> <span class="m">20</span>
	<span class="n">_</span> <span class="o">=</span> <span class="n">v</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// 10</span>
<span class="c">// 20</span>
<span class="c">// 30</span></code></pre>
</div>
</div>
</li>
<li>
<p>It&#8217;s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">ReadFile</span><span class="p">(</span><span class="n">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ReadAll</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Deferred functions are executed in LIFO order (stacking style).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// Output:</span>
<span class="c">// 4 3 2 1 0</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// All function values created by this loop "capture"</span>
<span class="c">// and share the same variable—an addressable storage location,</span>
<span class="c">// not its value at that particular moment.</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
    <span class="p">}()</span>
<span class="p">}</span>
<span class="c">// Output:</span>
<span class="c">// 5 5 5 5 5</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c">// declares inner i, intialized to outer i</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
    <span class="p">}()</span>
<span class="p">}</span>
<span class="c">// Output:</span>
<span class="c">// 4 3 2 1 0</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-types">6. Data types</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// any is an alias for interface{} and is equivalent to interface{} in all ways.</span>
<span class="c">// (go1.18)</span>
<span class="n">any</span>

<span class="c">// comparable is an interface that is implemented by all comparable types</span>
<span class="c">// (booleans, numbers, strings, pointers, channels, arrays of comparable types,</span>
<span class="c">// structs whose fields are all comparable types). The comparable interface may</span>
<span class="c">// only be used as a type parameter constraint, not as the type of a variable.</span>
<span class="c">// (go1.18)</span>
<span class="n">comparable</span>

<span class="kt">bool</span> <span class="c">// true false</span>

<span class="kt">string</span>

<span class="kt">int8</span>  <span class="kt">int16</span>  <span class="kt">int32</span>  <span class="kt">int64</span>
<span class="kt">uint8</span> <span class="kt">uint16</span> <span class="kt">uint32</span> <span class="kt">uint64</span> <span class="kt">uintptr</span>
<span class="kt">int</span> <span class="kt">uint</span> <span class="c">// either 32 or 64 bits</span>

<span class="kt">byte</span> <span class="c">// alias for uint8</span>

<span class="kt">rune</span> <span class="c">// alias for int32</span>
     <span class="c">// represents a Unicode code point</span>

<span class="kt">float32</span> <span class="kt">float64</span>

<span class="kt">complex64</span> <span class="kt">complex128</span>

<span class="c">// more types</span>
<span class="n">pointers</span> <span class="n">structs</span> <span class="n">array</span> <span class="n">slices</span> <span class="n">maps</span> <span class="n">functions</span> <span class="n">interfaces</span> <span class="n">channels</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="type">6.1. Type</h3>
<div class="paragraph">
<p>The <code>type</code> keyword in Go is used to define new types or create aliases for existing types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type definitions create a completely new type that is distinct from the base type, which can be added methods to it.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// new named type</span>
<span class="k">type</span> <span class="n">Celsius</span> <span class="kt">float64</span>
<span class="k">type</span> <span class="n">Fahrenheit</span> <span class="kt">float64</span>

<span class="c">// new type method</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="n">Celsius</span><span class="p">)</span> <span class="n">ToF</span><span class="p">()</span> <span class="n">Fahrenheit</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Fahrenheit</span><span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="m">9.0</span> <span class="o">/</span> <span class="m">5.0</span><span class="p">)</span> <span class="o">+</span> <span class="m">32.0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">cToF</span><span class="p">(</span><span class="n">c</span> <span class="n">Celsius</span><span class="p">)</span> <span class="n">Fahrenheit</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">ToF</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">tempC</span> <span class="n">Celsius</span> <span class="o">=</span> <span class="m">25.0</span>
	<span class="n">tempF</span> <span class="o">:=</span> <span class="n">cToF</span><span class="p">(</span><span class="n">tempC</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">tempF</span><span class="p">)</span> <span class="c">// 77</span>
	<span class="c">// Error: cannot use tempC (variable of float64 type Celsius) as float64 value in variable declaration</span>
	<span class="c">// var tempFloat float64 = tempC</span>
	<span class="c">// fmt.Println(tempFloat)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Read</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>
	<span class="n">Writer</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">MyChannel</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">channel</span> <span class="k">chan</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">my</span> <span class="n">MyChannel</span><span class="p">)</span> <span class="n">Read</span><span class="p">()</span> <span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="n">my</span><span class="o">.</span><span class="n">channel</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">my</span> <span class="n">MyChannel</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">my</span><span class="o">.</span><span class="n">channel</span> <span class="o">&lt;-</span> <span class="n">item</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">my</span> <span class="n">MyChannel</span><span class="p">)</span> <span class="n">Close</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">my</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">(</span><span class="n">size</span> <span class="kt">int</span><span class="p">)</span> <span class="n">MyChannel</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">MyChannel</span><span class="p">{</span><span class="n">channel</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="p">)}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">my</span> <span class="o">:=</span> <span class="n">New</span><span class="p">(</span><span class="m">5</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">my</span><span class="o">.</span><span class="n">Read</span><span class="p">()</span>
			<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">my</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">my</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">10</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Type aliases provide a different name for an existing type but don&#8217;t create a new type; they just give a new identifier.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// type alias</span>
<span class="k">type</span> <span class="n">Celsius</span> <span class="o">=</span> <span class="kt">float64</span>
<span class="k">type</span> <span class="n">Fahrenheit</span> <span class="o">=</span> <span class="kt">float64</span>

<span class="k">func</span> <span class="n">cToF</span><span class="p">(</span><span class="n">c</span> <span class="n">Celsius</span><span class="p">)</span> <span class="n">Fahrenheit</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Fahrenheit</span><span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="m">9.0</span> <span class="o">/</span> <span class="m">5.0</span><span class="p">)</span> <span class="o">+</span> <span class="m">32.0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">tempC</span> <span class="n">Celsius</span> <span class="o">=</span> <span class="m">25.0</span>
	<span class="n">tempF</span> <span class="o">:=</span> <span class="n">cToF</span><span class="p">(</span><span class="n">tempC</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">tempF</span><span class="p">)</span> <span class="c">// 77</span>
	<span class="c">// because Celsius and float64 are the same, this is legal:</span>
	<span class="k">var</span> <span class="n">tempFloat</span> <span class="kt">float64</span> <span class="o">=</span> <span class="n">tempC</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">tempFloat</span><span class="p">)</span> <span class="c">// 25</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="variables">6.2. Variables</h3>
<div class="ulist">
<ul>
<li>
<p>A var statement can be at package or function level to declare a list of variables; as in function argument lists, the type is last.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">c</span><span class="p">,</span> <span class="n">python</span><span class="p">,</span> <span class="n">java</span> <span class="kt">bool</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">i</span> <span class="kt">int</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">python</span><span class="p">,</span> <span class="n">java</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>A var declaration can include initializers, one per variable.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">c</span><span class="p">,</span> <span class="n">python</span><span class="p">,</span> <span class="n">java</span> <span class="o">=</span> <span class="no">true</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="s">"no!"</span></code></pre>
</div>
</div>
</li>
<li>
<p>Inside a function, the <code>:=</code> short assignment statement can be used in place of a var declaration with implicit type.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span>
	<span class="n">k</span> <span class="o">:=</span> <span class="m">3</span>
	<span class="n">c</span><span class="p">,</span> <span class="n">python</span><span class="p">,</span> <span class="n">java</span> <span class="o">:=</span> <span class="no">true</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="s">"no!"</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">python</span><span class="p">,</span> <span class="n">java</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="strings-bytes-runes-and-characters">6.3. Strings, bytes, runes and characters</h3>
<div class="ulist">
<ul>
<li>
<p>Go source code is always UTF-8.</p>
</li>
<li>
<p>A string holds arbitrary bytes.</p>
</li>
<li>
<p>A string literal, absent byte-level escapes, always holds valid UTF-8 sequences.</p>
</li>
<li>
<p>Those sequences represent Unicode code points, called runes.</p>
<div class="ulist">
<ul>
<li>
<p>A code point is a unique numerical value assigned to a character in the Unicode standard, that represents a character, regardless of how that character is stored or encoded.</p>
</li>
<li>
<p>A code unit is the actual bit sequence used to represent a code point in a specific encoding scheme.</p>
</li>
</ul>
</div>
</li>
<li>
<p>No guarantee is made in Go that characters in strings are normalized.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">const</span> <span class="n">nihongo</span> <span class="o">=</span> <span class="s">"日本語"</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">runeValue</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nihongo</span> <span class="p">{</span> <span class="c">// for-range: iterate over the Unicode code points (runes)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#U "</span><span class="p">,</span> <span class="n">runeValue</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>
<span class="c">// U+65E5 '日' U+672C '本' U+8A9E '語'</span>

<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cp</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">(</span><span class="n">nihongo</span><span class="p">)</span> <span class="p">{</span> <span class="c">// convert a string to a slice of runes</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#U "</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>
<span class="c">// U+65E5 '日' U+672C '本' U+8A9E '語'</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nihongo</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span> <span class="c">// for-loop: iterate over the UTF-8 encoded units or bytes</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%x "</span><span class="p">,</span> <span class="n">nihongo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>
<span class="c">// e6 97 a5 e6 9c ac e8 aa 9e</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nihongo</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%q "</span><span class="p">,</span> <span class="n">nihongo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>
<span class="c">// 'æ' '\u0097' '¥' 'æ' '\u009c' '¬' 'è' 'ª' '\u009e'</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nihongo</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+q "</span><span class="p">,</span> <span class="n">nihongo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>
<span class="c">// '\u00e6' '\u0097' '\u00a5' '\u00e6' '\u009c' '\u00ac' '\u00e8' '\u00aa' '\u009e'</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pointers">6.4. Pointers</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// A pointer holds the memory address of a value.</span>
<span class="c">// Unlike C, Go has no pointer arithmetic.</span>

<span class="c">// The type `*T` is a pointer to a `T` value. Its zero value is `nil`.</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="kt">int</span>

<span class="n">i</span> <span class="o">:=</span> <span class="m">42</span>
<span class="c">// The `&amp;` operator generates a pointer to its operand.</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span>

<span class="c">// The `*` operator ("dereferencing" or "indirecting") denotes the pointer's underlying value.</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="m">21</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="structs">6.5. Structs</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// A struct is a collection of fields.</span>
<span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">var</span> <span class="p">(</span>
    <span class="c">// A struct literal denotes a newly allocated struct value by listing the values of its fields.</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>  <span class="c">// has type Vertex</span>

    <span class="c">// You can list just a subset of fields by using the Name: syntax.</span>
    <span class="c">// (And the order of named fields is irrelevant.)</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{</span><span class="n">X</span><span class="o">:</span> <span class="m">1</span><span class="p">}</span>  <span class="c">// Y:0 is implicit</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{}</span>      <span class="c">// X:0 and Y:0</span>

    <span class="c">// The special prefix &amp; returns a pointer to the struct value</span>
    <span class="n">p</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">Vertex</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span> <span class="c">// has type *Vertex</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// Struct fields are accessed using a dot.</span>
    <span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="m">1e9</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="arrays">6.6. Arrays</h3>
<div class="ulist">
<ul>
<li>
<p>The type <code>[n]T</code> is an array of <code>n</code> values of type <code>T</code>.</p>
</li>
<li>
<p>Arrays are values. Assigning one array to another copies all the elements.</p>
<div class="paragraph">
<p>In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it.</p>
</div>
</li>
<li>
<p>The size of an array is part of its type.</p>
<div class="paragraph">
<p>The types <code>[10]int</code> and <code>[20]int</code> are distinct, so arrays cannot be resized.</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">a</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="kt">string</span>
<span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hello"</span>
<span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"World"</span>

<span class="c">// an array literal</span>
<span class="n">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">11</span><span class="p">,</span> <span class="m">13</span><span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="slices">6.7. Slices</h3>
<div class="ulist">
<ul>
<li>
<p>A slice, on the other hand, is a dynamically-sized, flexible view into the elements of an array.</p>
</li>
<li>
<p>The type <code>[]T</code> is a slice with elements of type <code>T</code>.</p>
</li>
<li>
<p>A slice is formed by specifying two indices, a low and high bound, separated by a colon:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// This selects a half-open range which includes the first element, but excludes the last one.</span>
<span class="n">a</span><span class="p">[</span><span class="n">low</span> <span class="o">:</span> <span class="n">high</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
<li>
<p>The following expression creates a slice which includes elements 1 through 3 of <code>a</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slices are like references to arrays</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A slice does not store any data, it just describes a section of an underlying array.</p>
</li>
<li>
<p>A slice hold references to an underlying array, and if you assign one slice to another, both refer to the same array.</p>
</li>
<li>
<p>Changing the elements of a slice modifies the corresponding elements of its underlying array.</p>
</li>
<li>
<p>Other slices that share the same underlying array will see those changes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slice literals</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A slice literal is like an array literal without the length.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="p">[]</span><span class="kt">bool</span><span class="p">{</span><span class="no">true</span><span class="p">,</span> <span class="no">true</span><span class="p">,</span> <span class="no">false</span><span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slice defaults</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>When slicing, you may omit the high or low bounds to use their defaults instead.</p>
</li>
<li>
<p>The default is zero for the low bound and the length of the slice for the high bound.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// For the array</span>
<span class="k">var</span> <span class="n">a</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span><span class="kt">int</span>
<span class="c">// these slice expressions are equivalent:</span>
<span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="m">10</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="m">10</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slice length and capacity</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A slice has both a <em>length</em> and a <em>capacity</em>.</p>
</li>
<li>
<p>The length of a slice is the number of elements it contains.</p>
</li>
<li>
<p>The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.</p>
</li>
<li>
<p>The length and capacity of a slice <code>s</code> can be obtained using the expressions <code>len(s)</code> and <code>cap(s)</code>.</p>
</li>
<li>
<p>You can extend a slice&#8217;s length by re-slicing it, provided it has sufficient capacity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Nil slices</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The zero value of a slice is <code>nil</code>.</p>
</li>
<li>
<p>A <code>nil</code> slice has a length and capacity of 0 and has no underlying array.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Appending to a slice</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is common to append new elements to a slice, and so Go provides a built-in <code>append</code> function.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">func</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">vs</span> <span class="o">...</span><span class="n">T</span><span class="p">)</span> <span class="p">[]</span><span class="n">T</span></code></pre>
</div>
</div>
</li>
<li>
<p>The resulting value of <code>append</code> is a slice containing all the elements of the original slice plus the provided values.</p>
</li>
<li>
<p>If the backing array of <code>s</code> is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">var</span> <span class="n">s</span> <span class="p">[]</span><span class="kt">int</span>

  <span class="c">// append works on nil slices.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>

  <span class="c">// The slice grows as needed.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>

  <span class="c">// We can add more than one element at a time.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="maps">6.8. Maps</h3>
<div class="ulist">
<ul>
<li>
<p>Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value).</p>
</li>
<li>
<p>The <strong>key</strong> can be of any type that is <em>comparable</em> for which the <em>equality operator</em> is defined.</p>
<div class="paragraph">
<p>The language spec defines the <a href="https://go.dev/ref/spec#Comparison_operators">Comparison operators</a> precisely, in short, <em>comparable</em> types are boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types.<a href="#BLOGMAPS">[1]</a></p>
</div>
<div class="paragraph">
<p>Notably absent from the list are slices, maps, and functions; these types cannot be compared using <code>==</code>, and may not be used as map keys.</p>
</div>
</li>
<li>
<p>Slices cannot be used as map keys, because equality is not defined on them.</p>
</li>
<li>
<p>Like slices, maps hold references to an underlying data structure.</p>
<div class="paragraph">
<p>If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.</p>
</div>
</li>
<li>
<p>The zero value of a map is <code>nil</code>.</p>
<div class="paragraph">
<p>A <code>nil</code> map has no keys, nor can keys be added.</p>
</div>
</li>
<li>
<p>Map literals are like struct literals, but the keys are required.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">m</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="c">// &lt;nil&gt;</span>
<span class="n">m</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
    <span class="s">"hello"</span><span class="o">:</span> <span class="m">100</span><span class="p">,</span>
    <span class="s">"world"</span><span class="o">:</span> <span class="m">200</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>make</code> function returns a map of the given type with an optional capacity hint as arguments, initialized and ready for use.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// m := make(map[string]int, 100)</span>
<span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="c">// insert or update an element</span>
<span class="n">m</span><span class="p">[</span><span class="s">"Answer"</span><span class="p">]</span> <span class="o">=</span> <span class="m">42</span>

<span class="c">// delete an element:</span>
<span class="c">// The delete function doesn’t return anything, and will do nothing if the specified key doesn’t exist.</span>
<span class="nb">delete</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"Answer"</span><span class="p">)</span>

<span class="c">// retrieve an element</span>
<span class="c">// If the requested key doesn’t exist, we get the value type’s zero value.</span>
<span class="n">v</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="s">"Answer"</span><span class="p">]</span>

<span class="c">// test that a key is present with a two-value assignment</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="s">"Answer"</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="functions">6.9. Functions</h3>
<div class="ulist">
<ul>
<li>
<p>A function can return any number of results.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">File</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
<li>
<p>The return or result "parameters" of a Go function can be given names and used as regular variables, just like the incoming parameters.</p>
<div class="paragraph">
<p>When named, they are initialized to the zero values for their types when the function begins; if the function executes a <code>return</code> statement with no arguments, the current values of the result parameters are used as the returned values.</p>
</div>
</li>
<li>
<p>Functions are values too. They can be passed around just like other values. Function values may be used as function arguments and return values.</p>
</li>
<li>
<p>Go functions may be closures, that is a function value that references (i.e. bounds to) variables from outside its body.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">adder</span><span class="p">()</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span>
		<span class="k">return</span> <span class="n">sum</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span> <span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">:=</span> <span class="n">adder</span><span class="p">(),</span> <span class="n">adder</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+d, %+2d</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">neg</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// +1, -1  +3, -3  +6, -6</span></code></pre>
</div>
</div>
</li>
<li>
<p>A function literal represents an anonymous function and cannot declare type parameters, and it can be assigned to a variable or invoked directly.</p>
</li>
<li>
<p>Function literals are closures: they may refer to variables defined in a surrounding function, which are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">sum</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">add</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="m">1</span>
	<span class="p">}</span>
	<span class="n">add</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// 1</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="methods">6.10. Methods</h3>
<div class="paragraph">
<p>A method is a function with a special receiver argument, defined on any <strong>named type</strong> (except a pointer or an interface) in the same package.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">MyInt</span> <span class="kt">int</span>

<span class="k">func</span> <span class="p">(</span><span class="n">mi</span> <span class="o">*</span><span class="n">MyInt</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"Hi %d!"</span><span class="p">,</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">mi</span> <span class="o">*</span><span class="n">MyInt</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="n">mi</span> <span class="o">=</span> <span class="o">*</span><span class="n">mi</span> <span class="o">+</span> <span class="n">MyInt</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">mi</span> <span class="n">MyInt</span> <span class="o">=</span> <span class="m">1</span><span class="n">_024</span>
	<span class="n">mi</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="n">_024</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// Hi 2048!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Choosing a value or pointer receiver</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are two reasons to use a pointer receiver.</p>
<div class="ulist">
<ul>
<li>
<p>The first is so that the method can modify the value that its receiver points to.</p>
</li>
<li>
<p>The second is to avoid copying the value on each method call, that can be more efficient if the receiver is a large struct, for example.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both.</p>
</li>
<li>
<p>The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>
<div class="ulist">
<ul>
<li>
<p>Value methods can be called on both values and pointers (automatically using <code>*</code> on pointers), while pointer methods can only be called on pointers (automatically using <code>&amp;</code> on values).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Nil is a valid receiver value</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if <code>nil</code> is a meaningful zero value of the type, as with maps and slices.</p>
</li>
<li>
<p>When you define a type whose methods allow <code>nil</code> as a receiver value, it&#8217;s worth pointing this out explicitly in its documentation comment.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">package bytes // import "bytes"</span>

<span class="go">type Buffer struct {</span>
<span class="go">	// Has unexported fields.</span>
<span class="go">}</span>
<span class="go">    A Buffer is a variable-sized buffer of bytes with Read and Write methods.</span>
<span class="hll"><span class="go">    The zero value for Buffer is an empty buffer ready to use.</span>
</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="interfaces">6.11. Interfaces</h3>
<div class="paragraph">
<p>An interface type defines a <em>type set</em>, that is the set of all concrete types that implement that interface.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to <em>implement the interface</em>.</p>
</li>
<li>
<p>The value of an uninitialized variable of interface type is <code>nil</code>.</p>
</li>
<li>
<p>An interface type is specified by a list of <em>interface elements</em>.</p>
<div class="paragraph">
<p>An interface element is either a <em>method</em> or a <em>type</em> element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interfaces in Go provide a way to specify the behavior of an object: <em>if something can do this, then it can be used here</em>.</p>
</div>
<div class="paragraph">
<p><strong>Interfaces are implemented implicitly</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A type implements an interface by implementing its methods. There is no explicit declaration of intent, no "implements" keyword.</p>
</li>
<li>
<p>Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Interface values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Under the hood, interface values can be thought of as a tuple of a value and a concrete type:</p>
<div class="paragraph">
<p>An interface value holds a value of a specific underlying concrete type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre><em>(value, type)</em></pre>
</div>
</div>
</li>
<li>
<p>Calling a method on an interface value executes the method of the same name on its underlying type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Interface values with nil underlying values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the concrete value inside the interface itself is nil, the method will be called with a <em>nil receiver</em>.</p>
</li>
<li>
<p>In some languages this would trigger a null pointer exception, but in Go it is common to write methods that gracefully handle being called with a nil receiver.</p>
</li>
<li>
<p>Note that an interface value that holds a nil concrete value is itself non-nil.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">I</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">M</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"&lt;nil receiver&gt;"</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">i</span> <span class="n">I</span> <span class="c">// `i` is nil</span>
	<span class="c">// i.M() // runtime error: invalid memory address or nil pointer dereference</span>
	<span class="k">var</span> <span class="n">t</span> <span class="o">*</span><span class="n">T</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">t</span> <span class="c">// `i` is not nil, but the concrete type `t` is nil</span>
	<span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v, %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

	<span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">{}</span> <span class="c">// the concrete type `t` is not nil</span>
	<span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v, %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// &lt;nil receiver&gt;</span>
<span class="c">// &lt;nil&gt;, *main.T</span>
<span class="c">// &amp;{}, *main.T</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Nil interface values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A nil interface value holds neither value nor concrete type.</p>
</li>
<li>
<p>Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">i</span> <span class="n">I</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="c">// (&lt;nil&gt;, &lt;nil&gt;)</span>
<span class="c">// panic: runtime error: invalid memory address or nil pointer dereference</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>The empty interface</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The interface type that specifies zero methods is known as the empty interface:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">interface</span><span class="p">{}</span></code></pre>
</div>
</div>
</li>
<li>
<p>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p>
</li>
<li>
<p>Empty interfaces are used by code that handles values of unknown type.</p>
</li>
<li>
<p>For convenience, the predeclared type <code>any</code> is an alias for the empty interface.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go doc builtin.any
<span class="go">package builtin // import "builtin"

type any = interface{}
    any is an alias for interface{} and is equivalent to interface{} in all
    ways.</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Basic interfaces</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interfaces whose type sets can be defined entirely by a list of methods are called <strong>basic interfaces</strong>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// A simple File interface.</span>
<span class="k">interface</span> <span class="p">{</span>
	<span class="n">Read</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="n">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Embedded interfaces</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>In a slightly more general form an interface T may use a (possibly qualified) interface type name E as an interface element, which is called <strong>embedding</strong> interface E in T.</p>
</li>
<li>
<p>The type set of T is the <em>intersection</em> of the type sets defined by T&#8217;s explicitly declared methods and the type sets of T’s embedded interfaces.</p>
<div class="paragraph">
<p>In other words, the type set of T is the set of all types that implement all the explicitly declared methods of T and also all the methods of E.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
	<span class="n">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
	<span class="n">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c">// ReadWriter's methods are Read, Write, and Close.</span>
<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>  <span class="c">// includes methods of Reader in ReadWriter's method set</span>
	<span class="n">Writer</span>  <span class="c">// includes methods of Writer in ReadWriter's method set</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>When embedding interfaces, methods with the same names must have identical signatures.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">ReadCloser</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>   <span class="c">// includes methods of Reader in ReadCloser's method set</span>
	<span class="n">Close</span><span class="p">()</span>  <span class="c">// illegal: signatures of Reader.Close and Close are different</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>General interfaces</strong></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Azure AI | ChatGPT 4</p>
</div>
<div class="paragraph">
<p>In Go, <em>general interfaces</em> are used to define <em>type constraints</em> for <em>type parameters</em> in <em>generic</em> functions and data structures. [GPT 4]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Comparable is an interface that defines a type constraint using</span>
<span class="c">// a union of types (int, float64, and string). This means that a</span>
<span class="c">// type parameter satisfying the Comparable constraint must be one</span>
<span class="c">// of these types.</span>
<span class="k">type</span> <span class="n">Comparable</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="o">|</span> <span class="kt">float64</span> <span class="o">|</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// The Max function is defined as a generic function using the type</span>
<span class="c">// parameter T. The type parameter is specified within square brackets</span>
<span class="c">// ([T Comparable]). It means that the function can work with any type</span>
<span class="c">// T that satisfies the Comparable constraint.</span>
<span class="k">func</span> <span class="n">Max</span><span class="p">[</span><span class="n">T</span> <span class="n">Comparable</span><span class="p">](</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>

<span class="c">// The Max function is called with different types of arguments (int,</span>
<span class="c">// float64, and string). The type parameter T is replaced with the actual</span>
<span class="c">// type of the arguments at each call, allowing the function to work with</span>
<span class="c">// different types while maintaining type safety.</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Max</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">))</span>           <span class="c">// int</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Max</span><span class="p">(</span><span class="m">2.5</span><span class="p">,</span> <span class="m">3.7</span><span class="p">))</span>       <span class="c">// float64</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Max</span><span class="p">(</span><span class="s">"apple"</span><span class="p">,</span> <span class="s">"cat"</span><span class="p">))</span> <span class="c">// string</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In summary, while you can&#8217;t assign a concrete type to a general interface, general interfaces are used to specify what types can be used with a generic function or data structure.</p>
</div>
<div class="paragraph">
<p>These type constraints allow you to create flexible and reusable generic code while maintaining type safety.</p>
</div>
</blockquote>
</div>
<div class="ulist">
<ul>
<li>
<p>In their most general form, an interface element may also be an arbitrary type term <code>T</code>, or a term of the form <code>~T</code> specifying the <em>underlying type</em> <code>T</code>, or a union of terms <code>t1|t2| . . . |tn</code>.</p>
</li>
<li>
<p>By construction, an interface&#8217;s type set never contains an interface type.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// An interface representing only the type int.</span>
<span class="k">interface</span> <span class="p">{</span>
	<span class="kt">int</span>
<span class="p">}</span>

<span class="c">// An interface representing all types with underlying type int.</span>
<span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c">// An interface representing all types with underlying type int that implement the String method.</span>
<span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span>
	<span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// An interface representing an empty type set: there is no type that is both an int and a string.</span>
<span class="c">//</span>
<span class="c">// This code defines an interface that no concrete type satisfies because there is no type that is</span>
<span class="c">// both an int and a string. It is not the same as an empty interface (interface{}), which any type</span>
<span class="c">// can satisfy. This code snippet is used to illustrate the concept of an unsatisfiable interface</span>
<span class="c">// in the Go language specification. (Azure AI | ChatGPT 4)</span>
<span class="c">//</span>
<span class="c">// While this interface can be compiled, it cannot be used in practical terms because no type can</span>
<span class="c">// satisfy the constraints. It's a theoretical construct to show the capabilities and limitations of</span>
<span class="c">// the type constraint system in Go. (Azure AI | ChatGPT 4)</span>
<span class="k">interface</span> <span class="p">{</span>
	<span class="kt">int</span>
	<span class="kt">string</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>In a term of the form <code>~T</code>, the underlying type of <code>T</code> must be itself, and <code>T</code> cannot be an interface.</p>
<div class="openblock">
<div class="content">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Azure AI | ChatGPT 4</p>
</div>
<div class="paragraph">
<p>The tilde symbol <code>~</code> defines a type set constraint that includes the underlying type of T as well as any other types whose underlying type is the same as T.</p>
</div>
<div class="paragraph">
<p>In this context, "underlying type" refers to the actual type without any type aliases or defined types based on it.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>"The underlying type of T must be itself": This means that when defining a type set constraint using <code>~T</code>, the type T must not be a type alias or a defined type based on another type. Instead, T must be a "base" type, such as int, float64, or a struct type.</p>
</li>
<li>
<p>"T cannot be an interface": This condition states that the type T in a type set constraint using ~T should not be an interface type. This is because interface types don&#8217;t have a specific underlying type that can be used in the type set definition.</p>
</li>
</ul>
</div>
</blockquote>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">MyInt</span> <span class="kt">int</span>

<span class="k">type</span> <span class="n">MyI</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="p">[]</span><span class="kt">byte</span>  <span class="c">// the underlying type of []byte is itself</span>
	<span class="err">~</span><span class="n">MyInt</span>   <span class="c">// illegal: the underlying type of MyInt is not MyInt</span>
	<span class="err">~</span><span class="kt">error</span>   <span class="c">// illegal: error is an interface</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Union elements denote unions of type sets:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// The Float interface represents all floating-point types</span>
<span class="c">// (including any named types whose underlying types are</span>
<span class="c">// either float32 or float64).</span>
<span class="k">type</span> <span class="n">Float</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">float32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">float64</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Generality</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself.</p>
</li>
<li>
<p>Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface.</p>
</li>
<li>
<p>It also avoids the need to repeat the documentation on every instance of a common method.</p>
</li>
<li>
<p>In such cases, the constructor should return an interface value rather than the implementing type.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// unexported type</span>
<span class="k">type</span> <span class="n">myString</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">s</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ms</span> <span class="n">myString</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">ms</span><span class="o">.</span><span class="n">s</span>
<span class="p">}</span>

<span class="c">// constructor function (exported) that returns the interface</span>
<span class="k">func</span> <span class="n">NewString</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Stringer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">myString</span><span class="p">{</span><span class="n">s</span><span class="o">:</span> <span class="n">s</span><span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Interface conversions and type assertions</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A type assertion provides access to an interface value&#8217;s underlying concrete value.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">t</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This statement asserts that the interface value <code>i</code> holds the concrete type <code>T</code> and assigns the underlying <code>T</code> value to the variable <code>t</code>.</p>
</div>
<div class="paragraph">
<p>If <code>i</code> does not hold a <code>T</code>, the statement will trigger a panic.</p>
</div>
</li>
<li>
<p>To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">t</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>i</code> holds a <code>T</code>, then <code>t</code> will be the underlying value and <code>ok</code> will be <code>true</code>.</p>
</div>
<div class="paragraph">
<p>If not, <code>ok</code> will be <code>false</code> and <code>t</code> will be the zero value of type <code>T</code>, and no panic occurs.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Type switches</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The declaration in a type switch has the same syntax as a type assertion <code>i.(T)</code>, but the specific type <code>T</code> is replaced with the keyword <code>type</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">switch</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">T</span><span class="o">:</span>
    <span class="c">// here v has type T</span>
<span class="k">case</span> <span class="n">S</span><span class="o">:</span>
    <span class="c">// here v has type S</span>
<span class="k">default</span><span class="o">:</span>
    <span class="c">// no match; here v has the same type as i</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="embedding-interfaces-and-structs">6.12. Embedding: interfaces and structs</h3>
<div class="ulist">
<ul>
<li>
<p>Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to &#8220;borrow&#8221; pieces of an implementation by embedding types within a struct or interface.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">io</span> <span class="c">// import "io"</span>

<span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span>
<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Reader</span>
    <span class="n">Writer</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">bufio</span> <span class="c">// import "bufio"</span>

<span class="k">type</span> <span class="n">Reader</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// Has unexported fields.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// Has unexported fields.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">Writer</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">nn</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">// ReadWriter stores pointers to a Reader and a Writer.</span>
<span class="c">// It implements io.ReadWriter.</span>
<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">Reader</span>
    <span class="o">*</span><span class="n">Writer</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>For the embedded type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one.</p>
<div class="paragraph">
<p>For example, when the <code>Read</code> method of a <code>bufio.ReadWriter</code> is invoked, the receiver is the <code>Reader</code> field of the <code>ReadWriter</code>, not the <code>ReadWriter</code> itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Reader</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="n">Read</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Read"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Writer</span><span class="p">)</span> <span class="n">Write</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Write"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="n">Reader</span>
	<span class="o">*</span><span class="n">Writer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">rw</span> <span class="o">:=</span> <span class="n">ReadWriter</span><span class="p">{}</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">Read</span><span class="p">()</span> <span class="c">// same as rw.Reader.Read()</span>
	<span class="c">// Output:</span>
	<span class="c">// Read</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Embedding types introduces the problem of name conflicts but the rules to resolve them are simple.</p>
<div class="ulist">
<ul>
<li>
<p>First, a field or method <code>X</code> hides any other item <code>X</code> in a more deeply nested part of the type.</p>
</li>
<li>
<p>Second, if the same name appears at the same nesting level, it is usually an error.</p>
</li>
<li>
<p>However, if the duplicate name is never mentioned in the program outside the type definition, it is OK.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Inner1</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Inner2</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Outer</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Inner1</span>
	<span class="n">Inner2</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">o</span> <span class="o">:=</span> <span class="n">Outer</span><span class="p">{</span>
		<span class="n">Inner1</span><span class="o">:</span> <span class="n">Inner1</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Inner 1 Name"</span><span class="p">},</span>
		<span class="n">Inner2</span><span class="o">:</span> <span class="n">Inner2</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Inner 2 Name"</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">Inner1</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">Inner2</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
	<span class="c">// Compile error: ambiguous selector o.Name</span>
	<span class="c">// fmt.Println(o.Name)</span>
<span class="p">}</span>

<span class="c">// Output</span>
<span class="c">// Inner 1 Name</span>
<span class="c">// Inner 2 Name</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Embedding</strong>:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Provides an "<strong>is-a</strong>" relationship where the outer struct or interface directly inherits the fields and methods of the embedded struct or interface.</p>
</li>
<li>
<p>Allows for easier and more direct access to the fields and methods of the embedded struct or interface, as they become part of the outer struct or interface.</p>
</li>
<li>
<p>Enhances code reuse and polymorphism by making the fields and methods of the embedded struct or interface available directly in the outer struct or interface.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong>Not Embedding</strong> (<strong>Composing</strong>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provides a "<strong>has-a</strong>" relationship where the outer struct or interface holds instances of other structs or interfaces as separate fields.</p>
</li>
<li>
<p>Requires explicitly accessing the fields and methods of the inner structs or interfaces through the composed fields.</p>
</li>
<li>
<p>Keeps a clear separation between the fields and methods of the outer struct or interface and the inner structs or interfaces it holds.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Reader</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">reader</span> <span class="n">Reader</span>
	<span class="n">writer</span> <span class="n">Writer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="n">Read</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Read."</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span><span class="n">Writer</span><span class="p">)</span> <span class="n">Write</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Write."</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">rw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ReadWriter</span><span class="p">{}</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">Read</span><span class="p">()</span>
	<span class="c">// rw.Read undefined (type *ReadWriter has no field or method Read)</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">Read</span><span class="p">()</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="channels">6.13. Channels</h3>
<div class="ulist">
<ul>
<li>
<p>Channels are a typed conduit through which you can send and receive values with the channel operator, <code>&lt;-</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">v</span>    <span class="c">// Send v to channel ch.</span>
<span class="n">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>  <span class="c">// Receive from ch, and assign value to v.</span>

<span class="c">// (The data flows in the direction of the arrow.)</span></code></pre>
</div>
</div>
</li>
<li>
<p>Like maps and slices, channels must be created before use:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// By default, sends and receives block until the other side is ready.</span>
<span class="c">// This allows goroutines to synchronize without explicit locks or condition variables.</span>
<span class="n">blockChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c">// Sends to a buffered channel block only when the buffer is full.</span>
<span class="c">// Receives block when the buffer is empty.</span>
<span class="n">bufChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
<li>
<p>A sender can <code>close</code> a channel to indicate that no more values will be sent.</p>
<div class="ulist">
<ul>
<li>
<p>After calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel&#8217;s type without blocking.</p>
</li>
<li>
<p>Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows.</p>
</li>
<li>
<p>The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// ok is false if there are no more values to receive and the channel is closed.</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span></code></pre>
</div>
</div>
</li>
<li>
<p>The loop for <code>v := range c</code> receives values from the channel repeatedly until it is closed.</p>
</li>
<li>
<p>Attempting to close an already-closed channel causes a panic, as does closing a nil channel.</p>
</li>
<li>
<p>Sending to a closed channel causes a run-time panic.</p>
</li>
<li>
<p>Only the sender should close a channel, never the receiver.</p>
</li>
<li>
<p>Channels aren&#8217;t like files; you don&#8217;t usually need to close them.</p>
<div class="paragraph">
<p>Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a <code>range</code> loop.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A channel may be constrained only to send or only to receive by assignment or explicit conversion.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="p">(</span>
		<span class="n">_</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>   <span class="c">// bidirectional</span>
		<span class="n">_</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c">// receive-only</span>
		<span class="n">_</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="c">// send-only</span>
	<span class="p">)</span>

	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

	<span class="c">// send-only</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span>
		<span class="p">}</span>
		<span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
	<span class="p">}(</span><span class="n">ch</span><span class="p">)</span>

	<span class="c">// receive-only</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}(</span><span class="n">ch</span><span class="p">)</span>

	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="c">// Output:</span>
	<span class="c">// 0</span>
	<span class="c">// 1</span>
	<span class="c">// 2</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="c">// buffering channel</span>
	<span class="n">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">ch1</span> <span class="o">&lt;-</span> <span class="m">2</span> <span class="o">*</span> <span class="n">i</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">1e3</span><span class="p">))</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="m">1</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">1e3</span><span class="p">))</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}(</span><span class="n">ch2</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="m">5e3</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="n">quit</span> <span class="o">&lt;-</span> <span class="m">0</span>
	<span class="p">}()</span>

	<span class="c">//  The select statement lets a goroutine wait on multiple communication operations.</span>
	<span class="c">//  A select blocks until one of its cases can run, then it executes that case.</span>
	<span class="c">//  It chooses one at random if multiple are ready.</span>
	<span class="n">ch3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">timeout</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">500</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="n">ch3</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c">// multiplexing: ch1 + ch2 =&gt; ch3</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">ch3</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="n">ch1</span><span class="o">:</span>
			<span class="k">case</span> <span class="n">ch3</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="n">ch2</span><span class="o">:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">timeout</span><span class="o">:</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"You're too slow."</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">quit</span><span class="o">:</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Quit."</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch3</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="type-conversions">6.14. Type conversions</h3>
<div class="paragraph">
<p>The expression <code>T(v)</code> converts the value <code>v</code> to the type <code>T</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Some numeric conversions:</span>
<span class="k">var</span> <span class="n">i</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">42</span>
<span class="k">var</span> <span class="n">f</span> <span class="kt">float64</span> <span class="o">=</span> <span class="kt">float64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">var</span> <span class="n">u</span> <span class="kt">uint</span> <span class="o">=</span> <span class="kt">uint</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="c">// Or, put more simply:</span>
<span class="n">i</span> <span class="o">:=</span> <span class="m">42</span>
<span class="n">f</span> <span class="o">:=</span> <span class="kt">float64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">u</span> <span class="o">:=</span> <span class="kt">uint</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generics">6.15. Generics</h3>
<div class="ulist">
<ul>
<li>
<p>Go <em>functions</em> can be written to work on multiple types using <em>type parameters</em>.</p>
<div class="paragraph">
<p>The type parameters of a function appear between brackets, before the function&#8217;s arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">Index</span><span class="p">[</span><span class="n">T</span> <span class="n">comparable</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span> <span class="n">T</span><span class="p">)</span> <span class="kt">int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This declaration means that <code>s</code> is a slice of any type <code>T</code> that fulfills the built-in constraint <code>comparable</code>. <code>x</code> is also a value of the same type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>comparable</code> is a useful constraint that makes it possible to use the <code>==</code> and <code>!=</code> operators on values of the type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">package builtin // import "builtin"

type comparable interface{ comparable }
    comparable is an interface that is implemented by all comparable types
    (booleans, numbers, strings, pointers, channels, arrays of comparable types,
    structs whose fields are all comparable types). The comparable interface may
    only be used as a type parameter constraint, not as the type of a variable.</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>In addition to generic functions, Go also supports generic <em>types</em>.</p>
<div class="paragraph">
<p>A type can be parameterized with a type parameter, which could be useful for implementing <em>generic data structures</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">ComparableOrdered</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">comparable</span>
	<span class="n">constraints</span><span class="o">.</span><span class="n">Ordered</span> <span class="c">// "golang.org/x/exp/constraints"</span>
<span class="p">}</span>

<span class="c">// List represents a singly-linked list that holds values of `ComparableOrdered` type.</span>
<span class="k">type</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span> <span class="n">ComparableOrdered</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">next</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
	<span class="n">val</span>  <span class="n">T</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="nb">append</span><span class="p">(</span><span class="n">vals</span> <span class="o">...</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">val</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tail</span> <span class="o">:=</span> <span class="n">head</span>
		<span class="k">for</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span>
		<span class="p">}</span>
		<span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]{</span><span class="n">val</span><span class="o">:</span> <span class="n">val</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">vals</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">max</span><span class="p">()</span> <span class="n">T</span> <span class="p">{</span>
	<span class="n">max</span> <span class="o">:=</span> <span class="n">head</span><span class="o">.</span><span class="n">val</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
	<span class="k">for</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="p">{</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">b</span> <span class="n">strings</span><span class="o">.</span><span class="n">Builder</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">head</span>
	<span class="k">for</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="s">"%v"</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
		<span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="s">" -&gt; "</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">list</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">List</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="n">val</span><span class="o">:</span> <span class="m">20</span><span class="p">}</span>
	<span class="n">list</span><span class="o">.</span><span class="nb">append</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">60</span><span class="p">)</span>
	<span class="n">list</span><span class="o">.</span><span class="nb">append</span><span class="p">(</span><span class="m">40</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"list: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"max: %v"</span><span class="p">,</span> <span class="n">list</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
	<span class="c">// Output:</span>
	<span class="c">// list: 20 -&gt; 60 -&gt; 30 -&gt; 10 -&gt; 40</span>
	<span class="c">// max: 60</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Type constraint and type parameter</p>
<div class="ulist">
<ul>
<li>
<p>A <em>type constraint</em> is an <em>interface</em> that defines the set of permissible <em>type arguments</em> for the respective <em>type parameter</em> and controls the operations supported by values of that type parameter.</p>
</li>
<li>
<p>If the constraint is an <em>interface literal</em> of the form <code>interface{E}</code> where <code>E</code> is an embedded type element (not a method), in a type parameter list the enclosing <code>interface{ … }</code> may be omitted for convenience:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="p">[</span><span class="n">T</span> <span class="p">[]</span><span class="n">P</span><span class="p">]</span>                      <span class="c">// = [T interface{[]P}]</span>
<span class="p">[</span><span class="n">T</span> <span class="err">~</span><span class="kt">int</span><span class="p">]</span>                     <span class="c">// = [T interface{~int}]</span>
<span class="p">[</span><span class="n">T</span> <span class="kt">int</span><span class="o">|</span><span class="kt">string</span><span class="p">]</span>               <span class="c">// = [T interface{int|string}]</span>
<span class="k">type</span> <span class="n">Constraint</span> <span class="err">~</span><span class="kt">int</span>         <span class="c">// illegal: ~int is not in a type parameter list</span></code></pre>
</div>
</div>
</li>
<li>
<p>A type argument <code>T</code> satisfies a type constraint <code>C</code> if <code>T</code> is an element of the <em>type set</em> defined by <code>C</code>; i.e., if <code>T</code> implements <code>C</code>.</p>
<div class="paragraph">
<p>As an exception, a strictly <code>comparable</code> type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument. More precisely:  A type <code>T</code> satisfies a constraint <code>C</code> if</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>T</code> implements <code>C</code>; or</p>
</li>
<li>
<p><code>C</code> can be written in the form <code>interface{ comparable; E }</code>, where <code>E</code> is a <em>basic interface</em> and <code>T</code> is <em>comparable</em> and implements <code>E</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">argument</span>      <span class="k">type</span> <span class="n">constraint</span>                <span class="c">// constraint satisfaction</span>

<span class="kt">int</span>                <span class="k">interface</span><span class="p">{</span> <span class="err">~</span><span class="kt">int</span> <span class="p">}</span>              <span class="c">// satisfied: int implements interface{ ~int }</span>
<span class="kt">string</span>             <span class="n">comparable</span>                     <span class="c">// satisfied: string implements comparable (string is strictly comparable)</span>
<span class="p">[]</span><span class="kt">byte</span>             <span class="n">comparable</span>                     <span class="c">// not satisfied: slices are not comparable</span>
<span class="n">any</span>                <span class="k">interface</span><span class="p">{</span> <span class="n">comparable</span><span class="p">;</span> <span class="kt">int</span> <span class="p">}</span>   <span class="c">// not satisfied: any does not implement interface{ int }</span>
<span class="n">any</span>                <span class="n">comparable</span>                     <span class="c">// satisfied: any is comparable and implements the basic interface any</span>
<span class="k">struct</span><span class="p">{</span><span class="n">f</span> <span class="n">any</span><span class="p">}</span>      <span class="n">comparable</span>                     <span class="c">// satisfied: struct{f any} is comparable and implements the basic interface any</span>
<span class="n">any</span>                <span class="k">interface</span><span class="p">{</span> <span class="n">comparable</span><span class="p">;</span> <span class="n">m</span><span class="p">()</span> <span class="p">}</span>   <span class="c">// not satisfied: any does not implement the basic interface interface{ m() }</span>
<span class="k">interface</span><span class="p">{</span> <span class="n">m</span><span class="p">()</span> <span class="p">}</span>   <span class="k">interface</span><span class="p">{</span> <span class="n">comparable</span><span class="p">;</span> <span class="n">m</span><span class="p">()</span> <span class="p">}</span>   <span class="c">// satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Because of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable).</p>
</div>
</div>
</div>
</li>
<li>
<p>A <strong>type parameter</strong> list declares the type parameters of a generic function or type declaration.</p>
<div class="paragraph">
<p>The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">TypeParameters  = "[" TypeParamList [ "," ] "]" .
TypeParamList   = TypeParamDecl { "," TypeParamDecl } .
TypeParamDecl   = IdentifierList TypeConstraint .</span></code></pre>
</div>
</div>
</li>
<li>
<p>All non-blank names in the type parameter list must be unique.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration.</p>
</li>
<li>
<p>The type parameter is replaced with a <em>type argument</em> upon instantiation of the generic function or type.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="p">[</span><span class="n">P</span> <span class="n">any</span><span class="p">]</span>
<span class="p">[</span><span class="n">S</span> <span class="k">interface</span><span class="p">{</span> <span class="err">~</span><span class="p">[]</span><span class="kt">byte</span><span class="o">|</span><span class="kt">string</span> <span class="p">}]</span>
<span class="p">[</span><span class="n">S</span> <span class="err">~</span><span class="p">[]</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span> <span class="n">any</span><span class="p">]</span>
<span class="p">[</span><span class="n">P</span> <span class="n">Constraint</span><span class="p">[</span><span class="kt">int</span><span class="p">]]</span>
<span class="p">[</span><span class="n">_</span> <span class="n">any</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>As the ordinary function parameter has a parameter type, the type parameter has a (meta-)type which is called its <em>type constraint</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initialization">7. Initialization</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="constants">7.1. Constants</h3>
<div class="ulist">
<ul>
<li>
<p>Constants are declared like variables, but with the <code>const</code> keyword.</p>
</li>
<li>
<p>Constants cannot be declared using the <code>:=</code> syntax.</p>
</li>
<li>
<p>Constants are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans.</p>
</li>
<li>
<p>Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler.</p>
</li>
<li>
<p>In Go, enumerated constants are created using the <code>iota</code> enumerator.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Weekday</span> <span class="kt">int</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">Sunday</span> <span class="n">Weekday</span> <span class="o">=</span> <span class="no">iota</span> <span class="o">+</span> <span class="m">1</span> <span class="c">// iota: 0 ~ Sunday    : 1</span>
    <span class="n">_</span>                         <span class="c">// iota: 1 ~ iota increased</span>
    <span class="c">// comments               // iota: 1 ~ skip: comment</span>
                              <span class="c">// iota: 1 ~ skip: empty line</span>
    <span class="n">Monday</span>                    <span class="c">// iota: 2 ~ Monday    : 3</span>
    <span class="n">Tuesday</span>                   <span class="c">// iota: 3 ~ Monday    : 4</span>
    <span class="n">Wednesday</span>                 <span class="c">// iota: 4 ~ Monday    : 5</span>
    <span class="n">Thursday</span>                  <span class="c">// iota: 5 ~ Monday    : 6</span>
    <span class="n">Friday</span>                    <span class="c">// iota: 6 ~ Monday    : 7</span>
    <span class="n">Saturday</span>                  <span class="c">// iota: 7 ~ Monday    : 8</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">iota (noun)
/aɪˈəʊtə/
/aɪˈəʊtə/

1. [singular] (usually used in negative sentences) an extremely small amount
    There is not one iota of truth (= no truth at all) in the story.
    I don't think that would help one iota.
2. the 9th letter of the Greek alphabet (I, ι)

ref: https://www.oxfordlearnersdictionaries.com/us/definition/english/iota</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="allocation-new-and-make">7.2. Allocation: new and make</h3>
<div class="ulist">
<ul>
<li>
<p>Go has two allocation primitives, the built-in functions <code>new</code> and <code>make</code>.</p>
</li>
<li>
<p>The <code>new</code> built-in function allocates memory of a type, return a pointer to a newly allocated zero value of that type.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">package builtin // import "builtin"

func new(Type) *Type
    The new built-in function allocates memory. The first argument is a type,
    not a value, and the value returned is a pointer to a newly allocated zero
    value of that type.</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The memory returned by <code>new</code> is zeroed is helpful to arrange when designing a data structures that the zero value of each type can be used without further initialization.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">ptr</span> <span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span> <span class="c">// nil</span>
<span class="c">// panic: runtime error: invalid memory address or nil pointer dereference</span>
<span class="c">// ptr.WriteString("Hello, world!")</span>

<span class="n">ptr</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// points to a zerod bytes.Buffer instance</span>
<span class="n">ptr</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>make</code> built-in function allocates and initializes an object of type slice, map, or chan (only).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">package builtin // import "builtin"

func make(t Type, size ...IntegerType) Type
    The make built-in function allocates and initializes an object of type
    slice, map, or chan (only). Like new, the first argument is a type, not a
    value. Unlike new, make's return type is the same as the type of its
    argument, not a pointer to it. The specification of the result depends on
    the type:

        Slice: The size specifies the length. The capacity of the slice is
        equal to its length. A second integer argument may be provided to
        specify a different capacity; it must be no smaller than the
        length. For example, make([]int, 0, 10) allocates an underlying array
        of size 10 and returns a slice of length 0 and capacity 10 that is
        backed by this underlying array.

        Map: An empty map is allocated with enough space to hold the
        specified number of elements. The size may be omitted, in which case
        a small starting size is allocated.

        Channel: The channel's buffer is initialized with the specified
        buffer capacity. If zero, or the size is omitted, the channel is
        unbuffered.</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type <code>T</code> (not <code>*T</code>).</p>
</li>
<li>
<p>The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="o">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>       <span class="c">// allocates slice structure; *p == nil; rarely useful</span>
<span class="k">var</span> <span class="n">v</span>  <span class="p">[]</span><span class="kt">int</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span> <span class="c">// the slice v now refers to a new array of 100 ints</span>

<span class="c">// Unnecessarily complex:</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="o">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>

<span class="c">// Idiomatic:</span>
<span class="n">v</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="the-init-function">7.3. The init function</h3>
<div class="ulist">
<ul>
<li>
<p>Each source file can define its own niladic <code>init</code> function to set up whatever state is required.</p>
</li>
<li>
<p>Actually each file can have multiple init functions, which called in the order they appear in the source.</p>
</li>
<li>
<p>The <code>init</code> function is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// init.go</span>
<span class="k">var</span> <span class="p">(</span>
	<span class="n">hello</span> <span class="o">=</span> <span class="s">"Hello"</span>
	<span class="n">world</span> <span class="o">=</span> <span class="s">"世界"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s">", "</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">world</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go run init.go
<span class="go">Hello, 世界</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="zero-values">7.4. Zero values</h3>
<div class="paragraph">
<p>Variables declared without an explicit initial value are given their zero value:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>0</code> for numeric types,</p>
</li>
<li>
<p><code>false</code> for the boolean type,</p>
</li>
<li>
<p><code>""</code> (the empty string) for strings,</p>
</li>
<li>
<p><code>nil</code> for the pointers, slices, maps, functions, interfaces, channels,</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrency">8. Concurrency</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="race-conditions">8.1. Race Conditions</h3>
<div class="ulist">
<ul>
<li>
<p>A <strong>race condition</strong> is a situation in which the program does not give the correct result for some interleaving of the operations of multiple goroutines.</p>
</li>
<li>
<p>A <strong>data race</strong>, that is, a particular kind of race condition, occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race.</p>
<div class="ulist">
<ul>
<li>
<p>The first way is not to write the variable.</p>
</li>
<li>
<p>The second way (<em>channels: share memory by communication</em>) to avoid a data race is to avoid accessing the variable from multiple goroutines.</p>
</li>
<li>
<p>The third way (<em>mutual exclusion</em>: <code>sync.Mutex</code>, <code>sync.RWMutex</code>) to avoid a data race is to allow many goroutines to access the variable, but only one at a time.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Synchronization is about more than just the order of execution of multiple goroutines; synchronization also affets memory.</p>
<div class="openblock">
<div class="content">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Azure Open AI | ChatGPT4</p>
</div>
<div class="paragraph">
<p>Other race conditions include deadlocks, livelocks, and starvation.</p>
</div>
<div class="paragraph">
<p><strong>Deadlocks</strong> occur when two or more processes are waiting for each other to release resources that they need to continue executing.</p>
</div>
<div class="paragraph">
<p><strong>Livelocks</strong> occur when two or more processes are constantly changing their state in response to the actions of the other process, without making any progress towards their goal.</p>
</div>
<div class="paragraph">
<p>A livelock is a situation where two or more processes or threads are actively trying to resolve a conflict but end up repeatedly yielding to each other, resulting in no progress being made. Livelocks are similar to deadlocks in that they both involve processes being stuck, but livelocks involve active, ongoing attempts to resolve the problem, whereas deadlocks involve processes waiting for resources.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of a livelock:</p>
</div>
<div class="paragraph">
<p>Imagine two people, Alice and Bob, walking in a narrow corridor towards each other. When they meet in the middle, they both step aside to let the other person pass. However, they both step in the same direction. Realizing this, they both step back to their original positions and try again, but they continue to step in the same direction each time. This results in a livelock, as they are both actively trying to resolve the situation but end up yielding to each other without making progress.</p>
</div>
<div class="paragraph">
<p><strong>Starvation</strong> occurs when a process is prevented from accessing the resources it needs to execute, either because other processes are monopolizing those resources or because the system is not allocating resources fairly.</p>
</div>
</blockquote>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="race-detector">8.2. Race Detector</h3>
<div class="ulist">
<ul>
<li>
<p>The <strong>race detector</strong> (add the <code>-race</code> flag to the <code>go build</code>, <code>go run</code>, or <code>go test</code> command) studies the steam of events, looking for cases in which one goroutine reads or writes a shared variables that was most recently written by a different goroutine without an intervening synchronization operation.</p>
</li>
<li>
<p>The race detector reports all data races that were actually executed.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
However, it can only detect race conditions that occur during a run; it cannot prove that none will ever occur.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="k">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="n">x</span> <span class="o">=</span> <span class="m">1</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"y = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="n">y</span> <span class="o">=</span> <span class="m">1</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go run <span class="nt">-race</span> race.go
<span class="go">x = 0</span>
<span class="go">==================</span>
<span class="go">WARNING: DATA RACE</span>
<span class="hll"><span class="go">Write at 0x00c0000160c8 by goroutine 7:</span>
</span><span class="go">  main.main.func1()</span>
<span class="go">      /home/x/learn/go/race.go:15 +0xaa</span>

<span class="hll"><span class="go">Previous read at 0x00c0000160c8 by goroutine 8:</span>
</span><span class="go">  main.main.func2()</span>
<span class="go">      /home/x/learn/go/race.go:23 +0xcf</span>
<span class="c">...</span>
<span class="go">==================</span>
<span class="go">==================</span>
<span class="go">WARNING: DATA RACE</span>
<span class="hll"><span class="go">Read at 0x00c0000160d8 by goroutine 7:</span>
</span><span class="go">  main.main.func1()</span>
<span class="go">      /home/x/learn/go/race.go:16 +0xcf</span>

<span class="hll"><span class="go">Previous write at 0x00c0000160d8 by goroutine 8:</span>
</span><span class="go">  main.main.func2()</span>
<span class="go">      /home/x/learn/go/race.go:22 +0xaa</span>
<span class="go">==================</span>
<span class="go">y = 1</span>
<span class="go">Found 2 data race(s)</span>
<span class="go">exit status 66</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Azure Open AI | ChatGPT4</div>
<div class="paragraph">
<p>When you run a Go program with the <code>-race</code> flag, the Go race detector instruments the code to monitor concurrent access to shared variables. If it detects a race condition, it generates a report with detailed information about the issue. The output of the <code>-race</code> flag typically consists of the following parts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A summary of the data race, indicating that it is a "DATA RACE."</p>
</li>
<li>
<p>A description of the current operation (read or write) that caused the race, including the memory address, the source code file, and the line number.</p>
</li>
<li>
<p>The current goroutine involved in the race, including its number and the stack trace.</p>
</li>
<li>
<p>A description of the previous conflicting operation (read or write) on the same memory address, including the source code file and the line number.</p>
</li>
<li>
<p>The previous goroutine involved in the race, including its number and the stack trace.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, consider the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">WARNING: DATA RACE
Write at 0x00c0000160c8 by goroutine 7:
  main.main.func1()
      /path/to/your/code/main.go:16 +0x6a

Previous read at 0x00c0000160c8 by goroutine 8:
  main.main.func2()
      /path/to/your/code/main.go:22 +0x3e</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This output can be interpreted as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The race detector has identified a data race.</p>
</li>
<li>
<p>A write operation occurred at memory address <code>0x00c0000160c8</code> by goroutine 7. The operation happened in the function <code>main.main.func1()</code> in the source code file main.go at line 16.</p>
</li>
<li>
<p>The current goroutine 7 is shown along with the stack trace.</p>
</li>
<li>
<p>A previous read operation occurred at the same memory address <code>0x00c0000160c8</code> by goroutine 8. The operation happened in the function <code>main.main.func2()</code> in the source code file main.go at line 22.</p>
</li>
<li>
<p>The previous goroutine 8 is shown along with the stack trace.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Using this information, you can identify the source code lines and goroutines involved in the race condition and take appropriate action to fix the issue, such as adding proper synchronization mechanisms like mutexes or channels.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="happen-before">8.3. Happen before</h3>
<div class="ulist">
<ul>
<li>
<p>Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program.</p>
</li>
<li>
<p>That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification.</p>
</li>
<li>
<p>Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another.</p>
<div class="paragraph">
<p>For example, if one goroutine executes <code>a = 1; b = 2</code>;, another might observe the updated value of <code>b</code> before the updated value of <code>a</code>.</p>
</div>
</li>
<li>
<p>To specify the requirements of reads and writes, we define <em>happens before</em>, a <em>partial order</em> on the execution of memory operations in a Go program.</p>
<div class="paragraph">
<p>If event <em>e1</em> happens before event <em>e2</em>, then we say that <em>e2</em> happens after <em>e1</em>.</p>
</div>
<div class="paragraph">
<p>Also, if <em>e1</em> does not happen before <em>e2</em> and does not happen after <em>e2</em>, then we say that <em>e1</em> and <em>e2</em> <em>happen concurrently</em>.</p>
</div>
</li>
<li>
<p>Within a single goroutine, the happens-before order is the order expressed by the program.</p>
</li>
<li>
<p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.</p>
</li>
<li>
<p>To serialize access, protect the data with <em>channel operations</em> or other <em>synchronization primitives</em> such as those in the <code>sync</code> and <code>sync/atomic</code> packages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="share-by-communicating">8.4. Share by communicating</h3>
<div class="ulist">
<ul>
<li>
<p><em>Do not communicate by sharing memory; instead, share memory by communicating.</em></p>
<div class="ulist">
<ul>
<li>
<p>Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution.</p>
</li>
<li>
<p>Only one goroutine has access to the value at any given time. Data races cannot occur, by design.</p>
</li>
</ul>
</div>
</li>
<li>
<p>One way to think about this model is to consider a typical single-threaded program running on one CPU.</p>
<div class="ulist">
<ul>
<li>
<p>It has no need for synchronization primitives.</p>
</li>
<li>
<p>Now run another such instance; it too needs no synchronization.</p>
</li>
<li>
<p>Now let those two communicate; if the communication is the synchronizer, there&#8217;s still no need for other synchronization.</p>
</li>
<li>
<p>Unix pipelines, for example, fit this model perfectly.</p>
</li>
<li>
<p>Although Go&#8217;s approach to concurrency originates in Hoare&#8217;s <em>Communicating Sequential Processes</em> (CSP), it can also be seen as a type-safe generalization of Unix pipes.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="goroutines">8.5. Goroutines</h3>
<div class="ulist">
<ul>
<li>
<p>A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space.</p>
<div class="ulist">
<ul>
<li>
<p>It is lightweight, costing little more than the allocation of stack space. <a href="#TALKSCONCURRENCY">[20]</a></p>
</li>
<li>
<p>And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run.</p>
<div class="ulist">
<ul>
<li>
<p>Their design hides many of the complexities of thread creation and management.</p>
</li>
<li>
<p>Prefix a function or method call with the <code>go</code> keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently.</p>
</li>
<li>
<p>The evaluation of <code>f</code>, <code>x</code>, <code>y</code>, and <code>z</code> of <code>go f(x, y, z)</code> happens in the current goroutine and the execution of <code>f</code> happens in the new goroutine.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// All function values created by this loop “capture”</span>
	<span class="c">// and share the same variable—an addressable storage location,</span>
	<span class="c">// not its value at that particular moment.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">:=</span> <span class="n">i</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>

	<span class="c">// Output:</span>
	<span class="c">// 5 5 5 5 5</span>
	<span class="c">// 4 0 1 2 3	// ignore the order</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Best number of goroutines in a process</strong></p>
</div>
<div class="paragraph">
<p>There is no one-size-fits-all answer to the best number of goroutines in a process, as it depends on various factors such as the nature of your application, the resources available on your system, and the level of parallelism your program can achieve. However, here are some general guidelines to help you determine the optimal number of goroutines: <a href="#Azure Open AI | ChatGPT4">[Azure Open AI | ChatGPT4]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>I/O-bound tasks: If your application performs tasks that are primarily I/O-bound, such as reading from or writing to disk, network, or other external resources, you can benefit from a higher number of goroutines. Since I/O-bound tasks often involve waiting for external resources, having more goroutines can help keep your application busy and utilize available CPU resources effectively. In this case, the optimal number of goroutines might be several times the number of available CPU cores.</p>
</li>
<li>
<p>CPU-bound tasks: If your application performs tasks that are primarily CPU-bound, such as complex calculations or data processing, you may not benefit from a higher number of goroutines than the number of available CPU cores. Having more goroutines than CPU cores can lead to frequent context switching, which can hurt performance. In this case, the optimal number of goroutines might be close to the number of available CPU cores.</p>
</li>
<li>
<p>Workload characteristics: The best number of goroutines also depends on the specific characteristics of your application&#8217;s workload. For example, if your application has a mix of I/O-bound and CPU-bound tasks, or if it has varying resource requirements over time, you might need to experiment with different numbers of goroutines to find the optimal balance.</p>
</li>
<li>
<p>Resource availability: The optimal number of goroutines also depends on the resources available on your system, such as CPU, memory, and I/O capacity. If your system is constrained in terms of resources, you may need to limit the number of goroutines to avoid exhausting system resources and causing performance issues.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When there are many Go processes running on the same operating system, it is essential to consider the overall resource usage of the entire system. Running multiple Go processes with a large number of goroutines can lead to contention for system resources, such as CPU, memory, and I/O capacity. In this case, it might be necessary to limit the number of goroutines per process or to distribute the processes across multiple machines to ensure optimal performance.</p>
</div>
<div class="paragraph">
<p>Ultimately, the best way to determine the optimal number of goroutines for your application is through benchmarking, monitoring, and profiling. By measuring the performance of your application under different conditions and configurations, you can make informed decisions about the appropriate number of goroutines and resource allocation.</p>
</div>
</div>
<div class="sect2">
<h3 id="channels-2">8.6. Channels</h3>
<div class="ulist">
<ul>
<li>
<p>Like maps, channels are allocated with <code>make</code>, and the resulting value acts as a reference to an underlying data structure.</p>
<div class="ulist">
<ul>
<li>
<p>If an optional integer parameter is provided, it sets the buffer size for the channel.</p>
</li>
<li>
<p>The default is zero, for an unbuffered or synchronous channel.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">ci</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>            <span class="c">// unbuffered channel of integers</span>
<span class="n">cj</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>         <span class="c">// unbuffered channel of integers</span>
<span class="n">cs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>  <span class="c">// buffered channel of pointers to Files</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Receivers always block until there is data to receive.</p>
</li>
<li>
<p>The sender blocks only until the value has been copied to the buffer.</p>
</li>
<li>
<p>A buffered channel can be used like a semaphore, for instance to limit throughput.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// create a buffered channel with capacity 1</span>
<span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">1</span>                 <span class="c">// send 1 to the channel (non-blocking because of buffer)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span>       <span class="c">// receive 1 from the channel</span>

<span class="n">ch</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c">// create an unbuffered (blocking) channel</span>
<span class="n">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c">// create a channel to synchronize the goroutine's completion</span>
<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">2</span>                      <span class="c">// send 2 to the channel (blocks until received)</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span> <span class="c">// simulate some work</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>               <span class="c">// print 3 after the send</span>
	<span class="n">stop</span> <span class="o">&lt;-</span> <span class="m">0</span>                    <span class="c">// signal that the goroutine is finished</span>
<span class="p">}()</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span> <span class="c">// receive 2 from the channel (unblocks the goroutine)</span>
<span class="o">&lt;-</span><span class="n">stop</span>            <span class="c">// wait for the goroutine to signal completion</span>

<span class="c">// Output:</span>
<span class="c">// 1</span>
<span class="c">// 2</span>
<span class="c">// 3</span></code></pre>
</div>
</div>
</li>
<li>
<p>The assembly line metaphor (pipeline) is useful one for channels and goroutines.</p>
<div class="listingblock">
<div class="title"><em>ref <a href="http://golang.org/s/prime-sieve" class="bare">http://golang.org/s/prime-sieve</a></em></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// A concurrent prime sieve</span>

<span class="c">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span>
<span class="k">func</span> <span class="n">Generate</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="c">// Send 'i' to channel 'ch'.</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// Copy the values from channel 'in' to channel 'out',</span>
<span class="c">// removing those divisible by 'prime'.</span>
<span class="k">func</span> <span class="n">Filter</span><span class="p">(</span><span class="n">in</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">out</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="n">prime</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">in</span> <span class="c">// Receive value from 'in'.</span>
		<span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="n">prime</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">out</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="c">// Send 'i' to 'out'.</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// The prime sieve: Daisy-chain Filter processes.</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c">// Create a new channel.</span>
	<span class="k">go</span> <span class="n">Generate</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>      <span class="c">// Launch Generate goroutine.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">prime</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>
		<span class="nb">print</span><span class="p">(</span><span class="n">prime</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
		<span class="n">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
		<span class="k">go</span> <span class="n">Filter</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ch1</span><span class="p">,</span> <span class="n">prime</span><span class="p">)</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">ch1</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="parallelization">8.7. Parallelization</h3>
<div class="paragraph">
<p>Be sure not to confuse the ideas of concurrency&#8212;&#8203;structuring a program as independently executing components&#8212;&#8203;and parallelism&#8212;&#8203;executing calculations in parallel for efficiency on multiple CPUs.</p>
</div>
<div class="paragraph">
<p>Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go&#8217;s model.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">package runtime // import "runtime"

func NumCPU() int
    NumCPU returns the number of logical CPUs usable by the current process.

    The set of available CPUs is checked by querying the operating system at
    process startup. Changes to operating system CPU allocation after process
    startup are not reflected.

func GOMAXPROCS(n int) int
    GOMAXPROCS sets the maximum number of CPUs that can be executing
    simultaneously and returns the previous setting. If n &lt; 1, it does not
    change the current setting. The number of logical CPUs on the local machine
    can be queried with NumCPU. This call will go away when the scheduler
    improves.</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="synchronization">8.8. Synchronization</h3>
<div class="paragraph">
<p>In Go, synchronization is essential for ensuring safe concurrent execution of code and coordinating the activities of multiple goroutines. Go provides various synchronization primitives and constructs to facilitate communication between goroutines, protect access to shared resources, and manage concurrent execution. Here&#8217;s a comprehensive introduction to synchronization in Go: <a href="#Azure Open AI | ChatGPT4">[Azure Open AI | ChatGPT4]</a></p>
</div>
<div class="sect3">
<h4 id="channels-3">8.8.1. Channels</h4>
<div class="paragraph">
<p>Channels are the primary synchronization mechanism in Go and are used for communication between goroutines. They allow goroutines to send and receive values, which can be used for signaling or passing data. Channels provide a way to synchronize the execution of goroutines and ensure that data is safely shared without race conditions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Creating a channel</span>
<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c">// Sending a value to a channel</span>
<span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">42</span>

<span class="c">// Receiving a value from a channel</span>
<span class="n">value</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Semaphores in Go?</strong></p>
<div class="paragraph">
<p>Go does not provide semaphores as a dedicated primitive like <code>sync.Mutex</code> . Instead, they can be implemented using buffered channels.</p>
</div>
<div class="paragraph">
<p>Semaphores are used to control access to a limited number of resources or to limit the degree of concurrency for a group of goroutines.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of how to implement a semaphore using a buffered channel in Go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">const</span> <span class="n">maxConcurrent</span> <span class="o">=</span> <span class="m">3</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="c">// Create a buffered channel to act as a semaphore</span>
	<span class="n">semaphore</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span> <span class="n">maxConcurrent</span><span class="p">)</span>
	<span class="c">// Simulate 10 tasks that need to be executed concurrently</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">taskID</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
			<span class="c">// Acquire the semaphore</span>
			<span class="n">semaphore</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
			<span class="c">// Execute the task</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Task %d started</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">taskID</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Task %d completed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">taskID</span><span class="p">)</span>
			<span class="c">// Release the semaphore</span>
			<span class="o">&lt;-</span><span class="n">semaphore</span>
		<span class="p">}(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sync-mutex">8.8.2. sync.Mutex</h4>
<div class="paragraph">
<p>A Mutex (short for "mutual exclusion",  /ˈmjuːtɛks/) is a synchronization primitive used to protect access to shared resources and ensure that only one goroutine can access the resource at a time.</p>
</div>
<div class="paragraph">
<p>Mutexes help prevent race conditions when multiple goroutines attempt to modify shared state concurrently.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">num</span> <span class="o">:=</span> <span class="m">0</span>

<span class="k">var</span> <span class="n">mu</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>

<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="n">_000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">num</span> <span class="o">+=</span> <span class="m">1</span>
	<span class="p">}</span>
<span class="p">}()</span>

<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="n">locked</span> <span class="o">:=</span> <span class="n">mu</span><span class="o">.</span><span class="n">TryLock</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">locked</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"recursive lock!"</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"not recursive lock!"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="n">_000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">num</span> <span class="o">+=</span> <span class="m">1</span>
	<span class="p">}</span>
<span class="p">}()</span>

<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="c">// 200000</span>

<span class="c">// Output:</span>
<span class="c">// not recursive lock!</span>
<span class="c">// 200000</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sync-rwmutex">8.8.3. sync.RWMutex</h4>
<div class="paragraph">
<p>An RWMutex (short for "read-write mutex") is similar to a Mutex but allows multiple readers to access a shared resource simultaneously, as long as no writer is accessing it.</p>
</div>
<div class="paragraph">
<p>It provides two separate locks: a read lock and a write lock. Multiple goroutines can acquire read locks at the same time, but only one can acquire a write lock, and it must wait for all read locks to be released.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">ConcurrentMap</span><span class="p">[</span><span class="n">TKey</span> <span class="n">comparable</span><span class="p">,</span> <span class="n">TValue</span> <span class="n">any</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">m</span>    <span class="k">map</span><span class="p">[</span><span class="n">TKey</span><span class="p">]</span><span class="n">TValue</span>
	<span class="n">rwMu</span> <span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">TKey</span> <span class="n">comparable</span><span class="p">,</span> <span class="n">TValue</span> <span class="n">any</span><span class="p">]()</span> <span class="o">*</span><span class="n">ConcurrentMap</span><span class="p">[</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">]</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ConcurrentMap</span><span class="p">[</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">]{</span><span class="n">m</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="n">TKey</span><span class="p">]</span><span class="n">TValue</span><span class="p">)}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span><span class="n">ConcurrentMap</span><span class="p">[</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">])</span> <span class="n">Add</span><span class="p">(</span><span class="n">key</span> <span class="n">TKey</span><span class="p">,</span> <span class="n">value</span> <span class="n">TValue</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">q</span><span class="o">.</span><span class="n">rwMu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">q</span><span class="o">.</span><span class="n">rwMu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="n">q</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span><span class="n">ConcurrentMap</span><span class="p">[</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">])</span> <span class="n">Remove</span><span class="p">(</span><span class="n">key</span> <span class="n">TKey</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">q</span><span class="o">.</span><span class="n">rwMu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">q</span><span class="o">.</span><span class="n">rwMu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="nb">delete</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span><span class="n">ConcurrentMap</span><span class="p">[</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">])</span> <span class="n">TryGet</span><span class="p">(</span><span class="n">key</span> <span class="n">TKey</span><span class="p">)</span> <span class="p">(</span><span class="n">item</span> <span class="n">TValue</span><span class="p">,</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">q</span><span class="o">.</span><span class="n">rwMu</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">q</span><span class="o">.</span><span class="n">rwMu</span><span class="o">.</span><span class="n">RUnlock</span><span class="p">()</span>
	<span class="n">item</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
	<span class="k">return</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sync-waitgroup">8.8.4. sync.WaitGroup</h4>
<div class="paragraph">
<p>A WaitGroup is a synchronization construct used to wait for a collection of goroutines to finish execution, that is often used when you start multiple goroutines to perform tasks concurrently and need to wait for all of them to complete before proceeding.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">num</span> <span class="kt">int32</span>
<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span> <span class="c">// define a WaitGroup</span>
<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>             <span class="c">// add delta, which may be negative, to the WaitGroup counter.</span>

<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="c">// decrement the WaitGroup counter by one.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="n">_000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="m">2</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}()</span>

<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="n">_000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="m">2</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
			<span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}()</span>

<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>        <span class="c">// block until the WaitGroup counter is zero.</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="c">// 10_000</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sync-cond">8.8.5. sync.Cond</h4>
<div class="paragraph">
<p>A Cond (short for "condition") is a synchronization primitive used to wait for or signal conditions.</p>
</div>
<div class="paragraph">
<p>It is useful when one or more goroutines need to wait for a specific condition to be met before they can proceed.</p>
</div>
<div class="paragraph">
<p>Conds are often used with a Mutex or RWMutex to protect access to the shared state being tested in the condition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">BlockingChannel</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">items</span> <span class="p">[]</span><span class="n">T</span>
	<span class="n">c</span>     <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span>
	<span class="n">mu</span>    <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span> <span class="c">// explicit mutex for clarity</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">BlockingChannel</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
	<span class="n">mu</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">BlockingChannel</span><span class="p">[</span><span class="n">T</span><span class="p">]{</span>
		<span class="n">items</span><span class="o">:</span> <span class="nb">make</span><span class="p">([]</span><span class="n">T</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">capacity</span><span class="p">),</span>
		<span class="n">c</span><span class="o">:</span>     <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="n">mu</span><span class="p">),</span> <span class="c">// create a new condition variable associated with the mutex</span>
		<span class="n">mu</span><span class="o">:</span>    <span class="n">mu</span><span class="p">,</span>               <span class="c">// store the mutex</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">bc</span> <span class="o">*</span><span class="n">BlockingChannel</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>         <span class="c">// acquire the lock before accessing shared resources</span>
	<span class="k">defer</span> <span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">// ensure the lock is released when the function returns</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span> <span class="c">// wait if the channel is full</span>
		<span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// release the lock and wait for a signal</span>
	<span class="p">}</span>

	<span class="n">bc</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">items</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="c">// add the item to the channel</span>
	<span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>                     <span class="c">// Signal a waiting reader that an item is available.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">bc</span> <span class="o">*</span><span class="n">BlockingChannel</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">Read</span><span class="p">()</span> <span class="n">T</span> <span class="p">{</span>
	<span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span> <span class="c">// wait if the channel is empty</span>
		<span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// release the lock and wait for a signal</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
	<span class="n">item</span> <span class="o">:=</span> <span class="n">bc</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="n">bc</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="o">:</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="n">bc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span> <span class="c">// Signal all waiting writers that space is available</span>
	<span class="k">return</span> <span class="n">item</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sync-once">8.8.6. sync.Once</h4>
<div class="paragraph">
<p>A Once is a synchronization construct used to ensure that a function is only executed once, regardless of how many goroutines attempt to call it, that is useful for initializing shared resources, such as global variables or singletons, in a concurrent environment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Defining a Once</span>
<span class="k">var</span> <span class="n">once</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>

<span class="c">// Executing a function only once, regardless of how many goroutines call it</span>
<span class="n">once</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// initialize shared resource</span>
<span class="p">})</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sync-map">8.8.7. sync.Map</h4>
<div class="paragraph">
<p>A Map is a concurrent, thread-safe map implementation provided by the <code>sync</code> package. It is designed for cases where the number of keys is large and their lifetimes are mostly unknown.</p>
</div>
<div class="paragraph">
<p>Unlike the built-in map type, <code>sync.Map</code> provides safe concurrent access without requiring an additional synchronization mechanism like a Mutex.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Defining a sync.Map</span>
<span class="k">var</span> <span class="n">m</span> <span class="n">sync</span><span class="o">.</span><span class="n">Map</span>

<span class="c">// Storing a value in sync.Map</span>
<span class="n">m</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="s">"key"</span><span class="p">,</span> <span class="s">"value"</span><span class="p">)</span>

<span class="c">// Loading a value from sync.Map</span>
<span class="n">value</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="s">"key"</span><span class="p">)</span>

<span class="c">// Deleting a value from sync.Map</span>
<span class="n">m</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="s">"key"</span><span class="p">)</span>

<span class="c">// Iterating over sync.Map</span>
<span class="n">m</span><span class="o">.</span><span class="n">Range</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"key: %v, value: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="no">true</span>
<span class="p">})</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syncatomic">8.8.8. sync/atomic</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">package atomic // import "sync/atomic"

Package atomic provides low-level atomic memory primitives useful for
implementing synchronization algorithms.

These functions require great care to be used correctly. Except for special,
low-level applications, synchronization is better done with channels or the
facilities of the sync package. Share memory by communicating; don't
communicate by sharing memory.

BUG: On 386, the 64-bit functions use instructions unavailable before the Pentium MMX.

On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.

On ARM, 386, and 32-bit MIPS, it is the caller's responsibility to arrange
for 64-bit alignment of 64-bit words accessed atomically via the primitive
atomic functions (types [Int64] and [Uint64] are automatically aligned).
The first word in an allocated struct, array, or slice; in a global
variable; or in a local variable (because on 32-bit architectures, the
subject of 64-bit atomic operations will escape to the heap) can be
relied upon to be 64-bit aligned.</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Share memory by communicating; don&#8217;t communicate by sharing memory.</p>
</li>
<li>
<p>For most synchronization needs, Go&#8217;s channels and the <code>sync</code> package (e.g., <code>sync.Mutex</code>, <code>sync.WaitGroup</code>, <code>sync.Cond</code>) provide safer and easier-to-use abstractions.</p>
</li>
<li>
<p>Channels provide a more structured and less error-prone way to synchronize concurrent operations.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="errors">9. Errors</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Library routines must often return some sort of error indication to the caller.</p>
</li>
<li>
<p>Go&#8217;s multi-value return makes it a good style to easily return a detailed error description alongside the normal return value.</p>
</li>
<li>
<p>The <code>error</code> built-in interface type is the conventional interface for representing an error condition, with the <code>nil</code> value representing no error, typically created using <code>fmt.Errorf</code> or <code>errors.New</code>.</p>
</li>
<li>
<p>When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="n">r</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"recoverd: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>
			<span class="n">foo</span> <span class="o">:=</span> <span class="n">errors</span><span class="o">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"inner error: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="n">fi</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">pe</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">err</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">PathError</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"path error: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"unknown error: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="n">fi</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"bar"</span><span class="p">)</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"foo: %w"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="c">// wrap an inner error</span>
	<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// path error: open hello.txt: no such file or directory</span>
<span class="c">// recoverd: foo: bar</span>
<span class="c">// inner error: bar</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>panic</code> built-in function stops normal execution of the current goroutine, and the <code>recover</code> built-in function allows a program to manage behavior of a panicking goroutine.</p>
<div class="ulist">
<ul>
<li>
<p>When a function <code>F</code> calls <code>panic</code>, normal execution of <code>F</code> stops immediately.</p>
</li>
<li>
<p>Any functions whose execution was deferred by <code>F</code> are run in the usual way, and then <code>F</code> returns to its caller.</p>
</li>
<li>
<p>To the caller <code>G</code>, the invocation of <code>F</code> then behaves like a call to <code>panic</code>, terminating G&#8217;s execution and running any deferred functions, until all functions in the executing goroutine have stopped, in reverse order.</p>
</li>
<li>
<p>At that point, the program is terminated with a non-zero exit code.</p>
</li>
<li>
<p>Executing a call to <code>recover</code> inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of <code>panic</code>.</p>
</li>
<li>
<p>If <code>recover</code> is called outside the deferred function it will not stop a panicking sequence.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">F</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"F: panic"</span><span class="p">)</span>
	<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">G</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="n">r</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"G: %w"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
			<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="n">F</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="n">r</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="n">G</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// G: F: panic</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing">10. Testing</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>The <code>go test</code> subcommand is a test driver for Go packages that are organized according to certain conventions.</p>
</li>
<li>
<p>In a package directory, files whose names end with <code>_test.go</code> are not part of the package ordinarily built by <code>go build</code> but are a part of it when built by <code>go test</code>.</p>
</li>
<li>
<p>Within <code>_test.go</code> files, four kinds of functions are treated specially: tests, fuzzs, benchmarks, and examples.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>A <em>test</em> function, which is a function whose name begins with <code>Test</code> exercises some program logic for correct behavior; <code>go test</code> calls the test function and report the result, which is either PASS or FAIL.</p>
</li>
<li>
<p>With <em>fuzzing</em>, random data is run against your test in an attempt to find vulnerabilities or crash-causing inputs.</p>
</li>
<li>
<p>A <em>benchmark</em> function has a name beginning with <code>Benchmark</code> and measures the performance of some operation; <code>go test</code> reports the mean execution time of the operation.</p>
</li>
<li>
<p>And an <em>example</em> function, whose name starts with <code>Example</code>, provides machine-checked documentation.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">Foo</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">TestFoo</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">tests</span> <span class="o">=</span> <span class="p">[]</span><span class="k">struct</span> <span class="p">{</span>
		<span class="n">s</span>    <span class="kt">string</span>
		<span class="n">want</span> <span class="kt">string</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">"Hello"</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">},</span>
		<span class="p">{</span><span class="s">"世界!"</span><span class="p">,</span> <span class="s">"世界!"</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tests</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">got</span> <span class="o">:=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">);</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"foo(%q) == %q, want %q"</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// Fuzz test</span>
<span class="k">func</span> <span class="n">FuzzFoo</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// Seed corpus addition</span>
	<span class="n">f</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
	<span class="c">// Fuzz target</span>
	<span class="n">f</span><span class="o">.</span><span class="n">Fuzz</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="c">// s string // Fuzzing arguments</span>

		<span class="k">if</span> <span class="n">got</span> <span class="o">:=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">s</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"foo(%q) == %q, want %q"</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkFoo</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ExampleFoo</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"BAR"</span><span class="p">)</span>
	<span class="c">// Output:</span>
	<span class="c">// BAR</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nv">GO111MODULE</span><span class="o">=</span>off go <span class="nb">test</span>
<span class="go">PASS
ok  	_/tmp/learn-notes	0.003s

</span><span class="gp">$</span><span class="w"> </span><span class="nv">GO111MODULE</span><span class="o">=</span>off go <span class="nb">test</span> <span class="nt">-fuzz</span><span class="o">=</span>Fuzz <span class="nt">-fuzztime</span><span class="o">=</span>3s
<span class="go">fuzz: elapsed: 0s, gathering baseline coverage: 0/1 completed
fuzz: elapsed: 0s, gathering baseline coverage: 1/1 completed, now fuzzing with 4 workers
fuzz: elapsed: 3s, execs: 226192 (75387/sec), new interesting: 0 (total: 1)
fuzz: elapsed: 3s, execs: 226192 (0/sec), new interesting: 0 (total: 1)
PASS
ok  	_/tmp/learn-notes	3.127s

</span><span class="gp">$</span><span class="w"> </span><span class="nv">GO111MODULE</span><span class="o">=</span>off go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span>.<span class="k">*</span>
<span class="go">goos: linux
goarch: amd64
cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz
BenchmarkFoo-4   	1000000000	         0.5349 ns/op
PASS
ok  	_/tmp/learn-notes	0.605s</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modules">11. Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Go 1.11 and 1.12 include preliminary <a href="https://go.dev/doc/go1.11#modules">support for modules</a>, Go’s new <a href="https://blog.golang.org/versioning-proposal">dependency management system</a> that makes dependency version information explicit and easier to manage.<a href="#BLOGSMODULES">[2]</a></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">GOPATH and GO111MODULE: <a href="https://go.dev/blog/go116-module-changes">New module changes in Go 1.16</a></div>
<div class="paragraph">
<p>The <code>go</code> command now builds packages in module-aware mode by default, even when no <code>go.mod</code> is present. This is a big step toward using modules in all projects.</p>
</div>
<div class="paragraph">
<p>It’s still possible to build packages in <code>GOPATH</code> mode by setting the <code>GO111MODULE</code> environment variable to off. You can also set <code>GO111MODULE</code> to auto to enable module-aware mode only when a go.mod file is present in the current directory or any parent directory. This was previously the default. Note that you can set <code>GO111MODULE</code> and other variables permanently with <code>go env -w</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">go <span class="nb">env</span> <span class="nt">-w</span> <span class="nv">GO111MODULE</span><span class="o">=</span>auto</code></pre>
</div>
</div>
<div class="paragraph">
<p>We plan to drop support for <code>GOPATH</code> mode in Go 1.17. In other words, Go 1.17 will ignore <code>GO111MODULE</code>. If you have projects that do not build in module-aware mode, now is the time to migrate.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Go, if an old package and a new package have the same import path, the new package must be backwards compatible with the old package.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is certainly a cost to needing to introduce a new name for each backwards-incompatible API change, but as the semver FAQ says, that cost should encourage authors to more clearly consider the impact of such changes and whether they are truly necessary.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A <strong>module path</strong> is the canonical name for a module, declared with the module directive in the module’s <code>go.mod</code> file. A module’s path is the prefix for package paths within the module.</p>
</div>
<div class="paragraph">
<p>A module path should describe both what the module does and where to find it. Typically, a module path consists of a repository root path, a directory within the repository (usually empty), and a major version suffix (only for major version 2 or higher). <a href="#REFMOD">[4]</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>module</em> is a collection of related Go packages that are versioned together as a single unit.</p>
</li>
<li>
<p>Modules record precise dependency requirements and create reproducible builds.</p>
</li>
<li>
<p>Most often, a version control repository contains exactly one module defined in the repository root.</p>
</li>
<li>
<p>Summarizing the relationship between repositories, modules, and packages:</p>
<div class="ulist">
<ul>
<li>
<p>A repository contains one or more Go modules.</p>
</li>
<li>
<p>Each module contains one or more Go packages.</p>
</li>
<li>
<p>Each package consists of one or more Go source files in a single directory.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Modules must be semantically versioned according to <a href="https://semver.org/">semver</a>, usually in the form <code>v(major).(minor).(patch)</code>, such as <code>v0.1.0</code>, <code>v1.2.3</code>, or <code>v1.5.0-rc.1</code>.</p>
<div class="ulist">
<ul>
<li>
<p>The leading <code>v</code> is required.</p>
</li>
<li>
<p>If using Git, tag released commits with their versions.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A module is defined by a tree of Go source files with a <code>go.mod</code> file in the tree&#8217;s root directory.</p>
</li>
<li>
<p>A module declares its identity in its <code>go.mod</code> via the <code>module</code> directive, which provides the <strong>module path</strong>.</p>
<div class="ulist">
<ul>
<li>
<p>The import paths for all packages in a module share the module path as a common prefix.</p>
</li>
<li>
<p>The module path and the relative path from the <code>go.mod</code> to a package&#8217;s directory together determine a package&#8217;s import path.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In Go source code, packages are imported using the full path including the module path.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">go <span class="nb">help </span>modules
go <span class="nb">help </span>go.mod
go <span class="nb">help </span>module-private

go <span class="nb">help </span>goproxy
go <span class="nb">env </span>GOPROXY <span class="c"># https://proxy.golang.org,direct</span>
go <span class="nb">env</span> <span class="nt">-w</span> <span class="nv">GOPROXY</span><span class="o">=</span>https://goproxy.cn,direct
go <span class="nb">env </span>GOPROXY <span class="c"># https://goproxy.cn,direct</span>

go <span class="nb">help </span>gopath</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="printf">12. Printf</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Package <code>fmt</code> implements formatted I/O with functions analogous to C&#8217;s <em>printf</em> and <em>scanf</em>.<a href="#PKGFMT">[16]</a></p>
</div>
<div class="sect2">
<h3 id="the-printing-verbs">12.1. The Printing verbs</h3>
<div class="listingblock">
<div class="title"><em>General</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%v	the value in a default format
	when printing structs, the plus flag (%+v) adds field names
%#v	a Go-syntax representation of the value
%T	a Go-syntax representation of the type of the value
%%	a literal percent sign; consumes no value</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Pointer</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">X</span> <span class="kt">int</span>
	<span class="n">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">p</span> <span class="o">:=</span> <span class="n">Pointer</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%v: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%+v: %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%#v: %#v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%T: %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// %v: {3 4}</span>
<span class="c">// %+v: {X:3 Y:4}</span>
<span class="c">// %#v: main.Pointer{X:3, Y:4}</span>
<span class="c">// %T: main.Pointer</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Boolean</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%t	the word true or false</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Integer</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%b	base 2
%c	the character represented by the corresponding Unicode code point
%d	base 10
%o	base 8
%O	base 8 with 0o prefix
%q	a single-quoted character literal safely escaped with Go syntax.
%x	base 16, with lower-case letters for a-f
%X	base 16, with upper-case letters for A-F
%U	Unicode format: U+1234; same as "U+%04X"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">1234</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%b: %b</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%c: %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%d: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%o: %o</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%O: %O</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%q: %q</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%x: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%X: %X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%U: %U</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// %b: 10011010010</span>
<span class="c">// %c: Ӓ</span>
<span class="c">// %d: 1234</span>
<span class="c">// %o: 2322</span>
<span class="c">// %O: 0o2322</span>
<span class="c">// %q: 'Ӓ'</span>
<span class="c">// %x: 4d2</span>
<span class="c">// %X: 4D2</span>
<span class="c">// %U: U+04D2</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Floating-point and complex constituents</em>:</div>
<div class="content">
<pre>%b	decimalless scientific notation with exponent a power of two,
	in the manner of <em>strconv.FormatFloat</em> with the 'b' format,
	e.g. -123456p-78
%e	scientific notation, e.g. -1.234456e+78
%E	scientific notation, e.g. -1.234456E+78
%f	decimal point but no exponent, e.g. 123.456
%F	synonym for %f
%g	%e for large exponents, %f otherwise. Precision is discussed below.
%G	%E for large exponents, %F otherwise
%x	hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20
%X	upper-case hexadecimal notation, e.g. -0X1.23ABCP+20</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="o">-</span><span class="m">123456.789</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%b: %b</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%e: %e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%E: %E</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%f: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%F: %F</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%g: %g</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%G: %G</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%x: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%%X: %X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// %b: -8483885939586761p-36</span>
<span class="c">// %e: -1.234568e+05</span>
<span class="c">// %E: -1.234568E+05</span>
<span class="c">// %f: -123456.789000</span>
<span class="c">// %F: -123456.789000</span>
<span class="c">// %g: -123456.789</span>
<span class="c">// %G: -123456.789</span>
<span class="c">// %x: -0x1.e240c9fbe76c9p+16</span>
<span class="c">// %X: -0X1.E240C9FBE76C9P+16</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>String and slice of bytes (treated equivalently with these verbs)</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%s	the uninterpreted bytes of the string or slice
%q	a double-quoted string safely escaped with Go syntax
%x	base 16, lower-case, two characters per byte
%X	base 16, upper-case, two characters per byte</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Slice</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%p	address of 0th element in base 16 notation, with leading 0x</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Pointer</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%p	base 16 notation, with leading 0x
The %b, %d, %o, %x and %X verbs also work with pointers,
formatting the value exactly as if it were an integer.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>The default format for <code>%v</code> is</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>For compound objects, the elements are printed using these rules, recursively, laid out like this</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">struct:             {field0 field1 ...}
array, slice:       [elem0 elem1 ...]
maps:               map[key1:value1 key2:value2 ...]
pointer to above:   &amp;{}, &amp;[], &amp;map[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Other flags</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">'+'	always print a sign for numeric values;
	guarantee ASCII-only output for %q (%+q)
'-'	pad with spaces on the right rather than the left (left-justify the field)
'#'	alternate format: add leading 0b for binary (%#b), 0 for octal (%#o),
	0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);
	for %q, print a raw (backquoted) string if strconv.CanBackquote
	returns true;
	always print a decimal point for %e, %E, %f, %F, %g and %G;
	do not remove trailing zeros for %g and %G;
	write e.g. U+0078 'x' if the character is printable for %U (%#U).
' '	(space) leave a space for elided sign in numbers (% d);
	put spaces between bytes printing strings or slices in hex (% x, % X)
'0'	pad with leading zeros rather than spaces;
	for numbers, this moves the padding after the sign;
	ignored for strings, byte slices and byte arrays</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">123</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+06d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// +00123</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width-and-precision">12.2. Width and Precision</h3>
<div class="ulist">
<ul>
<li>
<p><strong><em>Width</em></strong> is specified by an optional decimal number immediately preceding the verb.</p>
<div class="paragraph">
<p>If absent, the width is whatever is necessary to represent the value.</p>
</div>
</li>
<li>
<p><strong><em>Precision</em></strong> is specified after the (optional) width by a period followed by a decimal number.</p>
<div class="paragraph">
<p>If no period is present, a default precision is used. A period with no following number specifies a precision of zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%f     default width, default precision
%9f    width 9, default precision
%.2f   default width, precision 2
%9.2f  width 9, precision 2
%9.f   width 9, precision 0</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="stringer">12.3. Stringer</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Stringer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Stringer</code> is implemented by any value that has a <code>String</code> method, which defines the "native" format for that value.</p>
</div>
<div class="paragraph">
<p>The <code>String</code> method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as <code>Print</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Animal has a Name and an Age to represent an animal.</span>
<span class="k">type</span> <span class="n">Animal</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
	<span class="n">Age</span>  <span class="kt">uint</span>
<span class="p">}</span>

<span class="c">// String makes Animal satisfy the Stringer interface.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="n">Animal</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%v (%d)"</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">:=</span> <span class="n">Animal</span><span class="p">{</span>
		<span class="n">Name</span><span class="o">:</span> <span class="s">"Gopher"</span><span class="p">,</span>
		<span class="n">Age</span><span class="o">:</span>  <span class="m">2</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
	<span class="c">// Output:</span>
	<span class="c">// Gopher (2)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="BLOGMAPS"></a>[1] <a href="https://go.dev/blog/maps" class="bare">https://go.dev/blog/maps</a></p>
</li>
<li>
<p><a id="BLOGSMODULES"></a>[2] <a href="https://go.dev/blog/using-go-modules" class="bare">https://go.dev/blog/using-go-modules</a></p>
</li>
<li>
<p><a id="BLOGSTRINGS"></a>[3] <a href="https://go.dev/blog/strings" class="bare">https://go.dev/blog/strings</a></p>
</li>
<li>
<p><a id="REFMOD"></a>[4] <a href="https://go.dev/ref/mod" class="bare">https://go.dev/ref/mod</a></p>
</li>
<li>
<p><a id="CAPITERVAR"></a>[5] <a href="/2017/05/15/capturing-iteration-variables-in-go-language/">Capturing Iteration Variables in Go Language</a></p>
</li>
<li>
<p><a id="CHANNELCLOSING"></a>[6] <a href="https://groups.google.com/g/golang-nuts/c/pZwdYRGxCIk/m/qpbHxRRPJdUJ" class="bare">https://groups.google.com/g/golang-nuts/c/pZwdYRGxCIk/m/qpbHxRRPJdUJ</a></p>
</li>
<li>
<p><a id="DAVEPRACTICALGO"></a>[7] <a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">Practical Go: Real world advice for writing maintainable Go programs</a></p>
</li>
<li>
<p><a id="EFFECTIVEGO"></a>[8] <a href="https://go.dev/doc/effective_go.html" class="bare">https://go.dev/doc/effective_go.html</a></p>
</li>
<li>
<p><a id="ERRORS"></a>[9] <a href="/2017/05/15/errors-in-go-language/">Errors in Go language</a></p>
</li>
<li>
<p><a id="GOCHANNELS"></a>[10] <a href="/2017/06/11/goroutines-and-channels-in-go-lanugage/">Goroutines and Channels in Go Language</a></p>
</li>
<li>
<p><a id="GOOOP"></a>[11] <a href="/2017/05/21/object-oriented-programming-in-go-language/">Object-oriented Programming in Go Language</a></p>
</li>
<li>
<p><a id="GOTESTING"></a>[12] <a href="/2017/07/01/testing-in-go-language/">Testing in Go Language</a></p>
</li>
<li>
<p><a id="SEMVER"></a>[13] <a href="https://semver.org/" class="bare">https://semver.org/</a></p>
</li>
<li>
<p><a id="INITSO"></a>[14] <a href="https://stackoverflow.com/questions/24790175/when-is-the-init-function-run" class="bare">https://stackoverflow.com/questions/24790175/when-is-the-init-function-run</a></p>
</li>
<li>
<p><a id="MEDIUMGOMODULES"></a>[15] <a href="https://medium.com/@adiach3nko/package-management-with-go-modules-the-pragmatic-guide-c831b4eaaf31" class="bare">https://medium.com/@adiach3nko/package-management-with-go-modules-the-pragmatic-guide-c831b4eaaf31</a></p>
</li>
<li>
<p><a id="PKGFMT"></a>[16] <a href="https://pkg.go.dev/fmt" class="bare">https://pkg.go.dev/fmt</a></p>
</li>
<li>
<p><a id="REFMEM"></a>[17] <a href="https://go.dev/ref/mem" class="bare">https://go.dev/ref/mem</a></p>
</li>
<li>
<p><a id="SHAREDVAR"></a>[18] <a href="/2017/06/17/concurrency-with-shared-variables-in-go-language/">Concurrency with Shared Variables in Go Language</a></p>
</li>
<li>
<p><a id="SPECIOTA"></a>[19] <a href="https://go.dev/ref/spec#Iota" class="bare">https://go.dev/ref/spec#Iota</a></p>
</li>
<li>
<p><a id="TALKSCONCURRENCY"></a>[20] <a href="https://talks.golang.org/2012/concurrency.slide" class="bare">https://talks.golang.org/2012/concurrency.slide</a></p>
</li>
<li>
<p><a id="TOURGENERICS"></a>[21] <a href="https://go.dev/tour/generics/1" class="bare">https://go.dev/tour/generics/1</a></p>
</li>
<li>
<p><a id="VGOIMPORT"></a>[22] <a href="https://research.swtch.com/vgo-import" class="bare">https://research.swtch.com/vgo-import</a></p>
</li>
<li>
<p><a id="VGOMODULE"></a>[23] <a href="https://research.swtch.com/vgo-module" class="bare">https://research.swtch.com/vgo-module</a></p>
</li>
<li>
<p><a id="VGOMVS"></a>[24] <a href="https://research.swtch.com/vgo-mvs" class="bare">https://research.swtch.com/vgo-mvs</a></p>
</li>
<li>
<p><a id="WIKIIOTA"></a>[25] <a href="https://github.com/golang/go/wiki/Iota" class="bare">https://github.com/golang/go/wiki/Iota</a></p>
</li>
<li>
<p><a id="WIKIMODULES"></a>[26] <a href="https://github.com/golang/go/wiki/Modules" class="bare">https://github.com/golang/go/wiki/Modules</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
