<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Packages and the Go Tool in Go Language | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Packages and the Go Tool in Go Language" />
<meta property="og:locale" content="en" />
<meta name="description" content="Import Paths The Package Declaration Import Declarations Packages and Naming The Go Tool Workspace Orgnization Documenting Packages References The purpose of any package system is to make the design and maintenance of large programs pratical by grouping related features together into units that can be easily understood and changed, independent of the other packages of the program. This modularity allows packages to be shared and reused by different project, distributed within an organization, or make available to the wider world. Each package defines a distinct name space that encloses its identifiers. Each name is associated with a particular package, letting us choose short, clear names for the types, functions, and so on that we use most often, without creating conflicts with other parts of the program. Packages also provide encapsulation by controlling which names are visible or exported outside the package. Go compilation is notably faster than most other compiled languages, even when building from scratch. There are three main reasons for the compiler’s speed. First, all imports must be explicitly listed at the beginning of each source file, so the compiler does not have to read and process an entire file to determine its dependencies. Second, the dependencies of a package form a directed acyclic graph, and because there are no cycles, packages can be compiled separately and perhaps in parallel. Finally, the object file for compiled Go package records export information not just for the package itself, but for its dependencies too. When compiling a package, the compiler must read one object file for each import but need not look beyond these files. Import Paths Each package is identified by a unique string called its import path. Import paths are the strings that appear n import declarations. import ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;golang.org/x/net/html&quot; &quot;github.com/go-sql-driver/mysql&quot; ) The Go language specification doesn’t define the meaning of these strings or how to determine a package’s import path, but leaves these issues to the tools. For package you intend to share or publish, import paths should be globally unqiue. To avoid conflicts, the import paths of all packages other than those from the standard library should start with the Internaet domain name of the organization that owns or hosts the packages; this make it possible to find packages. The Package Declaration A package declaration is required at the start of every Go source file. Its main purpose is to determine the default identifier for that package (called the package name) when it is imported by another package. Conventionally, the package name is the last segment of the import path, and as a result, two packages may have the same name even though their import paths necessarily differ. There are three major exceptions to the “last segment” convention. The fist is that a package defining a command (an executable Go program) always has the name main, regardless of the package’s import path. This is a signal to go build that it must invoke the linker to make an executalbe file. The second exception is that some files in the directory may have the suffix _test on their package name if the file name ends with _test.go. The _test suffix signals to go test that it must build both package, and it indicates which files belong to each package. The third exception is that some tools for dependency management append version number suffixes to package import paths, such as “gopkg.in/yaml.v2”. The package name excludes the suffix, so in this case it would be just yaml. Import Declarations A Go source file may contain zero or more import declarations immediately after the pacakge declaration and before the first non-import declaration. Each import declaration may specify the import path of a single package, or multiple packages in a parenthesized list. import &quot;fmt&quot; import &quot;os&quot; import ( &quot;fmt&quot; &quot;os&quot; ) Imported packages may be grouped by introducing blank lines; such groupings usually indicate different domains. import ( &quot;fmt&quot; &quot;html/template&quot; &quot;os&quot; &quot;golang.org/x/net/html&quot; &quot;golang.org/x/net/ipv4&quot; ) If we need to import two packages whose names are the same, like math/rand and crypto/rand, into a third package, the import declaration must specify an alternative name for the least one of them to avoid a confilict. This is called a renaming import. import ( &quot;crypto/rand&quot; mrand &quot;math/rand&quot; // alternative name mrand avoids conflict ) Choosing an alternative name can help avoid conflicts with common local variable names. import pathpkg &quot;path&quot; // import the standard &quot;path&quot; package as pathpkg To suppress the “unused import” error we would otherwise encounter, we must use a renaming import in which the altertive name is _, the blank identifier. As usual, the blank identifier can never be referenced. These is known as a blank import. import _ &quot;image/png&quot; // register PNG decoder The database/sql package uses a similar mechanism to let users install just the database drivers they need. import ( &quot;database/mysql&quot; _ &quot;github.com/go-sql-driver/mysql&quot; // enable support for MySQL _ &quot;github.com/lib/pq&quot; // enable support for Postgres ) db, err = sql.Open(&quot;postgres&quot;, dbname) // OK db, err = sql.Open(&quot;mysql&quot;, dbname) // OK db, err = sql.Open(&quot;sqlite3&quot;, dbname) // returns error: unknown driver &quot;sqlite3&quot; Packages and Naming When creating a package, keep its name short, but not so short as to be cryptic. The most frequently used packages in the standard library are named bufio, bytes, flag, fmt, http, io, json, os, sort, sync, and time. Be descriptive and unambiguous where possible. For example, don’t name a utility package util when a name such as imageutil or ioutil is specific yet still concise. Avoid choosing packages names that are commonly used for related local variables, or you may compel the package’s client to use renaming imports, as with the path package. Packages names usually take the singular form. The standard packages bytes, errors, and strings use the plural to avoid hiding the corresponding predeclared types and, in the case of go/types, to avoid conflict with a keyword. When desiging a package, consider how the two parts of a qualified identifier work together, not the member name alone. Here are some characteristic examples: bytes.Equal flag.Int http.Get json.Marshal The Go Tool The go tool combines the features of a diverse set of tools into one command set. Its command-line interface uses the “Swiss army knife” style, with over a dozen subcomands, like get, run, build and fmt. $ go help Go is a tool for managing Go source code. Usage: go command [arguments] The commands are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information bug start a bug report fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages Use &quot;go help [command]&quot; for more information about a command. Workspace Orgnization The only configuration most users ever need is the GOPATH environment variable, which specifies the root of the workspace. The default GOPATH is $HOME/go. A second environment variable, GOROOT, specifies the root directory of the Go distribiution, which provides all the packages of the standard library. Documenting Packages The go doc tool prints the declaration and doc comment of the entity specified on the command line, which may be a package: $ go doc time package time // import &quot;time&quot; Package time provides functionality for measuring and displaying time. The calendrical calculations always assume a Gregorian calendar, with no leap seconds. const ANSIC = &quot;Mon Jan _2 15:04:05 2006&quot; ... func After(d Duration) &lt;-chan Time func Sleep(d Duration) func Tick(d Duration) &lt;-chan Time type Duration int64 const Nanosecond Duration = 1 ... ...many more... or a package member: $ go doc time.Since func Since(t Time) Duration Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). or a method: $ go doc time.Duration.Seconds func (d Duration) Seconds() float64 Seconds returns the duration as a floating point number of seconds. The tool does not need complete import paths or crrect identifier case. $ go doc json.decode func (dec *Decoder) Decode(v interface{}) error Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. See the documentation for Unmarshal for details about the conversion of JSON into a Go value. The second tool, confusingly named godoc, serves cross-linked HTML pages that provide the same information as go doc and much more. The godoc server at https://golang.org/pkg covers the standard library. The godoc server at https://godoc.org has a searchable index of thousands of open-source packages. You can also run an instance of godc in your workspace if you want to browse your own packages. $ godoc -http :8000 References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. How to Write Go Code - The Go Programming Language" />
<meta property="og:description" content="Import Paths The Package Declaration Import Declarations Packages and Naming The Go Tool Workspace Orgnization Documenting Packages References The purpose of any package system is to make the design and maintenance of large programs pratical by grouping related features together into units that can be easily understood and changed, independent of the other packages of the program. This modularity allows packages to be shared and reused by different project, distributed within an organization, or make available to the wider world. Each package defines a distinct name space that encloses its identifiers. Each name is associated with a particular package, letting us choose short, clear names for the types, functions, and so on that we use most often, without creating conflicts with other parts of the program. Packages also provide encapsulation by controlling which names are visible or exported outside the package. Go compilation is notably faster than most other compiled languages, even when building from scratch. There are three main reasons for the compiler’s speed. First, all imports must be explicitly listed at the beginning of each source file, so the compiler does not have to read and process an entire file to determine its dependencies. Second, the dependencies of a package form a directed acyclic graph, and because there are no cycles, packages can be compiled separately and perhaps in parallel. Finally, the object file for compiled Go package records export information not just for the package itself, but for its dependencies too. When compiling a package, the compiler must read one object file for each import but need not look beyond these files. Import Paths Each package is identified by a unique string called its import path. Import paths are the strings that appear n import declarations. import ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;golang.org/x/net/html&quot; &quot;github.com/go-sql-driver/mysql&quot; ) The Go language specification doesn’t define the meaning of these strings or how to determine a package’s import path, but leaves these issues to the tools. For package you intend to share or publish, import paths should be globally unqiue. To avoid conflicts, the import paths of all packages other than those from the standard library should start with the Internaet domain name of the organization that owns or hosts the packages; this make it possible to find packages. The Package Declaration A package declaration is required at the start of every Go source file. Its main purpose is to determine the default identifier for that package (called the package name) when it is imported by another package. Conventionally, the package name is the last segment of the import path, and as a result, two packages may have the same name even though their import paths necessarily differ. There are three major exceptions to the “last segment” convention. The fist is that a package defining a command (an executable Go program) always has the name main, regardless of the package’s import path. This is a signal to go build that it must invoke the linker to make an executalbe file. The second exception is that some files in the directory may have the suffix _test on their package name if the file name ends with _test.go. The _test suffix signals to go test that it must build both package, and it indicates which files belong to each package. The third exception is that some tools for dependency management append version number suffixes to package import paths, such as “gopkg.in/yaml.v2”. The package name excludes the suffix, so in this case it would be just yaml. Import Declarations A Go source file may contain zero or more import declarations immediately after the pacakge declaration and before the first non-import declaration. Each import declaration may specify the import path of a single package, or multiple packages in a parenthesized list. import &quot;fmt&quot; import &quot;os&quot; import ( &quot;fmt&quot; &quot;os&quot; ) Imported packages may be grouped by introducing blank lines; such groupings usually indicate different domains. import ( &quot;fmt&quot; &quot;html/template&quot; &quot;os&quot; &quot;golang.org/x/net/html&quot; &quot;golang.org/x/net/ipv4&quot; ) If we need to import two packages whose names are the same, like math/rand and crypto/rand, into a third package, the import declaration must specify an alternative name for the least one of them to avoid a confilict. This is called a renaming import. import ( &quot;crypto/rand&quot; mrand &quot;math/rand&quot; // alternative name mrand avoids conflict ) Choosing an alternative name can help avoid conflicts with common local variable names. import pathpkg &quot;path&quot; // import the standard &quot;path&quot; package as pathpkg To suppress the “unused import” error we would otherwise encounter, we must use a renaming import in which the altertive name is _, the blank identifier. As usual, the blank identifier can never be referenced. These is known as a blank import. import _ &quot;image/png&quot; // register PNG decoder The database/sql package uses a similar mechanism to let users install just the database drivers they need. import ( &quot;database/mysql&quot; _ &quot;github.com/go-sql-driver/mysql&quot; // enable support for MySQL _ &quot;github.com/lib/pq&quot; // enable support for Postgres ) db, err = sql.Open(&quot;postgres&quot;, dbname) // OK db, err = sql.Open(&quot;mysql&quot;, dbname) // OK db, err = sql.Open(&quot;sqlite3&quot;, dbname) // returns error: unknown driver &quot;sqlite3&quot; Packages and Naming When creating a package, keep its name short, but not so short as to be cryptic. The most frequently used packages in the standard library are named bufio, bytes, flag, fmt, http, io, json, os, sort, sync, and time. Be descriptive and unambiguous where possible. For example, don’t name a utility package util when a name such as imageutil or ioutil is specific yet still concise. Avoid choosing packages names that are commonly used for related local variables, or you may compel the package’s client to use renaming imports, as with the path package. Packages names usually take the singular form. The standard packages bytes, errors, and strings use the plural to avoid hiding the corresponding predeclared types and, in the case of go/types, to avoid conflict with a keyword. When desiging a package, consider how the two parts of a qualified identifier work together, not the member name alone. Here are some characteristic examples: bytes.Equal flag.Int http.Get json.Marshal The Go Tool The go tool combines the features of a diverse set of tools into one command set. Its command-line interface uses the “Swiss army knife” style, with over a dozen subcomands, like get, run, build and fmt. $ go help Go is a tool for managing Go source code. Usage: go command [arguments] The commands are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information bug start a bug report fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages Use &quot;go help [command]&quot; for more information about a command. Workspace Orgnization The only configuration most users ever need is the GOPATH environment variable, which specifies the root of the workspace. The default GOPATH is $HOME/go. A second environment variable, GOROOT, specifies the root directory of the Go distribiution, which provides all the packages of the standard library. Documenting Packages The go doc tool prints the declaration and doc comment of the entity specified on the command line, which may be a package: $ go doc time package time // import &quot;time&quot; Package time provides functionality for measuring and displaying time. The calendrical calculations always assume a Gregorian calendar, with no leap seconds. const ANSIC = &quot;Mon Jan _2 15:04:05 2006&quot; ... func After(d Duration) &lt;-chan Time func Sleep(d Duration) func Tick(d Duration) &lt;-chan Time type Duration int64 const Nanosecond Duration = 1 ... ...many more... or a package member: $ go doc time.Since func Since(t Time) Duration Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). or a method: $ go doc time.Duration.Seconds func (d Duration) Seconds() float64 Seconds returns the duration as a floating point number of seconds. The tool does not need complete import paths or crrect identifier case. $ go doc json.decode func (dec *Decoder) Decode(v interface{}) error Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. See the documentation for Unmarshal for details about the conversion of JSON into a Go value. The second tool, confusingly named godoc, serves cross-linked HTML pages that provide the same information as go doc and much more. The godoc server at https://golang.org/pkg covers the standard library. The godoc server at https://godoc.org has a searchable index of thousands of open-source packages. You can also run an instance of godc in your workspace if you want to browse your own packages. $ godoc -http :8000 References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. How to Write Go Code - The Go Programming Language" />
<link rel="canonical" href="https://blog.codefarm.me/2017/06/24/packages-and-the-go-tool-in-go-language/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/06/24/packages-and-the-go-tool-in-go-language/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-24T16:32:30+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Packages and the Go Tool in Go Language" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-06-24T16:32:30+08:00","datePublished":"2017-06-24T16:32:30+08:00","description":"Import Paths The Package Declaration Import Declarations Packages and Naming The Go Tool Workspace Orgnization Documenting Packages References The purpose of any package system is to make the design and maintenance of large programs pratical by grouping related features together into units that can be easily understood and changed, independent of the other packages of the program. This modularity allows packages to be shared and reused by different project, distributed within an organization, or make available to the wider world. Each package defines a distinct name space that encloses its identifiers. Each name is associated with a particular package, letting us choose short, clear names for the types, functions, and so on that we use most often, without creating conflicts with other parts of the program. Packages also provide encapsulation by controlling which names are visible or exported outside the package. Go compilation is notably faster than most other compiled languages, even when building from scratch. There are three main reasons for the compiler’s speed. First, all imports must be explicitly listed at the beginning of each source file, so the compiler does not have to read and process an entire file to determine its dependencies. Second, the dependencies of a package form a directed acyclic graph, and because there are no cycles, packages can be compiled separately and perhaps in parallel. Finally, the object file for compiled Go package records export information not just for the package itself, but for its dependencies too. When compiling a package, the compiler must read one object file for each import but need not look beyond these files. Import Paths Each package is identified by a unique string called its import path. Import paths are the strings that appear n import declarations. import ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;golang.org/x/net/html&quot; &quot;github.com/go-sql-driver/mysql&quot; ) The Go language specification doesn’t define the meaning of these strings or how to determine a package’s import path, but leaves these issues to the tools. For package you intend to share or publish, import paths should be globally unqiue. To avoid conflicts, the import paths of all packages other than those from the standard library should start with the Internaet domain name of the organization that owns or hosts the packages; this make it possible to find packages. The Package Declaration A package declaration is required at the start of every Go source file. Its main purpose is to determine the default identifier for that package (called the package name) when it is imported by another package. Conventionally, the package name is the last segment of the import path, and as a result, two packages may have the same name even though their import paths necessarily differ. There are three major exceptions to the “last segment” convention. The fist is that a package defining a command (an executable Go program) always has the name main, regardless of the package’s import path. This is a signal to go build that it must invoke the linker to make an executalbe file. The second exception is that some files in the directory may have the suffix _test on their package name if the file name ends with _test.go. The _test suffix signals to go test that it must build both package, and it indicates which files belong to each package. The third exception is that some tools for dependency management append version number suffixes to package import paths, such as “gopkg.in/yaml.v2”. The package name excludes the suffix, so in this case it would be just yaml. Import Declarations A Go source file may contain zero or more import declarations immediately after the pacakge declaration and before the first non-import declaration. Each import declaration may specify the import path of a single package, or multiple packages in a parenthesized list. import &quot;fmt&quot; import &quot;os&quot; import ( &quot;fmt&quot; &quot;os&quot; ) Imported packages may be grouped by introducing blank lines; such groupings usually indicate different domains. import ( &quot;fmt&quot; &quot;html/template&quot; &quot;os&quot; &quot;golang.org/x/net/html&quot; &quot;golang.org/x/net/ipv4&quot; ) If we need to import two packages whose names are the same, like math/rand and crypto/rand, into a third package, the import declaration must specify an alternative name for the least one of them to avoid a confilict. This is called a renaming import. import ( &quot;crypto/rand&quot; mrand &quot;math/rand&quot; // alternative name mrand avoids conflict ) Choosing an alternative name can help avoid conflicts with common local variable names. import pathpkg &quot;path&quot; // import the standard &quot;path&quot; package as pathpkg To suppress the “unused import” error we would otherwise encounter, we must use a renaming import in which the altertive name is _, the blank identifier. As usual, the blank identifier can never be referenced. These is known as a blank import. import _ &quot;image/png&quot; // register PNG decoder The database/sql package uses a similar mechanism to let users install just the database drivers they need. import ( &quot;database/mysql&quot; _ &quot;github.com/go-sql-driver/mysql&quot; // enable support for MySQL _ &quot;github.com/lib/pq&quot; // enable support for Postgres ) db, err = sql.Open(&quot;postgres&quot;, dbname) // OK db, err = sql.Open(&quot;mysql&quot;, dbname) // OK db, err = sql.Open(&quot;sqlite3&quot;, dbname) // returns error: unknown driver &quot;sqlite3&quot; Packages and Naming When creating a package, keep its name short, but not so short as to be cryptic. The most frequently used packages in the standard library are named bufio, bytes, flag, fmt, http, io, json, os, sort, sync, and time. Be descriptive and unambiguous where possible. For example, don’t name a utility package util when a name such as imageutil or ioutil is specific yet still concise. Avoid choosing packages names that are commonly used for related local variables, or you may compel the package’s client to use renaming imports, as with the path package. Packages names usually take the singular form. The standard packages bytes, errors, and strings use the plural to avoid hiding the corresponding predeclared types and, in the case of go/types, to avoid conflict with a keyword. When desiging a package, consider how the two parts of a qualified identifier work together, not the member name alone. Here are some characteristic examples: bytes.Equal flag.Int http.Get json.Marshal The Go Tool The go tool combines the features of a diverse set of tools into one command set. Its command-line interface uses the “Swiss army knife” style, with over a dozen subcomands, like get, run, build and fmt. $ go help Go is a tool for managing Go source code. Usage: go command [arguments] The commands are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information bug start a bug report fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages Use &quot;go help [command]&quot; for more information about a command. Workspace Orgnization The only configuration most users ever need is the GOPATH environment variable, which specifies the root of the workspace. The default GOPATH is $HOME/go. A second environment variable, GOROOT, specifies the root directory of the Go distribiution, which provides all the packages of the standard library. Documenting Packages The go doc tool prints the declaration and doc comment of the entity specified on the command line, which may be a package: $ go doc time package time // import &quot;time&quot; Package time provides functionality for measuring and displaying time. The calendrical calculations always assume a Gregorian calendar, with no leap seconds. const ANSIC = &quot;Mon Jan _2 15:04:05 2006&quot; ... func After(d Duration) &lt;-chan Time func Sleep(d Duration) func Tick(d Duration) &lt;-chan Time type Duration int64 const Nanosecond Duration = 1 ... ...many more... or a package member: $ go doc time.Since func Since(t Time) Duration Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). or a method: $ go doc time.Duration.Seconds func (d Duration) Seconds() float64 Seconds returns the duration as a floating point number of seconds. The tool does not need complete import paths or crrect identifier case. $ go doc json.decode func (dec *Decoder) Decode(v interface{}) error Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. See the documentation for Unmarshal for details about the conversion of JSON into a Go value. The second tool, confusingly named godoc, serves cross-linked HTML pages that provide the same information as go doc and much more. The godoc server at https://golang.org/pkg covers the standard library. The godoc server at https://godoc.org has a searchable index of thousands of open-source packages. You can also run an instance of godc in your workspace if you want to browse your own packages. $ godoc -http :8000 References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. How to Write Go Code - The Go Programming Language","headline":"Packages and the Go Tool in Go Language","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/06/24/packages-and-the-go-tool-in-go-language/"},"url":"https://blog.codefarm.me/2017/06/24/packages-and-the-go-tool-in-go-language/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Packages and the Go Tool in Go Language</h1><p class="c-post-meta">24 Jun 2017</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#import-paths" id="markdown-toc-import-paths">Import Paths</a></li>
  <li><a href="#the-package-declaration" id="markdown-toc-the-package-declaration">The Package Declaration</a></li>
  <li><a href="#import-declarations" id="markdown-toc-import-declarations">Import Declarations</a></li>
  <li><a href="#packages-and-naming" id="markdown-toc-packages-and-naming">Packages and Naming</a></li>
  <li><a href="#the-go-tool" id="markdown-toc-the-go-tool">The Go Tool</a></li>
  <li><a href="#workspace-orgnization" id="markdown-toc-workspace-orgnization">Workspace Orgnization</a></li>
  <li><a href="#documenting-packages" id="markdown-toc-documenting-packages">Documenting Packages</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<p>The purpose of any package system is to make the design and maintenance of large programs pratical by grouping related features together into units that can be easily understood and changed, independent of the other packages of the program. This <em>modularity</em> allows packages to be shared and reused by different project, distributed within an organization, or make available to the wider world.</p>

<p>Each package defines a distinct name space that encloses its identifiers. Each name is associated with a particular package, letting us choose short, clear names for the types, functions, and so on that we use most often, without creating conflicts with other parts of the program.</p>

<p>Packages also provide encapsulation by controlling which names are visible or exported outside the package.</p>

<p>Go compilation is notably faster than most other compiled languages, even when building from scratch. There are three main reasons for the compiler’s speed. First, all imports must be explicitly listed at the beginning of each source file, so the compiler does not have to read and process an entire file to determine its dependencies. Second, the dependencies of a package form a directed acyclic graph, and because there are no cycles, packages can be compiled separately and perhaps in parallel. Finally, the object file for compiled Go package records export information not just for the package itself, but for its dependencies too. When compiling a package, the compiler must read one object file for each import but need not look beyond these files.</p>

<h3 id="import-paths">Import Paths</h3>

<p>Each package is identified by a unique string called its <strong><em>import path</em></strong>. Import paths are the strings that appear n <strong>import</strong> declarations.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
	<span class="s">"encoding/json"</span>
	<span class="s">"fmt"</span>
	<span class="s">"math/rand"</span>

	<span class="s">"golang.org/x/net/html"</span>

	<span class="s">"github.com/go-sql-driver/mysql"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>The Go language specification doesn’t define the meaning of these strings or how to determine a package’s import path, but leaves these issues to the tools.</p>

<p>For package you intend to share or publish, import paths should be globally unqiue. To avoid conflicts, the import paths of all packages other than those from the standard library should start with the Internaet domain name of the organization that owns or hosts the packages; this make it possible to find packages.</p>

<h3 id="the-package-declaration">The Package Declaration</h3>

<p>A <strong>package</strong> declaration is required at the start of every Go source file. Its main purpose is to determine the default identifier for that package (called the <strong><em>package name</em></strong>) when it is imported by another package.</p>

<p>Conventionally, the package name is the last segment of the import path, and as a result, two packages may have the same name even though their import paths necessarily differ.</p>

<p>There are three major exceptions to the “last segment” convention. The fist is that a package defining a command (an executable Go program) always has the name <strong>main</strong>, regardless of the package’s import path. This is a signal to <strong>go build</strong> that it must invoke the linker to make an executalbe file.</p>

<p>The second exception is that some files in the directory may have the suffix <strong>_test</strong> on their package name if the file name ends with <strong>_test.go</strong>. The <strong>_test</strong> suffix signals to <strong>go test</strong> that it must build both package, and it indicates which files belong to each package.</p>

<p>The third exception is that some tools for dependency management append version number suffixes to package import paths, such as <strong>“gopkg.in/yaml.v2”</strong>. The package name excludes the suffix, so in this case it would be just <strong>yaml</strong>.</p>

<h3 id="import-declarations">Import Declarations</h3>

<p>A Go source file may contain zero or more <strong>import</strong> declarations immediately after the <strong>pacakge</strong> declaration and before the first non-import declaration.</p>

<p>Each import declaration may specify the import path of a single package, or multiple packages in a parenthesized list.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"fmt"</span>
<span class="k">import</span> <span class="s">"os"</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"os"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Imported packages may be grouped by introducing blank lines; such groupings usually indicate different domains.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"html/template"</span>
	<span class="s">"os"</span>

	<span class="s">"golang.org/x/net/html"</span>
	<span class="s">"golang.org/x/net/ipv4"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>If we need to import two packages whose names are the same, like <strong>math/rand</strong> and <strong>crypto/rand</strong>, into a third package, the import declaration must specify an alternative name for the least one of them to avoid a confilict. This is called a <strong><em>renaming import</em></strong>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
	<span class="s">"crypto/rand"</span>
	<span class="n">mrand</span> <span class="s">"math/rand"</span> <span class="c">// alternative name mrand avoids conflict</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Choosing an alternative name can help avoid conflicts with common local variable names.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">pathpkg</span> <span class="s">"path"</span> <span class="c">// import the standard "path" package as pathpkg</span>
</code></pre></div></div>

<p>To suppress the “unused import” error we would otherwise encounter, we must use a renaming import in which the altertive name is <strong>_</strong>, the blank identifier. As usual, the blank identifier can never be referenced. These is known as a <strong><em>blank import</em></strong>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">_</span> <span class="s">"image/png"</span> <span class="c">// register PNG decoder</span>
</code></pre></div></div>

<p>The <strong>database/sql</strong> package uses a similar mechanism to let users install just the database drivers they need.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
	<span class="s">"database/mysql"</span>

	<span class="n">_</span> <span class="s">"github.com/go-sql-driver/mysql"</span> <span class="c">// enable support for MySQL</span>
	<span class="n">_</span> <span class="s">"github.com/lib/pq"</span>              <span class="c">// enable support for Postgres</span>
<span class="p">)</span>

<span class="n">db</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"postgres"</span><span class="p">,</span> <span class="n">dbname</span><span class="p">)</span> <span class="c">// OK</span>
<span class="n">db</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="n">dbname</span><span class="p">)</span>    <span class="c">// OK</span>
<span class="n">db</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"sqlite3"</span><span class="p">,</span> <span class="n">dbname</span><span class="p">)</span>  <span class="c">// returns error: unknown driver "sqlite3"</span>
</code></pre></div></div>

<h3 id="packages-and-naming">Packages and Naming</h3>

<p>When creating a package, keep its name short, but not so short as to be cryptic. The most frequently used packages in the standard library are named <strong>bufio</strong>, <strong>bytes</strong>, <strong>flag</strong>, <strong>fmt</strong>, <strong>http</strong>, <strong>io</strong>, <strong>json</strong>, <strong>os</strong>, <strong>sort</strong>, <strong>sync</strong>, and <strong>time</strong>.</p>

<p>Be descriptive and unambiguous where possible. For example, don’t name a utility package <strong>util</strong> when a name such as <strong>imageutil</strong> or <strong>ioutil</strong> is specific yet still concise.</p>

<p>Avoid choosing packages names that are commonly used for related local variables, or you may compel the package’s client to use renaming imports, as with the <strong>path</strong> package.</p>

<p>Packages names usually take the singular form. The standard packages <strong>bytes</strong>, <strong>errors</strong>, and <strong>strings</strong> use the plural to avoid hiding the corresponding predeclared types and, in the case of <strong>go/types</strong>, to avoid conflict with a keyword.</p>

<p>When desiging a package, consider how the two parts of a qualified identifier work together, not the member name alone. Here are some characteristic examples:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">bytes</span><span class="o">.</span><span class="n">Equal</span>     <span class="n">flag</span><span class="o">.</span><span class="n">Int</span>        <span class="n">http</span><span class="o">.</span><span class="n">Get</span>        <span class="n">json</span><span class="o">.</span><span class="n">Marshal</span>
</code></pre></div></div>

<h3 id="the-go-tool">The Go Tool</h3>

<p>The <strong>go</strong> tool combines the features of a diverse set of tools into one command set. Its command-line interface uses the “Swiss army knife” style, with over a dozen subcomands, like <strong>get</strong>, <strong>run</strong>, <strong>build</strong> and <strong>fmt</strong>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">help
</span>Go is a tool <span class="k">for </span>managing Go <span class="nb">source </span>code.

Usage:

        go <span class="nb">command</span> <span class="o">[</span>arguments]

The commands are:

        build       compile packages and dependencies
        clean       remove object files
        doc         show documentation <span class="k">for </span>package or symbol
        <span class="nb">env         </span>print Go environment information
        bug         start a bug report
        fix         run go tool fix on packages
        <span class="nb">fmt         </span>run gofmt on package sources
        generate    generate Go files by processing <span class="nb">source
        </span>get         download and <span class="nb">install </span>packages and dependencies
        <span class="nb">install     </span>compile and <span class="nb">install </span>packages and dependencies
        list        list packages
        run         compile and run Go program
        <span class="nb">test        test </span>packages
        tool        run specified go tool
        version     print Go version
        vet         run go tool vet on packages

Use <span class="s2">"go help [command]"</span> <span class="k">for </span>more information about a command.
</code></pre></div></div>

<h3 id="workspace-orgnization">Workspace Orgnization</h3>

<p>The only configuration most users ever need is the <strong>GOPATH</strong> environment variable, which specifies the root of the workspace. The default <strong>GOPATH</strong> is <strong>$HOME/go</strong>.</p>

<p>A second environment variable, <strong>GOROOT</strong>, specifies the root directory of the Go distribiution, which provides all the packages of the standard library.</p>

<h3 id="documenting-packages">Documenting Packages</h3>

<p>The <strong>go doc</strong> tool prints the declaration and doc comment of the entity specified on the command line, which may be a package:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go doc <span class="nb">time
</span>package <span class="nb">time</span> // import <span class="s2">"time"</span>

Package <span class="nb">time </span>provides functionality <span class="k">for </span>measuring and displaying time.

The calendrical calculations always assume a Gregorian calendar, with no
leap seconds.

const ANSIC <span class="o">=</span> <span class="s2">"Mon Jan _2 15:04:05 2006"</span> ...
func After<span class="o">(</span>d Duration<span class="o">)</span> &lt;<span class="nt">-chan</span> Time
func Sleep<span class="o">(</span>d Duration<span class="o">)</span>
func Tick<span class="o">(</span>d Duration<span class="o">)</span> &lt;<span class="nt">-chan</span> Time
<span class="nb">type </span>Duration int64
    const Nanosecond Duration <span class="o">=</span> 1 ...
...many more...
</code></pre></div></div>

<p>or a package member:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go doc time.Since
func Since<span class="o">(</span>t Time<span class="o">)</span> Duration
    Since returns the <span class="nb">time </span>elapsed since t. It is shorthand <span class="k">for
    </span>time.Now<span class="o">()</span>.Sub<span class="o">(</span>t<span class="o">)</span><span class="nb">.</span>

</code></pre></div></div>

<p>or a method:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go doc time.Duration.Seconds
func <span class="o">(</span>d Duration<span class="o">)</span> Seconds<span class="o">()</span> float64
    Seconds returns the duration as a floating point number of seconds.

</code></pre></div></div>

<p>The tool does not need complete import paths or crrect identifier case.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go doc json.decode
func <span class="o">(</span>dec <span class="k">*</span>Decoder<span class="o">)</span> Decode<span class="o">(</span>v interface<span class="o">{})</span> error
    Decode reads the next JSON-encoded value from its input and stores it <span class="k">in </span>the
    value pointed to by v.

    See the documentation <span class="k">for </span>Unmarshal <span class="k">for </span>details about the conversion of JSON
    into a Go value.

</code></pre></div></div>

<p>The second tool, confusingly named <strong>godoc</strong>, serves cross-linked HTML pages that provide the same information as <strong>go doc</strong> and much more.</p>

<p>The <strong>godoc</strong> server at <strong>https://golang.org/pkg</strong> covers the standard library. The <strong>godoc</strong> server at <strong>https://godoc.org</strong> has a searchable index of thousands of open-source packages.</p>

<p>You can also run an instance of <strong>godc</strong> in your workspace if you want to browse your own packages.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>godoc <span class="nt">-http</span> :8000
</code></pre></div></div>

<hr />

<h3 id="references">References</h3>

<ol>
  <li>Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11.</li>
  <li><a href="https://golang.org/doc/code.html">How to Write Go Code</a> - The Go Programming Language</li>
</ol>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
