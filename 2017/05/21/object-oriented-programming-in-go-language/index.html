<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Object-oriented Programming in Go Language | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Object-oriented Programming in Go Language" />
<meta property="og:locale" content="en" />
<meta name="description" content="Methods Method Declarations Methods with a Pointer Receiver Nil Is a Valid Receiver Value Composing Types by Struct Embedding Method Values and Expressions Encapsulation Interfaces Interface as Contracts Interface Types Interface Satisfaction Interface Values Caveat: An Interface Containing a Nil Pointer Is Non-Nil Type Assertions Type Switches References Since the early 1990s, object-oriented programming (OOP) has been the dominant programming paradigm in industry and education, and nearly all widely used languages developed since then have inlcuded support for it. Go is no exception. Methods Although there is no universally accepted definition of object-oriented programming, for our purposes, an object is simply a value or variables that has methods, and a method is a function associated with a particular type. An object-oriented program is one that uses methods to express the properties and operations of each data structure so that clients need not access the object’s representation directly. Method Declarations A method is declared with variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attachs the function to the type of that parameter. package geometry import &quot;path&quot; type Point struct{ X, Y float64 } // traditional funcitoni func Distance(p, q Point) float64 { return maht.Hypot(p.X-q.X, p.Y-q.Y) } // same thing, but as a method of the Point type func (p Point) Distance(q Point) float64 { return maht.Hypot(p.X-q.X, p.Y-q.Y) } The extra parameter p is called the method’s receiver, a legacy from early object-oriented languages that described calling a method as “sending a message to an object”. In Go, we don’t use a special name like this or self for the receiver; we choose receiver names just as we would for any other parameter. Since the receiver name will be frequently used, it’s a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like p for Point. In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name. p := Point{1, 2} q := Point{4, 6} fmt.Println(Distance(p, q)) // &quot;5&quot;, function call fmt.Println(p.Distance(q)) // &quot;5&quot;, method call There’s no conflict between the two declarations of functions called Distance above. The first declares a package-level function called geometry.Distance. The second declares a method of the type Point, so its name is Point.Distance. The expression p.Distance is called a selector, because it select the appropriate Distance method for the receiver p of type Point. Selectors are also used to select fields of struct types, as in p.X. Since methods and fields inhabit the same name space, declaring a method X on the struct Point would be ambiguous and the compiler will reject it. Methods with a Pointer Receiver Because calling a function makes a copy of each argument value, if a function needs to update a variable, of if an argument is so large that we wish to avoid copying it, we must pass the address of the variable using a pointer. The same goes for methods that need to update receiver variable: we attach them to the pointer type, such as *Point. func (p *Point) ScaleBy(factor flaot64) { p.X *= factor p.Y *= factor } The name of this method is (*Point).ScaleBy. The parentheses are neccessary; without them, the expression would be parsed as *(Point.ScaleBy). In a realistic program, convention dictates that if any method of Point has a pointer receiver, the all methods of Point should have a pointer receiver, even ones that don’t strictly need it. Named types (Point) and pointers to them (*Point) are the only types that may appear in a receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types: type P *int func (P) f() { /* ... */ } // compile error: invalid receiver type If the receiver p is a variable of type Point but the method requires a *Point receiver, we can use this shorthand: p.ScaleBy(2) and the compiler will perform an implicity &amp;p on the variable. This works only for variables, including struct field like p.X and array or slice elements like perim[0]. We cannot call a *Point method on a non-addressable Point receiver, because there’s no way to obtain the address of a temporary value. // compile error: cannot call pointer method on Point literal // compile error: cannot take the address of Point literal Point{1, 2}.ScaleBy(2) But we can call a Point method like Point.Distance with a *Point reciver, because there is a way to obtain the value from the address: just load the value pointed to by the receiver. The compiler inserts an implicit * operation for us. The two function call are equivalent: Either the receiver argument has the same type as the receiver parameter, for example both have type T or both have type *T: Point{1, 2}.Distance(q) // Point pptr.Distance(q) // Point If all the methods of a named type T have a receiver type of T itself (not *T), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. But if any method has a pointer receiver, you should avoid copying instances of T because doing so may violate internal invariants. Nil Is a Valid Receiver Value Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices. When you define a type whose methods allow nil as a receiver value, it’s worth pointing this out explicitly in its documentation comment. Composing Types by Struct Embedding import &quot;image/color&quot; type Point struct{ X, Y float64 } type ColoredPoint struct { Point Color color.RGBA } We could have defined ColoredPoint as a struct of three fields, but instead we embedded a Point to provide the X and Y fields. A similar mechanism applies to the methods of Point. We can call methods of the embedded Point field using a receiver of type ColoredPoint, even though ColoredPoint has no declared methods: red := color.RGBA{255, 0, 0, 255} blue := color.RGBA{0, 0, 255, 255} var p = ColoredPoint{Point{1, 1}, red} var q = ColoredPoint{Point{5, 4}, blue} fmt.Println(p.Distance(q.Point)) // &quot;5&quot; p.ScaleBy(2) q.ScaleBy(2) fmt.Println(p.Distance(q.Point)) // &quot;10&quot; The methods of Point have been promoted to ColoredPoint. Notice the calls to Distance above. Distance has a parameter of type Point, and q is not a Point, so although q does have an embedded field of that type, we must explicitly select it. Attempting to pass q would be an error: p.Distance(q) // compile error: cannot use q (type ColoredPoint) as type Point in argument to p.Point.Distance A ColoredPoint is not a Point, but it “has a” Point, and it has two additional methods Distance and ScaleBy promoted from Point. If you prefer to think in terms of implementation, the embedded field instructs the compiler to generate additional wrapper that delegate to the declared method, equivalent to these: func (p ColoredPoint) Distance(q Point) float64 { return p.Point.Distance(q) } func (p *ColoredPont) ScaleBy(factor float64) { return p.Point.ScaleBy(factor) } When Point.Distance is called by the first of these wrapper methods, its receiver value is p.Point, not p, and there is no way for the method to access the ColoredPoint in which the Point is embedded. A struct type may have more than one anonymous field. When the compiler resolves a selector such as p.ScaleBy to a method, it first looks for directly method named ScaleBy, then for methods promoted once from ColoredPoint’s embedded fields, then for methods promoted twich from embedded fileds within Point and RGBA, and so on. The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank. With embedding, it’s possible and sometimes useful for unmamed struct types to have methods too. The following example shows part of a simple cache implemented using two package-level variable, a mutex and the map that it guards: var ( mu sync.Mutex // guards mapping mapping = make(map[string]string) ) func Lookup(key string) string { mu.Lock() defer mu.Unlock() return mapping[key] } The version below is funcitonally equivalent but groups together the two related variables in a single package-level variable, cache: var cache = struct { sync.Mutex mapping map[string]string }{ mapping: make(map[string]string), } func Lookup(key string) string { cache.Lock() defer cache.Unlock() return mapping[key] } The new variable gives more expressive names to the variables related to the cache, and because the sync.Mutex field is embeed witin it, its Lock and Unlock methods are promoted to the unnamed type, allowing us to lock the cache with a self-explanatory syntax. Method Values and Expressions Usually we select and call a method in the same expression, as in p.Distance, but it’s possible to separate these two operations. The selector p.Distance yields a method value, a function that binds a method (Point.Distance) to a specific receiver value p. This function can then be invoked without a receiver value; it needs only the non-receiver arguments. For example, the function time.AfterFunc calls a function value after a specified delay. This program uses it to launch the rocket r after 10 seconds: type Rocket struct { /* ... */ } func (r *Rocket) Launch() { /*...*/ } r := new(Rocket) time.AfterFunc(10*time.Second, func() { r.Launch() }) The method values syntax is shorter: time.AfterFunc(10*time.Second, r.Launch) Related to the method value is the method expression. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written T.f or (*T).f where T is a type, yield a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way. In the following example, the variable op represents either the addition or the subtraction method of type Point, and the Path.TranslateBy calls it for each point in the Path: type Point struct{ X, Y float64 } func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} } func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} } type Path []Point func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add { op = Point.Add } else { op = Point.Sub } for i := range path { // Call either path[i].Add(offset) or path[i].Sub(offset). path[i] = op(path[i], offset) } } Encapsulation Go has only one mechnism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncaptitalized names are not. The same mechanism that limits access to memebers of a package also limits access to the fields of a struct or the methods of a type. As a consequnce, to encapsulation an object, we must make it struct. type IntSet struct { words []uint64 } We could instead define IntSet as a slice type as follows: type IntSet []uint64 Although this version of IntSet would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly. Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. The fields of a struct type are visible to all code within the same package. Whether the code appears in a function or a method makes no difference. Function that merely access or modify interal values of a type, such as the method of the Logger type from log package, below, are called getters and setters. However, when naming a getter method, we usually omit the Get prefix. This preference for brevity extends to all methods, not just field accessors, and to other redundant prefixes as well, such as Fetch, Find, and Lookup. package log type Logger struct { flags int prefix string // ... } func (l *Logger) Flags() int func (l *Logger) SetFlags(flag int) func (l *Logger) Prefix() string func (l *Logger) SetPrefix(prefix string) Encapsulation is not always desirable. By revealing its represention as an int64 number of nanoseconds, time.Duration lets us use all the usual arithmetic and comparsion operations with durations, and even to define constants of this type: package main import ( &quot;fmt&quot; &quot;time&quot; ) const day = 24 * time.Hour func main() { fmt.Printf(&quot;%t\n&quot;, day) // %!t(time.Duration=86400000000000) } Interfaces Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces let us write functions that are more flexible and adaptable because they are not tied to the details of one particular implementation. Many object-oriented languages have some notion of interface, but what makes Go’s interfaces so distinctive is they are satisfied implicitly. In other words, there’s no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don’t control. Interface as Contracts A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetric for numbers, or indexing, append, and range for slices. A concrete type may also provide additional behaviors through its methods. When you have a value of a concrete type, you knonw exactly what it is and what you can do with it. An interface is an abstract type. It doesn’t expose the representation or iternal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods. Interface Types An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface. The io.Writer type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The io package defines many other useful interfaces. A Reader represents any type from which you can read bytes, and a Closer is any value that you can close, such as a file or a network connection. package io type Writer interface { Write(p []byte) (n int, err error) } type Reader interface { Read(p []byte) (n int, err error) } type Closer interface { Close() error } Looking farther, we find declarations of new interface types as combinations of existing ones. Here are two examples: package io // ReadWriter is the interface that groups the basic Read and Write methods. type ReadWriter interface { Reader Writer } // ReadWriteCloser is the interface that groups the basic Read, Write and Close methods. type ReadWriteCloser interface { Reader Writer Closer } The syntax used above, which resembles struct embedding, lets us name another interface as a shorthand for writting out all of its methods. This is called embedding an interface. Interface Satisfaction A type *statisfies an interface if it possesses all the methods the interface requires. For example, an *os.File satisfies io.Reader, Writer, Closer, and ReadWriter. A *bytes.Buffer satisfies Reader, Writer, and ReadWriter, but does not satisfy Closer because it does not have a Close method. The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satifies the interface. So: var w io.Writer w = os.Stdout // OK: *os.File has Write method w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method w = time.Second // compile error: time.Duration lacks Write method var rwc io.ReadWriteCloser rwc = os.Stdout // OK: *os.File has Read, Write, Close methods rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method This rule applies even when the right-hand side is itself an interface: w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method The type interface{}, which is called the empty interface type places no demands on the types that statisfy it, we can assign any value to the empty interface. var any interface{} any = true any = 12.34 any = &quot;hello&quot; any = map[string]int{&quot;one&quot;: 1} any = new(bytes.Buffer) Since interface satisfcation depends only on the methods of the two type involved, there is no need to declare the relationship between a concrete type and the interface it satifies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below assets at compile time that a value of type *bytes.Buffer satifies io.Writer: // *bytes.Buffer must satisfy io.Writer var w io.Writer = new(bytes.Buffer) We needn’t allocate a new variable since any value of type *bytes.Buffer will do, even nil, which we writes as (*bytes.Buffer)(nil) using an explicit conversion. And since we never intend to refer to w, we can replace it with the blank identifier. Together, these changes give us this more frugal variant: // *bytes.Buffer must satisfy io.Writer var _ io.Writer = (*bytes.Buffer)(nil) Interface Values Conceptually, a value of an interface type, or interface value, has two components, a concrete type and a value of that type. These are called the interface’s dynamic type and dynamic value. For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called type descriptors provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor. The zero value for an interface has both its type and value components set to nil. var w io.Writer An interface value is described as nil or non-nil based on its dynamic type, so this is a nil interface value. The below statement assigns a value of type *os.File to w: var w io.Writer = os.Stdout This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion io.Writer(os.Stdout). A conversion of this kind, whether explicit or implicit, captures the type and the value of its operand. The interface values’ dynamic type is set to the type descriptor for the pointer type *os.File, and its dynamic value holds a copy of os.Stdout, which is a pointer to the os.File variable representing the standard output of process. Calling the Write method on an interface value containing an *os.File pointer causes the (*os.File).Write method to be called. The call prints “hello”. w.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot; In general, we cannot know at compile time that what the dynamic type of an interface value will be, so a call through an interface must use dynamic dispatch. Instead of a direct call, the compiler must generate code to obtain the address of the method named Write from the type descriptor, then make an indirect call to the address. The receiver argument for the call is a copy of the interface’s dynamic value, os.Stdout. The effect is as if we had make this call directly: os.Stdout.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot; Interface values may be compared using == and !=. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynmaic values are equal according to the usual behavior of == for that type. However, if two interface values are compared and have the same dynamic type, but the that type is not comparable (a slice, for instance), then the comparision fails with a panic: var x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int Caveat: An Interface Containing a Nil Pointer Is Non-Nil A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil. package main import ( &quot;bytes&quot; &quot;io&quot; ) func main() { var buf *bytes.Buffer var out io.Writer out = buf // NOTE: subtly incorrect! if out != nil { out.Write([]byte(&quot;done!\n&quot;)) // panic: runtime error: invalid memory address or nil pointer dereference } } Type Assertions A type assertion is an operation applied to an interface value. Syntactically, it looks like x.(T), where x is an expression of an interface type and T is a type, called the “asserted” type. A type assertion checks that the dynamic type of its operand matches the asserted type. A type assertion to a concrete type extracts the concrete value from its operand. If the check fails, then the operation panics. var w io.Writer w = os.Stdout f := w.(*os.File) // success: f == os.Stdout c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer A type assertion to an interface type changes the type of the expression, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface. var w io.Writer w = os.Stdout rw := w.(io.ReadWriter) // success: *os.File has both Read and Write w = new(ByteCounter) rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method No matter what type was asserted, if the operand is a nil interface value, the value assertion fails. If the type assertion appears is an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success. var w io.Writer = os.Stdout f, ok := w.(*os.File) // success: ok, f == os.Stdout b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you’ll sometimes see the original name reused, shadowing the original, like this: var w io.Writer = os.Stdout if w, ok := w.(*os.File); ok { w.Write([]byte(&quot;Hello world&quot;)) // ...use w... } Type Switches Interfaces are used in two distinct styles. In the first style, exemplified by io.Reader, io.Writer, fmt.Stringer, sort.Interface, http.Handler, and error, an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation detail and intrinsic operations of those concrete types. The emphasis is on the methods, not on the concrete types. The second style exploits the ablility of an interface value to hold values of a variety of concrete types and considers the interface to be the union of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently. In this style, the emphasis is on the concrete types that satisfy the interface, not on the interface’s methods (if indeed it has any), and there is no hiding of information. Go’s API for quering an SQL database, like those of other languages, lets us cleanly separate the fixed part of a query from the variable parts. An example client might look like this: import &quot;database/sql&quot; func listTracks(db sql.DB, artist string, minYear, maxYear int) { result, err := db.Exec( &quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;, artist, minYear, maxYear) // ... } The Exec method replace each ‘?’ in the query string with an SQL literal denoting the coresponding argument value, which may be a boolean, a number, a string, or nil. Within Exec, we might find a function like the one below, which converts each argument value to its literal SQL notation. func sqlQuote(x interface{}) string { if x == nil { return &quot;NULL&quot; } else if _, ok := x.(int); ok { return fmt.Sprintf(&quot;%d&quot;, x) } else if _, ok := x.(uint); ok { return fmt.Sprintf(&quot;%d&quot;, x) } else if b, ok := x.(bool); ok { if b { return &quot;TRUE&quot; } return &quot;FALSE&quot; } else if s, ok := x.(string); ok { return sqlQuoteString(s) // (not shown) } else { panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x)) } } A switch statement simplifies an if-else chain that performs a series of value equality tests. An analogous type switch statement simplifies an if-else chain of type assertions. In its simplest form, a type switch looks like an oridinary switch statement in which the operand is x.(type)—that’s literally the keyword type—and each case has one or more types. A type switch enables a multi-way branch based on the interface value’s dynamic type. The nil case matchs if x == nil, and the default case matches if no other case does. No fallthrough is allowed. A type switch for sqlQuote would have these cases: switch x.(type) { case nil: // ... case int, uint: // ... case bool: // ... case string: // ... default: // ... } Typically, the type switch statement has an extended form that binds the extracted value to a new variable within each case: switch x := x.(type) { // ... } Like a switch statement, a type switch implicitly creates a lexical block, so the declration of the new variable called x does not conflict with a variable x in an outer block. Each case also implicitly creates a separate lexical block. Rewriting sqlQuote to use the extended form of type switch makes it significantly clearer: func sqlQuote(x interface{}) string { switch x := x.(type) { case nil: return &quot;NULL&quot; case int, uint: return fmt.Sprintf(&quot;%d&quot;, x) // x has type interface{} here. case bool: if x { return &quot;TRUE&quot; } return &quot;FALSE&quot; case string: return sqlQuoteString(x) // (not shown) default: panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x)) } } References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. Interface types, The Go Programming Language Specification. Interface names, Effective Go - The Go Programming Language" />
<meta property="og:description" content="Methods Method Declarations Methods with a Pointer Receiver Nil Is a Valid Receiver Value Composing Types by Struct Embedding Method Values and Expressions Encapsulation Interfaces Interface as Contracts Interface Types Interface Satisfaction Interface Values Caveat: An Interface Containing a Nil Pointer Is Non-Nil Type Assertions Type Switches References Since the early 1990s, object-oriented programming (OOP) has been the dominant programming paradigm in industry and education, and nearly all widely used languages developed since then have inlcuded support for it. Go is no exception. Methods Although there is no universally accepted definition of object-oriented programming, for our purposes, an object is simply a value or variables that has methods, and a method is a function associated with a particular type. An object-oriented program is one that uses methods to express the properties and operations of each data structure so that clients need not access the object’s representation directly. Method Declarations A method is declared with variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attachs the function to the type of that parameter. package geometry import &quot;path&quot; type Point struct{ X, Y float64 } // traditional funcitoni func Distance(p, q Point) float64 { return maht.Hypot(p.X-q.X, p.Y-q.Y) } // same thing, but as a method of the Point type func (p Point) Distance(q Point) float64 { return maht.Hypot(p.X-q.X, p.Y-q.Y) } The extra parameter p is called the method’s receiver, a legacy from early object-oriented languages that described calling a method as “sending a message to an object”. In Go, we don’t use a special name like this or self for the receiver; we choose receiver names just as we would for any other parameter. Since the receiver name will be frequently used, it’s a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like p for Point. In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name. p := Point{1, 2} q := Point{4, 6} fmt.Println(Distance(p, q)) // &quot;5&quot;, function call fmt.Println(p.Distance(q)) // &quot;5&quot;, method call There’s no conflict between the two declarations of functions called Distance above. The first declares a package-level function called geometry.Distance. The second declares a method of the type Point, so its name is Point.Distance. The expression p.Distance is called a selector, because it select the appropriate Distance method for the receiver p of type Point. Selectors are also used to select fields of struct types, as in p.X. Since methods and fields inhabit the same name space, declaring a method X on the struct Point would be ambiguous and the compiler will reject it. Methods with a Pointer Receiver Because calling a function makes a copy of each argument value, if a function needs to update a variable, of if an argument is so large that we wish to avoid copying it, we must pass the address of the variable using a pointer. The same goes for methods that need to update receiver variable: we attach them to the pointer type, such as *Point. func (p *Point) ScaleBy(factor flaot64) { p.X *= factor p.Y *= factor } The name of this method is (*Point).ScaleBy. The parentheses are neccessary; without them, the expression would be parsed as *(Point.ScaleBy). In a realistic program, convention dictates that if any method of Point has a pointer receiver, the all methods of Point should have a pointer receiver, even ones that don’t strictly need it. Named types (Point) and pointers to them (*Point) are the only types that may appear in a receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types: type P *int func (P) f() { /* ... */ } // compile error: invalid receiver type If the receiver p is a variable of type Point but the method requires a *Point receiver, we can use this shorthand: p.ScaleBy(2) and the compiler will perform an implicity &amp;p on the variable. This works only for variables, including struct field like p.X and array or slice elements like perim[0]. We cannot call a *Point method on a non-addressable Point receiver, because there’s no way to obtain the address of a temporary value. // compile error: cannot call pointer method on Point literal // compile error: cannot take the address of Point literal Point{1, 2}.ScaleBy(2) But we can call a Point method like Point.Distance with a *Point reciver, because there is a way to obtain the value from the address: just load the value pointed to by the receiver. The compiler inserts an implicit * operation for us. The two function call are equivalent: Either the receiver argument has the same type as the receiver parameter, for example both have type T or both have type *T: Point{1, 2}.Distance(q) // Point pptr.Distance(q) // Point If all the methods of a named type T have a receiver type of T itself (not *T), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. But if any method has a pointer receiver, you should avoid copying instances of T because doing so may violate internal invariants. Nil Is a Valid Receiver Value Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices. When you define a type whose methods allow nil as a receiver value, it’s worth pointing this out explicitly in its documentation comment. Composing Types by Struct Embedding import &quot;image/color&quot; type Point struct{ X, Y float64 } type ColoredPoint struct { Point Color color.RGBA } We could have defined ColoredPoint as a struct of three fields, but instead we embedded a Point to provide the X and Y fields. A similar mechanism applies to the methods of Point. We can call methods of the embedded Point field using a receiver of type ColoredPoint, even though ColoredPoint has no declared methods: red := color.RGBA{255, 0, 0, 255} blue := color.RGBA{0, 0, 255, 255} var p = ColoredPoint{Point{1, 1}, red} var q = ColoredPoint{Point{5, 4}, blue} fmt.Println(p.Distance(q.Point)) // &quot;5&quot; p.ScaleBy(2) q.ScaleBy(2) fmt.Println(p.Distance(q.Point)) // &quot;10&quot; The methods of Point have been promoted to ColoredPoint. Notice the calls to Distance above. Distance has a parameter of type Point, and q is not a Point, so although q does have an embedded field of that type, we must explicitly select it. Attempting to pass q would be an error: p.Distance(q) // compile error: cannot use q (type ColoredPoint) as type Point in argument to p.Point.Distance A ColoredPoint is not a Point, but it “has a” Point, and it has two additional methods Distance and ScaleBy promoted from Point. If you prefer to think in terms of implementation, the embedded field instructs the compiler to generate additional wrapper that delegate to the declared method, equivalent to these: func (p ColoredPoint) Distance(q Point) float64 { return p.Point.Distance(q) } func (p *ColoredPont) ScaleBy(factor float64) { return p.Point.ScaleBy(factor) } When Point.Distance is called by the first of these wrapper methods, its receiver value is p.Point, not p, and there is no way for the method to access the ColoredPoint in which the Point is embedded. A struct type may have more than one anonymous field. When the compiler resolves a selector such as p.ScaleBy to a method, it first looks for directly method named ScaleBy, then for methods promoted once from ColoredPoint’s embedded fields, then for methods promoted twich from embedded fileds within Point and RGBA, and so on. The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank. With embedding, it’s possible and sometimes useful for unmamed struct types to have methods too. The following example shows part of a simple cache implemented using two package-level variable, a mutex and the map that it guards: var ( mu sync.Mutex // guards mapping mapping = make(map[string]string) ) func Lookup(key string) string { mu.Lock() defer mu.Unlock() return mapping[key] } The version below is funcitonally equivalent but groups together the two related variables in a single package-level variable, cache: var cache = struct { sync.Mutex mapping map[string]string }{ mapping: make(map[string]string), } func Lookup(key string) string { cache.Lock() defer cache.Unlock() return mapping[key] } The new variable gives more expressive names to the variables related to the cache, and because the sync.Mutex field is embeed witin it, its Lock and Unlock methods are promoted to the unnamed type, allowing us to lock the cache with a self-explanatory syntax. Method Values and Expressions Usually we select and call a method in the same expression, as in p.Distance, but it’s possible to separate these two operations. The selector p.Distance yields a method value, a function that binds a method (Point.Distance) to a specific receiver value p. This function can then be invoked without a receiver value; it needs only the non-receiver arguments. For example, the function time.AfterFunc calls a function value after a specified delay. This program uses it to launch the rocket r after 10 seconds: type Rocket struct { /* ... */ } func (r *Rocket) Launch() { /*...*/ } r := new(Rocket) time.AfterFunc(10*time.Second, func() { r.Launch() }) The method values syntax is shorter: time.AfterFunc(10*time.Second, r.Launch) Related to the method value is the method expression. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written T.f or (*T).f where T is a type, yield a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way. In the following example, the variable op represents either the addition or the subtraction method of type Point, and the Path.TranslateBy calls it for each point in the Path: type Point struct{ X, Y float64 } func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} } func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} } type Path []Point func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add { op = Point.Add } else { op = Point.Sub } for i := range path { // Call either path[i].Add(offset) or path[i].Sub(offset). path[i] = op(path[i], offset) } } Encapsulation Go has only one mechnism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncaptitalized names are not. The same mechanism that limits access to memebers of a package also limits access to the fields of a struct or the methods of a type. As a consequnce, to encapsulation an object, we must make it struct. type IntSet struct { words []uint64 } We could instead define IntSet as a slice type as follows: type IntSet []uint64 Although this version of IntSet would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly. Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. The fields of a struct type are visible to all code within the same package. Whether the code appears in a function or a method makes no difference. Function that merely access or modify interal values of a type, such as the method of the Logger type from log package, below, are called getters and setters. However, when naming a getter method, we usually omit the Get prefix. This preference for brevity extends to all methods, not just field accessors, and to other redundant prefixes as well, such as Fetch, Find, and Lookup. package log type Logger struct { flags int prefix string // ... } func (l *Logger) Flags() int func (l *Logger) SetFlags(flag int) func (l *Logger) Prefix() string func (l *Logger) SetPrefix(prefix string) Encapsulation is not always desirable. By revealing its represention as an int64 number of nanoseconds, time.Duration lets us use all the usual arithmetic and comparsion operations with durations, and even to define constants of this type: package main import ( &quot;fmt&quot; &quot;time&quot; ) const day = 24 * time.Hour func main() { fmt.Printf(&quot;%t\n&quot;, day) // %!t(time.Duration=86400000000000) } Interfaces Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces let us write functions that are more flexible and adaptable because they are not tied to the details of one particular implementation. Many object-oriented languages have some notion of interface, but what makes Go’s interfaces so distinctive is they are satisfied implicitly. In other words, there’s no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don’t control. Interface as Contracts A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetric for numbers, or indexing, append, and range for slices. A concrete type may also provide additional behaviors through its methods. When you have a value of a concrete type, you knonw exactly what it is and what you can do with it. An interface is an abstract type. It doesn’t expose the representation or iternal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods. Interface Types An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface. The io.Writer type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The io package defines many other useful interfaces. A Reader represents any type from which you can read bytes, and a Closer is any value that you can close, such as a file or a network connection. package io type Writer interface { Write(p []byte) (n int, err error) } type Reader interface { Read(p []byte) (n int, err error) } type Closer interface { Close() error } Looking farther, we find declarations of new interface types as combinations of existing ones. Here are two examples: package io // ReadWriter is the interface that groups the basic Read and Write methods. type ReadWriter interface { Reader Writer } // ReadWriteCloser is the interface that groups the basic Read, Write and Close methods. type ReadWriteCloser interface { Reader Writer Closer } The syntax used above, which resembles struct embedding, lets us name another interface as a shorthand for writting out all of its methods. This is called embedding an interface. Interface Satisfaction A type *statisfies an interface if it possesses all the methods the interface requires. For example, an *os.File satisfies io.Reader, Writer, Closer, and ReadWriter. A *bytes.Buffer satisfies Reader, Writer, and ReadWriter, but does not satisfy Closer because it does not have a Close method. The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satifies the interface. So: var w io.Writer w = os.Stdout // OK: *os.File has Write method w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method w = time.Second // compile error: time.Duration lacks Write method var rwc io.ReadWriteCloser rwc = os.Stdout // OK: *os.File has Read, Write, Close methods rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method This rule applies even when the right-hand side is itself an interface: w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method The type interface{}, which is called the empty interface type places no demands on the types that statisfy it, we can assign any value to the empty interface. var any interface{} any = true any = 12.34 any = &quot;hello&quot; any = map[string]int{&quot;one&quot;: 1} any = new(bytes.Buffer) Since interface satisfcation depends only on the methods of the two type involved, there is no need to declare the relationship between a concrete type and the interface it satifies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below assets at compile time that a value of type *bytes.Buffer satifies io.Writer: // *bytes.Buffer must satisfy io.Writer var w io.Writer = new(bytes.Buffer) We needn’t allocate a new variable since any value of type *bytes.Buffer will do, even nil, which we writes as (*bytes.Buffer)(nil) using an explicit conversion. And since we never intend to refer to w, we can replace it with the blank identifier. Together, these changes give us this more frugal variant: // *bytes.Buffer must satisfy io.Writer var _ io.Writer = (*bytes.Buffer)(nil) Interface Values Conceptually, a value of an interface type, or interface value, has two components, a concrete type and a value of that type. These are called the interface’s dynamic type and dynamic value. For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called type descriptors provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor. The zero value for an interface has both its type and value components set to nil. var w io.Writer An interface value is described as nil or non-nil based on its dynamic type, so this is a nil interface value. The below statement assigns a value of type *os.File to w: var w io.Writer = os.Stdout This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion io.Writer(os.Stdout). A conversion of this kind, whether explicit or implicit, captures the type and the value of its operand. The interface values’ dynamic type is set to the type descriptor for the pointer type *os.File, and its dynamic value holds a copy of os.Stdout, which is a pointer to the os.File variable representing the standard output of process. Calling the Write method on an interface value containing an *os.File pointer causes the (*os.File).Write method to be called. The call prints “hello”. w.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot; In general, we cannot know at compile time that what the dynamic type of an interface value will be, so a call through an interface must use dynamic dispatch. Instead of a direct call, the compiler must generate code to obtain the address of the method named Write from the type descriptor, then make an indirect call to the address. The receiver argument for the call is a copy of the interface’s dynamic value, os.Stdout. The effect is as if we had make this call directly: os.Stdout.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot; Interface values may be compared using == and !=. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynmaic values are equal according to the usual behavior of == for that type. However, if two interface values are compared and have the same dynamic type, but the that type is not comparable (a slice, for instance), then the comparision fails with a panic: var x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int Caveat: An Interface Containing a Nil Pointer Is Non-Nil A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil. package main import ( &quot;bytes&quot; &quot;io&quot; ) func main() { var buf *bytes.Buffer var out io.Writer out = buf // NOTE: subtly incorrect! if out != nil { out.Write([]byte(&quot;done!\n&quot;)) // panic: runtime error: invalid memory address or nil pointer dereference } } Type Assertions A type assertion is an operation applied to an interface value. Syntactically, it looks like x.(T), where x is an expression of an interface type and T is a type, called the “asserted” type. A type assertion checks that the dynamic type of its operand matches the asserted type. A type assertion to a concrete type extracts the concrete value from its operand. If the check fails, then the operation panics. var w io.Writer w = os.Stdout f := w.(*os.File) // success: f == os.Stdout c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer A type assertion to an interface type changes the type of the expression, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface. var w io.Writer w = os.Stdout rw := w.(io.ReadWriter) // success: *os.File has both Read and Write w = new(ByteCounter) rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method No matter what type was asserted, if the operand is a nil interface value, the value assertion fails. If the type assertion appears is an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success. var w io.Writer = os.Stdout f, ok := w.(*os.File) // success: ok, f == os.Stdout b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you’ll sometimes see the original name reused, shadowing the original, like this: var w io.Writer = os.Stdout if w, ok := w.(*os.File); ok { w.Write([]byte(&quot;Hello world&quot;)) // ...use w... } Type Switches Interfaces are used in two distinct styles. In the first style, exemplified by io.Reader, io.Writer, fmt.Stringer, sort.Interface, http.Handler, and error, an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation detail and intrinsic operations of those concrete types. The emphasis is on the methods, not on the concrete types. The second style exploits the ablility of an interface value to hold values of a variety of concrete types and considers the interface to be the union of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently. In this style, the emphasis is on the concrete types that satisfy the interface, not on the interface’s methods (if indeed it has any), and there is no hiding of information. Go’s API for quering an SQL database, like those of other languages, lets us cleanly separate the fixed part of a query from the variable parts. An example client might look like this: import &quot;database/sql&quot; func listTracks(db sql.DB, artist string, minYear, maxYear int) { result, err := db.Exec( &quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;, artist, minYear, maxYear) // ... } The Exec method replace each ‘?’ in the query string with an SQL literal denoting the coresponding argument value, which may be a boolean, a number, a string, or nil. Within Exec, we might find a function like the one below, which converts each argument value to its literal SQL notation. func sqlQuote(x interface{}) string { if x == nil { return &quot;NULL&quot; } else if _, ok := x.(int); ok { return fmt.Sprintf(&quot;%d&quot;, x) } else if _, ok := x.(uint); ok { return fmt.Sprintf(&quot;%d&quot;, x) } else if b, ok := x.(bool); ok { if b { return &quot;TRUE&quot; } return &quot;FALSE&quot; } else if s, ok := x.(string); ok { return sqlQuoteString(s) // (not shown) } else { panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x)) } } A switch statement simplifies an if-else chain that performs a series of value equality tests. An analogous type switch statement simplifies an if-else chain of type assertions. In its simplest form, a type switch looks like an oridinary switch statement in which the operand is x.(type)—that’s literally the keyword type—and each case has one or more types. A type switch enables a multi-way branch based on the interface value’s dynamic type. The nil case matchs if x == nil, and the default case matches if no other case does. No fallthrough is allowed. A type switch for sqlQuote would have these cases: switch x.(type) { case nil: // ... case int, uint: // ... case bool: // ... case string: // ... default: // ... } Typically, the type switch statement has an extended form that binds the extracted value to a new variable within each case: switch x := x.(type) { // ... } Like a switch statement, a type switch implicitly creates a lexical block, so the declration of the new variable called x does not conflict with a variable x in an outer block. Each case also implicitly creates a separate lexical block. Rewriting sqlQuote to use the extended form of type switch makes it significantly clearer: func sqlQuote(x interface{}) string { switch x := x.(type) { case nil: return &quot;NULL&quot; case int, uint: return fmt.Sprintf(&quot;%d&quot;, x) // x has type interface{} here. case bool: if x { return &quot;TRUE&quot; } return &quot;FALSE&quot; case string: return sqlQuoteString(x) // (not shown) default: panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x)) } } References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. Interface types, The Go Programming Language Specification. Interface names, Effective Go - The Go Programming Language" />
<link rel="canonical" href="https://blog.codefarm.me/2017/05/21/object-oriented-programming-in-go-language/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/05/21/object-oriented-programming-in-go-language/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-05-21T17:27:56+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Object-oriented Programming in Go Language" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-05-21T17:27:56+08:00","datePublished":"2017-05-21T17:27:56+08:00","description":"Methods Method Declarations Methods with a Pointer Receiver Nil Is a Valid Receiver Value Composing Types by Struct Embedding Method Values and Expressions Encapsulation Interfaces Interface as Contracts Interface Types Interface Satisfaction Interface Values Caveat: An Interface Containing a Nil Pointer Is Non-Nil Type Assertions Type Switches References Since the early 1990s, object-oriented programming (OOP) has been the dominant programming paradigm in industry and education, and nearly all widely used languages developed since then have inlcuded support for it. Go is no exception. Methods Although there is no universally accepted definition of object-oriented programming, for our purposes, an object is simply a value or variables that has methods, and a method is a function associated with a particular type. An object-oriented program is one that uses methods to express the properties and operations of each data structure so that clients need not access the object’s representation directly. Method Declarations A method is declared with variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attachs the function to the type of that parameter. package geometry import &quot;path&quot; type Point struct{ X, Y float64 } // traditional funcitoni func Distance(p, q Point) float64 { return maht.Hypot(p.X-q.X, p.Y-q.Y) } // same thing, but as a method of the Point type func (p Point) Distance(q Point) float64 { return maht.Hypot(p.X-q.X, p.Y-q.Y) } The extra parameter p is called the method’s receiver, a legacy from early object-oriented languages that described calling a method as “sending a message to an object”. In Go, we don’t use a special name like this or self for the receiver; we choose receiver names just as we would for any other parameter. Since the receiver name will be frequently used, it’s a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like p for Point. In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name. p := Point{1, 2} q := Point{4, 6} fmt.Println(Distance(p, q)) // &quot;5&quot;, function call fmt.Println(p.Distance(q)) // &quot;5&quot;, method call There’s no conflict between the two declarations of functions called Distance above. The first declares a package-level function called geometry.Distance. The second declares a method of the type Point, so its name is Point.Distance. The expression p.Distance is called a selector, because it select the appropriate Distance method for the receiver p of type Point. Selectors are also used to select fields of struct types, as in p.X. Since methods and fields inhabit the same name space, declaring a method X on the struct Point would be ambiguous and the compiler will reject it. Methods with a Pointer Receiver Because calling a function makes a copy of each argument value, if a function needs to update a variable, of if an argument is so large that we wish to avoid copying it, we must pass the address of the variable using a pointer. The same goes for methods that need to update receiver variable: we attach them to the pointer type, such as *Point. func (p *Point) ScaleBy(factor flaot64) { p.X *= factor p.Y *= factor } The name of this method is (*Point).ScaleBy. The parentheses are neccessary; without them, the expression would be parsed as *(Point.ScaleBy). In a realistic program, convention dictates that if any method of Point has a pointer receiver, the all methods of Point should have a pointer receiver, even ones that don’t strictly need it. Named types (Point) and pointers to them (*Point) are the only types that may appear in a receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types: type P *int func (P) f() { /* ... */ } // compile error: invalid receiver type If the receiver p is a variable of type Point but the method requires a *Point receiver, we can use this shorthand: p.ScaleBy(2) and the compiler will perform an implicity &amp;p on the variable. This works only for variables, including struct field like p.X and array or slice elements like perim[0]. We cannot call a *Point method on a non-addressable Point receiver, because there’s no way to obtain the address of a temporary value. // compile error: cannot call pointer method on Point literal // compile error: cannot take the address of Point literal Point{1, 2}.ScaleBy(2) But we can call a Point method like Point.Distance with a *Point reciver, because there is a way to obtain the value from the address: just load the value pointed to by the receiver. The compiler inserts an implicit * operation for us. The two function call are equivalent: Either the receiver argument has the same type as the receiver parameter, for example both have type T or both have type *T: Point{1, 2}.Distance(q) // Point pptr.Distance(q) // Point If all the methods of a named type T have a receiver type of T itself (not *T), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. But if any method has a pointer receiver, you should avoid copying instances of T because doing so may violate internal invariants. Nil Is a Valid Receiver Value Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices. When you define a type whose methods allow nil as a receiver value, it’s worth pointing this out explicitly in its documentation comment. Composing Types by Struct Embedding import &quot;image/color&quot; type Point struct{ X, Y float64 } type ColoredPoint struct { Point Color color.RGBA } We could have defined ColoredPoint as a struct of three fields, but instead we embedded a Point to provide the X and Y fields. A similar mechanism applies to the methods of Point. We can call methods of the embedded Point field using a receiver of type ColoredPoint, even though ColoredPoint has no declared methods: red := color.RGBA{255, 0, 0, 255} blue := color.RGBA{0, 0, 255, 255} var p = ColoredPoint{Point{1, 1}, red} var q = ColoredPoint{Point{5, 4}, blue} fmt.Println(p.Distance(q.Point)) // &quot;5&quot; p.ScaleBy(2) q.ScaleBy(2) fmt.Println(p.Distance(q.Point)) // &quot;10&quot; The methods of Point have been promoted to ColoredPoint. Notice the calls to Distance above. Distance has a parameter of type Point, and q is not a Point, so although q does have an embedded field of that type, we must explicitly select it. Attempting to pass q would be an error: p.Distance(q) // compile error: cannot use q (type ColoredPoint) as type Point in argument to p.Point.Distance A ColoredPoint is not a Point, but it “has a” Point, and it has two additional methods Distance and ScaleBy promoted from Point. If you prefer to think in terms of implementation, the embedded field instructs the compiler to generate additional wrapper that delegate to the declared method, equivalent to these: func (p ColoredPoint) Distance(q Point) float64 { return p.Point.Distance(q) } func (p *ColoredPont) ScaleBy(factor float64) { return p.Point.ScaleBy(factor) } When Point.Distance is called by the first of these wrapper methods, its receiver value is p.Point, not p, and there is no way for the method to access the ColoredPoint in which the Point is embedded. A struct type may have more than one anonymous field. When the compiler resolves a selector such as p.ScaleBy to a method, it first looks for directly method named ScaleBy, then for methods promoted once from ColoredPoint’s embedded fields, then for methods promoted twich from embedded fileds within Point and RGBA, and so on. The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank. With embedding, it’s possible and sometimes useful for unmamed struct types to have methods too. The following example shows part of a simple cache implemented using two package-level variable, a mutex and the map that it guards: var ( mu sync.Mutex // guards mapping mapping = make(map[string]string) ) func Lookup(key string) string { mu.Lock() defer mu.Unlock() return mapping[key] } The version below is funcitonally equivalent but groups together the two related variables in a single package-level variable, cache: var cache = struct { sync.Mutex mapping map[string]string }{ mapping: make(map[string]string), } func Lookup(key string) string { cache.Lock() defer cache.Unlock() return mapping[key] } The new variable gives more expressive names to the variables related to the cache, and because the sync.Mutex field is embeed witin it, its Lock and Unlock methods are promoted to the unnamed type, allowing us to lock the cache with a self-explanatory syntax. Method Values and Expressions Usually we select and call a method in the same expression, as in p.Distance, but it’s possible to separate these two operations. The selector p.Distance yields a method value, a function that binds a method (Point.Distance) to a specific receiver value p. This function can then be invoked without a receiver value; it needs only the non-receiver arguments. For example, the function time.AfterFunc calls a function value after a specified delay. This program uses it to launch the rocket r after 10 seconds: type Rocket struct { /* ... */ } func (r *Rocket) Launch() { /*...*/ } r := new(Rocket) time.AfterFunc(10*time.Second, func() { r.Launch() }) The method values syntax is shorter: time.AfterFunc(10*time.Second, r.Launch) Related to the method value is the method expression. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written T.f or (*T).f where T is a type, yield a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way. In the following example, the variable op represents either the addition or the subtraction method of type Point, and the Path.TranslateBy calls it for each point in the Path: type Point struct{ X, Y float64 } func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} } func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} } type Path []Point func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add { op = Point.Add } else { op = Point.Sub } for i := range path { // Call either path[i].Add(offset) or path[i].Sub(offset). path[i] = op(path[i], offset) } } Encapsulation Go has only one mechnism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncaptitalized names are not. The same mechanism that limits access to memebers of a package also limits access to the fields of a struct or the methods of a type. As a consequnce, to encapsulation an object, we must make it struct. type IntSet struct { words []uint64 } We could instead define IntSet as a slice type as follows: type IntSet []uint64 Although this version of IntSet would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly. Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. The fields of a struct type are visible to all code within the same package. Whether the code appears in a function or a method makes no difference. Function that merely access or modify interal values of a type, such as the method of the Logger type from log package, below, are called getters and setters. However, when naming a getter method, we usually omit the Get prefix. This preference for brevity extends to all methods, not just field accessors, and to other redundant prefixes as well, such as Fetch, Find, and Lookup. package log type Logger struct { flags int prefix string // ... } func (l *Logger) Flags() int func (l *Logger) SetFlags(flag int) func (l *Logger) Prefix() string func (l *Logger) SetPrefix(prefix string) Encapsulation is not always desirable. By revealing its represention as an int64 number of nanoseconds, time.Duration lets us use all the usual arithmetic and comparsion operations with durations, and even to define constants of this type: package main import ( &quot;fmt&quot; &quot;time&quot; ) const day = 24 * time.Hour func main() { fmt.Printf(&quot;%t\\n&quot;, day) // %!t(time.Duration=86400000000000) } Interfaces Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces let us write functions that are more flexible and adaptable because they are not tied to the details of one particular implementation. Many object-oriented languages have some notion of interface, but what makes Go’s interfaces so distinctive is they are satisfied implicitly. In other words, there’s no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don’t control. Interface as Contracts A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetric for numbers, or indexing, append, and range for slices. A concrete type may also provide additional behaviors through its methods. When you have a value of a concrete type, you knonw exactly what it is and what you can do with it. An interface is an abstract type. It doesn’t expose the representation or iternal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods. Interface Types An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface. The io.Writer type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The io package defines many other useful interfaces. A Reader represents any type from which you can read bytes, and a Closer is any value that you can close, such as a file or a network connection. package io type Writer interface { Write(p []byte) (n int, err error) } type Reader interface { Read(p []byte) (n int, err error) } type Closer interface { Close() error } Looking farther, we find declarations of new interface types as combinations of existing ones. Here are two examples: package io // ReadWriter is the interface that groups the basic Read and Write methods. type ReadWriter interface { Reader Writer } // ReadWriteCloser is the interface that groups the basic Read, Write and Close methods. type ReadWriteCloser interface { Reader Writer Closer } The syntax used above, which resembles struct embedding, lets us name another interface as a shorthand for writting out all of its methods. This is called embedding an interface. Interface Satisfaction A type *statisfies an interface if it possesses all the methods the interface requires. For example, an *os.File satisfies io.Reader, Writer, Closer, and ReadWriter. A *bytes.Buffer satisfies Reader, Writer, and ReadWriter, but does not satisfy Closer because it does not have a Close method. The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satifies the interface. So: var w io.Writer w = os.Stdout // OK: *os.File has Write method w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method w = time.Second // compile error: time.Duration lacks Write method var rwc io.ReadWriteCloser rwc = os.Stdout // OK: *os.File has Read, Write, Close methods rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method This rule applies even when the right-hand side is itself an interface: w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method The type interface{}, which is called the empty interface type places no demands on the types that statisfy it, we can assign any value to the empty interface. var any interface{} any = true any = 12.34 any = &quot;hello&quot; any = map[string]int{&quot;one&quot;: 1} any = new(bytes.Buffer) Since interface satisfcation depends only on the methods of the two type involved, there is no need to declare the relationship between a concrete type and the interface it satifies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below assets at compile time that a value of type *bytes.Buffer satifies io.Writer: // *bytes.Buffer must satisfy io.Writer var w io.Writer = new(bytes.Buffer) We needn’t allocate a new variable since any value of type *bytes.Buffer will do, even nil, which we writes as (*bytes.Buffer)(nil) using an explicit conversion. And since we never intend to refer to w, we can replace it with the blank identifier. Together, these changes give us this more frugal variant: // *bytes.Buffer must satisfy io.Writer var _ io.Writer = (*bytes.Buffer)(nil) Interface Values Conceptually, a value of an interface type, or interface value, has two components, a concrete type and a value of that type. These are called the interface’s dynamic type and dynamic value. For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called type descriptors provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor. The zero value for an interface has both its type and value components set to nil. var w io.Writer An interface value is described as nil or non-nil based on its dynamic type, so this is a nil interface value. The below statement assigns a value of type *os.File to w: var w io.Writer = os.Stdout This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion io.Writer(os.Stdout). A conversion of this kind, whether explicit or implicit, captures the type and the value of its operand. The interface values’ dynamic type is set to the type descriptor for the pointer type *os.File, and its dynamic value holds a copy of os.Stdout, which is a pointer to the os.File variable representing the standard output of process. Calling the Write method on an interface value containing an *os.File pointer causes the (*os.File).Write method to be called. The call prints “hello”. w.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot; In general, we cannot know at compile time that what the dynamic type of an interface value will be, so a call through an interface must use dynamic dispatch. Instead of a direct call, the compiler must generate code to obtain the address of the method named Write from the type descriptor, then make an indirect call to the address. The receiver argument for the call is a copy of the interface’s dynamic value, os.Stdout. The effect is as if we had make this call directly: os.Stdout.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot; Interface values may be compared using == and !=. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynmaic values are equal according to the usual behavior of == for that type. However, if two interface values are compared and have the same dynamic type, but the that type is not comparable (a slice, for instance), then the comparision fails with a panic: var x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int Caveat: An Interface Containing a Nil Pointer Is Non-Nil A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil. package main import ( &quot;bytes&quot; &quot;io&quot; ) func main() { var buf *bytes.Buffer var out io.Writer out = buf // NOTE: subtly incorrect! if out != nil { out.Write([]byte(&quot;done!\\n&quot;)) // panic: runtime error: invalid memory address or nil pointer dereference } } Type Assertions A type assertion is an operation applied to an interface value. Syntactically, it looks like x.(T), where x is an expression of an interface type and T is a type, called the “asserted” type. A type assertion checks that the dynamic type of its operand matches the asserted type. A type assertion to a concrete type extracts the concrete value from its operand. If the check fails, then the operation panics. var w io.Writer w = os.Stdout f := w.(*os.File) // success: f == os.Stdout c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer A type assertion to an interface type changes the type of the expression, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface. var w io.Writer w = os.Stdout rw := w.(io.ReadWriter) // success: *os.File has both Read and Write w = new(ByteCounter) rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method No matter what type was asserted, if the operand is a nil interface value, the value assertion fails. If the type assertion appears is an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success. var w io.Writer = os.Stdout f, ok := w.(*os.File) // success: ok, f == os.Stdout b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you’ll sometimes see the original name reused, shadowing the original, like this: var w io.Writer = os.Stdout if w, ok := w.(*os.File); ok { w.Write([]byte(&quot;Hello world&quot;)) // ...use w... } Type Switches Interfaces are used in two distinct styles. In the first style, exemplified by io.Reader, io.Writer, fmt.Stringer, sort.Interface, http.Handler, and error, an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation detail and intrinsic operations of those concrete types. The emphasis is on the methods, not on the concrete types. The second style exploits the ablility of an interface value to hold values of a variety of concrete types and considers the interface to be the union of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently. In this style, the emphasis is on the concrete types that satisfy the interface, not on the interface’s methods (if indeed it has any), and there is no hiding of information. Go’s API for quering an SQL database, like those of other languages, lets us cleanly separate the fixed part of a query from the variable parts. An example client might look like this: import &quot;database/sql&quot; func listTracks(db sql.DB, artist string, minYear, maxYear int) { result, err := db.Exec( &quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;, artist, minYear, maxYear) // ... } The Exec method replace each ‘?’ in the query string with an SQL literal denoting the coresponding argument value, which may be a boolean, a number, a string, or nil. Within Exec, we might find a function like the one below, which converts each argument value to its literal SQL notation. func sqlQuote(x interface{}) string { if x == nil { return &quot;NULL&quot; } else if _, ok := x.(int); ok { return fmt.Sprintf(&quot;%d&quot;, x) } else if _, ok := x.(uint); ok { return fmt.Sprintf(&quot;%d&quot;, x) } else if b, ok := x.(bool); ok { if b { return &quot;TRUE&quot; } return &quot;FALSE&quot; } else if s, ok := x.(string); ok { return sqlQuoteString(s) // (not shown) } else { panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x)) } } A switch statement simplifies an if-else chain that performs a series of value equality tests. An analogous type switch statement simplifies an if-else chain of type assertions. In its simplest form, a type switch looks like an oridinary switch statement in which the operand is x.(type)—that’s literally the keyword type—and each case has one or more types. A type switch enables a multi-way branch based on the interface value’s dynamic type. The nil case matchs if x == nil, and the default case matches if no other case does. No fallthrough is allowed. A type switch for sqlQuote would have these cases: switch x.(type) { case nil: // ... case int, uint: // ... case bool: // ... case string: // ... default: // ... } Typically, the type switch statement has an extended form that binds the extracted value to a new variable within each case: switch x := x.(type) { // ... } Like a switch statement, a type switch implicitly creates a lexical block, so the declration of the new variable called x does not conflict with a variable x in an outer block. Each case also implicitly creates a separate lexical block. Rewriting sqlQuote to use the extended form of type switch makes it significantly clearer: func sqlQuote(x interface{}) string { switch x := x.(type) { case nil: return &quot;NULL&quot; case int, uint: return fmt.Sprintf(&quot;%d&quot;, x) // x has type interface{} here. case bool: if x { return &quot;TRUE&quot; } return &quot;FALSE&quot; case string: return sqlQuoteString(x) // (not shown) default: panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x)) } } References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. Interface types, The Go Programming Language Specification. Interface names, Effective Go - The Go Programming Language","headline":"Object-oriented Programming in Go Language","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/05/21/object-oriented-programming-in-go-language/"},"url":"https://blog.codefarm.me/2017/05/21/object-oriented-programming-in-go-language/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Object-oriented Programming in Go Language</h1><p class="c-post-meta">21 May 2017</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#methods" id="markdown-toc-methods">Methods</a>    <ul>
      <li><a href="#method-declarations" id="markdown-toc-method-declarations">Method Declarations</a></li>
      <li><a href="#methods-with-a-pointer-receiver" id="markdown-toc-methods-with-a-pointer-receiver">Methods with a Pointer Receiver</a>        <ul>
          <li><a href="#nil-is-a-valid-receiver-value" id="markdown-toc-nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</a></li>
        </ul>
      </li>
      <li><a href="#composing-types-by-struct-embedding" id="markdown-toc-composing-types-by-struct-embedding">Composing Types by Struct Embedding</a></li>
      <li><a href="#method-values-and-expressions" id="markdown-toc-method-values-and-expressions">Method Values and Expressions</a></li>
      <li><a href="#encapsulation" id="markdown-toc-encapsulation">Encapsulation</a></li>
    </ul>
  </li>
  <li><a href="#interfaces" id="markdown-toc-interfaces">Interfaces</a>    <ul>
      <li><a href="#interface-as-contracts" id="markdown-toc-interface-as-contracts">Interface as Contracts</a></li>
      <li><a href="#interface-types" id="markdown-toc-interface-types">Interface Types</a></li>
      <li><a href="#interface-satisfaction" id="markdown-toc-interface-satisfaction">Interface Satisfaction</a></li>
      <li><a href="#interface-values" id="markdown-toc-interface-values">Interface Values</a>        <ul>
          <li><a href="#caveat-an-interface-containing-a-nil-pointer-is-non-nil" id="markdown-toc-caveat-an-interface-containing-a-nil-pointer-is-non-nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</a></li>
        </ul>
      </li>
      <li><a href="#type-assertions" id="markdown-toc-type-assertions">Type Assertions</a></li>
      <li><a href="#type-switches" id="markdown-toc-type-switches">Type Switches</a></li>
      <li><a href="#references" id="markdown-toc-references">References</a></li>
    </ul>
  </li>
</ul>

<hr />

<p>Since the early 1990s, object-oriented programming (OOP) has been the dominant programming paradigm in industry and education, and nearly all widely used languages developed since then have inlcuded support for it. Go is no exception.</p>

<h2 id="methods">Methods</h2>

<p>Although there is no universally accepted definition of object-oriented programming, for our purposes, an <strong><em>object</em></strong> is simply a value or variables that has methods, and a <strong><em>method</em></strong> is a function associated with a particular type. An object-oriented program is one that uses methods to express the properties and operations of each data structure so that clients need not access the object’s representation directly.</p>

<h3 id="method-declarations">Method Declarations</h3>

<p>A method is declared with variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attachs the function to the type of that parameter.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">geometry</span>

<span class="k">import</span> <span class="s">"path"</span>

<span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span><span class="p">{</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c">// traditional funcitoni</span>
<span class="k">func</span> <span class="n">Distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">maht</span><span class="o">.</span><span class="n">Hypot</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">X</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// same thing, but as a method of the Point type</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Distance</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">maht</span><span class="o">.</span><span class="n">Hypot</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">X</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The extra parameter <code class="language-plaintext highlighter-rouge">p</code> is called the method’s <strong><em>receiver</em></strong>, a legacy from early object-oriented languages that described calling a method as “sending a message to an object”.</p>

<p>In Go, we don’t use a special name like <strong>this</strong> or <strong>self</strong> for the receiver; we choose receiver names just as we would for any other parameter. <strong>Since the receiver name will be frequently used, it’s a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like <code class="language-plaintext highlighter-rouge">p</code> for <code class="language-plaintext highlighter-rouge">Point</code>.</strong></p>

<p>In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">:=</span> <span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="n">q</span> <span class="o">:=</span> <span class="n">Point</span><span class="p">{</span><span class="m">4</span><span class="p">,</span> <span class="m">6</span><span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span> <span class="c">// "5", function call</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>  <span class="c">// "5", method call</span>
</code></pre></div></div>

<p>There’s no conflict between the two declarations of functions called <code class="language-plaintext highlighter-rouge">Distance</code> above. The first declares a package-level function called <code class="language-plaintext highlighter-rouge">geometry.Distance</code>. The second declares a method of the type <code class="language-plaintext highlighter-rouge">Point</code>, so its name is <code class="language-plaintext highlighter-rouge">Point.Distance</code>.</p>

<p>The expression <code class="language-plaintext highlighter-rouge">p.Distance</code> is called a <strong><em>selector</em></strong>, because it select the appropriate <code class="language-plaintext highlighter-rouge">Distance</code> method for the receiver <code class="language-plaintext highlighter-rouge">p</code> of type <code class="language-plaintext highlighter-rouge">Point</code>. Selectors are also used to select fields of struct types, as in <code class="language-plaintext highlighter-rouge">p.X</code>. <strong>Since methods and fields inhabit the same name space, declaring a method <code class="language-plaintext highlighter-rouge">X</code> on the struct <code class="language-plaintext highlighter-rouge">Point</code> would be ambiguous and the compiler will reject it.</strong></p>

<h3 id="methods-with-a-pointer-receiver">Methods with a Pointer Receiver</h3>

<p>Because calling a function makes a copy of each argument value, if a function needs to update a variable, of if an argument is so large that we wish to avoid copying it, we must pass the address of the variable using a pointer. The same goes for methods that need to update receiver variable: we attach them to the pointer type, such as <code class="language-plaintext highlighter-rouge">*Point</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Point</span><span class="p">)</span> <span class="n">ScaleBy</span><span class="p">(</span><span class="n">factor</span> <span class="n">flaot64</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">*=</span> <span class="n">factor</span>
	<span class="n">p</span><span class="o">.</span><span class="n">Y</span> <span class="o">*=</span> <span class="n">factor</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The name of this method is <code class="language-plaintext highlighter-rouge">(*Point).ScaleBy</code>. The parentheses are neccessary; without them, the expression would be parsed as <code class="language-plaintext highlighter-rouge">*(Point.ScaleBy)</code>.</p>

<p><strong>In a realistic program, convention dictates that if any method of <code class="language-plaintext highlighter-rouge">Point</code> has a pointer receiver, the <em>all</em> methods of <code class="language-plaintext highlighter-rouge">Point</code> should have a pointer receiver, even ones that don’t strictly need it.</strong></p>

<p>Named types (<code class="language-plaintext highlighter-rouge">Point</code>) and pointers to them (<code class="language-plaintext highlighter-rouge">*Point</code>) are the only types that may appear in a receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">P</span> <span class="o">*</span><span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span> <span class="c">// compile error: invalid receiver type</span>
</code></pre></div></div>

<p>If the receiver <code class="language-plaintext highlighter-rouge">p</code> is a <em>variable</em> of type <code class="language-plaintext highlighter-rouge">Point</code> but the method requires a <code class="language-plaintext highlighter-rouge">*Point</code> receiver, we can use this shorthand:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</code></pre></div></div>

<p>and the compiler will perform an implicity <code class="language-plaintext highlighter-rouge">&amp;p</code> on the variable. This works only for variables, including struct field like <code class="language-plaintext highlighter-rouge">p.X</code> and array or slice elements like <code class="language-plaintext highlighter-rouge">perim[0]</code>. We cannot call a <code class="language-plaintext highlighter-rouge">*Point</code> method on a non-addressable <code class="language-plaintext highlighter-rouge">Point</code> receiver, because there’s no way to obtain the address of a temporary value.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// compile error: cannot call pointer method on Point literal</span>
<span class="c">// compile error: cannot take the address of Point literal</span>
<span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</code></pre></div></div>

<p>But we <strong><em>can</em></strong> call a <code class="language-plaintext highlighter-rouge">Point</code> method like <code class="language-plaintext highlighter-rouge">Point.Distance</code> with a <code class="language-plaintext highlighter-rouge">*Point</code> reciver, because there is a way to obtain the value from the address: just load the value pointed to by the receiver. The compiler inserts an implicit <code class="language-plaintext highlighter-rouge">*</code> operation for us. The two function call are equivalent:</p>

<p>Either the receiver argument has the same type as the receiver parameter, for example both have type <code class="language-plaintext highlighter-rouge">T</code> or both have type <code class="language-plaintext highlighter-rouge">*T</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c">// Point</span>
	<span class="n">pptr</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>        <span class="c">// Point</span>
</code></pre></div></div>

<p>If all the methods of a named type <code class="language-plaintext highlighter-rouge">T</code> have a receiver type of <code class="language-plaintext highlighter-rouge">T</code> itself (not <code class="language-plaintext highlighter-rouge">*T</code>), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. But if any method has a pointer receiver, you should avoid copying instances of <code class="language-plaintext highlighter-rouge">T</code> because doing so may violate internal invariants.</p>

<h4 id="nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</h4>

<p>Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if <strong>nil</strong> is a meaningful zero value of the type, as with maps and slices.</p>

<p>When you define a type whose methods allow <strong>nil</strong> as a receiver value, it’s worth pointing this out explicitly in its documentation comment.</p>

<h3 id="composing-types-by-struct-embedding">Composing Types by Struct Embedding</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"image/color"</span>

<span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span><span class="p">{</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">ColoredPoint</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Point</span>
	<span class="n">Color</span> <span class="n">color</span><span class="o">.</span><span class="n">RGBA</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could have defined <code class="language-plaintext highlighter-rouge">ColoredPoint</code> as a struct of three fields, but instead we <strong><em>embedded</em></strong> a <code class="language-plaintext highlighter-rouge">Point</code> to provide the <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> fields. A similar mechanism applies to the <em>methods</em> of <code class="language-plaintext highlighter-rouge">Point</code>. We can call methods of the embedded <code class="language-plaintext highlighter-rouge">Point</code> field using a receiver of type <code class="language-plaintext highlighter-rouge">ColoredPoint</code>, even though <code class="language-plaintext highlighter-rouge">ColoredPoint</code> has no declared methods:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">red</span> <span class="o">:=</span> <span class="n">color</span><span class="o">.</span><span class="n">RGBA</span><span class="p">{</span><span class="m">255</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">}</span>
<span class="n">blue</span> <span class="o">:=</span> <span class="n">color</span><span class="o">.</span><span class="n">RGBA</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">,</span> <span class="m">255</span><span class="p">}</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ColoredPoint</span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">},</span> <span class="n">red</span><span class="p">}</span>
<span class="k">var</span> <span class="n">q</span> <span class="o">=</span> <span class="n">ColoredPoint</span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="m">5</span><span class="p">,</span> <span class="m">4</span><span class="p">},</span> <span class="n">blue</span><span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">Point</span><span class="p">))</span> <span class="c">// "5"</span>
<span class="n">p</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
<span class="n">q</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">Point</span><span class="p">))</span> <span class="c">// "10"</span>
</code></pre></div></div>

<p>The methods of <code class="language-plaintext highlighter-rouge">Point</code> have been <strong>promoted</strong> to <code class="language-plaintext highlighter-rouge">ColoredPoint</code>.</p>

<p>Notice the calls to <code class="language-plaintext highlighter-rouge">Distance</code> above. <code class="language-plaintext highlighter-rouge">Distance</code> has a parameter of type <code class="language-plaintext highlighter-rouge">Point</code>, and <code class="language-plaintext highlighter-rouge">q</code> is not a <code class="language-plaintext highlighter-rouge">Point</code>, so although <code class="language-plaintext highlighter-rouge">q</code> does have an embedded field of that type, we must explicitly select it. Attempting to pass <code class="language-plaintext highlighter-rouge">q</code> would be an error:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c">// compile error: cannot use q (type ColoredPoint) as type Point in argument to p.Point.Distance</span>
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">ColoredPoint</code> is not a <code class="language-plaintext highlighter-rouge">Point</code>, but it “has a” <code class="language-plaintext highlighter-rouge">Point</code>, and it has two additional methods <code class="language-plaintext highlighter-rouge">Distance</code> and <code class="language-plaintext highlighter-rouge">ScaleBy</code> promoted from <code class="language-plaintext highlighter-rouge">Point</code>. If you prefer to think in terms of implementation, the embedded field instructs the compiler to generate additional wrapper that delegate to the declared method, equivalent to these:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">ColoredPoint</span><span class="p">)</span> <span class="n">Distance</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">Point</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ColoredPont</span><span class="p">)</span> <span class="n">ScaleBy</span><span class="p">(</span><span class="n">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">Point</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">Point.Distance</code> is called by the first of these wrapper methods, its receiver value is <code class="language-plaintext highlighter-rouge">p.Point</code>, not <code class="language-plaintext highlighter-rouge">p</code>, and there is no way for the method to access the <code class="language-plaintext highlighter-rouge">ColoredPoint</code> in which the <code class="language-plaintext highlighter-rouge">Point</code> is embedded.</p>

<p>A struct type may have more than one anonymous field. <strong>When the compiler resolves a selector such as <code class="language-plaintext highlighter-rouge">p.ScaleBy</code> to a method, it first looks for directly method named <code class="language-plaintext highlighter-rouge">ScaleBy</code>, then for methods promoted once from <code class="language-plaintext highlighter-rouge">ColoredPoint</code>’s embedded fields, then for methods promoted twich from embedded fileds within <code class="language-plaintext highlighter-rouge">Point</code> and <code class="language-plaintext highlighter-rouge">RGBA</code>, and so on.</strong> <strong>The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank.</strong></p>

<p>With embedding, it’s possible and sometimes useful for <strong><em>unmamed</em></strong> struct types to have methods too. The following example shows part of a simple cache implemented using two package-level variable, a mutex and the map that it guards:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
	<span class="n">mu</span>      <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span> <span class="c">// guards mapping</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">Lookup</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The version below is funcitonally equivalent but groups together the two related variables in a single package-level variable, <code class="language-plaintext highlighter-rouge">cache</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">mapping</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}{</span>
	<span class="n">mapping</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Lookup</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="n">cache</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">cache</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The new variable gives more expressive names to the variables related to the cache, and because the <code class="language-plaintext highlighter-rouge">sync.Mutex</code> field is embeed witin it, its <code class="language-plaintext highlighter-rouge">Lock</code> and <code class="language-plaintext highlighter-rouge">Unlock</code> methods are promoted to the unnamed type, allowing us to lock the <code class="language-plaintext highlighter-rouge">cache</code> with a self-explanatory syntax.</p>

<h3 id="method-values-and-expressions">Method Values and Expressions</h3>

<p>Usually we select and call a method in the same expression, as in <code class="language-plaintext highlighter-rouge">p.Distance</code>, but it’s possible to separate these two operations. The selector <code class="language-plaintext highlighter-rouge">p.Distance</code> yields a <strong><em>method value</em></strong>, a function that binds a method (<code class="language-plaintext highlighter-rouge">Point.Distance</code>) to a specific receiver value <code class="language-plaintext highlighter-rouge">p</code>. This function can then be invoked without a receiver value; it needs only the non-receiver arguments.</p>

<p>For example, the function <code class="language-plaintext highlighter-rouge">time.AfterFunc</code> calls a function value after a specified delay. This program uses it to launch the rocket <code class="language-plaintext highlighter-rouge">r</code> after 10 seconds:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Rocket</span> <span class="k">struct</span> <span class="p">{</span> <span class="c">/* ... */</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Rocket</span><span class="p">)</span> <span class="n">Launch</span><span class="p">()</span> <span class="p">{</span> <span class="c">/*...*/</span> <span class="p">}</span>

<span class="n">r</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Rocket</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">AfterFunc</span><span class="p">(</span><span class="m">10</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">r</span><span class="o">.</span><span class="n">Launch</span><span class="p">()</span> <span class="p">})</span>
</code></pre></div></div>

<p>The method values syntax is shorter:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time</span><span class="o">.</span><span class="n">AfterFunc</span><span class="p">(</span><span class="m">10</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">Launch</span><span class="p">)</span>
</code></pre></div></div>

<p>Related to the method value is the <strong><em>method expression</em></strong>. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written <code class="language-plaintext highlighter-rouge">T.f</code> or <code class="language-plaintext highlighter-rouge">(*T).f</code> where <code class="language-plaintext highlighter-rouge">T</code> is a type, yield a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way.</p>

<p>In the following example, the variable <code class="language-plaintext highlighter-rouge">op</code> represents either the addition or the subtraction method of type <code class="language-plaintext highlighter-rouge">Point</code>, and the <code class="language-plaintext highlighter-rouge">Path.TranslateBy</code> calls it for each point in the <code class="language-plaintext highlighter-rouge">Path</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span><span class="p">{</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Point</span><span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span> <span class="o">+</span> <span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">}</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Sub</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Point</span><span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">}</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">Path</span> <span class="p">[]</span><span class="n">Point</span>

<span class="k">func</span> <span class="p">(</span><span class="n">path</span> <span class="n">Path</span><span class="p">)</span> <span class="n">TranslateBy</span><span class="p">(</span><span class="n">offset</span> <span class="n">Point</span><span class="p">,</span> <span class="n">add</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">op</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Point</span>
	<span class="k">if</span> <span class="n">add</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">Add</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">Sub</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">path</span> <span class="p">{</span>
		<span class="c">// Call either path[i].Add(offset) or path[i].Sub(offset).</span>
		<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">offset</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="encapsulation">Encapsulation</h3>

<p>Go has only one mechnism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncaptitalized names are not. The same mechanism that limits access to memebers of a package also limits access to the fields of a struct or the methods of a type. As a consequnce, to encapsulation an object, we must make it struct.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">IntSet</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could instead define <code class="language-plaintext highlighter-rouge">IntSet</code> as a slice type as follows:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">IntSet</span> <span class="p">[]</span><span class="kt">uint64</span>
</code></pre></div></div>

<p>Although this version of <code class="language-plaintext highlighter-rouge">IntSet</code> would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly.</p>

<p>Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. The fields of a struct type are visible to all code within the same package. Whether the code appears in a function or a method makes no difference.</p>

<p>Function that merely access or modify interal values of a type, such as the method of the <code class="language-plaintext highlighter-rouge">Logger</code> type from <code class="language-plaintext highlighter-rouge">log</code> package, below, are called <strong><em>getters</em></strong> and <strong><em>setters</em></strong>. However, when naming a getter method, we usually omit the <strong>Get</strong> prefix. This preference for brevity extends to all methods, not just field accessors, and to other redundant prefixes as well, such as <code class="language-plaintext highlighter-rouge">Fetch</code>, <code class="language-plaintext highlighter-rouge">Find</code>, and <code class="language-plaintext highlighter-rouge">Lookup</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">log</span>

<span class="k">type</span> <span class="n">Logger</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">flags</span>  <span class="kt">int</span>
	<span class="n">prefix</span> <span class="kt">string</span>
	<span class="c">// ...</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">Flags</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">SetFlags</span><span class="p">(</span><span class="n">flag</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">Prefix</span><span class="p">()</span> <span class="kt">string</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">SetPrefix</span><span class="p">(</span><span class="n">prefix</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></div></div>

<p>Encapsulation is not always desirable. By revealing its represention as an <code class="language-plaintext highlighter-rouge">int64</code> number of nanoseconds, <code class="language-plaintext highlighter-rouge">time.Duration</code> lets us use all the usual arithmetic and comparsion operations with durations, and even to define constants of this type:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">day</span> <span class="o">=</span> <span class="m">24</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Hour</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%t</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span> <span class="c">// %!t(time.Duration=86400000000000)</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="interfaces">Interfaces</h2>

<p>Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces let us write functions that are more flexible and adaptable because they are not tied to the details of one particular implementation.</p>

<p>Many object-oriented languages have some notion of interface, but what makes Go’s interfaces so distinctive is they are <strong><em>satisfied implicitly</em></strong>. In other words, there’s no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don’t control.</p>

<h3 id="interface-as-contracts">Interface as Contracts</h3>

<p>A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetric for numbers, or indexing, <em>append</em>, and <em>range</em> for slices. A concrete type may also provide additional behaviors through its methods. <strong>When you have a value of a concrete type, you knonw exactly what it <em>is</em> and what you can <em>do</em> with it.</strong></p>

<p>An interface is an <strong><em>abstract type</em></strong>. It doesn’t expose the representation or iternal structure of its values, or the set of basic operations they support; it reveals only some of their methods. <strong>When you have a value of an interface type, you know nothing about what it <em>is</em>; you know only what it can <em>do</em>, or more precisely, what behaviors are provided by its methods.</strong></p>

<h3 id="interface-types">Interface Types</h3>

<p>An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface.</p>

<p>The <strong>io.Writer</strong> type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The <strong>io</strong> package defines many other useful interfaces. A <strong>Reader</strong> represents any type from which you can read bytes, and a <strong>Closer</strong> is any value that you can close, such as a file or a network connection.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Closer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looking farther, we find declarations of new interface types as combinations of existing ones.</p>

<p>Here are two examples:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span>

<span class="c">// ReadWriter is the interface that groups the basic Read and Write methods.</span>
<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>
	<span class="n">Writer</span>
<span class="p">}</span>

<span class="c">// ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</span>
<span class="k">type</span> <span class="n">ReadWriteCloser</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>
	<span class="n">Writer</span>
	<span class="n">Closer</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The syntax used above, which resembles struct embedding, lets us name another interface as a shorthand for writting out all of its methods. This is called <strong><em>embedding</em></strong> an interface.</p>

<h3 id="interface-satisfaction">Interface Satisfaction</h3>

<p>A type *statisfies an interface if it possesses all the methods the interface requires. For example, an <strong>*os.File</strong> satisfies <strong>io.Reader</strong>, <strong>Writer</strong>, <strong>Closer</strong>, and <strong>ReadWriter</strong>. A <strong>*bytes.Buffer</strong> satisfies <strong>Reader</strong>, <strong>Writer</strong>, and <strong>ReadWriter</strong>, but does not satisfy <strong>Closer</strong> because it does not have a <strong>Close</strong> method.</p>

<p>The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satifies the interface. So:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>         <span class="c">// OK: *os.File has Write method</span>
	<span class="n">w</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// OK: *bytes.Buffer has Write method</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span>       <span class="c">// compile error: time.Duration lacks Write method</span>

	<span class="k">var</span> <span class="n">rwc</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadWriteCloser</span>
	<span class="n">rwc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>         <span class="c">// OK: *os.File has Read, Write, Close methods</span>
	<span class="n">rwc</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// compile error: *bytes.Buffer lacks Close method</span>
</code></pre></div></div>

<p>This rule applies even when the right-hand side is itself an interface:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">w</span> <span class="o">=</span> <span class="n">rwc</span> <span class="c">// OK: io.ReadWriteCloser has Write method</span>
	<span class="n">rwc</span> <span class="o">=</span> <span class="n">w</span> <span class="c">// compile error: io.Writer lacks Close method</span>
</code></pre></div></div>

<p>The type <strong>interface{}</strong>, which is called the <strong><em>empty interface</em></strong> type places no demands on the types that statisfy it, we can assign <strong><em>any</em></strong> value to the empty interface.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">any</span> <span class="k">interface</span><span class="p">{}</span>
	<span class="n">any</span> <span class="o">=</span> <span class="no">true</span>
	<span class="n">any</span> <span class="o">=</span> <span class="m">12.34</span>
	<span class="n">any</span> <span class="o">=</span> <span class="s">"hello"</span>
	<span class="n">any</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"one"</span><span class="o">:</span> <span class="m">1</span><span class="p">}</span>
	<span class="n">any</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span>
</code></pre></div></div>

<p>Since interface satisfcation depends only on the methods of the two type involved, there is no need to declare the relationship between a concrete type and the interface it satifies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below assets at compile time that a value of type <strong>*bytes.Buffer</strong> satifies <strong>io.Writer</strong>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c">// *bytes.Buffer must satisfy io.Writer</span>
	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span>
</code></pre></div></div>

<p>We needn’t allocate a new variable since any value of type <strong>*bytes.Buffer</strong> will do, even <strong>nil</strong>, which we writes as <strong>(*bytes.Buffer)(nil)</strong> using an explicit conversion. And since we never intend to refer to <strong>w</strong>, we can replace it with the blank identifier. Together, these changes give us this more frugal variant:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c">// *bytes.Buffer must satisfy io.Writer</span>
	<span class="k">var</span> <span class="n">_</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)(</span><span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="interface-values">Interface Values</h3>

<p>Conceptually, a value of an interface type, or <strong><em>interface value</em></strong>, has two components, a concrete type and a value of that type. These are called the interface’s <strong><em>dynamic type</em></strong> and <strong><em>dynamic value</em></strong>.</p>

<p>For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called <strong><em>type descriptors</em></strong> provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor.</p>

<p><strong>The zero value for an interface has both its type and value components set to <em>nil</em></strong>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
</code></pre></div></div>

<p><img src="/assets/gopl/a-nil-interface-value.png" alt="A nil interface value" title="A nil interface value" /></p>

<p><strong>An interface value is described as nil or non-nil based on its dynamic type</strong>, so this is a nil interface value.</p>

<p>The below statement assigns a value of type <strong>*os.File</strong> to <strong>w</strong>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
</code></pre></div></div>

<p>This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion <strong>io.Writer(os.Stdout)</strong>. A conversion of this kind, whether explicit or implicit, captures the type and the value of its operand. The interface values’ dynamic type is set to the type descriptor for the pointer type <strong>*os.File</strong>, and its dynamic value holds a copy of <strong>os.Stdout</strong>, which is a pointer to the <strong>os.File</strong> variable representing the standard output of process.</p>

<p><img src="/assets/gopl/an-interface-value-containing-an-os-File-pointer.png" alt="An interface value containing an *os.File pointer" /></p>

<p>Calling the <strong>Write</strong> method on an interface value containing an <strong>*os.File</strong> pointer causes the <strong>(*os.File).Write</strong> method to be called. The call prints <strong>“hello”</strong>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"hello"</span><span class="p">))</span>         <span class="c">// "hello"</span>
</code></pre></div></div>

<p>In general, we cannot know at compile time that what the dynamic type of an interface value will be, so a call through an interface must use <strong><em>dynamic dispatch</em></strong>. Instead of a direct call, the compiler must generate code to obtain the address of the method named <strong>Write</strong> from the type descriptor, then make an indirect call to the address. The receiver argument for the  call is a copy of the interface’s dynamic value, <strong>os.Stdout</strong>. The effect is as if we had make this call directly:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"hello"</span><span class="p">))</span> <span class="c">// "hello"</span>
</code></pre></div></div>

<p>Interface values may be compared using <code class="language-plaintext highlighter-rouge">==</code> and <code class="language-plaintext highlighter-rouge">!=</code>. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynmaic values are equal according to the usual behavior of <code class="language-plaintext highlighter-rouge">==</code> for that type. However, if two interface values are compared and have the same dynamic type, but the that type is not comparable (a slice, for instance), then the comparision fails with a panic:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">x</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="c">// panic: comparing uncomparable type []int</span>
</code></pre></div></div>

<h4 id="caveat-an-interface-containing-a-nil-pointer-is-non-nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</h4>

<p>A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"bytes"</span>
	<span class="s">"io"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">buf</span> <span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span>
	<span class="k">var</span> <span class="n">out</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">out</span> <span class="o">=</span> <span class="n">buf</span> <span class="c">// NOTE: subtly incorrect!</span>
	<span class="k">if</span> <span class="n">out</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">out</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"done!</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span> <span class="c">// panic: runtime error: invalid memory address or nil pointer dereference</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/gopl/a-non-nil-interface-containing-a-nil-pointer.png" alt="A non-nil interface containing a nil pointer" /></p>

<hr />

<h3 id="type-assertions">Type Assertions</h3>

<p>A <strong><em>type assertion</em></strong> is an operation applied to an interface value. Syntactically, it looks like <strong>x.(T)</strong>, where <strong>x</strong> is an expression of an interface type and <strong>T</strong> is a type, called the “asserted” type. A type assertion checks that the dynamic type of its operand matches the asserted type.</p>

<p><strong>A type assertion to a concrete type extracts the concrete value from its operand.</strong> If the check fails, then the operation panics.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">)</span>      <span class="c">// success: f == os.Stdout</span>
	<span class="n">c</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// panic: interface holds *os.File, not *bytes.Buffer</span>
</code></pre></div></div>
<p><strong>A type assertion to an interface type changes the type of the expression</strong>, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">rw</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadWriter</span><span class="p">)</span> <span class="c">// success: *os.File has both Read and Write</span>

	<span class="n">w</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">ByteCounter</span><span class="p">)</span>
	<span class="n">rw</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadWriter</span><span class="p">)</span> <span class="c">// panic: *ByteCounter has no Read method</span>
</code></pre></div></div>

<p>No matter what type was asserted, <strong>if the operand is a nil interface value, the value assertion fails</strong>.</p>

<p>If the type assertion appears is an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">)</span>      <span class="c">// success:  ok, f == os.Stdout</span>
	<span class="n">b</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// failure: !ok, b == nil</span>
</code></pre></div></div>

<p>When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you’ll sometimes see the original name reused, shadowing the original, like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="k">if</span> <span class="n">w</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Hello world"</span><span class="p">))</span>
		<span class="c">// ...use w...</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="type-switches">Type Switches</h3>

<p>Interfaces are used in two distinct styles. In the first style, exemplified by <strong>io.Reader</strong>, <strong>io.Writer</strong>, <strong>fmt.Stringer</strong>, <strong>sort.Interface</strong>, <strong>http.Handler</strong>, and <strong>error</strong>, an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation detail and intrinsic operations of those concrete types. <strong>The emphasis is on the methods, not on the concrete types.</strong></p>

<p>The second style exploits the ablility of an interface value to hold values of a variety of concrete types and considers the interface to be the <strong>union</strong> of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently. In this style, <strong>the emphasis is on the concrete types that satisfy the interface</strong>, not on the interface’s methods (if indeed it has any), and there is no hiding of information.</p>

<p>Go’s API for quering an SQL database, like those of other languages, lets us cleanly separate the fixed part of a query from the variable parts. An example client might look like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"database/sql"</span>

<span class="k">func</span> <span class="n">listTracks</span><span class="p">(</span><span class="n">db</span> <span class="n">sql</span><span class="o">.</span><span class="n">DB</span><span class="p">,</span> <span class="n">artist</span> <span class="kt">string</span><span class="p">,</span> <span class="n">minYear</span><span class="p">,</span> <span class="n">maxYear</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Exec</span><span class="p">(</span>
		<span class="s">"SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?"</span><span class="p">,</span>
		<span class="n">artist</span><span class="p">,</span> <span class="n">minYear</span><span class="p">,</span> <span class="n">maxYear</span><span class="p">)</span>
	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <strong>Exec</strong> method replace each ‘<strong>?</strong>’ in the query string with an SQL literal denoting the coresponding argument value, which may be a boolean, a number, a string, or <strong>nil</strong>. Within <strong>Exec</strong>, we might find a function like the one below, which converts each argument value to its literal SQL notation.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sqlQuote</span><span class="p">(</span><span class="n">x</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">"NULL"</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">uint</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">b</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">b</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">"TRUE"</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="s">"FALSE"</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">s</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">sqlQuoteString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// (not shown)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"unexpected type %T: %v"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A <strong>switch</strong> statement simplifies an <strong>if-else</strong> chain that performs a series of value equality tests. An analogous <strong>type switch</strong> statement simplifies an <strong>if-else</strong> chain of type assertions.</p>

<p>In its simplest form, a type switch looks like an oridinary switch statement in which the operand is <strong>x.(type)</strong>—that’s literally the keyword <strong>type</strong>—and each case has one or more types. <strong>A type switch enables a multi-way branch based on the interface value’s dynamic type.</strong> The <strong>nil</strong> case matchs if <strong>x == nil</strong>, and the <strong>default</strong> case matches if no other case does. No <strong>fallthrough</strong> is allowed. A type switch for <strong>sqlQuote</strong> would have these cases:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">switch</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="no">nil</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">case</span> <span class="kt">bool</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">case</span> <span class="kt">string</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">default</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>Typically, the type switch statement has an extended form that binds the extracted value to a new variable within each case:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">switch</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// ...</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>Like a <strong>switch</strong> statement, a type switch implicitly creates a lexical block, so the declration of the new variable called <strong>x</strong> does not conflict with a variable <strong>x</strong> in an outer block. Each <strong>case</strong> also implicitly creates a separate lexical block.</p>

<p>Rewriting <strong>sqlQuote</strong> to use the extended form of type switch makes it significantly clearer:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sqlQuote</span><span class="p">(</span><span class="n">x</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="no">nil</span><span class="o">:</span>
		<span class="k">return</span> <span class="s">"NULL"</span>
	<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c">// x has type interface{} here.</span>
	<span class="k">case</span> <span class="kt">bool</span><span class="o">:</span>
		<span class="k">if</span> <span class="n">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">"TRUE"</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="s">"FALSE"</span>
	<span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">sqlQuoteString</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// (not shown)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"unexpected type %T: %v"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="references">References</h3>

<ol>
  <li>Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11.</li>
  <li><a href="https://golang.org/ref/spec#Interface_types">Interface types</a>, The Go Programming Language Specification.</li>
  <li><a href="https://golang.org/doc/effective_go.html#interface-names">Interface names</a>, Effective Go - The Go Programming Language</li>
</ol>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
