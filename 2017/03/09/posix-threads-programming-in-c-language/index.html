<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>POSIX Threads Programming in C Language | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="POSIX Threads Programming in C Language" />
<meta property="og:locale" content="en" />
<meta name="description" content="What is Parallel Computing ? 1. Serial Computing 2. Parallel Computing 3. Parallel Computers 4. von Neumann Architecture 5. Synchronization POSIX Threads Programming 1. What is a Thread? 2. What are Pthreads 3. The Pthread API 4. Creating and Terminating Threads 5. Joing and Detaching Threads 6. Mutex Variables 7. Condition Variables References What is Parallel Computing ? 1. Serial Computing Traditionally, software has been written for serial computing: A problem is broken into a discrete series of instructions Instructions are executed sequentially one after another Executed on a single processor Only one instruction may execute at any moment in time 2. Parallel Computing In the simplest sense, parallel computing is the simultaneous use of multiple compute resources to solve a computational problem: A problem is broken into discrete parts that can be solved concurrently Each part is further broken down to a series of instructions Instructions from each part execute simultaneously on different processors An overall control/coordination mechanism is employed The computional problem should be able to: Be broken apart into discrete pieces of work that can be solved simultaneously Execute multiple program instructions at any moment in time Be solved in less time with multiple compute resources than with a single compute resource The compute resources are typically: A single computer with multiple processors/cores An arbitrary number of such computers connected by a network 3. Parallel Computers Virtually all stand-alone computers today are parallel from a hardware perspective: Multiple functional units (L1 cache, L2 cache, branch, prefetch, decode, floating-point, graphics processing (GPU), integer, etc.) Multiple execution units/cores Multiple hardware threads Networks connect multiple stand-alone computers (nodes) to make larger parallel computer clusters. For example, the schematic below shows a typical LLNL parallel computer cluster: Each compute node is a multi-processor parallel computer in itself Multiple compute nodes are networked together with an Infiniband network Special purpos node, also multi-processors, are used for other purposes 4. von Neumann Architecture Named after the Hungarian mathematician/genius John von Neumann who first authored the general requirements for an electronic computer in his 1945 papers. Also know as “stored-program computer” - both program instructions and data are kept in electronic memory. Differs from earlier computers which were programmed through “hard writing”. Since then, virtually all computers have followed the basic design: Comprised of four main components: Memory Control Unit Arithmetic Logic Unit Input/Output Read/write, random access memory is used to store both program instructions and data. Program instructions are coded data which tell the computer to do something Data is simply informaiton to be used by the program Control unit fetches instructions/data from memory, decodes the instructions and then sequentially coordinates operations to accomplish the programmed task. Arithmetic Unit performs basic arithmetic operations. Input/Output is the interface to the human operator So what? Who cares? Well, parallel computers still follow this basic design, just multiplied in units. the basic, fundamental architecture remains the same. 5. Synchronization Managing the sequence of work and the tasks performing it is a critical design consideration for most parallel programs. Can be a significant factor in program performance (or lack of it) Often requires “serialization” of segments of the program. Types of Synchronization Barrier Usually implies that all taks are involved Each task performs its work until it reaches the barriers. It then stops, or “blocks”. When the last task reaches the barrier, all tasks are synchronized. What happens from here varies. Often, a serial section of work must be done. In other cases, the tasks are automatically released to continue their work. Lock / semaphore Can involve any number of tasks Typically used to serialize (protect) access to global data or a section of code. Only one task at a time may use (own) the lock / semaphore / flag. The first task to acquire the lock “sets” it. This task can then safely (serially) access the protected data or code. Other tasks can attempt to acquire the lock but must wait until the task that owns the lock releases it. Can be blocking or non-blocking Synchronous communication operations Involves only those tasks executing a communication operation When a task performs a communication operation, some form of coordination is required with the other task(s) participating in the communication. For example, before a task can perform a send operation, it must first receive an acknowledgment from the receiving task that it is OK to send. POSIX Threads Programming 1. What is a Thread? Technically, a thread is defined as an independent stream ofinstructions that can be scheduled to run as such by the operating system. To the software developer, the concept of a “procedure” that runs independently from its main program may best desribe a thread. To go one step further, imagine a main program (a.out) that contains a number of procedures. Then imagine all of these procedures being able to be scheduled to run simultaneously and/or independently by the operating system. That would describe a “multi-threaded” program. Before understanding a thread, one first needs to understand a UNIX process. A process is created by the operating system, and requires a fair amout of “overhead”. Processes contain information about program resources and program execution state, including: Process ID, process group ID, and group ID Environment Working directory Program instructions Registers Stack Heap File descriptors Signal actions Shared libraries Inter-process communication tools (such as message queues, pipes, semaphores, or shared memeory). Threads use and exist within these process reources, yet are able to be scheduled by the operating system and run as independent entities largely because they duplicate only the bare essential resources that enable them to exist as executable code. This independent flow of control is accomplished because a thread maintains its own: Stack Pointer Registers Scheduling properties (such as policy or priority) Set of pending and blocked signals Thread specific data So, in summary, in the UNIX environment a thread: Exists within a process and uses the process resources Has its own independent flow of control as long as its parent process exists and the OS supports it Duplicates only the essential resources it needs to be independently schedulable May share the process resources with other threads that act equally independently (and dependently) Dies if the parent process dies - or something similar Is “lightweight” because most of the overhead has already been accomplished through the creation of it process Because threads within the same process share resources: Changes made by one thread to shared system resources (such as closing a file) will be seen by all other threads Two pointers having the same value point to the same data Reading and writing to the same memory location is possible, and therefore requires explicit synchronization by the programmer 2. What are Pthreads Pthreads are defined as a set of C language programming types and procedure calls, implemented with a pthread.h header/include file and a thread library - through this library may be part of another library, such as libc, in some implementations. 3. The Pthread API The original Pthreads API was defined in the ANSI/IEEE POSIX 1003.1 - 1995 standard. The POSIX standard has continued to evolve and undergo revisions, including the Pthreads specification. The subroutines which comprise the Pthreads API can be informally grouped into four major gorups: Thread management: Routines that work directory on threads - creating, detaching, joining, etc. They also include functions to set/query thread attributes (joinable, sheduling etc.) Mutexes: Routines that deal with synchronization, called a “mutext”, which is an abbreviation for “mutual exclusion”. Mutex functions provide for creating, destroying, locking and unlocking mutexes. These are supplemented by mutex attribute functions that set or modify attributes associated with mutexes. Condition variables: Routines that address communications between threads that share a mutex. Based upon programmer specified conditions. This group includes functions to create, destory, wait and signal based upon specified variable values. Functions to set/query condition variable attributes are also included. Synchronization: Routines that manage read/write locks and barries. All identifiers in the threads library begin with pthread_. Routine Prefix Functional Group pthread_ Threads themselves and miscellaneous subroutines pthread_attr_ Thread attributes objects pthread_mutext_ Mutexes pthread_mutexattr_ Mutex attributes objects pthread_cond_ Condition variables pthread_condattr_ Condition attributes objects pthread_key_ Thread-specific data keys pthread_rwlock_ Read/write locks pthread_barrier_ Synchronization barriers 4. Creating and Terminating Threads Routines pthread_create (thread, attr, start_routine, arg) pthread_exit (status) pthread_cancel (thread) pthread_attr_init (attr) pthread_attr_destroy(attr); Creating Threads Initially, your main() program comprises a single, default thread. All other threads must be explicitly created by the programmer. pthread_create creates a new thread and makes it executalbe. This routine can be called any number of times anywhere within your code. The pthread_create() routine permits the programmer to pass one argument to the thread start routine. For cases where multiple arguments must be passed, this limitation is easily overcome by creating a structure which contains all of the arguments, and then passing a pointer to that structure in the pthread_create() routine. All arguments must be passed by reference and cast to (void *). Once created, threads are peers, and may create other threads. There is no implied hierarchy or dependency between threads. Terminating Threads &amp; pthread_exit There are several ways in which a thread may be terminated: The thread returns normally from its starting routine. Its work is done. The thread makes a call to the pthread_exit subroutine - whether its works is done or not. The thread is canceled by another thread via the pthread_cancel routine The entire process is terminated due to makeing a call to either the exec() or exit() If main() finishes first, without calling pthread_exit explicitly itself. Cleanup: the pthread_exit() routine does not close files; any files opened inside the thread will remain open after the thread is terminated. Discussion on calling pthread_exit() from main() There is definite problem if main() finishes before the threads it spawned if you don’t call pthread_exit explicitly. All of the threads it created will terminate because main() is done and no longer exists to support the threads. By having main() explicitly call pthread_exit() as the last thing it does, main() will block and be kept alive to support the threads it created until they are done. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 2 static void *func(void *ch); int main(void) { char ch[NUM_THREADS] = { &#39;*&#39;, &#39;-&#39; }; pthread_t tids[NUM_THREADS]; int i; int rc; for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_create(&amp;tids[i], NULL, func, (void *)&amp;ch[i]); if(rc) { printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc); exit(EXIT_FAILURE); } } pthread_exit(NULL); exit(EXIT_SUCCESS); } static void *func(void *ch) { while(1) { usleep(100); printf(&quot;%c&quot;, *(char *)ch); fflush(stdout); } } 5. Joing and Detaching Threads Routines pthread_join (threadid, status) pthread_detach (threadid) pthread_attr_setdetachstate (attr, detachstate) pthread_attr_getdetachstate (attr, detachstate) Joining “Joining” is one way to accomplish synchronization between threads. The pthread_join() subroutine blocks the calling thread until the specified threadid thread terminates. The programmer is able to obtain the target thread’s termination return status if it was specified in the target thread’s call to pthread_exit(). A joining thread can match one pthread_join() call. It is a logical error to attempt multiple joins on the same thread. Joinable or Not? When a thread is created, one of its attributes defines whether it is joinable or detached. Only threads that are created as joinable can be joined. If a thread is created as detached, it can never be joined. The final draft of the POSIX standard specifies that threads should be created as joinable. To explicitly create a thread as joinable or detached, the attr argument in the pthread_create() routine is used. The typical 4 steps process is : Decalare a pthread attribute variable of the pthread_attr_t data type. Initialize the attribute variable with pthread_attr_init() Set the attribute detached status with pthread_attr_setdetachstate() When done, free library resources used by the attribute with pthread_attr_destory() Detaching The pthread_detach() routine can be used to explicitly detach even though it was created as joinable. There is no converse routine. Recommendations If a thread requires joining, consider explicitly creating it as joinable. This provides portablility as not all implementations may create threads as joinable by default. If you know in advance that a thread will never need to join with another thread, consider creating it in a detached state. Some system resources may be able to be freed. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 2 static void *func(void *ch); int main(void) { char ch[NUM_THREADS] = { &#39;*&#39;, &#39;-&#39; }; pthread_t tids[NUM_THREADS]; pthread_attr_t attr; int i; int rc; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_create(&amp;tids[i], &amp;attr, func, (void *)&amp;ch[i]); if(rc) { printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc); exit(EXIT_FAILURE); } } pthread_attr_destroy(&amp;attr); for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_join(tids[i], NULL); if(rc) { printf(&quot;ERROR; return code from pthread_join() is %d\n&quot;, rc); exit(EXIT_FAILURE); } } // pthread_exit(NULL); exit(EXIT_SUCCESS); } static void *func(void *ch) { while(1) { usleep(100); printf(&quot;%c&quot;, *(char *)ch); fflush(stdout); } } 6. Mutex Variables Mutex is an abbreviation for “mutual exclusion”. Mutex variables are one of the primary means of implementing thread synchronization and for protecting shared data when multiple writes occur. A mutex variable act like a “lock” protecting access to a shared data resource. The basic concept of a mutex as used in Phtreads that only one thread can lock (or own) a mutex variable at any given time. Thus, even if several threads try to lock a mutex only one thread will be successful. On other thread can own that mutex until the owning thread unclocks that mutex. Threads must “take turns” accessing protected data. Mutexs can be used to prevent “race” conditions. A program that depends on threads working in a certain sequence to complete normally. Race Conditions happen when mutexes are used improperly, or not at all. Very often the action performed by a thread owning a mutex is the updating of global variables. This is a safe way to ensuere that when several threads update the same variable, the final value is the same as what it would be if only one thread performed the update. The vairables being updated belong to a “critical section”. A typical sequence in the use of a mutex is as follows: Create and initialize a mutex variable Several threads attempt to lock the mutex Only one succeeds and that thread owns the mutex The owner unlocks the mutex Another thread acquires the mutex and repeats the process Finally the mutex is destroyed When several threads compete for a mutex, the loser block aht the call - an unblocking call is available with “trylock” instead of the “lock” call. When more than one thread is waiting for a locked mutex, unless thread priority scheduling is used, which thread will be granted the lock will be left to the native system scheduler and may appear to be more or less random. Routines pthread_mutex_init (mutex,attr) pthread_mutex_destroy (mutex) pthread_mutexattr_init (attr) pthread_mutexattr_destroy (attr) pthread_mutex_lock (mutex) pthread_mutex_trylock (mutex) pthread_mutex_unlock (mutex) Mutex variables must be decalre with type pthread_mutex_t, and must be initialized before they can be used. Statically, when it is declared. pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; Dynamically, with the pthread_mutex_init() routine. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 1000 static void *add(void *num); pthread_mutex_t mutex; int main(int argc, char *argv[]) { pthread_t tids[NUM_THREADS]; int t; int num = 0; pthread_mutex_init(&amp;mutex, NULL); pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(t = 0; t &lt; NUM_THREADS; t++) { pthread_create(&amp;tids[t], &amp;attr, add, &amp;num); } for(t = 0; t &lt; NUM_THREADS; t++) { pthread_join(tids[t], NULL); } pthread_attr_destroy(&amp;attr); pthread_mutex_destroy(&amp;mutex); printf(&quot;\n&quot;); exit(EXIT_SUCCESS); } static void *add(void *num) { int n; pthread_mutex_lock(&amp;mutex); n = *(int *)num; usleep(100); *(int *)num = n + 1; printf(&quot;%d &quot;, *(int *)num); pthread_mutex_unlock(&amp;mutex); pthread_exit(NULL); } 7. Condition Variables Condition variables provide yet another way for threads to synchronize. While mutexes implement synchronization by controlling thread access data, condition variables allow threads to synchronize based upon the actual value of data. Without condition variables, the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met. This can be very resource consuming since the thread would be continuously busy in this activity. A condition variable is a way to achieve the same goal without polling. A condition variable is always used in conjunction with a mutex lock. A representative sequence for using condition variable is shown below. Main Thread Declare and initialize global data/variables which require synchronization (such as &quot;count&quot;) Declare and initialize a condition variable object Declare and initialize an associated mutex Create threads A and B to do work Thread A Do work up to the point where a certain condition must occur (such as &quot;count&quot; must reach a specified value) Lock associated mutex and check value of a global variable Call pthread_cond_wait() to perform a blocking wait for signal from Thread-B. Note that a call to pthread_cond_wait() automatically and atomically unlocks the associated mutex variable so that it can be used by Thread-B. When signalled, wake up. Mutex is automatically and atomically locked. Explicitly unlock mutex Continue Thread B Do work Lock associated mutex Change the value of the global variable that Thread-A is waiting upon. Check value of the global Thread-A wait variable. If it fulfills the desired condition, signal Thread-A. Unlock mutex. Continue Main Thread Join / Continue Routines pthread_cond_init (condition,attr) pthread_cond_destroy (condition) pthread_condattr_init (attr) pthread_condattr_destroy (attr) pthread_cond_wait (condition,mutex) pthread_cond_signal (condition) pthread_cond_broadcast (condition) Condition variables must be decalred with type pthread_cond_t, and must be intialized before they can be used. There are two ways to initialize a condition variable: Statically, when it is declared. pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER; Dynamically, with the pthread_cond_init() routine. The ID of the created condition variable is returned to the calling thread through the condition parameter. This method permits setting condition variable object attributes, attr. pthread_cond_wait() blocks the calling thread until the specified condition is signalled. This routine should be called while mutex is locked, and it will automatically release the mutex while it waits. After signal is received and thread is awakened, mutex will be automatically locked for use by the thread. The programmer is the responsible for unlocking mutex when the thread is finished it. Recommendation: Using a WHILE loop instead of an IF statement to check the waited for condition can help deal with several potential problems, such as: If several threads are wating for the same wake up signal, they will take turns acquiring the mutex, and any one of them can then modify the condition they all waited for. If the thread received the signal in error due to a program bug. The Pthreads library is permitted to issue spurious wake ups to a waiting thread without violating the standard. The pthread_cond_signal() routine is used to signal (or wake up) another thread which is waiting on the condition variable. It should be called after mutex is locked, and must unlock mutex in order for *pthread_cond_wait()** routine to complete. The pthread_cond_broadcast() routine should be used instead of phtread_cond_signal if more than one thread is in a blocking wait state. It is a logical error to call pthread_cond_wait() before calling pthread_cond_wait(). Proper locking and unlocking of the associate mutex variable is essential when using these routines. For example: Failing to lock the mutex before calling pthread_cond_wait() may cause it NOT to block. Failing to unclok the mutex after calling phtread_cond_signal() may not allow a matching pthread_cond_wait() routine to complete (it will remain blocked). #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define INCR_TIMES 10 #define LIMIT 8 typedef struct { pthread_mutex_t mut; pthread_cond_t cv; int count; } data; static void *incr(void *d); static void *watch(void *d); int main(int argc, char *argv[]) { pthread_t in; pthread_t wt; pthread_attr_t attr; data d; d.count = 0; pthread_mutex_init(&amp;d.mut, NULL); pthread_cond_init(&amp;d.cv, NULL); pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); pthread_create(&amp;in, &amp; attr, incr, &amp;d); pthread_create(&amp;wt, &amp; attr, watch, &amp;d); pthread_join(in, NULL); pthread_join(wt, NULL); pthread_attr_destroy(&amp;attr); exit(EXIT_SUCCESS); } static void *incr(void *d) { data *p = (data *)d; int i; for(i = 0; i &lt; INCR_TIMES; i++) { usleep(500000); pthread_mutex_lock(&amp;p-&gt;mut); p-&gt;count = p-&gt;count + 1; if(p-&gt;count == LIMIT) { pthread_cond_signal(&amp;p-&gt;cv); printf(&quot;INCR.SIGNAL: %d\n&quot;, p-&gt;count); } else { printf(&quot;INCR: %d\n&quot;, p-&gt;count); } pthread_mutex_unlock(&amp;p-&gt;mut); } pthread_exit(NULL); } static void *watch(void *d) { data *p = (data *)d; pthread_mutex_lock(&amp;p-&gt;mut); while(p-&gt;count &lt; LIMIT) { pthread_cond_wait(&amp;p-&gt;cv, &amp;p-&gt;mut); printf(&quot;WATCH: %d\n&quot;, p-&gt;count); } pthread_mutex_unlock(&amp;p-&gt;mut); pthread_exit(NULL); } References Introduction to Parallel Computing POSIX Threads Programming Multithreading in C, POSIX style" />
<meta property="og:description" content="What is Parallel Computing ? 1. Serial Computing 2. Parallel Computing 3. Parallel Computers 4. von Neumann Architecture 5. Synchronization POSIX Threads Programming 1. What is a Thread? 2. What are Pthreads 3. The Pthread API 4. Creating and Terminating Threads 5. Joing and Detaching Threads 6. Mutex Variables 7. Condition Variables References What is Parallel Computing ? 1. Serial Computing Traditionally, software has been written for serial computing: A problem is broken into a discrete series of instructions Instructions are executed sequentially one after another Executed on a single processor Only one instruction may execute at any moment in time 2. Parallel Computing In the simplest sense, parallel computing is the simultaneous use of multiple compute resources to solve a computational problem: A problem is broken into discrete parts that can be solved concurrently Each part is further broken down to a series of instructions Instructions from each part execute simultaneously on different processors An overall control/coordination mechanism is employed The computional problem should be able to: Be broken apart into discrete pieces of work that can be solved simultaneously Execute multiple program instructions at any moment in time Be solved in less time with multiple compute resources than with a single compute resource The compute resources are typically: A single computer with multiple processors/cores An arbitrary number of such computers connected by a network 3. Parallel Computers Virtually all stand-alone computers today are parallel from a hardware perspective: Multiple functional units (L1 cache, L2 cache, branch, prefetch, decode, floating-point, graphics processing (GPU), integer, etc.) Multiple execution units/cores Multiple hardware threads Networks connect multiple stand-alone computers (nodes) to make larger parallel computer clusters. For example, the schematic below shows a typical LLNL parallel computer cluster: Each compute node is a multi-processor parallel computer in itself Multiple compute nodes are networked together with an Infiniband network Special purpos node, also multi-processors, are used for other purposes 4. von Neumann Architecture Named after the Hungarian mathematician/genius John von Neumann who first authored the general requirements for an electronic computer in his 1945 papers. Also know as “stored-program computer” - both program instructions and data are kept in electronic memory. Differs from earlier computers which were programmed through “hard writing”. Since then, virtually all computers have followed the basic design: Comprised of four main components: Memory Control Unit Arithmetic Logic Unit Input/Output Read/write, random access memory is used to store both program instructions and data. Program instructions are coded data which tell the computer to do something Data is simply informaiton to be used by the program Control unit fetches instructions/data from memory, decodes the instructions and then sequentially coordinates operations to accomplish the programmed task. Arithmetic Unit performs basic arithmetic operations. Input/Output is the interface to the human operator So what? Who cares? Well, parallel computers still follow this basic design, just multiplied in units. the basic, fundamental architecture remains the same. 5. Synchronization Managing the sequence of work and the tasks performing it is a critical design consideration for most parallel programs. Can be a significant factor in program performance (or lack of it) Often requires “serialization” of segments of the program. Types of Synchronization Barrier Usually implies that all taks are involved Each task performs its work until it reaches the barriers. It then stops, or “blocks”. When the last task reaches the barrier, all tasks are synchronized. What happens from here varies. Often, a serial section of work must be done. In other cases, the tasks are automatically released to continue their work. Lock / semaphore Can involve any number of tasks Typically used to serialize (protect) access to global data or a section of code. Only one task at a time may use (own) the lock / semaphore / flag. The first task to acquire the lock “sets” it. This task can then safely (serially) access the protected data or code. Other tasks can attempt to acquire the lock but must wait until the task that owns the lock releases it. Can be blocking or non-blocking Synchronous communication operations Involves only those tasks executing a communication operation When a task performs a communication operation, some form of coordination is required with the other task(s) participating in the communication. For example, before a task can perform a send operation, it must first receive an acknowledgment from the receiving task that it is OK to send. POSIX Threads Programming 1. What is a Thread? Technically, a thread is defined as an independent stream ofinstructions that can be scheduled to run as such by the operating system. To the software developer, the concept of a “procedure” that runs independently from its main program may best desribe a thread. To go one step further, imagine a main program (a.out) that contains a number of procedures. Then imagine all of these procedures being able to be scheduled to run simultaneously and/or independently by the operating system. That would describe a “multi-threaded” program. Before understanding a thread, one first needs to understand a UNIX process. A process is created by the operating system, and requires a fair amout of “overhead”. Processes contain information about program resources and program execution state, including: Process ID, process group ID, and group ID Environment Working directory Program instructions Registers Stack Heap File descriptors Signal actions Shared libraries Inter-process communication tools (such as message queues, pipes, semaphores, or shared memeory). Threads use and exist within these process reources, yet are able to be scheduled by the operating system and run as independent entities largely because they duplicate only the bare essential resources that enable them to exist as executable code. This independent flow of control is accomplished because a thread maintains its own: Stack Pointer Registers Scheduling properties (such as policy or priority) Set of pending and blocked signals Thread specific data So, in summary, in the UNIX environment a thread: Exists within a process and uses the process resources Has its own independent flow of control as long as its parent process exists and the OS supports it Duplicates only the essential resources it needs to be independently schedulable May share the process resources with other threads that act equally independently (and dependently) Dies if the parent process dies - or something similar Is “lightweight” because most of the overhead has already been accomplished through the creation of it process Because threads within the same process share resources: Changes made by one thread to shared system resources (such as closing a file) will be seen by all other threads Two pointers having the same value point to the same data Reading and writing to the same memory location is possible, and therefore requires explicit synchronization by the programmer 2. What are Pthreads Pthreads are defined as a set of C language programming types and procedure calls, implemented with a pthread.h header/include file and a thread library - through this library may be part of another library, such as libc, in some implementations. 3. The Pthread API The original Pthreads API was defined in the ANSI/IEEE POSIX 1003.1 - 1995 standard. The POSIX standard has continued to evolve and undergo revisions, including the Pthreads specification. The subroutines which comprise the Pthreads API can be informally grouped into four major gorups: Thread management: Routines that work directory on threads - creating, detaching, joining, etc. They also include functions to set/query thread attributes (joinable, sheduling etc.) Mutexes: Routines that deal with synchronization, called a “mutext”, which is an abbreviation for “mutual exclusion”. Mutex functions provide for creating, destroying, locking and unlocking mutexes. These are supplemented by mutex attribute functions that set or modify attributes associated with mutexes. Condition variables: Routines that address communications between threads that share a mutex. Based upon programmer specified conditions. This group includes functions to create, destory, wait and signal based upon specified variable values. Functions to set/query condition variable attributes are also included. Synchronization: Routines that manage read/write locks and barries. All identifiers in the threads library begin with pthread_. Routine Prefix Functional Group pthread_ Threads themselves and miscellaneous subroutines pthread_attr_ Thread attributes objects pthread_mutext_ Mutexes pthread_mutexattr_ Mutex attributes objects pthread_cond_ Condition variables pthread_condattr_ Condition attributes objects pthread_key_ Thread-specific data keys pthread_rwlock_ Read/write locks pthread_barrier_ Synchronization barriers 4. Creating and Terminating Threads Routines pthread_create (thread, attr, start_routine, arg) pthread_exit (status) pthread_cancel (thread) pthread_attr_init (attr) pthread_attr_destroy(attr); Creating Threads Initially, your main() program comprises a single, default thread. All other threads must be explicitly created by the programmer. pthread_create creates a new thread and makes it executalbe. This routine can be called any number of times anywhere within your code. The pthread_create() routine permits the programmer to pass one argument to the thread start routine. For cases where multiple arguments must be passed, this limitation is easily overcome by creating a structure which contains all of the arguments, and then passing a pointer to that structure in the pthread_create() routine. All arguments must be passed by reference and cast to (void *). Once created, threads are peers, and may create other threads. There is no implied hierarchy or dependency between threads. Terminating Threads &amp; pthread_exit There are several ways in which a thread may be terminated: The thread returns normally from its starting routine. Its work is done. The thread makes a call to the pthread_exit subroutine - whether its works is done or not. The thread is canceled by another thread via the pthread_cancel routine The entire process is terminated due to makeing a call to either the exec() or exit() If main() finishes first, without calling pthread_exit explicitly itself. Cleanup: the pthread_exit() routine does not close files; any files opened inside the thread will remain open after the thread is terminated. Discussion on calling pthread_exit() from main() There is definite problem if main() finishes before the threads it spawned if you don’t call pthread_exit explicitly. All of the threads it created will terminate because main() is done and no longer exists to support the threads. By having main() explicitly call pthread_exit() as the last thing it does, main() will block and be kept alive to support the threads it created until they are done. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 2 static void *func(void *ch); int main(void) { char ch[NUM_THREADS] = { &#39;*&#39;, &#39;-&#39; }; pthread_t tids[NUM_THREADS]; int i; int rc; for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_create(&amp;tids[i], NULL, func, (void *)&amp;ch[i]); if(rc) { printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc); exit(EXIT_FAILURE); } } pthread_exit(NULL); exit(EXIT_SUCCESS); } static void *func(void *ch) { while(1) { usleep(100); printf(&quot;%c&quot;, *(char *)ch); fflush(stdout); } } 5. Joing and Detaching Threads Routines pthread_join (threadid, status) pthread_detach (threadid) pthread_attr_setdetachstate (attr, detachstate) pthread_attr_getdetachstate (attr, detachstate) Joining “Joining” is one way to accomplish synchronization between threads. The pthread_join() subroutine blocks the calling thread until the specified threadid thread terminates. The programmer is able to obtain the target thread’s termination return status if it was specified in the target thread’s call to pthread_exit(). A joining thread can match one pthread_join() call. It is a logical error to attempt multiple joins on the same thread. Joinable or Not? When a thread is created, one of its attributes defines whether it is joinable or detached. Only threads that are created as joinable can be joined. If a thread is created as detached, it can never be joined. The final draft of the POSIX standard specifies that threads should be created as joinable. To explicitly create a thread as joinable or detached, the attr argument in the pthread_create() routine is used. The typical 4 steps process is : Decalare a pthread attribute variable of the pthread_attr_t data type. Initialize the attribute variable with pthread_attr_init() Set the attribute detached status with pthread_attr_setdetachstate() When done, free library resources used by the attribute with pthread_attr_destory() Detaching The pthread_detach() routine can be used to explicitly detach even though it was created as joinable. There is no converse routine. Recommendations If a thread requires joining, consider explicitly creating it as joinable. This provides portablility as not all implementations may create threads as joinable by default. If you know in advance that a thread will never need to join with another thread, consider creating it in a detached state. Some system resources may be able to be freed. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 2 static void *func(void *ch); int main(void) { char ch[NUM_THREADS] = { &#39;*&#39;, &#39;-&#39; }; pthread_t tids[NUM_THREADS]; pthread_attr_t attr; int i; int rc; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_create(&amp;tids[i], &amp;attr, func, (void *)&amp;ch[i]); if(rc) { printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc); exit(EXIT_FAILURE); } } pthread_attr_destroy(&amp;attr); for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_join(tids[i], NULL); if(rc) { printf(&quot;ERROR; return code from pthread_join() is %d\n&quot;, rc); exit(EXIT_FAILURE); } } // pthread_exit(NULL); exit(EXIT_SUCCESS); } static void *func(void *ch) { while(1) { usleep(100); printf(&quot;%c&quot;, *(char *)ch); fflush(stdout); } } 6. Mutex Variables Mutex is an abbreviation for “mutual exclusion”. Mutex variables are one of the primary means of implementing thread synchronization and for protecting shared data when multiple writes occur. A mutex variable act like a “lock” protecting access to a shared data resource. The basic concept of a mutex as used in Phtreads that only one thread can lock (or own) a mutex variable at any given time. Thus, even if several threads try to lock a mutex only one thread will be successful. On other thread can own that mutex until the owning thread unclocks that mutex. Threads must “take turns” accessing protected data. Mutexs can be used to prevent “race” conditions. A program that depends on threads working in a certain sequence to complete normally. Race Conditions happen when mutexes are used improperly, or not at all. Very often the action performed by a thread owning a mutex is the updating of global variables. This is a safe way to ensuere that when several threads update the same variable, the final value is the same as what it would be if only one thread performed the update. The vairables being updated belong to a “critical section”. A typical sequence in the use of a mutex is as follows: Create and initialize a mutex variable Several threads attempt to lock the mutex Only one succeeds and that thread owns the mutex The owner unlocks the mutex Another thread acquires the mutex and repeats the process Finally the mutex is destroyed When several threads compete for a mutex, the loser block aht the call - an unblocking call is available with “trylock” instead of the “lock” call. When more than one thread is waiting for a locked mutex, unless thread priority scheduling is used, which thread will be granted the lock will be left to the native system scheduler and may appear to be more or less random. Routines pthread_mutex_init (mutex,attr) pthread_mutex_destroy (mutex) pthread_mutexattr_init (attr) pthread_mutexattr_destroy (attr) pthread_mutex_lock (mutex) pthread_mutex_trylock (mutex) pthread_mutex_unlock (mutex) Mutex variables must be decalre with type pthread_mutex_t, and must be initialized before they can be used. Statically, when it is declared. pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; Dynamically, with the pthread_mutex_init() routine. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 1000 static void *add(void *num); pthread_mutex_t mutex; int main(int argc, char *argv[]) { pthread_t tids[NUM_THREADS]; int t; int num = 0; pthread_mutex_init(&amp;mutex, NULL); pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(t = 0; t &lt; NUM_THREADS; t++) { pthread_create(&amp;tids[t], &amp;attr, add, &amp;num); } for(t = 0; t &lt; NUM_THREADS; t++) { pthread_join(tids[t], NULL); } pthread_attr_destroy(&amp;attr); pthread_mutex_destroy(&amp;mutex); printf(&quot;\n&quot;); exit(EXIT_SUCCESS); } static void *add(void *num) { int n; pthread_mutex_lock(&amp;mutex); n = *(int *)num; usleep(100); *(int *)num = n + 1; printf(&quot;%d &quot;, *(int *)num); pthread_mutex_unlock(&amp;mutex); pthread_exit(NULL); } 7. Condition Variables Condition variables provide yet another way for threads to synchronize. While mutexes implement synchronization by controlling thread access data, condition variables allow threads to synchronize based upon the actual value of data. Without condition variables, the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met. This can be very resource consuming since the thread would be continuously busy in this activity. A condition variable is a way to achieve the same goal without polling. A condition variable is always used in conjunction with a mutex lock. A representative sequence for using condition variable is shown below. Main Thread Declare and initialize global data/variables which require synchronization (such as &quot;count&quot;) Declare and initialize a condition variable object Declare and initialize an associated mutex Create threads A and B to do work Thread A Do work up to the point where a certain condition must occur (such as &quot;count&quot; must reach a specified value) Lock associated mutex and check value of a global variable Call pthread_cond_wait() to perform a blocking wait for signal from Thread-B. Note that a call to pthread_cond_wait() automatically and atomically unlocks the associated mutex variable so that it can be used by Thread-B. When signalled, wake up. Mutex is automatically and atomically locked. Explicitly unlock mutex Continue Thread B Do work Lock associated mutex Change the value of the global variable that Thread-A is waiting upon. Check value of the global Thread-A wait variable. If it fulfills the desired condition, signal Thread-A. Unlock mutex. Continue Main Thread Join / Continue Routines pthread_cond_init (condition,attr) pthread_cond_destroy (condition) pthread_condattr_init (attr) pthread_condattr_destroy (attr) pthread_cond_wait (condition,mutex) pthread_cond_signal (condition) pthread_cond_broadcast (condition) Condition variables must be decalred with type pthread_cond_t, and must be intialized before they can be used. There are two ways to initialize a condition variable: Statically, when it is declared. pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER; Dynamically, with the pthread_cond_init() routine. The ID of the created condition variable is returned to the calling thread through the condition parameter. This method permits setting condition variable object attributes, attr. pthread_cond_wait() blocks the calling thread until the specified condition is signalled. This routine should be called while mutex is locked, and it will automatically release the mutex while it waits. After signal is received and thread is awakened, mutex will be automatically locked for use by the thread. The programmer is the responsible for unlocking mutex when the thread is finished it. Recommendation: Using a WHILE loop instead of an IF statement to check the waited for condition can help deal with several potential problems, such as: If several threads are wating for the same wake up signal, they will take turns acquiring the mutex, and any one of them can then modify the condition they all waited for. If the thread received the signal in error due to a program bug. The Pthreads library is permitted to issue spurious wake ups to a waiting thread without violating the standard. The pthread_cond_signal() routine is used to signal (or wake up) another thread which is waiting on the condition variable. It should be called after mutex is locked, and must unlock mutex in order for *pthread_cond_wait()** routine to complete. The pthread_cond_broadcast() routine should be used instead of phtread_cond_signal if more than one thread is in a blocking wait state. It is a logical error to call pthread_cond_wait() before calling pthread_cond_wait(). Proper locking and unlocking of the associate mutex variable is essential when using these routines. For example: Failing to lock the mutex before calling pthread_cond_wait() may cause it NOT to block. Failing to unclok the mutex after calling phtread_cond_signal() may not allow a matching pthread_cond_wait() routine to complete (it will remain blocked). #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define INCR_TIMES 10 #define LIMIT 8 typedef struct { pthread_mutex_t mut; pthread_cond_t cv; int count; } data; static void *incr(void *d); static void *watch(void *d); int main(int argc, char *argv[]) { pthread_t in; pthread_t wt; pthread_attr_t attr; data d; d.count = 0; pthread_mutex_init(&amp;d.mut, NULL); pthread_cond_init(&amp;d.cv, NULL); pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); pthread_create(&amp;in, &amp; attr, incr, &amp;d); pthread_create(&amp;wt, &amp; attr, watch, &amp;d); pthread_join(in, NULL); pthread_join(wt, NULL); pthread_attr_destroy(&amp;attr); exit(EXIT_SUCCESS); } static void *incr(void *d) { data *p = (data *)d; int i; for(i = 0; i &lt; INCR_TIMES; i++) { usleep(500000); pthread_mutex_lock(&amp;p-&gt;mut); p-&gt;count = p-&gt;count + 1; if(p-&gt;count == LIMIT) { pthread_cond_signal(&amp;p-&gt;cv); printf(&quot;INCR.SIGNAL: %d\n&quot;, p-&gt;count); } else { printf(&quot;INCR: %d\n&quot;, p-&gt;count); } pthread_mutex_unlock(&amp;p-&gt;mut); } pthread_exit(NULL); } static void *watch(void *d) { data *p = (data *)d; pthread_mutex_lock(&amp;p-&gt;mut); while(p-&gt;count &lt; LIMIT) { pthread_cond_wait(&amp;p-&gt;cv, &amp;p-&gt;mut); printf(&quot;WATCH: %d\n&quot;, p-&gt;count); } pthread_mutex_unlock(&amp;p-&gt;mut); pthread_exit(NULL); } References Introduction to Parallel Computing POSIX Threads Programming Multithreading in C, POSIX style" />
<link rel="canonical" href="https://blog.codefarm.me/2017/03/09/posix-threads-programming-in-c-language/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/03/09/posix-threads-programming-in-c-language/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-09T16:29:29+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="POSIX Threads Programming in C Language" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-03-09T16:29:29+08:00","datePublished":"2017-03-09T16:29:29+08:00","description":"What is Parallel Computing ? 1. Serial Computing 2. Parallel Computing 3. Parallel Computers 4. von Neumann Architecture 5. Synchronization POSIX Threads Programming 1. What is a Thread? 2. What are Pthreads 3. The Pthread API 4. Creating and Terminating Threads 5. Joing and Detaching Threads 6. Mutex Variables 7. Condition Variables References What is Parallel Computing ? 1. Serial Computing Traditionally, software has been written for serial computing: A problem is broken into a discrete series of instructions Instructions are executed sequentially one after another Executed on a single processor Only one instruction may execute at any moment in time 2. Parallel Computing In the simplest sense, parallel computing is the simultaneous use of multiple compute resources to solve a computational problem: A problem is broken into discrete parts that can be solved concurrently Each part is further broken down to a series of instructions Instructions from each part execute simultaneously on different processors An overall control/coordination mechanism is employed The computional problem should be able to: Be broken apart into discrete pieces of work that can be solved simultaneously Execute multiple program instructions at any moment in time Be solved in less time with multiple compute resources than with a single compute resource The compute resources are typically: A single computer with multiple processors/cores An arbitrary number of such computers connected by a network 3. Parallel Computers Virtually all stand-alone computers today are parallel from a hardware perspective: Multiple functional units (L1 cache, L2 cache, branch, prefetch, decode, floating-point, graphics processing (GPU), integer, etc.) Multiple execution units/cores Multiple hardware threads Networks connect multiple stand-alone computers (nodes) to make larger parallel computer clusters. For example, the schematic below shows a typical LLNL parallel computer cluster: Each compute node is a multi-processor parallel computer in itself Multiple compute nodes are networked together with an Infiniband network Special purpos node, also multi-processors, are used for other purposes 4. von Neumann Architecture Named after the Hungarian mathematician/genius John von Neumann who first authored the general requirements for an electronic computer in his 1945 papers. Also know as “stored-program computer” - both program instructions and data are kept in electronic memory. Differs from earlier computers which were programmed through “hard writing”. Since then, virtually all computers have followed the basic design: Comprised of four main components: Memory Control Unit Arithmetic Logic Unit Input/Output Read/write, random access memory is used to store both program instructions and data. Program instructions are coded data which tell the computer to do something Data is simply informaiton to be used by the program Control unit fetches instructions/data from memory, decodes the instructions and then sequentially coordinates operations to accomplish the programmed task. Arithmetic Unit performs basic arithmetic operations. Input/Output is the interface to the human operator So what? Who cares? Well, parallel computers still follow this basic design, just multiplied in units. the basic, fundamental architecture remains the same. 5. Synchronization Managing the sequence of work and the tasks performing it is a critical design consideration for most parallel programs. Can be a significant factor in program performance (or lack of it) Often requires “serialization” of segments of the program. Types of Synchronization Barrier Usually implies that all taks are involved Each task performs its work until it reaches the barriers. It then stops, or “blocks”. When the last task reaches the barrier, all tasks are synchronized. What happens from here varies. Often, a serial section of work must be done. In other cases, the tasks are automatically released to continue their work. Lock / semaphore Can involve any number of tasks Typically used to serialize (protect) access to global data or a section of code. Only one task at a time may use (own) the lock / semaphore / flag. The first task to acquire the lock “sets” it. This task can then safely (serially) access the protected data or code. Other tasks can attempt to acquire the lock but must wait until the task that owns the lock releases it. Can be blocking or non-blocking Synchronous communication operations Involves only those tasks executing a communication operation When a task performs a communication operation, some form of coordination is required with the other task(s) participating in the communication. For example, before a task can perform a send operation, it must first receive an acknowledgment from the receiving task that it is OK to send. POSIX Threads Programming 1. What is a Thread? Technically, a thread is defined as an independent stream ofinstructions that can be scheduled to run as such by the operating system. To the software developer, the concept of a “procedure” that runs independently from its main program may best desribe a thread. To go one step further, imagine a main program (a.out) that contains a number of procedures. Then imagine all of these procedures being able to be scheduled to run simultaneously and/or independently by the operating system. That would describe a “multi-threaded” program. Before understanding a thread, one first needs to understand a UNIX process. A process is created by the operating system, and requires a fair amout of “overhead”. Processes contain information about program resources and program execution state, including: Process ID, process group ID, and group ID Environment Working directory Program instructions Registers Stack Heap File descriptors Signal actions Shared libraries Inter-process communication tools (such as message queues, pipes, semaphores, or shared memeory). Threads use and exist within these process reources, yet are able to be scheduled by the operating system and run as independent entities largely because they duplicate only the bare essential resources that enable them to exist as executable code. This independent flow of control is accomplished because a thread maintains its own: Stack Pointer Registers Scheduling properties (such as policy or priority) Set of pending and blocked signals Thread specific data So, in summary, in the UNIX environment a thread: Exists within a process and uses the process resources Has its own independent flow of control as long as its parent process exists and the OS supports it Duplicates only the essential resources it needs to be independently schedulable May share the process resources with other threads that act equally independently (and dependently) Dies if the parent process dies - or something similar Is “lightweight” because most of the overhead has already been accomplished through the creation of it process Because threads within the same process share resources: Changes made by one thread to shared system resources (such as closing a file) will be seen by all other threads Two pointers having the same value point to the same data Reading and writing to the same memory location is possible, and therefore requires explicit synchronization by the programmer 2. What are Pthreads Pthreads are defined as a set of C language programming types and procedure calls, implemented with a pthread.h header/include file and a thread library - through this library may be part of another library, such as libc, in some implementations. 3. The Pthread API The original Pthreads API was defined in the ANSI/IEEE POSIX 1003.1 - 1995 standard. The POSIX standard has continued to evolve and undergo revisions, including the Pthreads specification. The subroutines which comprise the Pthreads API can be informally grouped into four major gorups: Thread management: Routines that work directory on threads - creating, detaching, joining, etc. They also include functions to set/query thread attributes (joinable, sheduling etc.) Mutexes: Routines that deal with synchronization, called a “mutext”, which is an abbreviation for “mutual exclusion”. Mutex functions provide for creating, destroying, locking and unlocking mutexes. These are supplemented by mutex attribute functions that set or modify attributes associated with mutexes. Condition variables: Routines that address communications between threads that share a mutex. Based upon programmer specified conditions. This group includes functions to create, destory, wait and signal based upon specified variable values. Functions to set/query condition variable attributes are also included. Synchronization: Routines that manage read/write locks and barries. All identifiers in the threads library begin with pthread_. Routine Prefix Functional Group pthread_ Threads themselves and miscellaneous subroutines pthread_attr_ Thread attributes objects pthread_mutext_ Mutexes pthread_mutexattr_ Mutex attributes objects pthread_cond_ Condition variables pthread_condattr_ Condition attributes objects pthread_key_ Thread-specific data keys pthread_rwlock_ Read/write locks pthread_barrier_ Synchronization barriers 4. Creating and Terminating Threads Routines pthread_create (thread, attr, start_routine, arg) pthread_exit (status) pthread_cancel (thread) pthread_attr_init (attr) pthread_attr_destroy(attr); Creating Threads Initially, your main() program comprises a single, default thread. All other threads must be explicitly created by the programmer. pthread_create creates a new thread and makes it executalbe. This routine can be called any number of times anywhere within your code. The pthread_create() routine permits the programmer to pass one argument to the thread start routine. For cases where multiple arguments must be passed, this limitation is easily overcome by creating a structure which contains all of the arguments, and then passing a pointer to that structure in the pthread_create() routine. All arguments must be passed by reference and cast to (void *). Once created, threads are peers, and may create other threads. There is no implied hierarchy or dependency between threads. Terminating Threads &amp; pthread_exit There are several ways in which a thread may be terminated: The thread returns normally from its starting routine. Its work is done. The thread makes a call to the pthread_exit subroutine - whether its works is done or not. The thread is canceled by another thread via the pthread_cancel routine The entire process is terminated due to makeing a call to either the exec() or exit() If main() finishes first, without calling pthread_exit explicitly itself. Cleanup: the pthread_exit() routine does not close files; any files opened inside the thread will remain open after the thread is terminated. Discussion on calling pthread_exit() from main() There is definite problem if main() finishes before the threads it spawned if you don’t call pthread_exit explicitly. All of the threads it created will terminate because main() is done and no longer exists to support the threads. By having main() explicitly call pthread_exit() as the last thing it does, main() will block and be kept alive to support the threads it created until they are done. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 2 static void *func(void *ch); int main(void) { char ch[NUM_THREADS] = { &#39;*&#39;, &#39;-&#39; }; pthread_t tids[NUM_THREADS]; int i; int rc; for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_create(&amp;tids[i], NULL, func, (void *)&amp;ch[i]); if(rc) { printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc); exit(EXIT_FAILURE); } } pthread_exit(NULL); exit(EXIT_SUCCESS); } static void *func(void *ch) { while(1) { usleep(100); printf(&quot;%c&quot;, *(char *)ch); fflush(stdout); } } 5. Joing and Detaching Threads Routines pthread_join (threadid, status) pthread_detach (threadid) pthread_attr_setdetachstate (attr, detachstate) pthread_attr_getdetachstate (attr, detachstate) Joining “Joining” is one way to accomplish synchronization between threads. The pthread_join() subroutine blocks the calling thread until the specified threadid thread terminates. The programmer is able to obtain the target thread’s termination return status if it was specified in the target thread’s call to pthread_exit(). A joining thread can match one pthread_join() call. It is a logical error to attempt multiple joins on the same thread. Joinable or Not? When a thread is created, one of its attributes defines whether it is joinable or detached. Only threads that are created as joinable can be joined. If a thread is created as detached, it can never be joined. The final draft of the POSIX standard specifies that threads should be created as joinable. To explicitly create a thread as joinable or detached, the attr argument in the pthread_create() routine is used. The typical 4 steps process is : Decalare a pthread attribute variable of the pthread_attr_t data type. Initialize the attribute variable with pthread_attr_init() Set the attribute detached status with pthread_attr_setdetachstate() When done, free library resources used by the attribute with pthread_attr_destory() Detaching The pthread_detach() routine can be used to explicitly detach even though it was created as joinable. There is no converse routine. Recommendations If a thread requires joining, consider explicitly creating it as joinable. This provides portablility as not all implementations may create threads as joinable by default. If you know in advance that a thread will never need to join with another thread, consider creating it in a detached state. Some system resources may be able to be freed. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 2 static void *func(void *ch); int main(void) { char ch[NUM_THREADS] = { &#39;*&#39;, &#39;-&#39; }; pthread_t tids[NUM_THREADS]; pthread_attr_t attr; int i; int rc; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_create(&amp;tids[i], &amp;attr, func, (void *)&amp;ch[i]); if(rc) { printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc); exit(EXIT_FAILURE); } } pthread_attr_destroy(&amp;attr); for(i = 0; i &lt; NUM_THREADS; ++i) { rc = pthread_join(tids[i], NULL); if(rc) { printf(&quot;ERROR; return code from pthread_join() is %d\\n&quot;, rc); exit(EXIT_FAILURE); } } // pthread_exit(NULL); exit(EXIT_SUCCESS); } static void *func(void *ch) { while(1) { usleep(100); printf(&quot;%c&quot;, *(char *)ch); fflush(stdout); } } 6. Mutex Variables Mutex is an abbreviation for “mutual exclusion”. Mutex variables are one of the primary means of implementing thread synchronization and for protecting shared data when multiple writes occur. A mutex variable act like a “lock” protecting access to a shared data resource. The basic concept of a mutex as used in Phtreads that only one thread can lock (or own) a mutex variable at any given time. Thus, even if several threads try to lock a mutex only one thread will be successful. On other thread can own that mutex until the owning thread unclocks that mutex. Threads must “take turns” accessing protected data. Mutexs can be used to prevent “race” conditions. A program that depends on threads working in a certain sequence to complete normally. Race Conditions happen when mutexes are used improperly, or not at all. Very often the action performed by a thread owning a mutex is the updating of global variables. This is a safe way to ensuere that when several threads update the same variable, the final value is the same as what it would be if only one thread performed the update. The vairables being updated belong to a “critical section”. A typical sequence in the use of a mutex is as follows: Create and initialize a mutex variable Several threads attempt to lock the mutex Only one succeeds and that thread owns the mutex The owner unlocks the mutex Another thread acquires the mutex and repeats the process Finally the mutex is destroyed When several threads compete for a mutex, the loser block aht the call - an unblocking call is available with “trylock” instead of the “lock” call. When more than one thread is waiting for a locked mutex, unless thread priority scheduling is used, which thread will be granted the lock will be left to the native system scheduler and may appear to be more or less random. Routines pthread_mutex_init (mutex,attr) pthread_mutex_destroy (mutex) pthread_mutexattr_init (attr) pthread_mutexattr_destroy (attr) pthread_mutex_lock (mutex) pthread_mutex_trylock (mutex) pthread_mutex_unlock (mutex) Mutex variables must be decalre with type pthread_mutex_t, and must be initialized before they can be used. Statically, when it is declared. pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; Dynamically, with the pthread_mutex_init() routine. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define NUM_THREADS 1000 static void *add(void *num); pthread_mutex_t mutex; int main(int argc, char *argv[]) { pthread_t tids[NUM_THREADS]; int t; int num = 0; pthread_mutex_init(&amp;mutex, NULL); pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for(t = 0; t &lt; NUM_THREADS; t++) { pthread_create(&amp;tids[t], &amp;attr, add, &amp;num); } for(t = 0; t &lt; NUM_THREADS; t++) { pthread_join(tids[t], NULL); } pthread_attr_destroy(&amp;attr); pthread_mutex_destroy(&amp;mutex); printf(&quot;\\n&quot;); exit(EXIT_SUCCESS); } static void *add(void *num) { int n; pthread_mutex_lock(&amp;mutex); n = *(int *)num; usleep(100); *(int *)num = n + 1; printf(&quot;%d &quot;, *(int *)num); pthread_mutex_unlock(&amp;mutex); pthread_exit(NULL); } 7. Condition Variables Condition variables provide yet another way for threads to synchronize. While mutexes implement synchronization by controlling thread access data, condition variables allow threads to synchronize based upon the actual value of data. Without condition variables, the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met. This can be very resource consuming since the thread would be continuously busy in this activity. A condition variable is a way to achieve the same goal without polling. A condition variable is always used in conjunction with a mutex lock. A representative sequence for using condition variable is shown below. Main Thread Declare and initialize global data/variables which require synchronization (such as &quot;count&quot;) Declare and initialize a condition variable object Declare and initialize an associated mutex Create threads A and B to do work Thread A Do work up to the point where a certain condition must occur (such as &quot;count&quot; must reach a specified value) Lock associated mutex and check value of a global variable Call pthread_cond_wait() to perform a blocking wait for signal from Thread-B. Note that a call to pthread_cond_wait() automatically and atomically unlocks the associated mutex variable so that it can be used by Thread-B. When signalled, wake up. Mutex is automatically and atomically locked. Explicitly unlock mutex Continue Thread B Do work Lock associated mutex Change the value of the global variable that Thread-A is waiting upon. Check value of the global Thread-A wait variable. If it fulfills the desired condition, signal Thread-A. Unlock mutex. Continue Main Thread Join / Continue Routines pthread_cond_init (condition,attr) pthread_cond_destroy (condition) pthread_condattr_init (attr) pthread_condattr_destroy (attr) pthread_cond_wait (condition,mutex) pthread_cond_signal (condition) pthread_cond_broadcast (condition) Condition variables must be decalred with type pthread_cond_t, and must be intialized before they can be used. There are two ways to initialize a condition variable: Statically, when it is declared. pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER; Dynamically, with the pthread_cond_init() routine. The ID of the created condition variable is returned to the calling thread through the condition parameter. This method permits setting condition variable object attributes, attr. pthread_cond_wait() blocks the calling thread until the specified condition is signalled. This routine should be called while mutex is locked, and it will automatically release the mutex while it waits. After signal is received and thread is awakened, mutex will be automatically locked for use by the thread. The programmer is the responsible for unlocking mutex when the thread is finished it. Recommendation: Using a WHILE loop instead of an IF statement to check the waited for condition can help deal with several potential problems, such as: If several threads are wating for the same wake up signal, they will take turns acquiring the mutex, and any one of them can then modify the condition they all waited for. If the thread received the signal in error due to a program bug. The Pthreads library is permitted to issue spurious wake ups to a waiting thread without violating the standard. The pthread_cond_signal() routine is used to signal (or wake up) another thread which is waiting on the condition variable. It should be called after mutex is locked, and must unlock mutex in order for *pthread_cond_wait()** routine to complete. The pthread_cond_broadcast() routine should be used instead of phtread_cond_signal if more than one thread is in a blocking wait state. It is a logical error to call pthread_cond_wait() before calling pthread_cond_wait(). Proper locking and unlocking of the associate mutex variable is essential when using these routines. For example: Failing to lock the mutex before calling pthread_cond_wait() may cause it NOT to block. Failing to unclok the mutex after calling phtread_cond_signal() may not allow a matching pthread_cond_wait() routine to complete (it will remain blocked). #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #define INCR_TIMES 10 #define LIMIT 8 typedef struct { pthread_mutex_t mut; pthread_cond_t cv; int count; } data; static void *incr(void *d); static void *watch(void *d); int main(int argc, char *argv[]) { pthread_t in; pthread_t wt; pthread_attr_t attr; data d; d.count = 0; pthread_mutex_init(&amp;d.mut, NULL); pthread_cond_init(&amp;d.cv, NULL); pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); pthread_create(&amp;in, &amp; attr, incr, &amp;d); pthread_create(&amp;wt, &amp; attr, watch, &amp;d); pthread_join(in, NULL); pthread_join(wt, NULL); pthread_attr_destroy(&amp;attr); exit(EXIT_SUCCESS); } static void *incr(void *d) { data *p = (data *)d; int i; for(i = 0; i &lt; INCR_TIMES; i++) { usleep(500000); pthread_mutex_lock(&amp;p-&gt;mut); p-&gt;count = p-&gt;count + 1; if(p-&gt;count == LIMIT) { pthread_cond_signal(&amp;p-&gt;cv); printf(&quot;INCR.SIGNAL: %d\\n&quot;, p-&gt;count); } else { printf(&quot;INCR: %d\\n&quot;, p-&gt;count); } pthread_mutex_unlock(&amp;p-&gt;mut); } pthread_exit(NULL); } static void *watch(void *d) { data *p = (data *)d; pthread_mutex_lock(&amp;p-&gt;mut); while(p-&gt;count &lt; LIMIT) { pthread_cond_wait(&amp;p-&gt;cv, &amp;p-&gt;mut); printf(&quot;WATCH: %d\\n&quot;, p-&gt;count); } pthread_mutex_unlock(&amp;p-&gt;mut); pthread_exit(NULL); } References Introduction to Parallel Computing POSIX Threads Programming Multithreading in C, POSIX style","headline":"POSIX Threads Programming in C Language","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/03/09/posix-threads-programming-in-c-language/"},"url":"https://blog.codefarm.me/2017/03/09/posix-threads-programming-in-c-language/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">POSIX Threads Programming in C Language</h1><p class="c-post-meta">09 Mar 2017</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#what-is-parallel-computing-" id="markdown-toc-what-is-parallel-computing-">What is Parallel Computing ?</a>    <ul>
      <li><a href="#1-serial-computing" id="markdown-toc-1-serial-computing">1. Serial Computing</a></li>
      <li><a href="#2-parallel-computing" id="markdown-toc-2-parallel-computing">2. Parallel Computing</a></li>
      <li><a href="#3-parallel-computers" id="markdown-toc-3-parallel-computers">3. Parallel Computers</a></li>
      <li><a href="#4-von-neumann-architecture" id="markdown-toc-4-von-neumann-architecture">4. von Neumann Architecture</a></li>
      <li><a href="#5-synchronization" id="markdown-toc-5-synchronization">5. Synchronization</a></li>
    </ul>
  </li>
  <li><a href="#posix-threads-programming" id="markdown-toc-posix-threads-programming">POSIX Threads Programming</a>    <ul>
      <li><a href="#1-what-is-a-thread" id="markdown-toc-1-what-is-a-thread">1. What is a Thread?</a></li>
      <li><a href="#2-what-are-pthreads" id="markdown-toc-2-what-are-pthreads">2. What are Pthreads</a></li>
      <li><a href="#3-the-pthread-api" id="markdown-toc-3-the-pthread-api">3. The Pthread API</a></li>
      <li><a href="#4-creating-and-terminating-threads" id="markdown-toc-4-creating-and-terminating-threads">4. Creating and Terminating Threads</a></li>
      <li><a href="#5-joing-and-detaching-threads" id="markdown-toc-5-joing-and-detaching-threads">5. Joing and Detaching Threads</a></li>
      <li><a href="#6-mutex-variables" id="markdown-toc-6-mutex-variables">6. Mutex Variables</a></li>
      <li><a href="#7-condition-variables" id="markdown-toc-7-condition-variables">7. Condition Variables</a></li>
    </ul>
  </li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<hr />

<h3 id="what-is-parallel-computing-">What is Parallel Computing ?</h3>

<h4 id="1-serial-computing">1. Serial Computing</h4>

<p>Traditionally, software has been written for <strong><em>serial</em></strong> computing:</p>

<ul>
  <li>A problem is broken into a discrete series of instructions</li>
  <li>Instructions are executed sequentially one after another</li>
  <li>Executed on a single processor</li>
  <li>Only one instruction may execute at any moment in time</li>
</ul>

<p><img src="https://computing.llnl.gov/tutorials/parallel_comp/images/serialProblem.gif" alt="Serial Computing" /></p>

<h4 id="2-parallel-computing">2. Parallel Computing</h4>

<p>In the simplest sense, <strong><em>parallel computing</em></strong> is the simultaneous use of multiple compute resources to solve a computational problem:</p>

<ul>
  <li>A problem is broken into discrete parts that can be solved concurrently</li>
  <li>Each part is further broken down to a series of instructions</li>
  <li>Instructions from each part execute simultaneously on different processors</li>
  <li>An overall control/coordination mechanism is employed</li>
</ul>

<p><img src="https://computing.llnl.gov/tutorials/parallel_comp/images/parallelProblem.gif" alt="Parallel Computing" /></p>

<ul>
  <li>
    <p>The computional problem should be able to:</p>

    <ul>
      <li>Be broken apart into discrete pieces of work that can be solved simultaneously</li>
      <li>Execute multiple program instructions at any moment in time</li>
      <li>Be solved in less time with multiple compute resources than with a single compute resource</li>
    </ul>
  </li>
  <li>
    <p>The compute resources are typically:</p>

    <ul>
      <li>A single computer with multiple processors/cores</li>
      <li>An arbitrary number of such computers connected by a network</li>
    </ul>
  </li>
</ul>

<h4 id="3-parallel-computers">3. Parallel Computers</h4>

<p>Virtually all stand-alone computers today are parallel from a hardware perspective:</p>

<ul>
  <li>Multiple functional units (L1 cache, L2 cache, branch, prefetch, decode, floating-point, graphics processing (GPU), integer, etc.)</li>
  <li>Multiple execution units/cores</li>
  <li>Multiple hardware threads</li>
</ul>

<p><img src="https://computing.llnl.gov/tutorials/parallel_comp/images/bgqComputeChip.jpg" alt="IBM BG/Q Compute Chip with 18 cores (PU) and 16 L2 Cache units (L2) " /></p>

<p>Networks connect multiple stand-alone computers (nodes) to make larger parallel computer clusters.</p>

<p><img src="https://computing.llnl.gov/tutorials/parallel_comp/images/nodesNetwork.gif" alt="Parallel Computer Clusters" /></p>

<ul>
  <li>
    <p>For example, the schematic below shows a typical LLNL parallel computer cluster:</p>

    <ul>
      <li>Each compute node is a multi-processor parallel computer in itself</li>
      <li>Multiple compute nodes are networked together with an Infiniband network</li>
      <li>Special purpos node, also multi-processors, are used for other purposes</li>
    </ul>
  </li>
</ul>

<p><img src="https://computing.llnl.gov/tutorials/parallel_comp/images/parallelComputer1.gif" alt="" /></p>

<h4 id="4-von-neumann-architecture">4. von Neumann Architecture</h4>

<p>Named after the Hungarian mathematician/genius John von Neumann who first authored the general requirements for an electronic computer in his 1945 papers.</p>

<p>Also know as “stored-program computer” - both program instructions and data are kept in electronic memory. Differs from earlier computers which were programmed through “hard writing”.</p>

<p>Since then, virtually all computers have followed the basic design:</p>

<ul>
  <li>Comprised of four main components:
    <ul>
      <li>Memory</li>
      <li>Control Unit</li>
      <li>Arithmetic Logic Unit</li>
      <li>Input/Output</li>
    </ul>
  </li>
  <li>
    <p>Read/write, random access memory is used to store both program instructions and data.</p>

    <ul>
      <li>Program instructions are coded data which tell the computer to do something</li>
      <li>Data is simply informaiton to be used by the program</li>
    </ul>
  </li>
  <li>Control unit fetches instructions/data from memory, decodes the instructions and then <strong><em>sequentially</em></strong> coordinates operations to accomplish the programmed task.</li>
  <li>Arithmetic Unit performs basic arithmetic operations.</li>
  <li>
    <p>Input/Output is the interface to the human operator</p>
  </li>
  <li>
    <p>So what? Who cares?</p>

    <ul>
      <li>Well, parallel computers still follow this basic design, just multiplied in units. the basic, fundamental architecture remains the same.</li>
    </ul>
  </li>
</ul>

<h4 id="5-synchronization">5. Synchronization</h4>

<ul>
  <li>
    <p>Managing the sequence of work and the tasks performing it is a critical design consideration for most parallel programs.</p>
  </li>
  <li>
    <p>Can be a significant factor in program performance (or lack of it)</p>
  </li>
  <li>
    <p>Often requires “serialization” of segments of the program.</p>
  </li>
</ul>

<p><strong>Types of Synchronization</strong></p>

<ul>
  <li>
    <p><strong>Barrier</strong></p>

    <ul>
      <li>Usually implies that all taks are involved</li>
      <li>Each task performs its work until it reaches the barriers. It then stops, or “blocks”.</li>
      <li>When the last task reaches the barrier, all tasks are synchronized.</li>
      <li>What happens from here varies. Often, a serial section of work must be done. In other cases, the tasks are automatically released to continue their work.</li>
    </ul>
  </li>
  <li>
    <p><strong>Lock / semaphore</strong></p>

    <ul>
      <li>Can involve any number of tasks</li>
      <li>Typically used to serialize (protect) access to global data or a section of code. Only one task at a time may use (own) the lock / semaphore / flag.</li>
      <li>The first task to acquire the lock “sets” it. This task can then safely (serially) access the protected data or code.</li>
      <li>Other tasks can attempt to acquire the lock but must wait until the task that owns the lock releases it.</li>
      <li>Can be blocking or non-blocking</li>
    </ul>
  </li>
  <li>
    <p><strong>Synchronous communication operations</strong></p>

    <ul>
      <li>Involves only those tasks executing a communication operation</li>
      <li>When a task performs a communication operation, some form of coordination is required with the other task(s) participating in the communication. For example, before a task can perform a send operation, it must first receive an acknowledgment from the receiving task that it is OK to send.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="posix-threads-programming">POSIX Threads Programming</h3>

<h4 id="1-what-is-a-thread">1. What is a Thread?</h4>

<ul>
  <li>
    <p>Technically, a thread is defined as an independent stream ofinstructions that can be scheduled to run as such by the operating system.</p>
  </li>
  <li>
    <p>To the software developer, the concept of a “procedure” that runs independently from its main program may best desribe a thread.</p>
  </li>
  <li>
    <p>To go one step further, imagine a main program (a.out) that contains a number of procedures. Then imagine all of these procedures being able to be scheduled to run simultaneously and/or independently by the operating system. That would describe a “multi-threaded” program.</p>
  </li>
  <li>
    <p>Before understanding a thread, one first needs to understand a UNIX process. A process is created by the operating system, and requires a fair amout of “overhead”. Processes contain information about program resources and program execution state, including:</p>

    <ul>
      <li>Process ID, process group ID, and group ID</li>
      <li>Environment</li>
      <li>Working directory</li>
      <li>Program instructions</li>
      <li>Registers</li>
      <li>Stack</li>
      <li>Heap</li>
      <li>File descriptors</li>
      <li>Signal actions</li>
      <li>Shared libraries</li>
      <li>Inter-process communication tools (such as message queues, pipes, semaphores, or shared memeory).</li>
    </ul>

    <p><img style="max-width: 50%; float: left;" src="https://computing.llnl.gov/tutorials/pthreads/images/process.gif" alt="UNIX PROCESS" title="UNIX PROCESS" />
  <img style="max-width: 50%; float: left; clear: right;" src="https://computing.llnl.gov/tutorials/pthreads/images/thread.gif" alt="THREADS WITHIN A UNIX PROCESS" title="THREADS WITHIN A UNIX PROCESS" /></p>
  </li>
  <li>
    <p>Threads use and exist within these process reources, yet are able to be scheduled by the operating system and run as independent entities largely because they duplicate only the bare essential resources that enable them to exist as executable code.</p>
  </li>
  <li>
    <p>This independent flow of control is accomplished because a thread maintains its own:</p>

    <ul>
      <li>Stack Pointer</li>
      <li>Registers</li>
      <li>Scheduling properties (such as policy or priority)</li>
      <li>Set of pending and blocked signals</li>
      <li>Thread specific data</li>
    </ul>
  </li>
  <li>
    <p>So, in summary, in the UNIX environment a thread:</p>

    <ul>
      <li>Exists within a process and uses the process resources</li>
      <li>Has its own independent flow of control as long as its parent process exists and the OS supports it</li>
      <li>Duplicates only the essential resources it needs to be independently schedulable</li>
      <li>May share the process resources with other threads that act equally independently (and dependently)</li>
      <li>Dies if the parent process dies - or something similar</li>
      <li>Is “lightweight” because most of the overhead has already been accomplished through the creation of it process</li>
    </ul>
  </li>
  <li>
    <p>Because threads within the same process share resources:</p>

    <ul>
      <li>Changes made by one thread to shared system resources (such as closing a file) will be seen by all other threads</li>
      <li>Two pointers having the same value point to the same data</li>
      <li>Reading and writing to the same memory location is possible, and therefore requires explicit synchronization by the programmer</li>
    </ul>
  </li>
</ul>

<h4 id="2-what-are-pthreads">2. What are Pthreads</h4>

<p>Pthreads are defined as a set of C language programming types and procedure calls, implemented with a <strong>pthread.h</strong> header/include file and a thread library - through this library may be part of another library, such as <strong>libc</strong>, in some implementations.</p>

<h4 id="3-the-pthread-api">3. The Pthread API</h4>

<p>The original Pthreads API was defined in the ANSI/IEEE POSIX 1003.1 - 1995 standard. The POSIX standard has continued to evolve and undergo revisions, including the Pthreads specification.</p>

<p>The subroutines which comprise the Pthreads API can be informally grouped into four major gorups:</p>

<ol>
  <li>
    <p><strong>Thread management</strong>: Routines that work directory on threads - creating, detaching, joining, etc. They also include functions to set/query thread attributes (joinable, sheduling etc.)</p>
  </li>
  <li>
    <p><strong>Mutexes</strong>: Routines that deal with synchronization, called a “mutext”, which is an abbreviation for “mutual exclusion”. Mutex functions provide for creating, destroying, locking and unlocking mutexes. These are supplemented by mutex attribute functions that set or modify attributes associated with mutexes.</p>
  </li>
  <li>
    <p><strong>Condition variables</strong>: Routines that address communications between threads that share a mutex. Based upon programmer specified conditions. This group includes functions to create, destory, wait and signal based upon specified variable values. Functions to set/query condition variable attributes are also included.</p>
  </li>
  <li>
    <p><strong>Synchronization</strong>: Routines that manage read/write locks and barries.</p>
  </li>
</ol>

<p>All identifiers in the threads library begin with <strong>pthread_</strong>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Routine Prefix</th>
      <th style="text-align: left">Functional Group</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">pthread_</td>
      <td style="text-align: left">Threads themselves and miscellaneous subroutines</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_attr_</td>
      <td style="text-align: left">Thread attributes objects</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_mutext_</td>
      <td style="text-align: left">Mutexes</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_mutexattr_</td>
      <td style="text-align: left">Mutex attributes objects</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_cond_</td>
      <td style="text-align: left">Condition variables</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_condattr_</td>
      <td style="text-align: left">Condition attributes objects</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_key_</td>
      <td style="text-align: left">Thread-specific data keys</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_rwlock_</td>
      <td style="text-align: left">Read/write locks</td>
    </tr>
    <tr>
      <td style="text-align: left">pthread_barrier_</td>
      <td style="text-align: left">Synchronization barriers</td>
    </tr>
  </tbody>
</table>

<h4 id="4-creating-and-terminating-threads">4. Creating and Terminating Threads</h4>

<ul>
  <li><strong>Routines</strong></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_create</span> <span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">start_routine</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="n">pthread_exit</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
<span class="n">pthread_cancel</span> <span class="p">(</span><span class="kr">thread</span><span class="p">)</span>
<span class="n">pthread_attr_init</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span>
<span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>
    <p><strong>Creating Threads</strong></p>

    <p>Initially, your <code class="language-plaintext highlighter-rouge">main()</code> program comprises a single, default thread. All other threads must be explicitly created by the programmer.</p>

    <p><code class="language-plaintext highlighter-rouge">pthread_create</code> creates a new thread and makes it executalbe. This routine can be called any number of times anywhere within your code.</p>

    <p>The <code class="language-plaintext highlighter-rouge">pthread_create()</code> routine permits the programmer to pass one argument to the thread start routine. For cases where multiple arguments must be passed, this limitation is easily overcome by creating a structure which contains all of the arguments, and then passing a pointer to that structure in the <code class="language-plaintext highlighter-rouge">pthread_create()</code> routine. All arguments must be passed by reference and cast to <code class="language-plaintext highlighter-rouge">(void *)</code>.</p>

    <p>Once created, threads are peers, and may create other threads. There is no implied hierarchy or dependency between threads.</p>

    <p><img src="https://computing.llnl.gov/tutorials/pthreads/images/peerThreads.gif" alt="" /></p>
  </li>
  <li>
    <p><strong>Terminating Threads</strong> &amp; <code class="language-plaintext highlighter-rouge">pthread_exit</code></p>

    <p>There are several ways in which a thread may be terminated:</p>
    <ul>
      <li>The thread returns normally from its starting routine. Its work is done.</li>
      <li>The thread makes a call to the <code class="language-plaintext highlighter-rouge">pthread_exit</code> subroutine - whether its works is done or not.</li>
      <li>The thread is canceled by another thread via the <code class="language-plaintext highlighter-rouge">pthread_cancel</code> routine</li>
      <li>The entire process is terminated due to makeing a call to either the <code class="language-plaintext highlighter-rouge">exec()</code> or <code class="language-plaintext highlighter-rouge">exit()</code></li>
      <li>If <code class="language-plaintext highlighter-rouge">main()</code> finishes first, without calling <code class="language-plaintext highlighter-rouge">pthread_exit</code> explicitly itself.</li>
      <li>Cleanup: the <code class="language-plaintext highlighter-rouge">pthread_exit()</code> routine does not close files; any files opened inside the thread will remain open after the thread is terminated.</li>
      <li>
        <p><strong>Discussion on calling</strong> <code class="language-plaintext highlighter-rouge">pthread_exit()</code> from main()</p>

        <ul>
          <li>
            <p>There is definite problem if <code class="language-plaintext highlighter-rouge">main()</code> finishes before the threads it spawned if you don’t call <code class="language-plaintext highlighter-rouge">pthread_exit</code> explicitly. All of the threads it created will terminate because <code class="language-plaintext highlighter-rouge">main()</code> is done and no longer exists to support the threads.</p>
          </li>
          <li>
            <p>By having <code class="language-plaintext highlighter-rouge">main()</code> explicitly call <strong>pthread_exit()</strong> as the last thing it does, <code class="language-plaintext highlighter-rouge">main()</code> will block and be kept alive to support the threads it created until they are done.</p>
          </li>
        </ul>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    
  <span class="cp">#define NUM_THREADS     2
</span>    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ch</span><span class="p">);</span>
    
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">char</span> <span class="n">ch</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'*'</span><span class="p">,</span> <span class="sc">'-'</span> <span class="p">};</span>
      <span class="n">pthread_t</span> <span class="n">tids</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
    
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">rc</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    
          <span class="k">if</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">printf</span><span class="p">(</span><span class="s">"ERROR; return code from pthread_create() is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
              <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
    
      <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ch</span><span class="p">);</span>
          <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="5-joing-and-detaching-threads">5. Joing and Detaching Threads</h4>

<ul>
  <li><strong>Routines</strong></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_join</span> <span class="p">(</span><span class="n">threadid</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<span class="n">pthread_detach</span> <span class="p">(</span><span class="n">threadid</span><span class="p">)</span>
<span class="n">pthread_attr_setdetachstate</span> <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">detachstate</span><span class="p">)</span>
<span class="n">pthread_attr_getdetachstate</span> <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">detachstate</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p><strong>Joining</strong></p>

    <ul>
      <li>
        <p>“Joining” is one way to accomplish synchronization between threads.</p>

        <p><img src="https://computing.llnl.gov/tutorials/pthreads/images/joining.gif" alt="" /></p>
      </li>
      <li>
        <p>The <strong>pthread_join()</strong> subroutine blocks the calling thread until the specified <strong>threadid</strong> thread terminates.</p>
      </li>
      <li>
        <p>The programmer is able to obtain the target thread’s termination return <strong>status</strong> if it was specified in the target thread’s call to <strong>pthread_exit()</strong>.</p>
      </li>
      <li>
        <p>A joining thread can match one <strong>pthread_join()</strong> call. It is a logical error to attempt multiple joins on the same thread.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Joinable or Not?</strong></p>

    <ul>
      <li>
        <p>When a thread is created, one of its attributes defines whether it is joinable or detached. Only threads that are created as joinable can be joined. If a thread is created as detached, it can never be joined.</p>
      </li>
      <li>
        <p>The final draft of the POSIX standard specifies that threads should be created as joinable.</p>
      </li>
      <li>
        <p>To explicitly create a thread as joinable or detached, the <strong>attr</strong> argument in the <strong>pthread_create()</strong> routine is used. The typical 4 steps process is :</p>

        <ol>
          <li>Decalare a pthread attribute variable of the <strong>pthread_attr_t</strong> data type.</li>
          <li>Initialize the attribute variable with <strong>pthread_attr_init()</strong></li>
          <li>Set the attribute detached status with <strong>pthread_attr_setdetachstate()</strong></li>
          <li>When done, free library resources used by the attribute with <strong>pthread_attr_destory()</strong></li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Detaching</strong></p>

    <ul>
      <li>
        <p>The <strong>pthread_detach()</strong> routine can be used to explicitly detach even though it was created as joinable.</p>
      </li>
      <li>
        <p>There is no converse routine.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Recommendations</strong></p>

    <ul>
      <li>
        <p>If a thread requires joining, consider explicitly creating it as joinable. This provides portablility as not all implementations may create threads as joinable by default.</p>
      </li>
      <li>
        <p>If you know in advance that a thread will never need to join with another thread, consider creating it in a detached state. Some system resources may be able to be freed.</p>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    
  <span class="cp">#define NUM_THREADS     2
</span>    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ch</span><span class="p">);</span>
    
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">char</span> <span class="n">ch</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'*'</span><span class="p">,</span> <span class="sc">'-'</span> <span class="p">};</span>
      <span class="n">pthread_t</span> <span class="n">tids</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span>
      <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
      <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
      <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_JOINABLE</span><span class="p">);</span>
    
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">rc</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    
          <span class="k">if</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">printf</span><span class="p">(</span><span class="s">"ERROR; return code from pthread_create() is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
              <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
    
      <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
    
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">rc</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    
          <span class="k">if</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">printf</span><span class="p">(</span><span class="s">"ERROR; return code from pthread_join() is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
              <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
    
      <span class="c1">// pthread_exit(NULL);</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ch</span><span class="p">);</span>
          <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="6-mutex-variables">6. Mutex Variables</h4>

<ul>
  <li>
    <p>Mutex is an abbreviation for “mutual exclusion”. Mutex variables are one of the primary means of implementing thread synchronization and for protecting shared data when multiple writes occur.</p>
  </li>
  <li>
    <p>A mutex variable act like a “lock” protecting access to a shared data resource. The basic concept of a mutex as used in Phtreads that only one thread can lock (or own) a mutex variable at any given time. Thus, even if several threads try to lock a mutex only one thread will be successful. On other thread can own that mutex until the owning thread unclocks that mutex. Threads must “take turns” accessing protected data.</p>
  </li>
  <li>
    <p>Mutexs can be used to prevent “race” conditions.</p>

    <p>A program that depends on threads working in a certain sequence to complete normally. Race Conditions happen when mutexes are used improperly, or not at all.</p>
  </li>
  <li>
    <p>Very often the action performed by a thread owning a mutex is the updating of global variables. This is a safe way to ensuere that when several threads update the same variable, the final value is the same as what it would be if only one thread performed the update. The vairables being updated belong to a “critical section”.</p>
  </li>
  <li>
    <p>A typical sequence in the use of a mutex is as follows:</p>

    <ul>
      <li>Create and initialize a mutex variable</li>
      <li>Several threads attempt to lock the mutex</li>
      <li>Only one succeeds and that thread owns the mutex</li>
      <li>The owner unlocks the mutex</li>
      <li>Another thread acquires the mutex and repeats the process</li>
      <li>Finally the mutex is destroyed</li>
    </ul>
  </li>
  <li>
    <p>When several threads compete for a mutex, the loser block aht the call - an unblocking call is available with “trylock” instead of the “lock” call.</p>
  </li>
  <li>
    <p>When more than one thread is waiting for a locked mutex, unless thread priority scheduling is used, which thread will be granted the lock will be left to the native system scheduler and may appear to be more or less random.</p>
  </li>
  <li>
    <p><strong>Routines</strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">pthread_mutex_init</span> <span class="p">(</span><span class="n">mutex</span><span class="p">,</span><span class="n">attr</span><span class="p">)</span>
    
  <span class="n">pthread_mutex_destroy</span> <span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
  <span class="n">pthread_mutexattr_init</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span>
    
  <span class="n">pthread_mutexattr_destroy</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span> 
    
  <span class="n">pthread_mutex_lock</span> <span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
  <span class="n">pthread_mutex_trylock</span> <span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
  <span class="n">pthread_mutex_unlock</span> <span class="p">(</span><span class="n">mutex</span><span class="p">)</span> 
</code></pre></div>    </div>

    <ul>
      <li>
        <p>Mutex variables must be decalre with type <strong>pthread_mutex_t</strong>, and must be initialized before they can be used.</p>

        <ol>
          <li>
            <p>Statically, when it is declared.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pthread_mutex_t</span> <span class="n">mymutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>Dynamically, with the <strong>pthread_mutex_init()</strong> routine.</p>
          </li>
        </ol>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    
  <span class="cp">#define NUM_THREADS     1000
</span>    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">add</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">num</span><span class="p">);</span>
    
  <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
    
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
  <span class="p">{</span>
      <span class="n">pthread_t</span> <span class="n">tids</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
      <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
      <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_JOINABLE</span><span class="p">);</span>
    
      <span class="k">for</span><span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tids</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
      <span class="p">}</span>
    
      <span class="k">for</span><span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">pthread_join</span><span class="p">(</span><span class="n">tids</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="p">}</span>
    
      <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
      <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">add</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">num</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">num</span><span class="p">;</span>
      <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">num</span><span class="p">);</span>
      <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="7-condition-variables">7. Condition Variables</h4>

<ul>
  <li>
    <p>Condition variables provide yet another way for threads to synchronize. While mutexes implement synchronization by controlling thread access data, condition variables allow threads to synchronize based upon the actual value of data.</p>
  </li>
  <li>
    <p>Without condition variables, the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met. This can be very resource consuming since the thread would be continuously busy in this activity. A condition variable is a way to achieve the same goal without polling.</p>
  </li>
  <li>
    <p>A condition variable is always used in conjunction with a mutex lock.</p>
  </li>
  <li>
    <p>A representative sequence for using condition variable is shown below.</p>

    <table width="90%" cellspacing="0" cellpadding="5" border="1">
      <tbody>
          <tr valign="top">
              <td colspan="2" bgcolor="#FOF5FE"><span class="heading3">Main Thread</span>
                  <ul>
                      <li>Declare and initialize global data/variables which require synchronization (such as "count")
                      </li>
                      <li>Declare and initialize a condition variable object
                      </li>
                      <li>Declare and initialize an associated mutex
                      </li>
                      <li>Create threads A and B to do work
                      </li>
                  </ul>
              </td>
          </tr>
          <tr valign="top">
              <td width="50%">
                  <strong>Thread A</strong>
                  <ul>
                      <li>Do work up to the point where a certain condition must occur (such as "count" must reach a specified value)
                      </li>
                      <li>Lock associated mutex and check value of a global variable
                      </li>
                      <li>Call
                          <tt>pthread_cond_wait()</tt> to perform a blocking wait for signal from Thread-B. Note that a call to
                          <tt>pthread_cond_wait()</tt> automatically and atomically unlocks the associated mutex variable so that it can be used by Thread-B.
                      </li>
                      <li>When signalled, wake up. Mutex is automatically and atomically locked.
                      </li>
                      <li>Explicitly unlock mutex
                      </li>
                      <li>Continue
                      </li>
                  </ul>
              </td>
              <td width="50%">
                  <strong>Thread B</strong>
                  <ul>
                      <li>Do work
                      </li>
                      <li>Lock associated mutex
                      </li>
                      <li>Change the value of the global variable that Thread-A is waiting upon.
                      </li>
                      <li>Check value of the global Thread-A wait variable. If it fulfills the desired condition, signal Thread-A.
                      </li>
                      <li>Unlock mutex.
                      </li>
                      <li>Continue
                      </li>
                  </ul>
              </td>
          </tr>
          <tr valign="top">
              <td colspan="2" bgcolor="#FOF5FE">
                  <span class="heading3">Main Thread</span>
                  <ul>
                      Join / Continue
                  </ul>
              </td>
          </tr>
      </tbody>
  </table>
  </li>
  <li>
    <p><strong>Routines</strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">pthread_cond_init</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="n">attr</span><span class="p">)</span>
    
  <span class="n">pthread_cond_destroy</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
    
  <span class="n">pthread_condattr_init</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span>
    
  <span class="n">pthread_condattr_destroy</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span> 
    
  <span class="n">pthread_cond_wait</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="n">mutex</span><span class="p">)</span>
    
  <span class="n">pthread_cond_signal</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
    
  <span class="n">pthread_cond_broadcast</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> 
    
</code></pre></div>    </div>

    <ul>
      <li>
        <p>Condition variables must be decalred with type <strong>pthread_cond_t</strong>, and must be intialized before they can be used. There are two ways to initialize a condition variable:</p>

        <ol>
          <li>
            <p>Statically, when it is declared.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pthread_cond_t</span> <span class="n">myconvar</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>Dynamically, with the <strong>pthread_cond_init()</strong> routine. The ID of the created condition variable is returned to the calling thread through the <em>condition</em> parameter. This method permits setting condition variable object attributes, <em>attr</em>.</p>
          </li>
        </ol>
      </li>
      <li>
        <p><strong>pthread_cond_wait()</strong> blocks the calling thread until the specified <em>condition</em> is signalled. This routine should be called while <em>mutex</em> is locked, and it will automatically release the mutex while it waits. After signal is received and thread is awakened, <em>mutex</em> will be automatically locked for use by the thread. The programmer is the responsible for unlocking <em>mutex</em> when the thread is finished it.</p>

        <p><strong>Recommendation</strong>: Using a WHILE loop instead of an IF statement to check the waited for condition can help deal with several potential problems, such as:</p>
        <ul>
          <li>If several threads are wating for the same wake up signal, they will take turns acquiring the mutex, and any one of them can then modify the condition they all waited for.</li>
          <li>If the thread received the signal in error due to a program bug.</li>
          <li>The Pthreads library is permitted to issue spurious wake ups to a waiting thread without violating the standard.</li>
        </ul>
      </li>
      <li>
        <p>The <strong>pthread_cond_signal()</strong> routine is used to signal (or wake up) another thread which is waiting on the condition variable. It should be called after <em>mutex</em> is locked, and must unlock <em>mutex</em> in order for *pthread_cond_wait()** routine to complete.</p>
      </li>
      <li>
        <p>The <strong>pthread_cond_broadcast()</strong> routine should be used instead of <strong>phtread_cond_signal</strong> if more than one thread is in a blocking wait state.</p>
      </li>
      <li>
        <p>It is a logical error to call <strong>pthread_cond_wait()</strong> before calling <strong>pthread_cond_wait()</strong>.</p>

        <p>Proper locking and unlocking of the associate mutex variable is essential when using these routines. For example:</p>
        <ul>
          <li>Failing to lock the mutex before calling <strong>pthread_cond_wait()</strong> may cause it NOT to block.</li>
          <li>Failing to unclok the mutex after calling <strong>phtread_cond_signal()</strong> may not allow a matching <strong>pthread_cond_wait()</strong> routine to complete (it will remain blocked).</li>
        </ul>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    
  <span class="cp">#define INCR_TIMES      10
</span>  <span class="cp">#define LIMIT           8
</span>    
  <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
      <span class="n">pthread_mutex_t</span> <span class="n">mut</span><span class="p">;</span>
      <span class="n">pthread_cond_t</span>  <span class="n">cv</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">data</span><span class="p">;</span>
    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">incr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">watch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
    
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
  <span class="p">{</span>
      <span class="n">pthread_t</span> <span class="n">in</span><span class="p">;</span>
      <span class="n">pthread_t</span> <span class="n">wt</span><span class="p">;</span>
      <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
      <span class="n">data</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">d</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">.</span><span class="n">mut</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">.</span><span class="n">cv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
      <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_JOINABLE</span><span class="p">);</span>
      <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">attr</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
      <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wt</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">attr</span><span class="p">,</span> <span class="n">watch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
      <span class="n">pthread_join</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="n">pthread_join</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">incr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">INCR_TIMES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">usleep</span><span class="p">(</span><span class="mi">500000</span><span class="p">);</span>
          <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
          <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
          <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">LIMIT</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
              <span class="n">printf</span><span class="p">(</span><span class="s">"INCR.SIGNAL: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="n">printf</span><span class="p">(</span><span class="s">"INCR: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
          <span class="p">}</span>
    
          <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
      <span class="p">}</span>
    
      <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">watch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
      <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
    
      <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">LIMIT</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"WATCH: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
      <span class="p">}</span>
    
      <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
      <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h3 id="references">References</h3>

<ol>
  <li><a href="https://computing.llnl.gov/tutorials/parallel_comp/">Introduction to Parallel Computing</a></li>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/">POSIX Threads Programming</a></li>
  <li><a href="http://softpixel.com/~cwright/programming/threads/threads.c.php">Multithreading in C, POSIX style</a></li>
</ol>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
