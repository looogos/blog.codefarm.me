<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Pointers in C Language | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Pointers in C Language" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. Declaring Pointers 2. Intializing Pointers 3. Pointers to Unions 4. Pointers to Structures 5. Dangling, Void , Null and Wild Pointers 6. References Pointers hold memory address of stored constants or variables. For any data type, including both primitive types and custom types, you can create a pointer that holds the memory address of an instance of that type. 1. Declaring Pointers You declare a pointer by specifying a name for it and a data type. The data type indicates of what type of variable the pointer will hold memory addresses. To declare a pointer, include the indirection operator before the identifier. Here is the general form of a pointer declaration: data-type * name; White space is not significant around the indirection operator: data-type *name; data-type* name; Here is an example of declaring a pointer to hold the address of an int variable: int *ip; Be careful, though: when declaring multiple pointers in the same statement, you must explicitly declare each as a pointer, using the indirection operator: int *foo, *bar; /* Two pointers. */ int *baz, quux; /* A pointer and an integer variable. */ 2. Intializing Pointers You can initialize a pointer when you first declare it by specifying a variable address to store in it. For example, the following code declares an int variable i, and a pointer which is initialized with the address of i: int i; int *p = &amp;i; Note the use of the address operator, used to get the memory address of a variable. After you declare a pointer, you do not use the indirection operator with the pointer’s name when assigning it a new address to point to. On the countrary, that would change the value of the variable that the points to, not the value of the ponter itself. For example: int i, j; int *ip = &amp;i; /* ‘ip’ now holds the address of ‘i’. */ ip = &amp;j; /* ‘ip’ now holds the address of ‘j’. */ *ip = &amp;i; /* ‘j’ now holds the address of ‘i’. */ The value stored in a pointer is an integral number: a location within the computer’s memory space. If you are so inclined, you can assign pointer values explicitly using literal integers, casting them to the appropriate pointer type. However, we do not recommend this practice unless you need to have extremely fine-tuned control over what is stored in memory, and you known exactly what are doing. It would be all too easy to accidentally overwrite something that you did not intend to. Most uses of this technique are also non-portable. It is important to note thant if you do not initialize a pointer with the address of some other existing object, it points nowhere in particular and will likely make your program crash if you use it (formmally, this kind of thing is called undefined behavior). 3. Pointers to Unions You can create a pointer to a union type just as you can a pointer to a primitive data type. union numbers { int i; float f; }; union numbers foo = { 4 }; union numbers *number_ptr = &amp;foo; That example creates a new union type, union numbers, and declares ( and initializes the first member of) a variable of that type named foo. Finally, it declares a pointer to the type union numbers, and gives it th address of foo. You can access the members of a union variable through a pointer, but you can’t use the regular member access operator anymore. Instead, you have to use the indirect member access operator. Continuing with the previous example, the following example will change the value of the first member of foo: number_ptr -&gt; i = 450; Now the i member in foo is 450. 4. Pointers to Structures You can create a pointer to a structure type just as you can a pointer to a primitive data type. struct fish { float length, weight; }; struct fish salmon = { 4.3, 5.8 }; struct fish *fish_prt = &amp;salmon; That example creates a new structure type, struct fish, and declares (and initializes) a variable of that type named salmon. You can access the members of a structure variable through a pointer, but you can’t use the regular memeber access operator anymore. Instead, you have to use the indirect member access operator. Continuing with the previous example, the following example will change the values of the members of salmon: fish_ptr -&gt; length = 5.1; fish_ptr -&gt; weight = 6.2; Now the length and width members in salmon are 5.1 and 6.2, respectively. 5. Dangling, Void , Null and Wild Pointers Dangling Pointer A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. There are three different ways where Pointer acts as dangling pointer. De-allocation of memory // Deallocating a memory address by ptr causes dangling pointer #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int *ptr = (int*)malloc(sizeof(int)); // After below free call, ptr becomes a dangling pointer free(ptr); // No more a dangling pointer ptr = NULL; } Function Call // The pointer poiting to local variable becomes // dangling when local variable is not static. #include &lt;stdio.h&gt; int *fun() { // x is local variable and goes out of // scope after an execution of fun() is // over. int x = 5; return &amp;x; } // Driver Code int main(void) { int *p = fun(); fflush(stdin); // p points to something which is not // valid anymore printf(&quot;%p -&gt; %d\n&quot;, p, *p); return 0; } The above problem doesn’t appear (or p doesn’t become dangling) if x is a static vairable. // The pointer poiting to local variable doesn&#39;t become // dangling when local variable is static. #include &lt;stdio.h&gt; int *fun() { // x now has scope througout the program static int x = 5; return &amp;x; } int main() { int *p = fun(); fflush(stdin); // Not a dangling pointer as it points to static variable. printf(&quot;%p -&gt; %d\n&quot;, p, *p); return 0; } Variable goes out of scope void main(void) { int *ptr; // ... // ... { int ch; ptr = &amp;ch; } // ... // Here ptr is dangling pointer } Void pointer Void pointer is a specific pointer type (void *), a pointer that points to some data location in storage, which doesn’t have any specific type. Void refers to the type. Basically the type of data that it points to is can be any. If we assign address of char data type to void pointer it will become char Pointer, if int data type then int pointer and so on. Any pointer type is convertible to a void pointer hence it can point to any value. Important Points void pointers cannot be dereferenced. It can however be done using typecasting the void pointer. Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size. malloc() and calloc() return void * type and this allows these functions to be used to allocate memory of any data type (just because of void *) void pointer in C are used to implement generic funciton in C. #include &lt;stdio.h&gt; int main(void) { int x = 4; float y = 5.5; // A void pointer void *ptr; ptr = &amp;x; // (int*)ptr - does type casting of void // *((int*)ptr) dereferences the typecasted void pointer variable printf(&quot;Integer variable is %d\n&quot;, *((int *)ptr)); // void pointer is now float ptr = &amp;y; printf(&quot;Float variable is %f\n&quot;, *((float *)ptr)); return 0; } NULL Pointer NULL Pointer is a pointer which is pointing to noting. In case, if we don’t have address to be assigned to a pointer, then we can simply use NULL. #include &lt;stdio.h&gt; int main(void) { // NULL Pointer int *ptr = NULL; printf(&quot;The value of ptr is %u\n&quot;, ptr); return 0; } Important Points NULL vs Unitialized Pointer An unitialized pointer stores an undefined value. A null pointer stores a defined value, but one that is defined by the environment to not be a valid address for any member or object. NULL vs Void Pointer NULL pointer is a value, while void pointer is a type. Wild Pointer A pointer which has not been initialized to anything (not even NULL) is known as wild pointer. The pointer may be initialized to a non-NULL garbage value that may not be a valid address. void main(void) { int *p; /* wild pointer */ int x = 10; // p is not a wild pointer now p = &amp;x; } 6. References https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html http://www.geeksforgeeks.org/dangling-void-null-wild-pointers/" />
<meta property="og:description" content="1. Declaring Pointers 2. Intializing Pointers 3. Pointers to Unions 4. Pointers to Structures 5. Dangling, Void , Null and Wild Pointers 6. References Pointers hold memory address of stored constants or variables. For any data type, including both primitive types and custom types, you can create a pointer that holds the memory address of an instance of that type. 1. Declaring Pointers You declare a pointer by specifying a name for it and a data type. The data type indicates of what type of variable the pointer will hold memory addresses. To declare a pointer, include the indirection operator before the identifier. Here is the general form of a pointer declaration: data-type * name; White space is not significant around the indirection operator: data-type *name; data-type* name; Here is an example of declaring a pointer to hold the address of an int variable: int *ip; Be careful, though: when declaring multiple pointers in the same statement, you must explicitly declare each as a pointer, using the indirection operator: int *foo, *bar; /* Two pointers. */ int *baz, quux; /* A pointer and an integer variable. */ 2. Intializing Pointers You can initialize a pointer when you first declare it by specifying a variable address to store in it. For example, the following code declares an int variable i, and a pointer which is initialized with the address of i: int i; int *p = &amp;i; Note the use of the address operator, used to get the memory address of a variable. After you declare a pointer, you do not use the indirection operator with the pointer’s name when assigning it a new address to point to. On the countrary, that would change the value of the variable that the points to, not the value of the ponter itself. For example: int i, j; int *ip = &amp;i; /* ‘ip’ now holds the address of ‘i’. */ ip = &amp;j; /* ‘ip’ now holds the address of ‘j’. */ *ip = &amp;i; /* ‘j’ now holds the address of ‘i’. */ The value stored in a pointer is an integral number: a location within the computer’s memory space. If you are so inclined, you can assign pointer values explicitly using literal integers, casting them to the appropriate pointer type. However, we do not recommend this practice unless you need to have extremely fine-tuned control over what is stored in memory, and you known exactly what are doing. It would be all too easy to accidentally overwrite something that you did not intend to. Most uses of this technique are also non-portable. It is important to note thant if you do not initialize a pointer with the address of some other existing object, it points nowhere in particular and will likely make your program crash if you use it (formmally, this kind of thing is called undefined behavior). 3. Pointers to Unions You can create a pointer to a union type just as you can a pointer to a primitive data type. union numbers { int i; float f; }; union numbers foo = { 4 }; union numbers *number_ptr = &amp;foo; That example creates a new union type, union numbers, and declares ( and initializes the first member of) a variable of that type named foo. Finally, it declares a pointer to the type union numbers, and gives it th address of foo. You can access the members of a union variable through a pointer, but you can’t use the regular member access operator anymore. Instead, you have to use the indirect member access operator. Continuing with the previous example, the following example will change the value of the first member of foo: number_ptr -&gt; i = 450; Now the i member in foo is 450. 4. Pointers to Structures You can create a pointer to a structure type just as you can a pointer to a primitive data type. struct fish { float length, weight; }; struct fish salmon = { 4.3, 5.8 }; struct fish *fish_prt = &amp;salmon; That example creates a new structure type, struct fish, and declares (and initializes) a variable of that type named salmon. You can access the members of a structure variable through a pointer, but you can’t use the regular memeber access operator anymore. Instead, you have to use the indirect member access operator. Continuing with the previous example, the following example will change the values of the members of salmon: fish_ptr -&gt; length = 5.1; fish_ptr -&gt; weight = 6.2; Now the length and width members in salmon are 5.1 and 6.2, respectively. 5. Dangling, Void , Null and Wild Pointers Dangling Pointer A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. There are three different ways where Pointer acts as dangling pointer. De-allocation of memory // Deallocating a memory address by ptr causes dangling pointer #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int *ptr = (int*)malloc(sizeof(int)); // After below free call, ptr becomes a dangling pointer free(ptr); // No more a dangling pointer ptr = NULL; } Function Call // The pointer poiting to local variable becomes // dangling when local variable is not static. #include &lt;stdio.h&gt; int *fun() { // x is local variable and goes out of // scope after an execution of fun() is // over. int x = 5; return &amp;x; } // Driver Code int main(void) { int *p = fun(); fflush(stdin); // p points to something which is not // valid anymore printf(&quot;%p -&gt; %d\n&quot;, p, *p); return 0; } The above problem doesn’t appear (or p doesn’t become dangling) if x is a static vairable. // The pointer poiting to local variable doesn&#39;t become // dangling when local variable is static. #include &lt;stdio.h&gt; int *fun() { // x now has scope througout the program static int x = 5; return &amp;x; } int main() { int *p = fun(); fflush(stdin); // Not a dangling pointer as it points to static variable. printf(&quot;%p -&gt; %d\n&quot;, p, *p); return 0; } Variable goes out of scope void main(void) { int *ptr; // ... // ... { int ch; ptr = &amp;ch; } // ... // Here ptr is dangling pointer } Void pointer Void pointer is a specific pointer type (void *), a pointer that points to some data location in storage, which doesn’t have any specific type. Void refers to the type. Basically the type of data that it points to is can be any. If we assign address of char data type to void pointer it will become char Pointer, if int data type then int pointer and so on. Any pointer type is convertible to a void pointer hence it can point to any value. Important Points void pointers cannot be dereferenced. It can however be done using typecasting the void pointer. Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size. malloc() and calloc() return void * type and this allows these functions to be used to allocate memory of any data type (just because of void *) void pointer in C are used to implement generic funciton in C. #include &lt;stdio.h&gt; int main(void) { int x = 4; float y = 5.5; // A void pointer void *ptr; ptr = &amp;x; // (int*)ptr - does type casting of void // *((int*)ptr) dereferences the typecasted void pointer variable printf(&quot;Integer variable is %d\n&quot;, *((int *)ptr)); // void pointer is now float ptr = &amp;y; printf(&quot;Float variable is %f\n&quot;, *((float *)ptr)); return 0; } NULL Pointer NULL Pointer is a pointer which is pointing to noting. In case, if we don’t have address to be assigned to a pointer, then we can simply use NULL. #include &lt;stdio.h&gt; int main(void) { // NULL Pointer int *ptr = NULL; printf(&quot;The value of ptr is %u\n&quot;, ptr); return 0; } Important Points NULL vs Unitialized Pointer An unitialized pointer stores an undefined value. A null pointer stores a defined value, but one that is defined by the environment to not be a valid address for any member or object. NULL vs Void Pointer NULL pointer is a value, while void pointer is a type. Wild Pointer A pointer which has not been initialized to anything (not even NULL) is known as wild pointer. The pointer may be initialized to a non-NULL garbage value that may not be a valid address. void main(void) { int *p; /* wild pointer */ int x = 10; // p is not a wild pointer now p = &amp;x; } 6. References https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html http://www.geeksforgeeks.org/dangling-void-null-wild-pointers/" />
<link rel="canonical" href="https://blog.codefarm.me/2017/03/02/pointers-in-c-language/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/03/02/pointers-in-c-language/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-02T17:19:51+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pointers in C Language" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-03-02T17:19:51+08:00","datePublished":"2017-03-02T17:19:51+08:00","description":"1. Declaring Pointers 2. Intializing Pointers 3. Pointers to Unions 4. Pointers to Structures 5. Dangling, Void , Null and Wild Pointers 6. References Pointers hold memory address of stored constants or variables. For any data type, including both primitive types and custom types, you can create a pointer that holds the memory address of an instance of that type. 1. Declaring Pointers You declare a pointer by specifying a name for it and a data type. The data type indicates of what type of variable the pointer will hold memory addresses. To declare a pointer, include the indirection operator before the identifier. Here is the general form of a pointer declaration: data-type * name; White space is not significant around the indirection operator: data-type *name; data-type* name; Here is an example of declaring a pointer to hold the address of an int variable: int *ip; Be careful, though: when declaring multiple pointers in the same statement, you must explicitly declare each as a pointer, using the indirection operator: int *foo, *bar; /* Two pointers. */ int *baz, quux; /* A pointer and an integer variable. */ 2. Intializing Pointers You can initialize a pointer when you first declare it by specifying a variable address to store in it. For example, the following code declares an int variable i, and a pointer which is initialized with the address of i: int i; int *p = &amp;i; Note the use of the address operator, used to get the memory address of a variable. After you declare a pointer, you do not use the indirection operator with the pointer’s name when assigning it a new address to point to. On the countrary, that would change the value of the variable that the points to, not the value of the ponter itself. For example: int i, j; int *ip = &amp;i; /* ‘ip’ now holds the address of ‘i’. */ ip = &amp;j; /* ‘ip’ now holds the address of ‘j’. */ *ip = &amp;i; /* ‘j’ now holds the address of ‘i’. */ The value stored in a pointer is an integral number: a location within the computer’s memory space. If you are so inclined, you can assign pointer values explicitly using literal integers, casting them to the appropriate pointer type. However, we do not recommend this practice unless you need to have extremely fine-tuned control over what is stored in memory, and you known exactly what are doing. It would be all too easy to accidentally overwrite something that you did not intend to. Most uses of this technique are also non-portable. It is important to note thant if you do not initialize a pointer with the address of some other existing object, it points nowhere in particular and will likely make your program crash if you use it (formmally, this kind of thing is called undefined behavior). 3. Pointers to Unions You can create a pointer to a union type just as you can a pointer to a primitive data type. union numbers { int i; float f; }; union numbers foo = { 4 }; union numbers *number_ptr = &amp;foo; That example creates a new union type, union numbers, and declares ( and initializes the first member of) a variable of that type named foo. Finally, it declares a pointer to the type union numbers, and gives it th address of foo. You can access the members of a union variable through a pointer, but you can’t use the regular member access operator anymore. Instead, you have to use the indirect member access operator. Continuing with the previous example, the following example will change the value of the first member of foo: number_ptr -&gt; i = 450; Now the i member in foo is 450. 4. Pointers to Structures You can create a pointer to a structure type just as you can a pointer to a primitive data type. struct fish { float length, weight; }; struct fish salmon = { 4.3, 5.8 }; struct fish *fish_prt = &amp;salmon; That example creates a new structure type, struct fish, and declares (and initializes) a variable of that type named salmon. You can access the members of a structure variable through a pointer, but you can’t use the regular memeber access operator anymore. Instead, you have to use the indirect member access operator. Continuing with the previous example, the following example will change the values of the members of salmon: fish_ptr -&gt; length = 5.1; fish_ptr -&gt; weight = 6.2; Now the length and width members in salmon are 5.1 and 6.2, respectively. 5. Dangling, Void , Null and Wild Pointers Dangling Pointer A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. There are three different ways where Pointer acts as dangling pointer. De-allocation of memory // Deallocating a memory address by ptr causes dangling pointer #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int *ptr = (int*)malloc(sizeof(int)); // After below free call, ptr becomes a dangling pointer free(ptr); // No more a dangling pointer ptr = NULL; } Function Call // The pointer poiting to local variable becomes // dangling when local variable is not static. #include &lt;stdio.h&gt; int *fun() { // x is local variable and goes out of // scope after an execution of fun() is // over. int x = 5; return &amp;x; } // Driver Code int main(void) { int *p = fun(); fflush(stdin); // p points to something which is not // valid anymore printf(&quot;%p -&gt; %d\\n&quot;, p, *p); return 0; } The above problem doesn’t appear (or p doesn’t become dangling) if x is a static vairable. // The pointer poiting to local variable doesn&#39;t become // dangling when local variable is static. #include &lt;stdio.h&gt; int *fun() { // x now has scope througout the program static int x = 5; return &amp;x; } int main() { int *p = fun(); fflush(stdin); // Not a dangling pointer as it points to static variable. printf(&quot;%p -&gt; %d\\n&quot;, p, *p); return 0; } Variable goes out of scope void main(void) { int *ptr; // ... // ... { int ch; ptr = &amp;ch; } // ... // Here ptr is dangling pointer } Void pointer Void pointer is a specific pointer type (void *), a pointer that points to some data location in storage, which doesn’t have any specific type. Void refers to the type. Basically the type of data that it points to is can be any. If we assign address of char data type to void pointer it will become char Pointer, if int data type then int pointer and so on. Any pointer type is convertible to a void pointer hence it can point to any value. Important Points void pointers cannot be dereferenced. It can however be done using typecasting the void pointer. Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size. malloc() and calloc() return void * type and this allows these functions to be used to allocate memory of any data type (just because of void *) void pointer in C are used to implement generic funciton in C. #include &lt;stdio.h&gt; int main(void) { int x = 4; float y = 5.5; // A void pointer void *ptr; ptr = &amp;x; // (int*)ptr - does type casting of void // *((int*)ptr) dereferences the typecasted void pointer variable printf(&quot;Integer variable is %d\\n&quot;, *((int *)ptr)); // void pointer is now float ptr = &amp;y; printf(&quot;Float variable is %f\\n&quot;, *((float *)ptr)); return 0; } NULL Pointer NULL Pointer is a pointer which is pointing to noting. In case, if we don’t have address to be assigned to a pointer, then we can simply use NULL. #include &lt;stdio.h&gt; int main(void) { // NULL Pointer int *ptr = NULL; printf(&quot;The value of ptr is %u\\n&quot;, ptr); return 0; } Important Points NULL vs Unitialized Pointer An unitialized pointer stores an undefined value. A null pointer stores a defined value, but one that is defined by the environment to not be a valid address for any member or object. NULL vs Void Pointer NULL pointer is a value, while void pointer is a type. Wild Pointer A pointer which has not been initialized to anything (not even NULL) is known as wild pointer. The pointer may be initialized to a non-NULL garbage value that may not be a valid address. void main(void) { int *p; /* wild pointer */ int x = 10; // p is not a wild pointer now p = &amp;x; } 6. References https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html http://www.geeksforgeeks.org/dangling-void-null-wild-pointers/","headline":"Pointers in C Language","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/03/02/pointers-in-c-language/"},"url":"https://blog.codefarm.me/2017/03/02/pointers-in-c-language/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Pointers in C Language</h1><p class="c-post-meta">02 Mar 2017</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#1-declaring-pointers" id="markdown-toc-1-declaring-pointers">1. Declaring Pointers</a></li>
  <li><a href="#2-intializing-pointers" id="markdown-toc-2-intializing-pointers">2. Intializing Pointers</a></li>
  <li><a href="#3-pointers-to-unions" id="markdown-toc-3-pointers-to-unions">3. Pointers to Unions</a></li>
  <li><a href="#4-pointers-to-structures" id="markdown-toc-4-pointers-to-structures">4. Pointers to Structures</a></li>
  <li><a href="#5-dangling-void--null-and-wild-pointers" id="markdown-toc-5-dangling-void--null-and-wild-pointers">5. Dangling, Void , Null and Wild Pointers</a></li>
  <li><a href="#6-references" id="markdown-toc-6-references">6. References</a></li>
</ul>

<hr />

<p>Pointers hold memory address of stored constants or variables. For any data type, including both primitive types and custom types, you can create a pointer that holds the memory address of an instance of that type.</p>

<h3 id="1-declaring-pointers">1. Declaring Pointers</h3>

<p>You declare a pointer by specifying a name for it and a data type. The data type indicates of what type of variable the pointer will hold memory addresses.</p>

<p>To declare a pointer, include the <strong>indirection operator</strong> before the identifier. Here is the general form of a pointer declaration:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="o">-</span><span class="n">type</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</code></pre></div></div>

<p>White space is not significant around the indirection operator:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="o">-</span><span class="n">type</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="n">data</span><span class="o">-</span><span class="n">type</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</code></pre></div></div>

<p>Here is an example of declaring a pointer to hold the address of an <code class="language-plaintext highlighter-rouge">int</code> variable:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
</code></pre></div></div>

<p>Be careful, though: when declaring multiple pointers in the same statement, you must explicitly declare each as a pointer, using the indirection operator:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>     <span class="cm">/* Two pointers. */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">baz</span><span class="p">,</span> <span class="n">quux</span><span class="p">;</span>     <span class="cm">/* A pointer and an integer variable. */</span>
</code></pre></div></div>

<h3 id="2-intializing-pointers">2. Intializing Pointers</h3>

<p>You can initialize a pointer when you first declare it by specifying a variable address to store in it. For example, the following code declares an <code class="language-plaintext highlighter-rouge">int</code> variable <code class="language-plaintext highlighter-rouge">i</code>, and a pointer which is initialized with the address of <code class="language-plaintext highlighter-rouge">i</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<p>Note the use of the <strong>address operator</strong>, used to get the memory address of a variable. After you declare a pointer, you do <em>not</em> use the indirection operator with the pointer’s name when assigning it a new address to point to. On the countrary, that would change the value of the variable that the points to, not the value of the ponter itself. For example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>  <span class="cm">/* ‘ip’ now holds the address of ‘i’. */</span>
<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">;</span>       <span class="cm">/* ‘ip’ now holds the address of ‘j’. */</span>
<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>      <span class="cm">/* ‘j’ now holds the address of ‘i’. */</span>
</code></pre></div></div>

<p>The value stored in a pointer is an integral number: a location within the computer’s memory space. If you are so inclined, you can assign pointer values explicitly using literal integers, casting them to the appropriate pointer type. However, we do not recommend this practice unless you need to have extremely fine-tuned control over what is stored in memory, and you known exactly what are doing. It would be all too easy to accidentally overwrite something that you did not intend to. Most uses of this technique are also non-portable.</p>

<p>It is important to note thant if you do not initialize a pointer with the address of some other existing object, it points nowhere in particular and will likely make your program crash if you use it (formmally, this kind of thing is called <em>undefined behavior</em>).</p>

<h3 id="3-pointers-to-unions">3. Pointers to Unions</h3>

<p>You can create a pointer to a union type just as you can a pointer to a primitive data type.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">numbers</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">union</span> <span class="n">numbers</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span> <span class="p">};</span>
<span class="k">union</span> <span class="n">numbers</span> <span class="o">*</span><span class="n">number_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
</code></pre></div></div>

<p>That example creates a new union type, <code class="language-plaintext highlighter-rouge">union numbers</code>, and declares ( and initializes the first member of) a variable of that type named <code class="language-plaintext highlighter-rouge">foo</code>. Finally, it declares a pointer to the type <code class="language-plaintext highlighter-rouge">union numbers</code>, and gives it th address of <code class="language-plaintext highlighter-rouge">foo</code>.</p>

<p>You can access the members of a union variable through a pointer, but you can’t use the regular <strong>member access operator</strong> anymore. Instead, you have to use the <strong>indirect member access operator</strong>. Continuing with the previous example, the following example will change the value of the first member of <code class="language-plaintext highlighter-rouge">foo</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number_ptr</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">450</span><span class="p">;</span>
</code></pre></div></div>

<p>Now the <code class="language-plaintext highlighter-rouge">i</code> member in <code class="language-plaintext highlighter-rouge">foo</code> is 450.</p>

<h3 id="4-pointers-to-structures">4. Pointers to Structures</h3>

<p>You can create a pointer to a structure type just as you can a pointer to a primitive data type.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">fish</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">length</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">fish</span> <span class="n">salmon</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">.</span><span class="mi">8</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">fish</span> <span class="o">*</span><span class="n">fish_prt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">salmon</span><span class="p">;</span>
</code></pre></div></div>

<p>That example creates a new structure type, <code class="language-plaintext highlighter-rouge">struct fish</code>, and declares (and initializes) a variable of that type named <code class="language-plaintext highlighter-rouge">salmon</code>.</p>

<p>You can access the members of a structure variable through a pointer, but you can’t use the regular <strong>memeber access operator</strong> anymore. Instead, you have to use the <strong>indirect member access operator</strong>. Continuing with the previous example, the following example will change the values of the members of <code class="language-plaintext highlighter-rouge">salmon</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fish_ptr</span> <span class="o">-&gt;</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
<span class="n">fish_ptr</span> <span class="o">-&gt;</span> <span class="n">weight</span> <span class="o">=</span> <span class="mi">6</span><span class="p">.</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>Now the <code class="language-plaintext highlighter-rouge">length</code> and <code class="language-plaintext highlighter-rouge">width</code> members in <code class="language-plaintext highlighter-rouge">salmon</code> are 5.1 and 6.2, respectively.</p>

<h3 id="5-dangling-void--null-and-wild-pointers">5. Dangling, Void , Null and Wild Pointers</h3>

<ul>
  <li>
    <p><strong>Dangling Pointer</strong></p>

    <p>A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. There are three different ways where Pointer acts as dangling pointer.</p>

    <ul>
      <li><strong><em>De-allocation of memory</em></strong></li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Deallocating a memory address by ptr causes dangling pointer</span>
  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>    
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

      <span class="c1">// After below free call, ptr becomes a dangling pointer</span>
      <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

      <span class="c1">// No more a dangling pointer</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p><strong><em>Function Call</em></strong></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// The pointer poiting to local variable becomes</span>
  <span class="c1">// dangling when local variable is not static.</span>
  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>        
  <span class="kt">int</span> <span class="o">*</span><span class="nf">fun</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="c1">// x is local variable and goes out of</span>
      <span class="c1">// scope after an execution of fun() is</span>
      <span class="c1">// over.</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
        
  <span class="c1">// Driver Code</span>
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">fun</span><span class="p">();</span>
      <span class="n">fflush</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
      <span class="c1">// p points to something which is not</span>
      <span class="c1">// valid anymore</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%p -&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <p>The above problem doesn’t appear (or p doesn’t become dangling) if <code class="language-plaintext highlighter-rouge">x</code> is a static vairable.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// The pointer poiting to local variable doesn't become</span>
  <span class="c1">// dangling when local variable is static.</span>
  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>        
  <span class="kt">int</span> <span class="o">*</span><span class="nf">fun</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="c1">// x now has scope througout the program</span>
      <span class="k">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
        
  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">fun</span><span class="p">();</span>
      <span class="n">fflush</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
      <span class="c1">// Not a dangling pointer as it points to static variable.</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%p -&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li><strong><em>Variable goes out of scope</em></strong></li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
      <span class="c1">// ...</span>
      <span class="c1">// ...</span>
      <span class="p">{</span>
          <span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
          <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// ...</span>
      <span class="c1">// Here ptr is dangling pointer</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Void pointer</strong></p>

    <p>Void pointer is a specific pointer type (<code class="language-plaintext highlighter-rouge">void *</code>), a pointer that points to some data location in storage, which doesn’t have any specific type. Void refers to the type. Basically the type of data that it points to is can be any. If we assign address of char data type to void pointer it will become char Pointer, if int data type then int pointer and so on. Any pointer type is convertible to a void pointer hence it can point to any value.</p>

    <p><strong><em>Important Points</em></strong></p>

    <ul>
      <li>
        <p>void pointers <strong>cannot be dereferenced</strong>. It can however be done using typecasting the void pointer.</p>
      </li>
      <li>
        <p>Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">malloc()</code> and <code class="language-plaintext highlighter-rouge">calloc()</code> return void * type and this allows these functions to be used to allocate memory of any data type (just because of void *)</p>
      </li>
      <li>
        <p>void pointer in C are used to implement generic funciton in C.</p>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
      <span class="c1">// A void pointer</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
      <span class="c1">// (int*)ptr - does type casting of void</span>
      <span class="c1">// *((int*)ptr) dereferences the typecasted void pointer variable</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Integer variable is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">));</span>
      <span class="c1">// void pointer is now float</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Float variable is %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">));</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>NULL Pointer</strong></p>

    <p>NULL Pointer is a pointer which is pointing to noting. In case, if we don’t have address to be assigned to a pointer, then we can simply use NULL.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// NULL Pointer</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"The value of ptr is %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p><strong><em>Important Points</em></strong></p>

        <ul>
          <li>
            <p><strong>NULL vs Unitialized Pointer</strong></p>

            <p>An unitialized pointer stores an undefined value. A null pointer stores a defined value, but one that is defined by the environment to not be a valid address for any member or object.</p>
          </li>
          <li>
            <p><strong>NULL vs Void Pointer</strong></p>

            <p>NULL pointer is a value, while void pointer is a type.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Wild Pointer</strong></p>

    <p>A pointer which has not been initialized to anything (not even NULL) is known as wild pointer. The pointer may be initialized to a non-NULL garbage value that may not be a valid address.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="cm">/* wild pointer */</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
      <span class="c1">// p is not a wild pointer now</span>
      <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h3 id="6-references">6. References</h3>

<ol>
  <li>
    <p><a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Pointers">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html</a></p>
  </li>
  <li>
    <p><a href="http://www.geeksforgeeks.org/dangling-void-null-wild-pointers/">http://www.geeksforgeeks.org/dangling-void-null-wild-pointers/</a></p>
  </li>
</ol>


<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
