<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Compile and Run C Program in Linux Using GCC | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Compile and Run C Program in Linux Using GCC" />
<meta property="og:locale" content="en" />
<meta name="description" content="Compile C Program in Linux - The Classic Hello World! 1. Preprocessing 2. Compilation 3. Assembly 4. Linking Static and Dynamic Link Libraries in C on Linux 1. What is Linker ? 2. What is Static Linking? 3. How to Create Static Libraries? 4. What is Dynamic Linking? 5. How to Create and Use Shared Libraries? References Compile C Program in Linux - The Classic Hello World! Kernighan and Ritchie (K &amp; R) in their classic book on C programming language acquaint readers to C language by compiling and executing “Hello World!” C program as follows. /* hello.c */ #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello World!\n&quot;); return 0; } The following command compiles C program hello.c and creates an executable file (which contains a sequence of instructions that a machine can unserstand). $ gcc hello.c -o hello While compiling hello.c the GCC compiler reads the source file hello.c and translates it into an executable hello. The compilation is performed in four sequential phases by the compilation system (a collection of four programs - preprocessor, compiler, assembler, and linker). 1. Preprocessing During compilation of a C program the compilation is started off with preprocessing the directives (e.g. #include and #define). The preprocessor (cpp - c preprocessor) is a separate program in reality, but it is invoked automatically by the compiler. The result is another file typically with the .i suffix. In pratice, the preprocessed file is not saved to disk unless the -save-temps option is used. This is the first stage of compilation process where preprocessor directives (macros and header files are most common) are expanded. To perform this step GCC executes the following command internally. $ cpp hello.c &gt; hello.i # gcc -E hello.c &gt; hello.i By default, the preprocessor looks for header files included by the quote form of the directive #include &quot;file&quot; first relative to the directory of the current file, and then in a preconfigured list of standard system directories. For example, if /usr/include/sys/stat.h contains #include &quot;types.h&quot;, GCC looks for types.h first in /usr/include/sys, then in its usual search path. For the angle-bracket form #include &lt;file&gt;, the preprocessor’s default behavior is to look only in the standard system directories. The exact search directory list depends on the target system, how GCC is configured, and where it is installed. You can find the default search directory list for your version of CPP by invoking it with the -v option. For example, cpp -v /dev/null -o /dev/null #include &quot;...&quot; search starts here: #include &lt;...&gt; search starts here: /usr/lib/gcc/x86_64-linux-gnu/8/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/8/include-fixed /usr/include/x86_64-linux-gnu /usr/include There are a number of command-line options you can use to add additional directories to the search path. The most commonly-used option is -Idir, which causes dir to be searched after the current directory (for the quote form of the directive) and ahead of the standard system directories. You can specify multiple -I options on the command line, in which case the directories are searched in left-to-right order. 2. Compilation In this phase compilation proper takes place. The compiler (cc1) translates hello.i into hello.s. File hello.s contains assembly code. You can explicitly tell GCC to translate hello.i to hello.s by executing the following command. $ /usr/lib/gcc/x86_64-linux-gnu/8/cc1 -quiet hello.i # gcc -S hello.i The command line option -S tells the compiler to convert the preprocessed code to assembly language without creating an object file. You may note the assembly code conatins a call to the external function printf (or puts on gcc version 8.3.0). 3. Assembly Here, the assembler (as) translates hello.s into machine language instructions, and generates an object file hello.o. You can invoke the assembler at your own by executing the following command. $ as hello.s -o hello.o # gcc -c hello.s The above command will generate hello.o as it is specified with -o option. And, the resulting file contains the machine instructions for classic “Hello World!” program, with an undefined reference to printf. 4. Linking This is the final stage in compilation of “Hello World!” program. This phase links objects files to produce final executable file. An executable file requires many external resources (system functions, C run-time libraries etc.). Regardings our “Hello World!” program you have noticed that it calls the printf funtion to print the ‘Hello World!’ message on console. This function is conatined in a separate pre compiled object printf.o, which must somehow be merged with out hello.o file. The linker (ld) performs this task for you. Eventually, the resulting file hello is produced, which is an executable. This is now ready to be loaded into memory and execute by the system. There is no need to type the complex ld command directly - the entire linking process is handled transparently by GCC when invoked, as follows. $ gcc hello.o -o hello And, you can greet the universe as follows: $ ./hello Output: Hello World! Static and Dynamic Link Libraries in C on Linux Static and dynamic linking are two processes of collecting and combining multiple object files in order to create a single executable. Linking can be performed at both compile time, when the source code is translated into machine code and load time, when the program is loaded into memory and executed by the loader, and even at run time, by application programs. And, it is performed by programs called linkers. Linkers are also called link editors. 1. What is Linker ? Linker is system software which plays curcial role in software development because it enables separate compilation. Instead of organizing a large application as one monolithic source file, you can decompose it into smaller, more manageable chunks that can be modified and compiled separately. When you change one of the modules, you simply recompile it and re-link the application, without recompiling the other source files. Linker as a system program takes relocatable object files and command line arguments in order to generate an executable object file. To produce an executable file the Linker has to perform the symbol resolution, and Relocation. Note: Object files come in three flavors viz Relocatable, Executable, and Shared. Relocatable object files contain code and data in a form which can be combined with other objects files of its kind at compile time to create an executable object file. They consist of various code and data sections. Instructions are in one section, initialized global variables in another section, and unitialized variables are yet in another section. Executable object files contain binary code and data in a form which can directly be copied into memory and executed. Shared object files are files those can be loaded into memory and linked dynamically, at either load or run time by a linker. While linking, the linker complains about missing function definitions, if there is any. During compilation, if compiler does not find a function definition for a particular module, it just assumes that the function is defined in another file, and treats it as an external reference. The compiler does not look at more than one file at a time. Whereas, linker may look at multiple files and seeks references for the modules that were not mentioned. The separate compilation and linking processes reduce the complexity of program and gives the ease to break code into smaller pieces which are better manageable. 2. What is Static Linking? Static linking is the process of copying all library modules used in the program into the final executable image. The linker combines library routines with the program code in order to resolve external references, and to generate an executable image suitable for loading into memory. This of course takes more space on the disk and in memory than dynamic linking. But static linking is faster and more portable because it does not require the presence of the library on the system where it runs. We will deveop an add module and place in a separate add.c file. Prototype of add module will be placed inn a separate file called add.h. Code file hello.c will be created to demonstrate the linking process. /* add.h */ int add(int , int); /* add.c */ int add(int a, int b) { return a + b; } /* hello.c */ #include &lt;stdio.h&gt; #include &lt;add.h&gt; int main(void) { int a = 3, b = 4; printf(&quot;%d + %d = %d\n&quot;, a, b, add(a, b)); return 0; } After having created above files, you can start building the executable as follows: $ gcc -I . -c hello.c The -I option tells GCC compiler to search for header files in the directory which is specified after it. The -c option tells GCC compiler to compile into an object file. It will stop after that and won’t perform the linking to create the executable. As similar to the above command, compile add.c to create the object file. $ gcc -c add.c Now the final step is to generate the executable by linking add.o, and hello.o together. $ gcc -o hello add.o hello.o 3. How to Create Static Libraries? A library contains hundreds or thousands of object files to keep the orgnaization of object files simple and maintainable. Static libraries are bundle of relocatable object files. Usually they have .a extension. For more explanatory demonstration of use of libraries we would create a new header file math.h and will add singatures of two functions add, sub to that. /* math.h */ int add(int, int); int sub(int, int); /* sub.c */ int sub(int a, int b) { return a - b; } Now compile add.c and sub.c as follows in order to get the binary object files. $ gcc -c add.c sub.c Create the static library libmath.a to collecting both add.o and sub.o files together by executing the following command: $ ar rs libmath.a add.o sub.o To use the sub funciton in hello we need to replace the #include &lt;math.h&gt; by #include &lt;math.h&gt; and recompile it. /* hello.c */ #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int a = 3, b = 4; printf(&quot;%d + %d = %2d\n&quot;, a, b, add(a, b)); printf(&quot;%d - %d = %2d\n&quot;, a, b, sub(a, b)); return 0; } $ gcc -c hello.c -I . And link it with libmath.a to generate final executable object file. $ gcc -o hello hello.o libmath.a You can also use the following command as an alternative to link the libmath.a with hello.o in order to generate the final executable file. $ gcc -o hello hello.o -L . -lmath In above command -lmath should be read as -l math which tells the linker to link the object files contained in lib&lt;library&gt;.a with hello.o to generate the executable object file. The -L option tells the linker to search for libraries in the following argument (similar to how we did for -I). 4. What is Dynamic Linking? Dynamic linking defers much of the linking process until a program starts running. During dynamic linking the name of the shared library is placed in the executable image, while the actual linking takes place at run time when both the executable and library are placed in memory. Dynamic linking serves the advantage of sharing a single shareable library among multiple programs. 5. How to Create and Use Shared Libraries? Let’s continue with the previous example of add, and sub modules. Now we will have to recompile both add.c and sub.c again with -fpic or -fPIC option. The -fpic or -fPIC option enable “position independent code” generation, a requirement for shared libraries, and used to generate code that is target-dependent. The -fPIC choice always works, but may produce larger code than -fpic. Using -fpic option usually generates smaller and faster code, but will have platform-dependent limitations. So, while creating shared library you have to recompile both add.c, and sub.c with following options: $ gcc -Wall -fPIC -c add.c sub.c Now build the library libmath.so using the following command. $ gcc -shared -o libmath.so add.o sub.o But to use a shared library is not as straightfoward as static library was. And, the simplest approach of installation is to copy the library into one of the standard directories (e.g., /usr/lib) and run ldconfig command. Now recompile hello.c and generate the executable object file as following: $ gcc -c hello.c -I . $ gcc -o hello hello.o libmath.so or $ gcc -o hello hello.o -L . -lmath You can list the shared library dependencies which your executable is depedent upon with ldd &lt;name-of-executable&gt; command. $ ldd hello linux-vdso.so.1 (0x00007ffdfdda2000) libmath.so =&gt; not found libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f318cde8000) /lib64/ld-linux-x86-64.so.2 (0x00007f318d193000) For more information about shared library, please refer to Linux Shared Library Management &amp; Debugging Problem. References C track: compiling C programs. GCC Compilation Process and Steps of C Program in Linux Create Static and Dynamic Library in C using GCC on Linux Search Path (The C Preprocessor)" />
<meta property="og:description" content="Compile C Program in Linux - The Classic Hello World! 1. Preprocessing 2. Compilation 3. Assembly 4. Linking Static and Dynamic Link Libraries in C on Linux 1. What is Linker ? 2. What is Static Linking? 3. How to Create Static Libraries? 4. What is Dynamic Linking? 5. How to Create and Use Shared Libraries? References Compile C Program in Linux - The Classic Hello World! Kernighan and Ritchie (K &amp; R) in their classic book on C programming language acquaint readers to C language by compiling and executing “Hello World!” C program as follows. /* hello.c */ #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello World!\n&quot;); return 0; } The following command compiles C program hello.c and creates an executable file (which contains a sequence of instructions that a machine can unserstand). $ gcc hello.c -o hello While compiling hello.c the GCC compiler reads the source file hello.c and translates it into an executable hello. The compilation is performed in four sequential phases by the compilation system (a collection of four programs - preprocessor, compiler, assembler, and linker). 1. Preprocessing During compilation of a C program the compilation is started off with preprocessing the directives (e.g. #include and #define). The preprocessor (cpp - c preprocessor) is a separate program in reality, but it is invoked automatically by the compiler. The result is another file typically with the .i suffix. In pratice, the preprocessed file is not saved to disk unless the -save-temps option is used. This is the first stage of compilation process where preprocessor directives (macros and header files are most common) are expanded. To perform this step GCC executes the following command internally. $ cpp hello.c &gt; hello.i # gcc -E hello.c &gt; hello.i By default, the preprocessor looks for header files included by the quote form of the directive #include &quot;file&quot; first relative to the directory of the current file, and then in a preconfigured list of standard system directories. For example, if /usr/include/sys/stat.h contains #include &quot;types.h&quot;, GCC looks for types.h first in /usr/include/sys, then in its usual search path. For the angle-bracket form #include &lt;file&gt;, the preprocessor’s default behavior is to look only in the standard system directories. The exact search directory list depends on the target system, how GCC is configured, and where it is installed. You can find the default search directory list for your version of CPP by invoking it with the -v option. For example, cpp -v /dev/null -o /dev/null #include &quot;...&quot; search starts here: #include &lt;...&gt; search starts here: /usr/lib/gcc/x86_64-linux-gnu/8/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/8/include-fixed /usr/include/x86_64-linux-gnu /usr/include There are a number of command-line options you can use to add additional directories to the search path. The most commonly-used option is -Idir, which causes dir to be searched after the current directory (for the quote form of the directive) and ahead of the standard system directories. You can specify multiple -I options on the command line, in which case the directories are searched in left-to-right order. 2. Compilation In this phase compilation proper takes place. The compiler (cc1) translates hello.i into hello.s. File hello.s contains assembly code. You can explicitly tell GCC to translate hello.i to hello.s by executing the following command. $ /usr/lib/gcc/x86_64-linux-gnu/8/cc1 -quiet hello.i # gcc -S hello.i The command line option -S tells the compiler to convert the preprocessed code to assembly language without creating an object file. You may note the assembly code conatins a call to the external function printf (or puts on gcc version 8.3.0). 3. Assembly Here, the assembler (as) translates hello.s into machine language instructions, and generates an object file hello.o. You can invoke the assembler at your own by executing the following command. $ as hello.s -o hello.o # gcc -c hello.s The above command will generate hello.o as it is specified with -o option. And, the resulting file contains the machine instructions for classic “Hello World!” program, with an undefined reference to printf. 4. Linking This is the final stage in compilation of “Hello World!” program. This phase links objects files to produce final executable file. An executable file requires many external resources (system functions, C run-time libraries etc.). Regardings our “Hello World!” program you have noticed that it calls the printf funtion to print the ‘Hello World!’ message on console. This function is conatined in a separate pre compiled object printf.o, which must somehow be merged with out hello.o file. The linker (ld) performs this task for you. Eventually, the resulting file hello is produced, which is an executable. This is now ready to be loaded into memory and execute by the system. There is no need to type the complex ld command directly - the entire linking process is handled transparently by GCC when invoked, as follows. $ gcc hello.o -o hello And, you can greet the universe as follows: $ ./hello Output: Hello World! Static and Dynamic Link Libraries in C on Linux Static and dynamic linking are two processes of collecting and combining multiple object files in order to create a single executable. Linking can be performed at both compile time, when the source code is translated into machine code and load time, when the program is loaded into memory and executed by the loader, and even at run time, by application programs. And, it is performed by programs called linkers. Linkers are also called link editors. 1. What is Linker ? Linker is system software which plays curcial role in software development because it enables separate compilation. Instead of organizing a large application as one monolithic source file, you can decompose it into smaller, more manageable chunks that can be modified and compiled separately. When you change one of the modules, you simply recompile it and re-link the application, without recompiling the other source files. Linker as a system program takes relocatable object files and command line arguments in order to generate an executable object file. To produce an executable file the Linker has to perform the symbol resolution, and Relocation. Note: Object files come in three flavors viz Relocatable, Executable, and Shared. Relocatable object files contain code and data in a form which can be combined with other objects files of its kind at compile time to create an executable object file. They consist of various code and data sections. Instructions are in one section, initialized global variables in another section, and unitialized variables are yet in another section. Executable object files contain binary code and data in a form which can directly be copied into memory and executed. Shared object files are files those can be loaded into memory and linked dynamically, at either load or run time by a linker. While linking, the linker complains about missing function definitions, if there is any. During compilation, if compiler does not find a function definition for a particular module, it just assumes that the function is defined in another file, and treats it as an external reference. The compiler does not look at more than one file at a time. Whereas, linker may look at multiple files and seeks references for the modules that were not mentioned. The separate compilation and linking processes reduce the complexity of program and gives the ease to break code into smaller pieces which are better manageable. 2. What is Static Linking? Static linking is the process of copying all library modules used in the program into the final executable image. The linker combines library routines with the program code in order to resolve external references, and to generate an executable image suitable for loading into memory. This of course takes more space on the disk and in memory than dynamic linking. But static linking is faster and more portable because it does not require the presence of the library on the system where it runs. We will deveop an add module and place in a separate add.c file. Prototype of add module will be placed inn a separate file called add.h. Code file hello.c will be created to demonstrate the linking process. /* add.h */ int add(int , int); /* add.c */ int add(int a, int b) { return a + b; } /* hello.c */ #include &lt;stdio.h&gt; #include &lt;add.h&gt; int main(void) { int a = 3, b = 4; printf(&quot;%d + %d = %d\n&quot;, a, b, add(a, b)); return 0; } After having created above files, you can start building the executable as follows: $ gcc -I . -c hello.c The -I option tells GCC compiler to search for header files in the directory which is specified after it. The -c option tells GCC compiler to compile into an object file. It will stop after that and won’t perform the linking to create the executable. As similar to the above command, compile add.c to create the object file. $ gcc -c add.c Now the final step is to generate the executable by linking add.o, and hello.o together. $ gcc -o hello add.o hello.o 3. How to Create Static Libraries? A library contains hundreds or thousands of object files to keep the orgnaization of object files simple and maintainable. Static libraries are bundle of relocatable object files. Usually they have .a extension. For more explanatory demonstration of use of libraries we would create a new header file math.h and will add singatures of two functions add, sub to that. /* math.h */ int add(int, int); int sub(int, int); /* sub.c */ int sub(int a, int b) { return a - b; } Now compile add.c and sub.c as follows in order to get the binary object files. $ gcc -c add.c sub.c Create the static library libmath.a to collecting both add.o and sub.o files together by executing the following command: $ ar rs libmath.a add.o sub.o To use the sub funciton in hello we need to replace the #include &lt;math.h&gt; by #include &lt;math.h&gt; and recompile it. /* hello.c */ #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int a = 3, b = 4; printf(&quot;%d + %d = %2d\n&quot;, a, b, add(a, b)); printf(&quot;%d - %d = %2d\n&quot;, a, b, sub(a, b)); return 0; } $ gcc -c hello.c -I . And link it with libmath.a to generate final executable object file. $ gcc -o hello hello.o libmath.a You can also use the following command as an alternative to link the libmath.a with hello.o in order to generate the final executable file. $ gcc -o hello hello.o -L . -lmath In above command -lmath should be read as -l math which tells the linker to link the object files contained in lib&lt;library&gt;.a with hello.o to generate the executable object file. The -L option tells the linker to search for libraries in the following argument (similar to how we did for -I). 4. What is Dynamic Linking? Dynamic linking defers much of the linking process until a program starts running. During dynamic linking the name of the shared library is placed in the executable image, while the actual linking takes place at run time when both the executable and library are placed in memory. Dynamic linking serves the advantage of sharing a single shareable library among multiple programs. 5. How to Create and Use Shared Libraries? Let’s continue with the previous example of add, and sub modules. Now we will have to recompile both add.c and sub.c again with -fpic or -fPIC option. The -fpic or -fPIC option enable “position independent code” generation, a requirement for shared libraries, and used to generate code that is target-dependent. The -fPIC choice always works, but may produce larger code than -fpic. Using -fpic option usually generates smaller and faster code, but will have platform-dependent limitations. So, while creating shared library you have to recompile both add.c, and sub.c with following options: $ gcc -Wall -fPIC -c add.c sub.c Now build the library libmath.so using the following command. $ gcc -shared -o libmath.so add.o sub.o But to use a shared library is not as straightfoward as static library was. And, the simplest approach of installation is to copy the library into one of the standard directories (e.g., /usr/lib) and run ldconfig command. Now recompile hello.c and generate the executable object file as following: $ gcc -c hello.c -I . $ gcc -o hello hello.o libmath.so or $ gcc -o hello hello.o -L . -lmath You can list the shared library dependencies which your executable is depedent upon with ldd &lt;name-of-executable&gt; command. $ ldd hello linux-vdso.so.1 (0x00007ffdfdda2000) libmath.so =&gt; not found libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f318cde8000) /lib64/ld-linux-x86-64.so.2 (0x00007f318d193000) For more information about shared library, please refer to Linux Shared Library Management &amp; Debugging Problem. References C track: compiling C programs. GCC Compilation Process and Steps of C Program in Linux Create Static and Dynamic Library in C using GCC on Linux Search Path (The C Preprocessor)" />
<link rel="canonical" href="https://blog.codefarm.me/2017/03/14/compile-and-run-c-program-in-linux-using-gcc/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/03/14/compile-and-run-c-program-in-linux-using-gcc/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-14T15:41:52+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Compile and Run C Program in Linux Using GCC" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-03-14T15:41:52+08:00","datePublished":"2017-03-14T15:41:52+08:00","description":"Compile C Program in Linux - The Classic Hello World! 1. Preprocessing 2. Compilation 3. Assembly 4. Linking Static and Dynamic Link Libraries in C on Linux 1. What is Linker ? 2. What is Static Linking? 3. How to Create Static Libraries? 4. What is Dynamic Linking? 5. How to Create and Use Shared Libraries? References Compile C Program in Linux - The Classic Hello World! Kernighan and Ritchie (K &amp; R) in their classic book on C programming language acquaint readers to C language by compiling and executing “Hello World!” C program as follows. /* hello.c */ #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello World!\\n&quot;); return 0; } The following command compiles C program hello.c and creates an executable file (which contains a sequence of instructions that a machine can unserstand). $ gcc hello.c -o hello While compiling hello.c the GCC compiler reads the source file hello.c and translates it into an executable hello. The compilation is performed in four sequential phases by the compilation system (a collection of four programs - preprocessor, compiler, assembler, and linker). 1. Preprocessing During compilation of a C program the compilation is started off with preprocessing the directives (e.g. #include and #define). The preprocessor (cpp - c preprocessor) is a separate program in reality, but it is invoked automatically by the compiler. The result is another file typically with the .i suffix. In pratice, the preprocessed file is not saved to disk unless the -save-temps option is used. This is the first stage of compilation process where preprocessor directives (macros and header files are most common) are expanded. To perform this step GCC executes the following command internally. $ cpp hello.c &gt; hello.i # gcc -E hello.c &gt; hello.i By default, the preprocessor looks for header files included by the quote form of the directive #include &quot;file&quot; first relative to the directory of the current file, and then in a preconfigured list of standard system directories. For example, if /usr/include/sys/stat.h contains #include &quot;types.h&quot;, GCC looks for types.h first in /usr/include/sys, then in its usual search path. For the angle-bracket form #include &lt;file&gt;, the preprocessor’s default behavior is to look only in the standard system directories. The exact search directory list depends on the target system, how GCC is configured, and where it is installed. You can find the default search directory list for your version of CPP by invoking it with the -v option. For example, cpp -v /dev/null -o /dev/null #include &quot;...&quot; search starts here: #include &lt;...&gt; search starts here: /usr/lib/gcc/x86_64-linux-gnu/8/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/8/include-fixed /usr/include/x86_64-linux-gnu /usr/include There are a number of command-line options you can use to add additional directories to the search path. The most commonly-used option is -Idir, which causes dir to be searched after the current directory (for the quote form of the directive) and ahead of the standard system directories. You can specify multiple -I options on the command line, in which case the directories are searched in left-to-right order. 2. Compilation In this phase compilation proper takes place. The compiler (cc1) translates hello.i into hello.s. File hello.s contains assembly code. You can explicitly tell GCC to translate hello.i to hello.s by executing the following command. $ /usr/lib/gcc/x86_64-linux-gnu/8/cc1 -quiet hello.i # gcc -S hello.i The command line option -S tells the compiler to convert the preprocessed code to assembly language without creating an object file. You may note the assembly code conatins a call to the external function printf (or puts on gcc version 8.3.0). 3. Assembly Here, the assembler (as) translates hello.s into machine language instructions, and generates an object file hello.o. You can invoke the assembler at your own by executing the following command. $ as hello.s -o hello.o # gcc -c hello.s The above command will generate hello.o as it is specified with -o option. And, the resulting file contains the machine instructions for classic “Hello World!” program, with an undefined reference to printf. 4. Linking This is the final stage in compilation of “Hello World!” program. This phase links objects files to produce final executable file. An executable file requires many external resources (system functions, C run-time libraries etc.). Regardings our “Hello World!” program you have noticed that it calls the printf funtion to print the ‘Hello World!’ message on console. This function is conatined in a separate pre compiled object printf.o, which must somehow be merged with out hello.o file. The linker (ld) performs this task for you. Eventually, the resulting file hello is produced, which is an executable. This is now ready to be loaded into memory and execute by the system. There is no need to type the complex ld command directly - the entire linking process is handled transparently by GCC when invoked, as follows. $ gcc hello.o -o hello And, you can greet the universe as follows: $ ./hello Output: Hello World! Static and Dynamic Link Libraries in C on Linux Static and dynamic linking are two processes of collecting and combining multiple object files in order to create a single executable. Linking can be performed at both compile time, when the source code is translated into machine code and load time, when the program is loaded into memory and executed by the loader, and even at run time, by application programs. And, it is performed by programs called linkers. Linkers are also called link editors. 1. What is Linker ? Linker is system software which plays curcial role in software development because it enables separate compilation. Instead of organizing a large application as one monolithic source file, you can decompose it into smaller, more manageable chunks that can be modified and compiled separately. When you change one of the modules, you simply recompile it and re-link the application, without recompiling the other source files. Linker as a system program takes relocatable object files and command line arguments in order to generate an executable object file. To produce an executable file the Linker has to perform the symbol resolution, and Relocation. Note: Object files come in three flavors viz Relocatable, Executable, and Shared. Relocatable object files contain code and data in a form which can be combined with other objects files of its kind at compile time to create an executable object file. They consist of various code and data sections. Instructions are in one section, initialized global variables in another section, and unitialized variables are yet in another section. Executable object files contain binary code and data in a form which can directly be copied into memory and executed. Shared object files are files those can be loaded into memory and linked dynamically, at either load or run time by a linker. While linking, the linker complains about missing function definitions, if there is any. During compilation, if compiler does not find a function definition for a particular module, it just assumes that the function is defined in another file, and treats it as an external reference. The compiler does not look at more than one file at a time. Whereas, linker may look at multiple files and seeks references for the modules that were not mentioned. The separate compilation and linking processes reduce the complexity of program and gives the ease to break code into smaller pieces which are better manageable. 2. What is Static Linking? Static linking is the process of copying all library modules used in the program into the final executable image. The linker combines library routines with the program code in order to resolve external references, and to generate an executable image suitable for loading into memory. This of course takes more space on the disk and in memory than dynamic linking. But static linking is faster and more portable because it does not require the presence of the library on the system where it runs. We will deveop an add module and place in a separate add.c file. Prototype of add module will be placed inn a separate file called add.h. Code file hello.c will be created to demonstrate the linking process. /* add.h */ int add(int , int); /* add.c */ int add(int a, int b) { return a + b; } /* hello.c */ #include &lt;stdio.h&gt; #include &lt;add.h&gt; int main(void) { int a = 3, b = 4; printf(&quot;%d + %d = %d\\n&quot;, a, b, add(a, b)); return 0; } After having created above files, you can start building the executable as follows: $ gcc -I . -c hello.c The -I option tells GCC compiler to search for header files in the directory which is specified after it. The -c option tells GCC compiler to compile into an object file. It will stop after that and won’t perform the linking to create the executable. As similar to the above command, compile add.c to create the object file. $ gcc -c add.c Now the final step is to generate the executable by linking add.o, and hello.o together. $ gcc -o hello add.o hello.o 3. How to Create Static Libraries? A library contains hundreds or thousands of object files to keep the orgnaization of object files simple and maintainable. Static libraries are bundle of relocatable object files. Usually they have .a extension. For more explanatory demonstration of use of libraries we would create a new header file math.h and will add singatures of two functions add, sub to that. /* math.h */ int add(int, int); int sub(int, int); /* sub.c */ int sub(int a, int b) { return a - b; } Now compile add.c and sub.c as follows in order to get the binary object files. $ gcc -c add.c sub.c Create the static library libmath.a to collecting both add.o and sub.o files together by executing the following command: $ ar rs libmath.a add.o sub.o To use the sub funciton in hello we need to replace the #include &lt;math.h&gt; by #include &lt;math.h&gt; and recompile it. /* hello.c */ #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int a = 3, b = 4; printf(&quot;%d + %d = %2d\\n&quot;, a, b, add(a, b)); printf(&quot;%d - %d = %2d\\n&quot;, a, b, sub(a, b)); return 0; } $ gcc -c hello.c -I . And link it with libmath.a to generate final executable object file. $ gcc -o hello hello.o libmath.a You can also use the following command as an alternative to link the libmath.a with hello.o in order to generate the final executable file. $ gcc -o hello hello.o -L . -lmath In above command -lmath should be read as -l math which tells the linker to link the object files contained in lib&lt;library&gt;.a with hello.o to generate the executable object file. The -L option tells the linker to search for libraries in the following argument (similar to how we did for -I). 4. What is Dynamic Linking? Dynamic linking defers much of the linking process until a program starts running. During dynamic linking the name of the shared library is placed in the executable image, while the actual linking takes place at run time when both the executable and library are placed in memory. Dynamic linking serves the advantage of sharing a single shareable library among multiple programs. 5. How to Create and Use Shared Libraries? Let’s continue with the previous example of add, and sub modules. Now we will have to recompile both add.c and sub.c again with -fpic or -fPIC option. The -fpic or -fPIC option enable “position independent code” generation, a requirement for shared libraries, and used to generate code that is target-dependent. The -fPIC choice always works, but may produce larger code than -fpic. Using -fpic option usually generates smaller and faster code, but will have platform-dependent limitations. So, while creating shared library you have to recompile both add.c, and sub.c with following options: $ gcc -Wall -fPIC -c add.c sub.c Now build the library libmath.so using the following command. $ gcc -shared -o libmath.so add.o sub.o But to use a shared library is not as straightfoward as static library was. And, the simplest approach of installation is to copy the library into one of the standard directories (e.g., /usr/lib) and run ldconfig command. Now recompile hello.c and generate the executable object file as following: $ gcc -c hello.c -I . $ gcc -o hello hello.o libmath.so or $ gcc -o hello hello.o -L . -lmath You can list the shared library dependencies which your executable is depedent upon with ldd &lt;name-of-executable&gt; command. $ ldd hello linux-vdso.so.1 (0x00007ffdfdda2000) libmath.so =&gt; not found libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f318cde8000) /lib64/ld-linux-x86-64.so.2 (0x00007f318d193000) For more information about shared library, please refer to Linux Shared Library Management &amp; Debugging Problem. References C track: compiling C programs. GCC Compilation Process and Steps of C Program in Linux Create Static and Dynamic Library in C using GCC on Linux Search Path (The C Preprocessor)","headline":"Compile and Run C Program in Linux Using GCC","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/03/14/compile-and-run-c-program-in-linux-using-gcc/"},"url":"https://blog.codefarm.me/2017/03/14/compile-and-run-c-program-in-linux-using-gcc/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Compile and Run C Program in Linux Using GCC</h1><p class="c-post-meta">14 Mar 2017</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#compile-c-program-in-linux---the-classic-hello-world" id="markdown-toc-compile-c-program-in-linux---the-classic-hello-world">Compile C Program in Linux - The Classic Hello World!</a>    <ul>
      <li><a href="#1-preprocessing" id="markdown-toc-1-preprocessing">1. Preprocessing</a></li>
      <li><a href="#2-compilation" id="markdown-toc-2-compilation">2. Compilation</a></li>
      <li><a href="#3-assembly" id="markdown-toc-3-assembly">3. Assembly</a></li>
      <li><a href="#4-linking" id="markdown-toc-4-linking">4. Linking</a></li>
    </ul>
  </li>
  <li><a href="#static-and-dynamic-link-libraries-in-c-on-linux" id="markdown-toc-static-and-dynamic-link-libraries-in-c-on-linux">Static and Dynamic Link Libraries in C on Linux</a>    <ul>
      <li><a href="#1-what-is-linker-" id="markdown-toc-1-what-is-linker-">1. What is Linker ?</a></li>
      <li><a href="#2-what-is-static-linking" id="markdown-toc-2-what-is-static-linking">2. What is Static Linking?</a></li>
      <li><a href="#3-how-to-create-static-libraries" id="markdown-toc-3-how-to-create-static-libraries">3. How to Create Static Libraries?</a></li>
      <li><a href="#4-what-is-dynamic-linking" id="markdown-toc-4-what-is-dynamic-linking">4. What is Dynamic Linking?</a></li>
      <li><a href="#5-how-to-create-and-use-shared-libraries" id="markdown-toc-5-how-to-create-and-use-shared-libraries">5. How to Create and Use Shared Libraries?</a></li>
    </ul>
  </li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<hr />

<h3 id="compile-c-program-in-linux---the-classic-hello-world">Compile C Program in Linux - The Classic Hello World!</h3>

<p>Kernighan and Ritchie (K &amp; R) in their classic book on C programming language acquaint readers to C language by compiling and executing “Hello World!” C program as follows.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* hello.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello World!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following command compiles C program <code class="language-plaintext highlighter-rouge">hello.c</code> and creates an executable file (which contains a sequence of instructions that a machine can unserstand).</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc hello.c <span class="nt">-o</span> hello
</code></pre></div></div>

<p>While compiling <code class="language-plaintext highlighter-rouge">hello.c</code> the <em>GCC</em> compiler reads the source file <code class="language-plaintext highlighter-rouge">hello.c</code> and translates it into an executable <code class="language-plaintext highlighter-rouge">hello</code>. The compilation is performed in four sequential phases by the compilation system (a collection of four programs - <em>preprocessor</em>, <em>compiler</em>, <em>assembler</em>, and <em>linker</em>).</p>

<h4 id="1-preprocessing">1. Preprocessing</h4>

<p>During compilation of a C program the compilation is started off with preprocessing the directives (e.g. <code class="language-plaintext highlighter-rouge">#include</code> and <code class="language-plaintext highlighter-rouge">#define</code>). The preprocessor (<strong>cpp</strong> - c preprocessor) is a separate program in reality, but it is invoked automatically by the compiler. The result is another file typically with the <code class="language-plaintext highlighter-rouge">.i</code> suffix. In pratice, the preprocessed file is not saved to disk unless the <code class="language-plaintext highlighter-rouge">-save-temps</code> option is used.</p>

<p>This is the first stage of compilation process where preprocessor directives (macros and header files are most common) are expanded. To perform this step GCC executes the following command internally.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>cpp hello.c <span class="o">&gt;</span> hello.i <span class="c"># gcc -E hello.c &gt; hello.i</span>
</code></pre></div></div>

<p>By default, the preprocessor looks for <em>header files</em> included by the quote form of the directive <code class="language-plaintext highlighter-rouge">#include "file"</code> first relative to the directory of the current file, and then in a preconfigured list of standard system directories. For example, if <em>/usr/include/sys/stat.h</em> contains <code class="language-plaintext highlighter-rouge">#include "types.h"</code>, GCC looks for <em>types.h</em> first in <em>/usr/include/sys</em>, then in its usual search path.</p>

<p>For the angle-bracket form <code class="language-plaintext highlighter-rouge">#include &lt;file&gt;</code>, the preprocessor’s default behavior is to look only in the standard system directories. The exact search directory list depends on the target system, how GCC is configured, and where it is installed. You can find the default search directory list for your version of CPP by invoking it with the <em>-v</em> option. For example,</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpp <span class="nt">-v</span> /dev/null <span class="nt">-o</span> /dev/null
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span>include <span class="s2">"..."</span> search starts here:
<span class="gp">#</span>include &lt;...&gt; search starts here:
<span class="go"> /usr/lib/gcc/x86_64-linux-gnu/8/include
 /usr/local/include
 /usr/lib/gcc/x86_64-linux-gnu/8/include-fixed
 /usr/include/x86_64-linux-gnu
 /usr/include
</span></code></pre></div></div>

<p>There are a number of command-line options you can use to add additional directories to the search path. The most commonly-used option is <code class="language-plaintext highlighter-rouge">-Idir</code>, which causes dir to be searched after the current directory (for the quote form of the directive) and ahead of the standard system directories. You can specify multiple <code class="language-plaintext highlighter-rouge">-I</code> options on the command line, in which case the directories are searched in left-to-right order.</p>

<h4 id="2-compilation">2. Compilation</h4>

<p>In this phase compilation proper takes place. The compiler (<strong>cc1</strong>) translates <code class="language-plaintext highlighter-rouge">hello.i</code> into <code class="language-plaintext highlighter-rouge">hello.s</code>. File <code class="language-plaintext highlighter-rouge">hello.s</code> contains assembly code. You can explicitly tell <em>GCC</em> to translate <code class="language-plaintext highlighter-rouge">hello.i</code> to <code class="language-plaintext highlighter-rouge">hello.s</code> by executing the following command.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>/usr/lib/gcc/x86_64-linux-gnu/8/cc1 <span class="nt">-quiet</span> hello.i <span class="c"># gcc -S hello.i</span>
</code></pre></div></div>

<p>The command line option <code class="language-plaintext highlighter-rouge">-S</code> tells the compiler to convert the preprocessed code to assembly language without creating an object file. You may note the assembly code conatins a call to the external function <code class="language-plaintext highlighter-rouge">printf</code> (or <code class="language-plaintext highlighter-rouge">puts</code> on <em>gcc version 8.3.0</em>).</p>

<h4 id="3-assembly">3. Assembly</h4>

<p>Here, the assembler (<strong>as</strong>) translates <code class="language-plaintext highlighter-rouge">hello.s</code> into machine language instructions, and generates an object file <code class="language-plaintext highlighter-rouge">hello.o</code>. You can invoke the assembler at your own by executing the following command.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>as hello.s <span class="nt">-o</span> hello.o <span class="c"># gcc -c hello.s</span>
</code></pre></div></div>

<p>The above command will generate <code class="language-plaintext highlighter-rouge">hello.o</code> as it is specified with <code class="language-plaintext highlighter-rouge">-o</code> option. And, the resulting file contains the machine instructions for classic “Hello World!” program, with an undefined reference to <code class="language-plaintext highlighter-rouge">printf</code>.</p>

<h4 id="4-linking">4. Linking</h4>

<p>This is the final stage in compilation of “Hello World!” program. This phase links objects files to produce final executable file. An executable file requires many external resources (system functions, C run-time libraries etc.). Regardings our “Hello World!” program you have noticed that it calls the <code class="language-plaintext highlighter-rouge">printf</code> funtion to print the ‘Hello World!’ message on console. This function is conatined in a separate pre compiled object <code class="language-plaintext highlighter-rouge">printf.o</code>, which must somehow be merged with out <code class="language-plaintext highlighter-rouge">hello.o</code> file. The linker (<strong>ld</strong>) performs this task for you. Eventually, the resulting file <code class="language-plaintext highlighter-rouge">hello</code> is produced, which is an executable. This is now ready to be loaded into memory and execute by the system.</p>

<p>There is no need to type the complex <code class="language-plaintext highlighter-rouge">ld</code> command directly - the entire linking process is handled transparently by <em>GCC</em> when invoked, as follows.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc hello.o <span class="nt">-o</span> hello
</code></pre></div></div>

<p>And, you can greet the universe as follows:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./hello
</code></pre></div></div>

<p>Output:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello World!
</code></pre></div></div>

<hr />

<h3 id="static-and-dynamic-link-libraries-in-c-on-linux">Static and Dynamic Link Libraries in C on Linux</h3>

<p>Static and dynamic linking are two processes of collecting and combining multiple object files in order to create a single executable. Linking can be performed at both <strong>compile time</strong>, when the source code is translated into machine code and <strong>load time</strong>, when the program is loaded into memory and executed by the loader, and even at <strong>run time</strong>, by application programs. And, it is performed by programs called <strong>linkers</strong>. Linkers are also called link editors.</p>

<h4 id="1-what-is-linker-">1. What is Linker ?</h4>

<p>Linker is system software which plays curcial role in software development because it enables separate compilation. Instead of organizing a large application as one monolithic source file, you can decompose it into smaller, more manageable chunks that can be modified and compiled separately. When you change one of the modules, you simply recompile it and re-link the application, without recompiling the other source files.</p>

<p>Linker as a system program takes relocatable object files and command line arguments in order to generate an executable object file. To produce an executable file the Linker has to perform the symbol resolution, and Relocation.</p>

<p>Note: Object files come in three flavors viz Relocatable, Executable, and Shared.</p>

<ul>
  <li><strong>Relocatable object files</strong> contain code and data in a form which can be combined with other objects files of its kind at compile time to create an executable object file. They consist of various code and data sections. Instructions are in one section, initialized global variables in another section, and unitialized variables are yet in another section.</li>
  <li><strong>Executable object files</strong> contain binary code and data in a form which can directly be copied into memory and executed.</li>
  <li><strong>Shared object files</strong> are files those can be loaded into memory and linked dynamically, at either load or run time by a linker.</li>
</ul>

<p>While linking, the linker complains about missing function definitions, if there is any. During compilation, if compiler does not find a function definition for a particular module, it just assumes that the function is defined in another file, and treats it as an <strong>external reference</strong>. The compiler does not look at more than one file at a time. Whereas, linker may look at multiple files and seeks references for the modules that were not mentioned. The separate compilation and linking processes reduce the complexity of program and gives the ease to break code into smaller pieces which are better manageable.</p>

<h4 id="2-what-is-static-linking">2. What is Static Linking?</h4>

<p>Static linking is the process of copying all library modules used in the program into the final executable image. The linker combines library routines with the program code in order to resolve external references, and to generate an executable image suitable for loading into memory. This of course takes more space on the disk and in memory than dynamic linking. But static linking is faster and more portable because it does not require the presence of the library on the system where it runs.</p>

<p>We will deveop an <code class="language-plaintext highlighter-rouge">add</code> module and place in a separate <code class="language-plaintext highlighter-rouge">add.c</code> file. Prototype of <code class="language-plaintext highlighter-rouge">add</code> module will be placed inn a separate file called <code class="language-plaintext highlighter-rouge">add.h</code>. Code file <code class="language-plaintext highlighter-rouge">hello.c</code> will be created to demonstrate the linking process.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* add.h */</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* add.c */</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* hello.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;add.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d + %d = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After having created above files, you can start building the executable as follows:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-I</span> <span class="nb">.</span> <span class="nt">-c</span> hello.c
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">-I</code> option tells <em>GCC</em> compiler to search for header files in the directory which is specified after it.</p>

<p>The <code class="language-plaintext highlighter-rouge">-c</code> option tells <em>GCC</em> compiler to compile into an object file. It will stop after that and won’t perform the linking to create the executable.</p>

<p>As similar to the above command, compile <code class="language-plaintext highlighter-rouge">add.c</code> to create the object file.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-c</span> add.c
</code></pre></div></div>

<p>Now the final step is to generate the executable by linking <code class="language-plaintext highlighter-rouge">add.o</code>, and <code class="language-plaintext highlighter-rouge">hello.o</code> together.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> hello add.o hello.o
</code></pre></div></div>

<h4 id="3-how-to-create-static-libraries">3. How to Create Static Libraries?</h4>

<p>A library contains hundreds or thousands of object files to keep the orgnaization of object files simple and maintainable.</p>

<p>Static libraries are bundle of <em>relocatable</em> object files. Usually they have <code class="language-plaintext highlighter-rouge">.a</code> extension.</p>

<p>For more explanatory demonstration of use of libraries we would create a new header file <code class="language-plaintext highlighter-rouge">math.h</code> and will add singatures of two functions <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code> to that.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* math.h */</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sub</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/* sub.c */</span>

<span class="kt">int</span> <span class="nf">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now compile <code class="language-plaintext highlighter-rouge">add.c</code> and <code class="language-plaintext highlighter-rouge">sub.c</code> as follows in order to get the binary object files.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-c</span> add.c sub.c
</code></pre></div></div>

<p>Create the static library <code class="language-plaintext highlighter-rouge">libmath.a</code> to collecting both <code class="language-plaintext highlighter-rouge">add.o</code> and <code class="language-plaintext highlighter-rouge">sub.o</code> files together by executing the following command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ar rs libmath.a add.o sub.o
</code></pre></div></div>

<p>To use the <code class="language-plaintext highlighter-rouge">sub</code> funciton in <code class="language-plaintext highlighter-rouge">hello</code> we need to replace the <code class="language-plaintext highlighter-rouge">#include &lt;math.h&gt;</code> by <code class="language-plaintext highlighter-rouge">#include &lt;math.h&gt;</code> and recompile it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* hello.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d + %d = %2d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d - %d = %2d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-c</span> hello.c <span class="nt">-I</span> <span class="nb">.</span>
</code></pre></div></div>

<p>And link it with <code class="language-plaintext highlighter-rouge">libmath.a</code> to generate final executable object file.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> hello hello.o libmath.a
</code></pre></div></div>

<p>You can also use the following command as an alternative to link the <code class="language-plaintext highlighter-rouge">libmath.a</code> with <code class="language-plaintext highlighter-rouge">hello.o</code> in order to generate the final executable file.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> hello hello.o <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lmath</span>
</code></pre></div></div>

<p>In above command <code class="language-plaintext highlighter-rouge">-lmath</code> should be read as <code class="language-plaintext highlighter-rouge">-l math</code> which tells the linker to link the object files contained in <code class="language-plaintext highlighter-rouge">lib&lt;library&gt;.a</code> with <code class="language-plaintext highlighter-rouge">hello.o</code> to generate the executable object file.</p>

<p>The <code class="language-plaintext highlighter-rouge">-L</code> option tells the linker to search for libraries in the following argument (similar to how we did for <code class="language-plaintext highlighter-rouge">-I</code>).</p>

<h4 id="4-what-is-dynamic-linking">4. What is Dynamic Linking?</h4>

<p>Dynamic linking defers much of the linking process until a program starts running. During dynamic linking the name of the shared library is placed in the executable image, while the actual linking takes place at run time when both the executable and library are placed in memory. Dynamic linking serves the advantage of sharing a single shareable library among multiple programs.</p>

<h4 id="5-how-to-create-and-use-shared-libraries">5. How to Create and Use Shared Libraries?</h4>

<p>Let’s continue with the previous example of <code class="language-plaintext highlighter-rouge">add</code>, and <code class="language-plaintext highlighter-rouge">sub</code> modules. Now we will have to recompile both <code class="language-plaintext highlighter-rouge">add.c</code> and <code class="language-plaintext highlighter-rouge">sub.c</code> again with <code class="language-plaintext highlighter-rouge">-fpic</code> or <code class="language-plaintext highlighter-rouge">-fPIC</code> option. The <code class="language-plaintext highlighter-rouge">-fpic</code> or <code class="language-plaintext highlighter-rouge">-fPIC</code> option enable “<em>position independent code</em>” generation, a requirement for shared libraries, and used to generate code that is target-dependent. The <code class="language-plaintext highlighter-rouge">-fPIC</code> choice always works, but may produce larger code than <code class="language-plaintext highlighter-rouge">-fpic</code>. Using <code class="language-plaintext highlighter-rouge">-fpic</code> option usually generates smaller and faster code, but will have platform-dependent limitations. So, while creating shared library you have to recompile both <code class="language-plaintext highlighter-rouge">add.c</code>, and <code class="language-plaintext highlighter-rouge">sub.c</code> with following options:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-Wall</span> <span class="nt">-fPIC</span> <span class="nt">-c</span> add.c sub.c
</code></pre></div></div>

<p>Now build the library <code class="language-plaintext highlighter-rouge">libmath.so</code> using the following command.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-shared</span> <span class="nt">-o</span> libmath.so add.o sub.o
</code></pre></div></div>

<p>But to use a shared library is not as straightfoward as static library was. And, the simplest approach of installation is to copy the library into one of the standard directories (e.g., /usr/lib) and run <code class="language-plaintext highlighter-rouge">ldconfig</code> command.</p>

<p>Now recompile <code class="language-plaintext highlighter-rouge">hello.c</code> and generate the executable object file as following:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-c</span> hello.c <span class="nt">-I</span> <span class="nb">.</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> hello hello.o libmath.so
</code></pre></div></div>

<p>or</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> hello hello.o <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lmath</span>
</code></pre></div></div>

<p>You can list the shared library dependencies which your executable is depedent upon with <code class="language-plaintext highlighter-rouge">ldd &lt;name-of-executable&gt;</code> command.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ldd hello
        linux-vdso.so.1 <span class="o">(</span>0x00007ffdfdda2000<span class="o">)</span>
        libmath.so <span class="o">=&gt;</span> not found
        libc.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="o">(</span>0x00007f318cde8000<span class="o">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f318d193000<span class="o">)</span>
</code></pre></div></div>

<p>For more information about shared library, please refer to <a href="/2016/05/12/linux-commands-for-shared-library-management-and-debugging-problem/">Linux Shared Library Management &amp; Debugging Problem</a>.</p>

<hr />

<h3 id="references">References</h3>

<ol>
  <li><a href="http://courses.cms.caltech.edu/cs11/material/c/mike/misc/compiling_c.html">C track: compiling C programs.</a></li>
  <li><a href="http://cs-fundamentals.com/c-programming/how-to-compile-c-program-using-gcc.php">GCC Compilation Process and Steps of C Program in Linux</a></li>
  <li><a href="http://cs-fundamentals.com/c-programming/static-and-dynamic-linking-in-c.php">Create Static and Dynamic Library in C using GCC on Linux</a></li>
  <li><a href="https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path">Search Path (The C Preprocessor)</a></li>
</ol>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
