<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Testing in Go Language | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Testing in Go Language" />
<meta property="og:locale" content="en" />
<meta name="description" content="The go test Tool Test Functions Randomized Testing Testing a Command White-Box Testing External Test Packages Writing Effective Tests Avoiding Brittle Tests Coverage Benchmark Functions Profiling Example Functions References Go’s approach to testing relies on one command, go test, and a set of conventions for writing test functions that go test can run. It is effective for pure testing, and it extends naturally to benchmarks and systematic examples for documentation. The go test Tool The go test subcommand is a test driver for Go packages that are orgnized according to certain conventions. In a package directory, files whose names end with _test.go are not part of the package ordinarily built by go build but are a part of it when built by go test. Within *_test.go files, three kinds of functions are treated specially: tests, benchmarks, and examples. A test function, which is a function whose name begins with Test, exercises some program logic for correct behavior; go test calls the test function and report the result, which is either PASS or FAIL. A benchmark function has a name beginning with Benchmark and measures the performance of some operation; go test reports the mean execution time of the operation. And an example function, whose name starts with Example, provides machine-checked documentation. Test Functions Each test file must import the testing package. Test functions have the following signature: func TestName(t *testing.T) { } Test function names must begin with Test; the optional suffix Name must begin with a capital letter: func TestSin(t *testing.T) { /* ... */ } func TestCos(t *testing.T) { /* ... */ } func TestLog(t *testing.T) { /* ... */ } The t parameter provides methods for reporting test failures and logging additional information. func TestPalindrome(t *testing.T) { if !IsPalindrome(&quot;detartrated&quot;) { t.Error(`IsPalindrome(&quot;detartrated&quot;) = false`) } if !IsPalindrome(&quot;kayak&quot;) { t.Error(`IsPalindrome(&quot;kayak&quot;) = false`) } } func TestNonPalindrome(t *testing.T) { if IsPalindrome(&quot;palindrome&quot;) { t.Error(`IsPalindrome(&quot;palindrome&quot;) = true`) } } // a table-driven test func TestIsPalindrome(t *testing.T) { var tests = []struct { input string want bool }{ {&quot;&quot;, true}, {&quot;a&quot;, true}, {&quot;aa&quot;, true}, {&quot;ab&quot;, false}, {&quot;kayak&quot;, true}, } for _, test := range tests { if got := IsPalindrome(test.input); got != test.want { t.Errorf(&quot;IsPalindrome(%q) = %v&quot;, test.input, got) } } } Test failure messages are usually of the form “f(x) = y, want z”, where f(x) explains the attempted operation and its input, y is the actual result, and z is the expected result. Randomized Testing Table-driven tests are convenient for checking that a function works on inputs carefully selected to exercise interesting cases in the logic. Another approach, randomized testing, explores a broader range of inputs by constructing inputs at random. import &quot;math/rand&quot; // randomPalindrome returns a palindrome whose length and contents // are derived from the pseudo-random number generator rng. func randomPalindrome(rng *rand.Rand) string { n := rng.Intn(25) // random length up to 24 runes := make([]rune, n) for i := 0; i &lt; (n+1)/2; i++ { r := rune(rng.Intn(0x1000)) // random rune up to &#39;\u0999&#39; runes[i] = r runes[n-1-i] = r } return string(runes) } func TestRandomPalindromes(t *testing.T) { // Initialize a pseudo-random number generator. seed := time.Now().UTC().UnixNano() t.Logf(&quot;Random seed: %d&quot;, seed) rng := rand.New(rand.NewSource(seed)) for i := 0; i &lt; 1000; i++ { p := randomPalindrome(rng) if !IsPalindrome(p) { t.Errorf(&quot;IsPalindrome(%q) = false&quot;, p) } } } Testing a Command A package named main ordinarily produces an executable program, but it can be imported as a library too. // Echo prints its command-line arguments. package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot; &quot;strings&quot; ) var ( n = flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;) s = flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;) ) var out io.Writer = os.Stdout // modified during testing func main() { flag.Parse() if err := echo(!*n, *s, flag.Args()); err != nil { fmt.Fprintf(os.Stderr, &quot;echo: %v\n&quot;, err) os.Exit(1) } } func echo(newline bool, sep string, args []string) error { fmt.Fprint(out, strings.Join(args, sep)) if newline { fmt.Fprintln(out) } return nil } By having echo write through the global variable, out, not directly to os.Stdout, the tests can substitute a different Writer implementation that records what was written for later inspection. Here’s the test, in file echo_test.go: package main import ( &quot;bytes&quot; &quot;fmt&quot; &quot;testing&quot; ) func TestEcho(t *testing.T) { var tests = []struct { newline bool sep string args []string want string }{ {true, &quot;&quot;, []string{}, &quot;\n&quot;}, {false, &quot;&quot;, []string{}, &quot;&quot;}, {true, &quot;\t&quot;, []string{&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}, &quot;one\ttwo\tthree\n&quot;}, {true, &quot;,&quot;, []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, &quot;a,b,c\n&quot;}, {false, &quot;:&quot;, []string{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;}, &quot;1:2:3&quot;}, } for _, test := range tests { descr := fmt.Sprintf(&quot;echo(%v, %q, %q)&quot;, test.newline, test.sep, test.args) out = new(bytes.Buffer) // captured output if err := echo(test.newline, test.sep, test.args); err != nil { t.Errorf(&quot;%s failed: %v&quot;, descr, err) continue } got := out.(*bytes.Buffer).String() if got != test.want { t.Errorf(&quot;%s = %q, want %q&quot;, descr, got, test.want) } } } Although the package name of the test code is main and it defines a main function, during testing this package acts as a library that exposes the function TestEcho to the test driver; its main function is ignored. White-Box Testing One way of categorizing tests is by the level of knowledge they require of the internal workings of the package under test. A black-box test assumes nothing about the package other than what is exposed by its API and specified by its documentation; the package’s internal are opaque. In contrast, a white-box test has privileged access to the internal functions and data structres of th package and can make observations and changes that an ordinary client can not. The two approaches are complementary. Black-box tests are usually more robust, needing fewer updates as the software evolves. They also help the test author empathize with the client of the package and can reveal flaws in the API design. In contrast, white-box tests can provide more detailed coverage of the trickier parts of the implementation. External Test Packages Consider the package net/url, which provides a URL parser, and net/http, which provides a web server and HTTP client library. As we might expect, the higher-level net/http depends on the lover-level net/url. However, one of the tests in net/url is an example demonstrating the interaction between URLs and the HTTP client library. In other words, a test of the lover-level package imports the higher-level packages. Declaring this test function in the net/url package would create a cycle in the package import graph. We resolve the problem by declaring the test function in an external test package, that is, in a file the net/url directory whose package declaration reads package url_test. The extral suffix _test is a signal to go test that it should build an additional package containing just these files and run its tests. In terms of the design layers, the external test package is logically higher up than both of the package it depends upon. We can use the go list tool to summarize which Go source files in a package directory are production code, in-pcakges tests, and external tests. GoFiles is the list of files that contain the production code; this are the files that go build will include in your application: $ go list -f={{.GoFiles}} fmt [doc.go format.go print.go scan.go] TestGoFiles is the list of files that also belong to the fmt package, but these files, whose names all end in _test.go, are included only when building tests: $ go list -f={{.TestGoFiles}} fmt [export_test.go] XTestGoFiles is the list of files that constitute the external test package, fmt_test, so these files must import the fmt package in order to use it. Again, they are included only during testing: $ go list -f={{.XTestGoFiles}} fmt [fmt_test.go scan_test.go stringer_test.go] Sometimes an external test package may need privileged access to the internals of the package under test, if for example a white-box test must live in a separate package to avoid an import cycle. In such cases, we use a trick: we add declaration to an in-package _test.go file to expose the necessary internals to the external test. This file thus offers the test a “back door” to the package. If the source file exists only for this purpose and contains no tests itself, it is often called export_test.go. Writing Effective Tests Other languages’ frameworks provide mechanisms for identifying test functions (often using reflection or metadata), hooks for perforrming “setup” and “teardown” operations before and after the tests run, and libraries of utility functions for asserting common predicates, comparing values, formatting error messages, and aborting a failed test (often using exceptions). Although these mechanisms can make tests very concise, the resulting tests often seem like they are written in a foreign language. Furthermore, although they may report PASSS or FALL correctly, their manner may be unfriendly to the unfortunate maintainer, with cryptic failure message like “assert: 0 == 1” or page after page of stack traces. A good test does not explode on failure but prints a clear and succinct description of the symptom of the problem, and perhaps other relevant facts about the context. Ideally, the maintainer should not need to read the source code to decipher a test failure. A good test should not give up after one failure but should try to report several errors in a single run, since the pattern of failures may itself be revealing. The assertion function below compares two values, constructs a generic error message, and stops the program. It’s easy to use and it’s correct, but when it fails, the error message is almost useless. import ( &quot;fmt&quot; &quot;strings&quot; &quot;testing&quot; ) // A poor assertion function. func assertEqual(x, y int) { if x != y { panic(fmt.Sprintf(&quot;%d != %d&quot;, x, y)) } } func TestSplit(t *testing.T) { words := strings.Split(&quot;a:b:c&quot;, &quot;:&quot;) assertEqual(len(words), 3) // ... } In this sense, assertion functions suffer from premature abstraction: by treating the failure of this particular test as a mere difference of two integers, we forfeit the opportunity to provide meaningful context. We can provide a better message by starting from the concrete details, as in the example below. import ( &quot;strings&quot; &quot;testing&quot; ) func TestSplit(t *testing.T) { var tests = []struct { s string sep string want int }{ {&quot;a:b:c&quot;, &quot;:&quot;, 3}, } for _, test := range tests { words := strings.Split(test.s, test.sep) if got := len(words); got != test.want { t.Errorf(&quot;Split(%q, %q) returned %d words, want %d&quot;, test.s, test.sep, got, test.want) } } } Now the test reports the function that was called, its inputs, and the significance of the results; it explicitly identifies the actual value and the expectation; and it continues to execute even if this assertion should fail. Avoiding Brittle Tests An application that often fails when it encounters new but valid inputs is called buggy; a test that spuriously fails when a sound change was made to the program is called brittle. Just as a buggy program frustrates its users, a brittle test exasperates its maintainers. The most brittle tests, which fail from almost any change to the production code, good or bad, are sometimes called change detector or status quo tests, and the time dealing with them can quickly deplete any benefit they once seemed to provide. The easiest way to avoid brittle tests is to check only the properties you care about. Test your program’s simpler and more stable interfaces in preference to its internal functions. Be selective in your assertions. Don’t check for exact string matches, for example, but look for relevant substrings that remain unchanged as the program evolves. It’s often worth writing a substantial function to distill a complex output down to its essence so that assertions will be reliable. Even though that may seem like a lot of up-front effort, it can pay for itself quickly in time that would otherwise be spent fixing spuriously failing tests. Coverage No quantity of tests can ever prove a package free of bugs. At best, they increase our confidence that the package works well in a wide range of important scenarios. The degree to which a test exercises the package under test is called the test’s coverage. Statement coverage is the simplest and most widely used of these heuristics. The statement coverage of a test suite is the fraction of source statements that are executed at least once during the test. We’ll use the Go’s cover tool, which is integrated into go test, to measure statement coverage and help identify obvious gaps in the tests. This command displays the usage message of the coverage tool: $ go tool cover Usage of &#39;go tool cover&#39;: Given a coverage profile produced by &#39;go test&#39;: go test -coverprofile=c.out Open a web browser displaying annotated source code: go tool cover -html=c.out Write out an HTML file instead of launching a web browser: go tool cover -html=c.out -o coverage.html Display coverage percentages to stdout for each function: go tool cover -func=c.out The go tool command runs one of the executable from the Go toolchain. These programs live in the directory $GOROOT/pkg/tool/${GOOS}_${GOARCH}. package cover func foo(s string) string { return s } func bar(s string) string { return s } package cover import &quot;testing&quot; func TestFoo(t *testing.T) { var tests = []struct { s string want string }{ {&quot;hello&quot;, &quot;hello&quot;}, {&quot;world&quot;, &quot;world&quot;}, } for _, test := range tests { if got := foo(test.s); got != test.want { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, test.s, got, test.want) } } } $ go test -covermode=count PASS coverage: 50.0% of statements ok gopl.io/ch11/cover 0.002s $ go test -coverprofile=c.out PASS coverage: 50.0% of statements ok gopl.io/ch11/cover 0.002s $ go tool cover -func=c.out gopl.io/ch11/cover/cover.go:3: foo 100.0% gopl.io/ch11/cover/cover.go:7: bar 0.0% total: (statements) 50.0% Benchmark Functions Benchmarking is the practice of measuring the performance of a program on a fixed workload. In Go, a benchmark function looks like a test function, but with the Benchmark prefix and a *testing.B parameter that provides most of the same methods as a *testing.T, plus a few extra related to performance measurement. It also exposes an integer filed N, which specifies the number of times to perform the operation being measured. func foo(s string) string { var letters []rune for _, b := range s { letters = append(letters, b) } return string(letters) } func bar(s string) string { // pre-allocate a sufficiently large array for use by letters, // rather than expand it by successive calls to append letters := make([]rune, 0, len(s)) for _, b := range s { letters = append(letters, b) } return string(letters) } func BenchmarkFoo(b *testing.B) { for n := 0; n &lt; b.N; n++ { foo(&quot;hello world&quot;) } } func BenchmarkBar(b *testing.B) { for n := 0; n &lt; b.N; n++ { bar(&quot;hello world&quot;) } } Unlike tests, by default no benchmarks are run. The argument to the -bench flag selects which benchmarks to run. It is a regular expression matching the names of Benchmark functions, with a default value that matches none of them. The “.” pattern causes it to match all benchmarks. BenchmarkFoo-2 5000000 339 ns/op BenchmarkBar-2 10000000 188 ns/op PASS ok _/tmp 4.123s The benchmark names’s numeric suffix, 2 here, indicates the value of GOMAXPROCS, which is important for concurrent benchmarks. The report tells us that each call to foo took about 0.339 microseconds, averaged over 5000000 runs. The -benchmem command-line flag will include memory allocation statistics in its report. $ go test -bench=. -benchmem BenchmarkFoo-2 5000000 333 ns/op 136 B/op 5 allocs/op BenchmarkBar-2 10000000 188 ns/op 64 B/op 2 allocs/op PASS ok _/tmp 4.088s Benchmarks like this tell us the absolute time required for a given operation, but in many settings the interesting performance questions are about the relative timings of two different operations. For example, if a function takes 1ms to process 1,000 elements, how long will it take to process 10,000 or a million? Comarative benchmarks are just regular code. They typically take the form os a single parameterized function, called from several Benchmark function with different values, like this: func benchmark(b *testing.B, size int) { /* ... */ } func Benchmark10(b *testing.B) { benchmark(b, 10) } func Benchmark100(b *testing.B) { benchmark(b, 100) } func Benchmark1000(b *testing.B) { benchmark(b, 1000) } Profiling Benchmarks are useful for measuring the performance of specific operations, but when we’re trying to make a slow program faster, we often have no idea where to begin. Programmer waste enormous amounts of time thinking about, or worry about, the speed of noncritical parts of their programs. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. When we wish to look carefully at the speed of our programs, the best technique for identifying the critical code is profiling. Profiling is an automated approach to performance measurement based on sampling a number of profile events during execution, then extrapolating from them during a post-processing step; the resutling statistical summary is called a profile. The go test tool has built-in support for serval kinds of profiling. A CPU profile identifies the functions whose executation reuqires the most CPU time. The currently running thread on each CPU is interrupted periodically by the operating system every few milliseconds, with each interruption recording once profile event before normal execution resumes. A heap profile identifies the statements responsible for allocating the most memory. The profiling library samples calls to the internal memory allocation routines so that on average, on profile event is recorded per 512KB of allocated memory. A blocking profile identifies the operations resposible for blocking goroutines the longest, such system calls, channel sends and receives, and acquisitions of locks. The profiling library records an event every time a goroutine is blocked by one the these operations. Gathering a profile for code under test is as easy as enabling one of the flags below. Be careful when using more than one flag at a time, however: the machinery for gathering one kind of profile may skew the results of others. $ go test -cpuprofile=cpu.log $ go test -blockprofile=block.log $ go test -memprofile=mem.log Profiling is especially useful in lonng-running applications, so the Go runtime’s profiling features can be eanbled under programmer control using the runtime API. Once we’ve gathered a profile, we need to analyze it using the pprof tool. This is a standard part of the Go distribution, but since it’s not an everyday tool, it’s accessed indirectly using go tool pprof. To make profiling efficient and save space, the log does not include function names; instead, functions are identified by their address. This mean that pprof needs the executalbe in order to make sense of the log. Although go test usually discards the test executable once the test is complete, when profiling is enabled it saves the executable as foo.test, where foo is the name of the tested package. The command below show how to gather and display a simple CPU profile. We’ve selected one of the benchmarks from the net/http package. It is usually better to profile specific benchmarks that have been constuctured to be representative of workloads one cares about. Benchmarking test cases is almost never representative, which is why we disabled them by using the filter -run=NONE. $ go test -run=NONE -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http BenchmarkClientServerParallelTLS64-2 30000 47156 ns/op 5201 B/op 67 allocs/op PASS ok net/http 2.726s $ go tool pprof -text -nodecount=5 ./http.test cpu.log 1380ms of 4870ms total (28.34%) Dropped 203 nodes (cum &lt;= 24.35ms) Showing top 5 nodes out of 223 (cum &gt;= 140ms) flat flat% sum% cum cum% 760ms 15.61% 15.61% 840ms 17.25% syscall.Syscall 170ms 3.49% 19.10% 490ms 10.06% runtime.mallocgc 170ms 3.49% 22.59% 170ms 3.49% runtime.memmove 140ms 2.87% 25.46% 320ms 6.57% runtime.pcvalue 140ms 2.87% 28.34% 140ms 2.87% vendor/golang_org/x/crypto/curve25519.ladderstep Example Functions The third kind of function treated specially by go test is an example function, one whose name starts with Exmaple. It has neither parameters nor results. Here’s an example function for IsPalindrome: func ExampleIsPalindrome() { fmt.Println(IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;)) fmt.Println(IsPalindrome(&quot;palindrome&quot;)) // Output: // true // false } Example functions serve three purposes. The primary one is documentation: a good example can be a more succinct or intuitive way to convey the behavior of a library function than its prose description, especially when used as a reminder or quick reference. An example can also demostrate the interaction between several types and functions belonging to one API, whereas prose documentation must always be attached to one place, like a type or function declaration or the package as a whole. And unlike exmpales within comments, example functions are real Go code, subject to compile-time checking, so they don’t become stale as the code evolves. Based on the suffix of the Example function, the web-based documentation server godoc associates example functions with the function or package they exemplify, so ExampleIsPanlidrome would be shown with the documentation for the IsPalindrome function, and an example called just Example would be associated with the word package as a whole. The second purpose is that examples are executable tests run by go test. If the exaple function contains a final // Output: comment like the one above, the test driver will execute the function and check that what it printed to its standard output matches the text within the comment. The third purpose of an example is hands-on experimentation. The godoc server at golang.org uses the Go Playground to let the user edit and run each example function from within a web browser. References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. testing - The Go Programming Language TableDrivenTests · golang/go Wiki Profiling Go Programs - The Go Blog The cover story - The Go Programming Language" />
<meta property="og:description" content="The go test Tool Test Functions Randomized Testing Testing a Command White-Box Testing External Test Packages Writing Effective Tests Avoiding Brittle Tests Coverage Benchmark Functions Profiling Example Functions References Go’s approach to testing relies on one command, go test, and a set of conventions for writing test functions that go test can run. It is effective for pure testing, and it extends naturally to benchmarks and systematic examples for documentation. The go test Tool The go test subcommand is a test driver for Go packages that are orgnized according to certain conventions. In a package directory, files whose names end with _test.go are not part of the package ordinarily built by go build but are a part of it when built by go test. Within *_test.go files, three kinds of functions are treated specially: tests, benchmarks, and examples. A test function, which is a function whose name begins with Test, exercises some program logic for correct behavior; go test calls the test function and report the result, which is either PASS or FAIL. A benchmark function has a name beginning with Benchmark and measures the performance of some operation; go test reports the mean execution time of the operation. And an example function, whose name starts with Example, provides machine-checked documentation. Test Functions Each test file must import the testing package. Test functions have the following signature: func TestName(t *testing.T) { } Test function names must begin with Test; the optional suffix Name must begin with a capital letter: func TestSin(t *testing.T) { /* ... */ } func TestCos(t *testing.T) { /* ... */ } func TestLog(t *testing.T) { /* ... */ } The t parameter provides methods for reporting test failures and logging additional information. func TestPalindrome(t *testing.T) { if !IsPalindrome(&quot;detartrated&quot;) { t.Error(`IsPalindrome(&quot;detartrated&quot;) = false`) } if !IsPalindrome(&quot;kayak&quot;) { t.Error(`IsPalindrome(&quot;kayak&quot;) = false`) } } func TestNonPalindrome(t *testing.T) { if IsPalindrome(&quot;palindrome&quot;) { t.Error(`IsPalindrome(&quot;palindrome&quot;) = true`) } } // a table-driven test func TestIsPalindrome(t *testing.T) { var tests = []struct { input string want bool }{ {&quot;&quot;, true}, {&quot;a&quot;, true}, {&quot;aa&quot;, true}, {&quot;ab&quot;, false}, {&quot;kayak&quot;, true}, } for _, test := range tests { if got := IsPalindrome(test.input); got != test.want { t.Errorf(&quot;IsPalindrome(%q) = %v&quot;, test.input, got) } } } Test failure messages are usually of the form “f(x) = y, want z”, where f(x) explains the attempted operation and its input, y is the actual result, and z is the expected result. Randomized Testing Table-driven tests are convenient for checking that a function works on inputs carefully selected to exercise interesting cases in the logic. Another approach, randomized testing, explores a broader range of inputs by constructing inputs at random. import &quot;math/rand&quot; // randomPalindrome returns a palindrome whose length and contents // are derived from the pseudo-random number generator rng. func randomPalindrome(rng *rand.Rand) string { n := rng.Intn(25) // random length up to 24 runes := make([]rune, n) for i := 0; i &lt; (n+1)/2; i++ { r := rune(rng.Intn(0x1000)) // random rune up to &#39;\u0999&#39; runes[i] = r runes[n-1-i] = r } return string(runes) } func TestRandomPalindromes(t *testing.T) { // Initialize a pseudo-random number generator. seed := time.Now().UTC().UnixNano() t.Logf(&quot;Random seed: %d&quot;, seed) rng := rand.New(rand.NewSource(seed)) for i := 0; i &lt; 1000; i++ { p := randomPalindrome(rng) if !IsPalindrome(p) { t.Errorf(&quot;IsPalindrome(%q) = false&quot;, p) } } } Testing a Command A package named main ordinarily produces an executable program, but it can be imported as a library too. // Echo prints its command-line arguments. package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot; &quot;strings&quot; ) var ( n = flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;) s = flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;) ) var out io.Writer = os.Stdout // modified during testing func main() { flag.Parse() if err := echo(!*n, *s, flag.Args()); err != nil { fmt.Fprintf(os.Stderr, &quot;echo: %v\n&quot;, err) os.Exit(1) } } func echo(newline bool, sep string, args []string) error { fmt.Fprint(out, strings.Join(args, sep)) if newline { fmt.Fprintln(out) } return nil } By having echo write through the global variable, out, not directly to os.Stdout, the tests can substitute a different Writer implementation that records what was written for later inspection. Here’s the test, in file echo_test.go: package main import ( &quot;bytes&quot; &quot;fmt&quot; &quot;testing&quot; ) func TestEcho(t *testing.T) { var tests = []struct { newline bool sep string args []string want string }{ {true, &quot;&quot;, []string{}, &quot;\n&quot;}, {false, &quot;&quot;, []string{}, &quot;&quot;}, {true, &quot;\t&quot;, []string{&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}, &quot;one\ttwo\tthree\n&quot;}, {true, &quot;,&quot;, []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, &quot;a,b,c\n&quot;}, {false, &quot;:&quot;, []string{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;}, &quot;1:2:3&quot;}, } for _, test := range tests { descr := fmt.Sprintf(&quot;echo(%v, %q, %q)&quot;, test.newline, test.sep, test.args) out = new(bytes.Buffer) // captured output if err := echo(test.newline, test.sep, test.args); err != nil { t.Errorf(&quot;%s failed: %v&quot;, descr, err) continue } got := out.(*bytes.Buffer).String() if got != test.want { t.Errorf(&quot;%s = %q, want %q&quot;, descr, got, test.want) } } } Although the package name of the test code is main and it defines a main function, during testing this package acts as a library that exposes the function TestEcho to the test driver; its main function is ignored. White-Box Testing One way of categorizing tests is by the level of knowledge they require of the internal workings of the package under test. A black-box test assumes nothing about the package other than what is exposed by its API and specified by its documentation; the package’s internal are opaque. In contrast, a white-box test has privileged access to the internal functions and data structres of th package and can make observations and changes that an ordinary client can not. The two approaches are complementary. Black-box tests are usually more robust, needing fewer updates as the software evolves. They also help the test author empathize with the client of the package and can reveal flaws in the API design. In contrast, white-box tests can provide more detailed coverage of the trickier parts of the implementation. External Test Packages Consider the package net/url, which provides a URL parser, and net/http, which provides a web server and HTTP client library. As we might expect, the higher-level net/http depends on the lover-level net/url. However, one of the tests in net/url is an example demonstrating the interaction between URLs and the HTTP client library. In other words, a test of the lover-level package imports the higher-level packages. Declaring this test function in the net/url package would create a cycle in the package import graph. We resolve the problem by declaring the test function in an external test package, that is, in a file the net/url directory whose package declaration reads package url_test. The extral suffix _test is a signal to go test that it should build an additional package containing just these files and run its tests. In terms of the design layers, the external test package is logically higher up than both of the package it depends upon. We can use the go list tool to summarize which Go source files in a package directory are production code, in-pcakges tests, and external tests. GoFiles is the list of files that contain the production code; this are the files that go build will include in your application: $ go list -f={{.GoFiles}} fmt [doc.go format.go print.go scan.go] TestGoFiles is the list of files that also belong to the fmt package, but these files, whose names all end in _test.go, are included only when building tests: $ go list -f={{.TestGoFiles}} fmt [export_test.go] XTestGoFiles is the list of files that constitute the external test package, fmt_test, so these files must import the fmt package in order to use it. Again, they are included only during testing: $ go list -f={{.XTestGoFiles}} fmt [fmt_test.go scan_test.go stringer_test.go] Sometimes an external test package may need privileged access to the internals of the package under test, if for example a white-box test must live in a separate package to avoid an import cycle. In such cases, we use a trick: we add declaration to an in-package _test.go file to expose the necessary internals to the external test. This file thus offers the test a “back door” to the package. If the source file exists only for this purpose and contains no tests itself, it is often called export_test.go. Writing Effective Tests Other languages’ frameworks provide mechanisms for identifying test functions (often using reflection or metadata), hooks for perforrming “setup” and “teardown” operations before and after the tests run, and libraries of utility functions for asserting common predicates, comparing values, formatting error messages, and aborting a failed test (often using exceptions). Although these mechanisms can make tests very concise, the resulting tests often seem like they are written in a foreign language. Furthermore, although they may report PASSS or FALL correctly, their manner may be unfriendly to the unfortunate maintainer, with cryptic failure message like “assert: 0 == 1” or page after page of stack traces. A good test does not explode on failure but prints a clear and succinct description of the symptom of the problem, and perhaps other relevant facts about the context. Ideally, the maintainer should not need to read the source code to decipher a test failure. A good test should not give up after one failure but should try to report several errors in a single run, since the pattern of failures may itself be revealing. The assertion function below compares two values, constructs a generic error message, and stops the program. It’s easy to use and it’s correct, but when it fails, the error message is almost useless. import ( &quot;fmt&quot; &quot;strings&quot; &quot;testing&quot; ) // A poor assertion function. func assertEqual(x, y int) { if x != y { panic(fmt.Sprintf(&quot;%d != %d&quot;, x, y)) } } func TestSplit(t *testing.T) { words := strings.Split(&quot;a:b:c&quot;, &quot;:&quot;) assertEqual(len(words), 3) // ... } In this sense, assertion functions suffer from premature abstraction: by treating the failure of this particular test as a mere difference of two integers, we forfeit the opportunity to provide meaningful context. We can provide a better message by starting from the concrete details, as in the example below. import ( &quot;strings&quot; &quot;testing&quot; ) func TestSplit(t *testing.T) { var tests = []struct { s string sep string want int }{ {&quot;a:b:c&quot;, &quot;:&quot;, 3}, } for _, test := range tests { words := strings.Split(test.s, test.sep) if got := len(words); got != test.want { t.Errorf(&quot;Split(%q, %q) returned %d words, want %d&quot;, test.s, test.sep, got, test.want) } } } Now the test reports the function that was called, its inputs, and the significance of the results; it explicitly identifies the actual value and the expectation; and it continues to execute even if this assertion should fail. Avoiding Brittle Tests An application that often fails when it encounters new but valid inputs is called buggy; a test that spuriously fails when a sound change was made to the program is called brittle. Just as a buggy program frustrates its users, a brittle test exasperates its maintainers. The most brittle tests, which fail from almost any change to the production code, good or bad, are sometimes called change detector or status quo tests, and the time dealing with them can quickly deplete any benefit they once seemed to provide. The easiest way to avoid brittle tests is to check only the properties you care about. Test your program’s simpler and more stable interfaces in preference to its internal functions. Be selective in your assertions. Don’t check for exact string matches, for example, but look for relevant substrings that remain unchanged as the program evolves. It’s often worth writing a substantial function to distill a complex output down to its essence so that assertions will be reliable. Even though that may seem like a lot of up-front effort, it can pay for itself quickly in time that would otherwise be spent fixing spuriously failing tests. Coverage No quantity of tests can ever prove a package free of bugs. At best, they increase our confidence that the package works well in a wide range of important scenarios. The degree to which a test exercises the package under test is called the test’s coverage. Statement coverage is the simplest and most widely used of these heuristics. The statement coverage of a test suite is the fraction of source statements that are executed at least once during the test. We’ll use the Go’s cover tool, which is integrated into go test, to measure statement coverage and help identify obvious gaps in the tests. This command displays the usage message of the coverage tool: $ go tool cover Usage of &#39;go tool cover&#39;: Given a coverage profile produced by &#39;go test&#39;: go test -coverprofile=c.out Open a web browser displaying annotated source code: go tool cover -html=c.out Write out an HTML file instead of launching a web browser: go tool cover -html=c.out -o coverage.html Display coverage percentages to stdout for each function: go tool cover -func=c.out The go tool command runs one of the executable from the Go toolchain. These programs live in the directory $GOROOT/pkg/tool/${GOOS}_${GOARCH}. package cover func foo(s string) string { return s } func bar(s string) string { return s } package cover import &quot;testing&quot; func TestFoo(t *testing.T) { var tests = []struct { s string want string }{ {&quot;hello&quot;, &quot;hello&quot;}, {&quot;world&quot;, &quot;world&quot;}, } for _, test := range tests { if got := foo(test.s); got != test.want { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, test.s, got, test.want) } } } $ go test -covermode=count PASS coverage: 50.0% of statements ok gopl.io/ch11/cover 0.002s $ go test -coverprofile=c.out PASS coverage: 50.0% of statements ok gopl.io/ch11/cover 0.002s $ go tool cover -func=c.out gopl.io/ch11/cover/cover.go:3: foo 100.0% gopl.io/ch11/cover/cover.go:7: bar 0.0% total: (statements) 50.0% Benchmark Functions Benchmarking is the practice of measuring the performance of a program on a fixed workload. In Go, a benchmark function looks like a test function, but with the Benchmark prefix and a *testing.B parameter that provides most of the same methods as a *testing.T, plus a few extra related to performance measurement. It also exposes an integer filed N, which specifies the number of times to perform the operation being measured. func foo(s string) string { var letters []rune for _, b := range s { letters = append(letters, b) } return string(letters) } func bar(s string) string { // pre-allocate a sufficiently large array for use by letters, // rather than expand it by successive calls to append letters := make([]rune, 0, len(s)) for _, b := range s { letters = append(letters, b) } return string(letters) } func BenchmarkFoo(b *testing.B) { for n := 0; n &lt; b.N; n++ { foo(&quot;hello world&quot;) } } func BenchmarkBar(b *testing.B) { for n := 0; n &lt; b.N; n++ { bar(&quot;hello world&quot;) } } Unlike tests, by default no benchmarks are run. The argument to the -bench flag selects which benchmarks to run. It is a regular expression matching the names of Benchmark functions, with a default value that matches none of them. The “.” pattern causes it to match all benchmarks. BenchmarkFoo-2 5000000 339 ns/op BenchmarkBar-2 10000000 188 ns/op PASS ok _/tmp 4.123s The benchmark names’s numeric suffix, 2 here, indicates the value of GOMAXPROCS, which is important for concurrent benchmarks. The report tells us that each call to foo took about 0.339 microseconds, averaged over 5000000 runs. The -benchmem command-line flag will include memory allocation statistics in its report. $ go test -bench=. -benchmem BenchmarkFoo-2 5000000 333 ns/op 136 B/op 5 allocs/op BenchmarkBar-2 10000000 188 ns/op 64 B/op 2 allocs/op PASS ok _/tmp 4.088s Benchmarks like this tell us the absolute time required for a given operation, but in many settings the interesting performance questions are about the relative timings of two different operations. For example, if a function takes 1ms to process 1,000 elements, how long will it take to process 10,000 or a million? Comarative benchmarks are just regular code. They typically take the form os a single parameterized function, called from several Benchmark function with different values, like this: func benchmark(b *testing.B, size int) { /* ... */ } func Benchmark10(b *testing.B) { benchmark(b, 10) } func Benchmark100(b *testing.B) { benchmark(b, 100) } func Benchmark1000(b *testing.B) { benchmark(b, 1000) } Profiling Benchmarks are useful for measuring the performance of specific operations, but when we’re trying to make a slow program faster, we often have no idea where to begin. Programmer waste enormous amounts of time thinking about, or worry about, the speed of noncritical parts of their programs. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. When we wish to look carefully at the speed of our programs, the best technique for identifying the critical code is profiling. Profiling is an automated approach to performance measurement based on sampling a number of profile events during execution, then extrapolating from them during a post-processing step; the resutling statistical summary is called a profile. The go test tool has built-in support for serval kinds of profiling. A CPU profile identifies the functions whose executation reuqires the most CPU time. The currently running thread on each CPU is interrupted periodically by the operating system every few milliseconds, with each interruption recording once profile event before normal execution resumes. A heap profile identifies the statements responsible for allocating the most memory. The profiling library samples calls to the internal memory allocation routines so that on average, on profile event is recorded per 512KB of allocated memory. A blocking profile identifies the operations resposible for blocking goroutines the longest, such system calls, channel sends and receives, and acquisitions of locks. The profiling library records an event every time a goroutine is blocked by one the these operations. Gathering a profile for code under test is as easy as enabling one of the flags below. Be careful when using more than one flag at a time, however: the machinery for gathering one kind of profile may skew the results of others. $ go test -cpuprofile=cpu.log $ go test -blockprofile=block.log $ go test -memprofile=mem.log Profiling is especially useful in lonng-running applications, so the Go runtime’s profiling features can be eanbled under programmer control using the runtime API. Once we’ve gathered a profile, we need to analyze it using the pprof tool. This is a standard part of the Go distribution, but since it’s not an everyday tool, it’s accessed indirectly using go tool pprof. To make profiling efficient and save space, the log does not include function names; instead, functions are identified by their address. This mean that pprof needs the executalbe in order to make sense of the log. Although go test usually discards the test executable once the test is complete, when profiling is enabled it saves the executable as foo.test, where foo is the name of the tested package. The command below show how to gather and display a simple CPU profile. We’ve selected one of the benchmarks from the net/http package. It is usually better to profile specific benchmarks that have been constuctured to be representative of workloads one cares about. Benchmarking test cases is almost never representative, which is why we disabled them by using the filter -run=NONE. $ go test -run=NONE -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http BenchmarkClientServerParallelTLS64-2 30000 47156 ns/op 5201 B/op 67 allocs/op PASS ok net/http 2.726s $ go tool pprof -text -nodecount=5 ./http.test cpu.log 1380ms of 4870ms total (28.34%) Dropped 203 nodes (cum &lt;= 24.35ms) Showing top 5 nodes out of 223 (cum &gt;= 140ms) flat flat% sum% cum cum% 760ms 15.61% 15.61% 840ms 17.25% syscall.Syscall 170ms 3.49% 19.10% 490ms 10.06% runtime.mallocgc 170ms 3.49% 22.59% 170ms 3.49% runtime.memmove 140ms 2.87% 25.46% 320ms 6.57% runtime.pcvalue 140ms 2.87% 28.34% 140ms 2.87% vendor/golang_org/x/crypto/curve25519.ladderstep Example Functions The third kind of function treated specially by go test is an example function, one whose name starts with Exmaple. It has neither parameters nor results. Here’s an example function for IsPalindrome: func ExampleIsPalindrome() { fmt.Println(IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;)) fmt.Println(IsPalindrome(&quot;palindrome&quot;)) // Output: // true // false } Example functions serve three purposes. The primary one is documentation: a good example can be a more succinct or intuitive way to convey the behavior of a library function than its prose description, especially when used as a reminder or quick reference. An example can also demostrate the interaction between several types and functions belonging to one API, whereas prose documentation must always be attached to one place, like a type or function declaration or the package as a whole. And unlike exmpales within comments, example functions are real Go code, subject to compile-time checking, so they don’t become stale as the code evolves. Based on the suffix of the Example function, the web-based documentation server godoc associates example functions with the function or package they exemplify, so ExampleIsPanlidrome would be shown with the documentation for the IsPalindrome function, and an example called just Example would be associated with the word package as a whole. The second purpose is that examples are executable tests run by go test. If the exaple function contains a final // Output: comment like the one above, the test driver will execute the function and check that what it printed to its standard output matches the text within the comment. The third purpose of an example is hands-on experimentation. The godoc server at golang.org uses the Go Playground to let the user edit and run each example function from within a web browser. References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. testing - The Go Programming Language TableDrivenTests · golang/go Wiki Profiling Go Programs - The Go Blog The cover story - The Go Programming Language" />
<link rel="canonical" href="https://blog.codefarm.me/2017/07/01/testing-in-go-language/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/07/01/testing-in-go-language/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-01T13:42:56+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Testing in Go Language" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-07-01T13:42:56+08:00","datePublished":"2017-07-01T13:42:56+08:00","description":"The go test Tool Test Functions Randomized Testing Testing a Command White-Box Testing External Test Packages Writing Effective Tests Avoiding Brittle Tests Coverage Benchmark Functions Profiling Example Functions References Go’s approach to testing relies on one command, go test, and a set of conventions for writing test functions that go test can run. It is effective for pure testing, and it extends naturally to benchmarks and systematic examples for documentation. The go test Tool The go test subcommand is a test driver for Go packages that are orgnized according to certain conventions. In a package directory, files whose names end with _test.go are not part of the package ordinarily built by go build but are a part of it when built by go test. Within *_test.go files, three kinds of functions are treated specially: tests, benchmarks, and examples. A test function, which is a function whose name begins with Test, exercises some program logic for correct behavior; go test calls the test function and report the result, which is either PASS or FAIL. A benchmark function has a name beginning with Benchmark and measures the performance of some operation; go test reports the mean execution time of the operation. And an example function, whose name starts with Example, provides machine-checked documentation. Test Functions Each test file must import the testing package. Test functions have the following signature: func TestName(t *testing.T) { } Test function names must begin with Test; the optional suffix Name must begin with a capital letter: func TestSin(t *testing.T) { /* ... */ } func TestCos(t *testing.T) { /* ... */ } func TestLog(t *testing.T) { /* ... */ } The t parameter provides methods for reporting test failures and logging additional information. func TestPalindrome(t *testing.T) { if !IsPalindrome(&quot;detartrated&quot;) { t.Error(`IsPalindrome(&quot;detartrated&quot;) = false`) } if !IsPalindrome(&quot;kayak&quot;) { t.Error(`IsPalindrome(&quot;kayak&quot;) = false`) } } func TestNonPalindrome(t *testing.T) { if IsPalindrome(&quot;palindrome&quot;) { t.Error(`IsPalindrome(&quot;palindrome&quot;) = true`) } } // a table-driven test func TestIsPalindrome(t *testing.T) { var tests = []struct { input string want bool }{ {&quot;&quot;, true}, {&quot;a&quot;, true}, {&quot;aa&quot;, true}, {&quot;ab&quot;, false}, {&quot;kayak&quot;, true}, } for _, test := range tests { if got := IsPalindrome(test.input); got != test.want { t.Errorf(&quot;IsPalindrome(%q) = %v&quot;, test.input, got) } } } Test failure messages are usually of the form “f(x) = y, want z”, where f(x) explains the attempted operation and its input, y is the actual result, and z is the expected result. Randomized Testing Table-driven tests are convenient for checking that a function works on inputs carefully selected to exercise interesting cases in the logic. Another approach, randomized testing, explores a broader range of inputs by constructing inputs at random. import &quot;math/rand&quot; // randomPalindrome returns a palindrome whose length and contents // are derived from the pseudo-random number generator rng. func randomPalindrome(rng *rand.Rand) string { n := rng.Intn(25) // random length up to 24 runes := make([]rune, n) for i := 0; i &lt; (n+1)/2; i++ { r := rune(rng.Intn(0x1000)) // random rune up to &#39;\\u0999&#39; runes[i] = r runes[n-1-i] = r } return string(runes) } func TestRandomPalindromes(t *testing.T) { // Initialize a pseudo-random number generator. seed := time.Now().UTC().UnixNano() t.Logf(&quot;Random seed: %d&quot;, seed) rng := rand.New(rand.NewSource(seed)) for i := 0; i &lt; 1000; i++ { p := randomPalindrome(rng) if !IsPalindrome(p) { t.Errorf(&quot;IsPalindrome(%q) = false&quot;, p) } } } Testing a Command A package named main ordinarily produces an executable program, but it can be imported as a library too. // Echo prints its command-line arguments. package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot; &quot;strings&quot; ) var ( n = flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;) s = flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;) ) var out io.Writer = os.Stdout // modified during testing func main() { flag.Parse() if err := echo(!*n, *s, flag.Args()); err != nil { fmt.Fprintf(os.Stderr, &quot;echo: %v\\n&quot;, err) os.Exit(1) } } func echo(newline bool, sep string, args []string) error { fmt.Fprint(out, strings.Join(args, sep)) if newline { fmt.Fprintln(out) } return nil } By having echo write through the global variable, out, not directly to os.Stdout, the tests can substitute a different Writer implementation that records what was written for later inspection. Here’s the test, in file echo_test.go: package main import ( &quot;bytes&quot; &quot;fmt&quot; &quot;testing&quot; ) func TestEcho(t *testing.T) { var tests = []struct { newline bool sep string args []string want string }{ {true, &quot;&quot;, []string{}, &quot;\\n&quot;}, {false, &quot;&quot;, []string{}, &quot;&quot;}, {true, &quot;\\t&quot;, []string{&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}, &quot;one\\ttwo\\tthree\\n&quot;}, {true, &quot;,&quot;, []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, &quot;a,b,c\\n&quot;}, {false, &quot;:&quot;, []string{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;}, &quot;1:2:3&quot;}, } for _, test := range tests { descr := fmt.Sprintf(&quot;echo(%v, %q, %q)&quot;, test.newline, test.sep, test.args) out = new(bytes.Buffer) // captured output if err := echo(test.newline, test.sep, test.args); err != nil { t.Errorf(&quot;%s failed: %v&quot;, descr, err) continue } got := out.(*bytes.Buffer).String() if got != test.want { t.Errorf(&quot;%s = %q, want %q&quot;, descr, got, test.want) } } } Although the package name of the test code is main and it defines a main function, during testing this package acts as a library that exposes the function TestEcho to the test driver; its main function is ignored. White-Box Testing One way of categorizing tests is by the level of knowledge they require of the internal workings of the package under test. A black-box test assumes nothing about the package other than what is exposed by its API and specified by its documentation; the package’s internal are opaque. In contrast, a white-box test has privileged access to the internal functions and data structres of th package and can make observations and changes that an ordinary client can not. The two approaches are complementary. Black-box tests are usually more robust, needing fewer updates as the software evolves. They also help the test author empathize with the client of the package and can reveal flaws in the API design. In contrast, white-box tests can provide more detailed coverage of the trickier parts of the implementation. External Test Packages Consider the package net/url, which provides a URL parser, and net/http, which provides a web server and HTTP client library. As we might expect, the higher-level net/http depends on the lover-level net/url. However, one of the tests in net/url is an example demonstrating the interaction between URLs and the HTTP client library. In other words, a test of the lover-level package imports the higher-level packages. Declaring this test function in the net/url package would create a cycle in the package import graph. We resolve the problem by declaring the test function in an external test package, that is, in a file the net/url directory whose package declaration reads package url_test. The extral suffix _test is a signal to go test that it should build an additional package containing just these files and run its tests. In terms of the design layers, the external test package is logically higher up than both of the package it depends upon. We can use the go list tool to summarize which Go source files in a package directory are production code, in-pcakges tests, and external tests. GoFiles is the list of files that contain the production code; this are the files that go build will include in your application: $ go list -f={{.GoFiles}} fmt [doc.go format.go print.go scan.go] TestGoFiles is the list of files that also belong to the fmt package, but these files, whose names all end in _test.go, are included only when building tests: $ go list -f={{.TestGoFiles}} fmt [export_test.go] XTestGoFiles is the list of files that constitute the external test package, fmt_test, so these files must import the fmt package in order to use it. Again, they are included only during testing: $ go list -f={{.XTestGoFiles}} fmt [fmt_test.go scan_test.go stringer_test.go] Sometimes an external test package may need privileged access to the internals of the package under test, if for example a white-box test must live in a separate package to avoid an import cycle. In such cases, we use a trick: we add declaration to an in-package _test.go file to expose the necessary internals to the external test. This file thus offers the test a “back door” to the package. If the source file exists only for this purpose and contains no tests itself, it is often called export_test.go. Writing Effective Tests Other languages’ frameworks provide mechanisms for identifying test functions (often using reflection or metadata), hooks for perforrming “setup” and “teardown” operations before and after the tests run, and libraries of utility functions for asserting common predicates, comparing values, formatting error messages, and aborting a failed test (often using exceptions). Although these mechanisms can make tests very concise, the resulting tests often seem like they are written in a foreign language. Furthermore, although they may report PASSS or FALL correctly, their manner may be unfriendly to the unfortunate maintainer, with cryptic failure message like “assert: 0 == 1” or page after page of stack traces. A good test does not explode on failure but prints a clear and succinct description of the symptom of the problem, and perhaps other relevant facts about the context. Ideally, the maintainer should not need to read the source code to decipher a test failure. A good test should not give up after one failure but should try to report several errors in a single run, since the pattern of failures may itself be revealing. The assertion function below compares two values, constructs a generic error message, and stops the program. It’s easy to use and it’s correct, but when it fails, the error message is almost useless. import ( &quot;fmt&quot; &quot;strings&quot; &quot;testing&quot; ) // A poor assertion function. func assertEqual(x, y int) { if x != y { panic(fmt.Sprintf(&quot;%d != %d&quot;, x, y)) } } func TestSplit(t *testing.T) { words := strings.Split(&quot;a:b:c&quot;, &quot;:&quot;) assertEqual(len(words), 3) // ... } In this sense, assertion functions suffer from premature abstraction: by treating the failure of this particular test as a mere difference of two integers, we forfeit the opportunity to provide meaningful context. We can provide a better message by starting from the concrete details, as in the example below. import ( &quot;strings&quot; &quot;testing&quot; ) func TestSplit(t *testing.T) { var tests = []struct { s string sep string want int }{ {&quot;a:b:c&quot;, &quot;:&quot;, 3}, } for _, test := range tests { words := strings.Split(test.s, test.sep) if got := len(words); got != test.want { t.Errorf(&quot;Split(%q, %q) returned %d words, want %d&quot;, test.s, test.sep, got, test.want) } } } Now the test reports the function that was called, its inputs, and the significance of the results; it explicitly identifies the actual value and the expectation; and it continues to execute even if this assertion should fail. Avoiding Brittle Tests An application that often fails when it encounters new but valid inputs is called buggy; a test that spuriously fails when a sound change was made to the program is called brittle. Just as a buggy program frustrates its users, a brittle test exasperates its maintainers. The most brittle tests, which fail from almost any change to the production code, good or bad, are sometimes called change detector or status quo tests, and the time dealing with them can quickly deplete any benefit they once seemed to provide. The easiest way to avoid brittle tests is to check only the properties you care about. Test your program’s simpler and more stable interfaces in preference to its internal functions. Be selective in your assertions. Don’t check for exact string matches, for example, but look for relevant substrings that remain unchanged as the program evolves. It’s often worth writing a substantial function to distill a complex output down to its essence so that assertions will be reliable. Even though that may seem like a lot of up-front effort, it can pay for itself quickly in time that would otherwise be spent fixing spuriously failing tests. Coverage No quantity of tests can ever prove a package free of bugs. At best, they increase our confidence that the package works well in a wide range of important scenarios. The degree to which a test exercises the package under test is called the test’s coverage. Statement coverage is the simplest and most widely used of these heuristics. The statement coverage of a test suite is the fraction of source statements that are executed at least once during the test. We’ll use the Go’s cover tool, which is integrated into go test, to measure statement coverage and help identify obvious gaps in the tests. This command displays the usage message of the coverage tool: $ go tool cover Usage of &#39;go tool cover&#39;: Given a coverage profile produced by &#39;go test&#39;: go test -coverprofile=c.out Open a web browser displaying annotated source code: go tool cover -html=c.out Write out an HTML file instead of launching a web browser: go tool cover -html=c.out -o coverage.html Display coverage percentages to stdout for each function: go tool cover -func=c.out The go tool command runs one of the executable from the Go toolchain. These programs live in the directory $GOROOT/pkg/tool/${GOOS}_${GOARCH}. package cover func foo(s string) string { return s } func bar(s string) string { return s } package cover import &quot;testing&quot; func TestFoo(t *testing.T) { var tests = []struct { s string want string }{ {&quot;hello&quot;, &quot;hello&quot;}, {&quot;world&quot;, &quot;world&quot;}, } for _, test := range tests { if got := foo(test.s); got != test.want { t.Errorf(&quot;foo(%q) == %q, want %q&quot;, test.s, got, test.want) } } } $ go test -covermode=count PASS coverage: 50.0% of statements ok gopl.io/ch11/cover 0.002s $ go test -coverprofile=c.out PASS coverage: 50.0% of statements ok gopl.io/ch11/cover 0.002s $ go tool cover -func=c.out gopl.io/ch11/cover/cover.go:3: foo 100.0% gopl.io/ch11/cover/cover.go:7: bar 0.0% total: (statements) 50.0% Benchmark Functions Benchmarking is the practice of measuring the performance of a program on a fixed workload. In Go, a benchmark function looks like a test function, but with the Benchmark prefix and a *testing.B parameter that provides most of the same methods as a *testing.T, plus a few extra related to performance measurement. It also exposes an integer filed N, which specifies the number of times to perform the operation being measured. func foo(s string) string { var letters []rune for _, b := range s { letters = append(letters, b) } return string(letters) } func bar(s string) string { // pre-allocate a sufficiently large array for use by letters, // rather than expand it by successive calls to append letters := make([]rune, 0, len(s)) for _, b := range s { letters = append(letters, b) } return string(letters) } func BenchmarkFoo(b *testing.B) { for n := 0; n &lt; b.N; n++ { foo(&quot;hello world&quot;) } } func BenchmarkBar(b *testing.B) { for n := 0; n &lt; b.N; n++ { bar(&quot;hello world&quot;) } } Unlike tests, by default no benchmarks are run. The argument to the -bench flag selects which benchmarks to run. It is a regular expression matching the names of Benchmark functions, with a default value that matches none of them. The “.” pattern causes it to match all benchmarks. BenchmarkFoo-2 5000000 339 ns/op BenchmarkBar-2 10000000 188 ns/op PASS ok _/tmp 4.123s The benchmark names’s numeric suffix, 2 here, indicates the value of GOMAXPROCS, which is important for concurrent benchmarks. The report tells us that each call to foo took about 0.339 microseconds, averaged over 5000000 runs. The -benchmem command-line flag will include memory allocation statistics in its report. $ go test -bench=. -benchmem BenchmarkFoo-2 5000000 333 ns/op 136 B/op 5 allocs/op BenchmarkBar-2 10000000 188 ns/op 64 B/op 2 allocs/op PASS ok _/tmp 4.088s Benchmarks like this tell us the absolute time required for a given operation, but in many settings the interesting performance questions are about the relative timings of two different operations. For example, if a function takes 1ms to process 1,000 elements, how long will it take to process 10,000 or a million? Comarative benchmarks are just regular code. They typically take the form os a single parameterized function, called from several Benchmark function with different values, like this: func benchmark(b *testing.B, size int) { /* ... */ } func Benchmark10(b *testing.B) { benchmark(b, 10) } func Benchmark100(b *testing.B) { benchmark(b, 100) } func Benchmark1000(b *testing.B) { benchmark(b, 1000) } Profiling Benchmarks are useful for measuring the performance of specific operations, but when we’re trying to make a slow program faster, we often have no idea where to begin. Programmer waste enormous amounts of time thinking about, or worry about, the speed of noncritical parts of their programs. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. When we wish to look carefully at the speed of our programs, the best technique for identifying the critical code is profiling. Profiling is an automated approach to performance measurement based on sampling a number of profile events during execution, then extrapolating from them during a post-processing step; the resutling statistical summary is called a profile. The go test tool has built-in support for serval kinds of profiling. A CPU profile identifies the functions whose executation reuqires the most CPU time. The currently running thread on each CPU is interrupted periodically by the operating system every few milliseconds, with each interruption recording once profile event before normal execution resumes. A heap profile identifies the statements responsible for allocating the most memory. The profiling library samples calls to the internal memory allocation routines so that on average, on profile event is recorded per 512KB of allocated memory. A blocking profile identifies the operations resposible for blocking goroutines the longest, such system calls, channel sends and receives, and acquisitions of locks. The profiling library records an event every time a goroutine is blocked by one the these operations. Gathering a profile for code under test is as easy as enabling one of the flags below. Be careful when using more than one flag at a time, however: the machinery for gathering one kind of profile may skew the results of others. $ go test -cpuprofile=cpu.log $ go test -blockprofile=block.log $ go test -memprofile=mem.log Profiling is especially useful in lonng-running applications, so the Go runtime’s profiling features can be eanbled under programmer control using the runtime API. Once we’ve gathered a profile, we need to analyze it using the pprof tool. This is a standard part of the Go distribution, but since it’s not an everyday tool, it’s accessed indirectly using go tool pprof. To make profiling efficient and save space, the log does not include function names; instead, functions are identified by their address. This mean that pprof needs the executalbe in order to make sense of the log. Although go test usually discards the test executable once the test is complete, when profiling is enabled it saves the executable as foo.test, where foo is the name of the tested package. The command below show how to gather and display a simple CPU profile. We’ve selected one of the benchmarks from the net/http package. It is usually better to profile specific benchmarks that have been constuctured to be representative of workloads one cares about. Benchmarking test cases is almost never representative, which is why we disabled them by using the filter -run=NONE. $ go test -run=NONE -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http BenchmarkClientServerParallelTLS64-2 30000 47156 ns/op 5201 B/op 67 allocs/op PASS ok net/http 2.726s $ go tool pprof -text -nodecount=5 ./http.test cpu.log 1380ms of 4870ms total (28.34%) Dropped 203 nodes (cum &lt;= 24.35ms) Showing top 5 nodes out of 223 (cum &gt;= 140ms) flat flat% sum% cum cum% 760ms 15.61% 15.61% 840ms 17.25% syscall.Syscall 170ms 3.49% 19.10% 490ms 10.06% runtime.mallocgc 170ms 3.49% 22.59% 170ms 3.49% runtime.memmove 140ms 2.87% 25.46% 320ms 6.57% runtime.pcvalue 140ms 2.87% 28.34% 140ms 2.87% vendor/golang_org/x/crypto/curve25519.ladderstep Example Functions The third kind of function treated specially by go test is an example function, one whose name starts with Exmaple. It has neither parameters nor results. Here’s an example function for IsPalindrome: func ExampleIsPalindrome() { fmt.Println(IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;)) fmt.Println(IsPalindrome(&quot;palindrome&quot;)) // Output: // true // false } Example functions serve three purposes. The primary one is documentation: a good example can be a more succinct or intuitive way to convey the behavior of a library function than its prose description, especially when used as a reminder or quick reference. An example can also demostrate the interaction between several types and functions belonging to one API, whereas prose documentation must always be attached to one place, like a type or function declaration or the package as a whole. And unlike exmpales within comments, example functions are real Go code, subject to compile-time checking, so they don’t become stale as the code evolves. Based on the suffix of the Example function, the web-based documentation server godoc associates example functions with the function or package they exemplify, so ExampleIsPanlidrome would be shown with the documentation for the IsPalindrome function, and an example called just Example would be associated with the word package as a whole. The second purpose is that examples are executable tests run by go test. If the exaple function contains a final // Output: comment like the one above, the test driver will execute the function and check that what it printed to its standard output matches the text within the comment. The third purpose of an example is hands-on experimentation. The godoc server at golang.org uses the Go Playground to let the user edit and run each example function from within a web browser. References Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11. testing - The Go Programming Language TableDrivenTests · golang/go Wiki Profiling Go Programs - The Go Blog The cover story - The Go Programming Language","headline":"Testing in Go Language","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/07/01/testing-in-go-language/"},"url":"https://blog.codefarm.me/2017/07/01/testing-in-go-language/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Testing in Go Language</h1><p class="c-post-meta">01 Jul 2017</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#the-go-test-tool" id="markdown-toc-the-go-test-tool">The go test Tool</a></li>
  <li><a href="#test-functions" id="markdown-toc-test-functions">Test Functions</a></li>
  <li><a href="#randomized-testing" id="markdown-toc-randomized-testing">Randomized Testing</a></li>
  <li><a href="#testing-a-command" id="markdown-toc-testing-a-command">Testing a Command</a></li>
  <li><a href="#white-box-testing" id="markdown-toc-white-box-testing">White-Box Testing</a></li>
  <li><a href="#external-test-packages" id="markdown-toc-external-test-packages">External Test Packages</a></li>
  <li><a href="#writing-effective-tests" id="markdown-toc-writing-effective-tests">Writing Effective Tests</a></li>
  <li><a href="#avoiding-brittle-tests" id="markdown-toc-avoiding-brittle-tests">Avoiding Brittle Tests</a></li>
  <li><a href="#coverage" id="markdown-toc-coverage">Coverage</a></li>
  <li><a href="#benchmark-functions" id="markdown-toc-benchmark-functions">Benchmark Functions</a></li>
  <li><a href="#profiling" id="markdown-toc-profiling">Profiling</a></li>
  <li><a href="#example-functions" id="markdown-toc-example-functions">Example Functions</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<p>Go’s approach to testing relies on one command, <strong>go test</strong>, and a set of conventions for writing test functions that <strong>go test</strong> can run. It is effective for pure testing, and it extends naturally to benchmarks and systematic examples for documentation.</p>

<h3 id="the-go-test-tool">The go test Tool</h3>

<p>The <strong>go test</strong> subcommand is a test driver for Go packages that are orgnized according to certain conventions. In a package directory, files whose names end with <strong>_test.go</strong> are not part of the package ordinarily built by <strong>go build</strong> but are a part of it when built by <strong>go test</strong>.</p>

<p>Within <strong>*_test.go</strong> files, three kinds of functions are treated specially: tests, benchmarks, and examples. A <strong><em>test function</em></strong>, which is a function whose name begins with <strong>Test</strong>, exercises some program logic for correct behavior; <strong>go test</strong> calls the test function and report the result, which is either <strong>PASS</strong> or <strong>FAIL</strong>. A <strong><em>benchmark function</em></strong> has a name beginning with <strong>Benchmark</strong> and measures the performance of some operation; <strong>go test</strong> reports the mean execution time of the operation. And an <strong><em>example function</em></strong>, whose name starts with <strong>Example</strong>, provides machine-checked documentation.</p>

<h3 id="test-functions">Test Functions</h3>

<p>Each test file must import the <strong>testing</strong> package. Test functions have the following signature:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">TestName</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Test function names must begin with <strong>Test</strong>; the optional suffix <strong>Name</strong> must begin with a capital letter:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">TestSin</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">TestCos</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">TestLog</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
</code></pre></div></div>

<p>The <strong>t</strong> parameter provides methods for reporting test failures and logging additional information.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">TestPalindrome</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">IsPalindrome</span><span class="p">(</span><span class="s">"detartrated"</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">`IsPalindrome("detartrated") = false`</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">IsPalindrome</span><span class="p">(</span><span class="s">"kayak"</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">`IsPalindrome("kayak") = false`</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">TestNonPalindrome</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">IsPalindrome</span><span class="p">(</span><span class="s">"palindrome"</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">`IsPalindrome("palindrome") = true`</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// a table-driven test</span>
<span class="k">func</span> <span class="n">TestIsPalindrome</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">tests</span> <span class="o">=</span> <span class="p">[]</span><span class="k">struct</span> <span class="p">{</span>
		<span class="n">input</span> <span class="kt">string</span>
		<span class="n">want</span>  <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">""</span><span class="p">,</span> <span class="no">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="no">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">"aa"</span><span class="p">,</span> <span class="no">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">"ab"</span><span class="p">,</span> <span class="no">false</span><span class="p">},</span>
		<span class="p">{</span><span class="s">"kayak"</span><span class="p">,</span> <span class="no">true</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tests</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">got</span> <span class="o">:=</span> <span class="n">IsPalindrome</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">input</span><span class="p">);</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"IsPalindrome(%q) = %v"</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">got</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Test failure messages are usually of the form <strong>“f(x) = y, want z”</strong>, where <strong>f(x)</strong> explains the attempted operation and its input, <strong>y</strong> is the actual result, and <strong>z</strong> is the expected result.</p>

<h3 id="randomized-testing">Randomized Testing</h3>

<p>Table-driven tests are convenient for checking that a function works on inputs carefully selected to exercise interesting cases in the logic. Another approach, <strong><em>randomized testing</em></strong>, explores a broader range of inputs by constructing inputs at random.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"math/rand"</span>

<span class="c">// randomPalindrome returns a palindrome whose length and contents</span>
<span class="c">// are derived from the pseudo-random number generator rng.</span>
<span class="k">func</span> <span class="n">randomPalindrome</span><span class="p">(</span><span class="n">rng</span> <span class="o">*</span><span class="n">rand</span><span class="o">.</span><span class="n">Rand</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="n">rng</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">25</span><span class="p">)</span> <span class="c">// random length up to 24</span>
	<span class="n">runes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="m">1</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">:=</span> <span class="kt">rune</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">0x1000</span><span class="p">))</span> <span class="c">// random rune up to '\u0999'</span>
		<span class="n">runes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
		<span class="n">runes</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kt">string</span><span class="p">(</span><span class="n">runes</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">TestRandomPalindromes</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// Initialize a pseudo-random number generator.</span>
	<span class="n">seed</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UTC</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">()</span>
	<span class="n">t</span><span class="o">.</span><span class="n">Logf</span><span class="p">(</span><span class="s">"Random seed: %d"</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
	<span class="n">rng</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">NewSource</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">:=</span> <span class="n">randomPalindrome</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
		<span class="k">if</span> <span class="o">!</span><span class="n">IsPalindrome</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"IsPalindrome(%q) = false"</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="testing-a-command">Testing a Command</h3>

<p>A package named <strong>main</strong> ordinarily produces an executable program, but it can be imported as a library too.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Echo prints its command-line arguments.</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"flag"</span>
	<span class="s">"fmt"</span>
	<span class="s">"io"</span>
	<span class="s">"os"</span>
	<span class="s">"strings"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="p">(</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">Bool</span><span class="p">(</span><span class="s">"n"</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="s">"omit trailing newline"</span><span class="p">)</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="s">"s"</span><span class="p">,</span> <span class="s">" "</span><span class="p">,</span> <span class="s">"separator"</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">var</span> <span class="n">out</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span> <span class="c">// modified during testing</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">Parse</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">echo</span><span class="p">(</span><span class="o">!*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">Args</span><span class="p">());</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stderr</span><span class="p">,</span> <span class="s">"echo: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
		<span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">echo</span><span class="p">(</span><span class="n">newline</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">sep</span> <span class="kt">string</span><span class="p">,</span> <span class="n">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">strings</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">sep</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">newline</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintln</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>By having <strong>echo</strong> write through the global variable, <strong>out</strong>, not directly to <strong>os.Stdout</strong>, the tests can substitute a different <strong>Writer</strong> implementation that records what was written for later inspection. Here’s the test, in file <strong>echo_test.go</strong>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"bytes"</span>
	<span class="s">"fmt"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">TestEcho</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">tests</span> <span class="o">=</span> <span class="p">[]</span><span class="k">struct</span> <span class="p">{</span>
		<span class="n">newline</span> <span class="kt">bool</span>
		<span class="n">sep</span>     <span class="kt">string</span>
		<span class="n">args</span>    <span class="p">[]</span><span class="kt">string</span>
		<span class="n">want</span>    <span class="kt">string</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="no">true</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">},</span>
		<span class="p">{</span><span class="no">false</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="s">""</span><span class="p">},</span>
		<span class="p">{</span><span class="no">true</span><span class="p">,</span> <span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">},</span> <span class="s">"one</span><span class="se">\t</span><span class="s">two</span><span class="se">\t</span><span class="s">three</span><span class="se">\n</span><span class="s">"</span><span class="p">},</span>
		<span class="p">{</span><span class="no">true</span><span class="p">,</span> <span class="s">","</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a,b,c</span><span class="se">\n</span><span class="s">"</span><span class="p">},</span>
		<span class="p">{</span><span class="no">false</span><span class="p">,</span> <span class="s">":"</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">},</span> <span class="s">"1:2:3"</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tests</span> <span class="p">{</span>
		<span class="n">descr</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"echo(%v, %q, %q)"</span><span class="p">,</span>
			<span class="n">test</span><span class="o">.</span><span class="n">newline</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
		<span class="n">out</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// captured output</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">echo</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">newline</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">args</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"%s failed: %v"</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="n">got</span> <span class="o">:=</span> <span class="n">out</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"%s = %q, want %q"</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Although the package name of the test code is <strong>main</strong> and it defines a <strong>main</strong> function, during testing this package acts as a library that exposes the function <strong>TestEcho</strong> to the test driver; its <strong>main</strong> function is ignored.</p>

<h3 id="white-box-testing">White-Box Testing</h3>

<p>One way of categorizing tests is by the level of knowledge they require of the internal workings of the package under test. A <strong><em>black-box</em></strong> test assumes nothing about the package other than what is exposed by its API and specified by its documentation; the package’s internal are opaque. In contrast, a <strong><em>white-box</em></strong> test has privileged access to the internal functions and data structres of th package and can make observations and changes that an ordinary client can not.</p>

<p>The two approaches are complementary. Black-box tests are usually more robust, needing fewer updates as the software evolves. They also help the test author empathize with the client of the package and can reveal flaws in the API design. In contrast, white-box tests can provide more detailed coverage of the trickier parts of the implementation.</p>

<h3 id="external-test-packages">External Test Packages</h3>

<p>Consider the package <strong>net/url</strong>, which provides a URL parser, and <strong>net/http</strong>, which provides a web server and HTTP client library. As we might expect, the higher-level <strong>net/http</strong> depends on the lover-level <strong>net/url</strong>. However, one of the tests in <strong>net/url</strong> is an example demonstrating the interaction between URLs and the HTTP client library. In other words, a test of the lover-level package imports the higher-level packages.</p>

<p><img src="/assets/gopl/a-test-of-net-url-dep-ends-on-net-http.png" alt="A test of net/url dep ends on net/http" /></p>

<p>Declaring this test function in the <strong>net/url</strong> package would create a cycle in the package import graph.</p>

<p>We resolve the problem by declaring the test function in an <strong><em>external test package</em></strong>, that is, in a file the <strong>net/url</strong> directory whose package declaration reads <strong>package url_test</strong>. The extral suffix <strong>_test</strong> is a signal to <strong>go test</strong> that it should build an additional package containing just these files and run its tests.</p>

<p>In terms of the design layers, the external test package is logically higher up than both of the package it depends upon.</p>

<p><img src="/assets/gopl/external-test-packages-bre-ak-dep-endency-cycles.png" alt="external-test-packages-bre-ak-dep-endency-cycles" /></p>

<p>We can use the <strong>go list</strong> tool to summarize which Go source files in a package directory are production code, in-pcakges tests, and external tests.</p>

<p><strong>GoFiles</strong> is the list of files that contain the production code; this are the files that <strong>go build</strong> will include in your application:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go list <span class="nt">-f</span><span class="o">={{</span>.GoFiles<span class="o">}}</span> <span class="nb">fmt</span>
<span class="o">[</span>doc.go format.go print.go scan.go]
</code></pre></div></div>

<p><strong>TestGoFiles</strong> is the list of files that also belong to the <strong>fmt</strong> package, but these files, whose names all end in <strong>_test.go</strong>, are included only when building tests:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go list <span class="nt">-f</span><span class="o">={{</span>.TestGoFiles<span class="o">}}</span> <span class="nb">fmt</span>
<span class="o">[</span>export_test.go]
</code></pre></div></div>

<p><strong>XTestGoFiles</strong> is the list of files that constitute the external test package, <strong>fmt_test</strong>, so these files must import the <strong>fmt</strong> package in order to use it. Again, they are included only during testing:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go list <span class="nt">-f</span><span class="o">={{</span>.XTestGoFiles<span class="o">}}</span> <span class="nb">fmt</span>
<span class="o">[</span>fmt_test.go scan_test.go stringer_test.go]
</code></pre></div></div>

<p>Sometimes an external test package may need privileged access to the internals of the package under test, if for example a white-box test must live in a separate package to avoid an import cycle. In such cases, we use a trick: we add declaration to an in-package <strong>_test.go</strong> file to expose the necessary internals to the external test. This file thus offers the test a “back door” to the package. If the source file exists only for this purpose and contains no tests itself, it is often called <strong>export_test.go</strong>.</p>

<h3 id="writing-effective-tests">Writing Effective Tests</h3>

<p>Other languages’ frameworks provide mechanisms for identifying test functions (often using reflection or metadata), hooks for perforrming “setup” and “teardown” operations before and after the tests run, and libraries of utility functions for asserting common predicates, comparing values, formatting error messages, and aborting a failed test (often using exceptions). Although these mechanisms can make tests very concise, the resulting tests often seem like they are written in a foreign language. Furthermore, although they may report <strong>PASSS</strong> or <strong>FALL</strong> correctly, their manner may be unfriendly to the unfortunate maintainer, with cryptic failure message like “<strong>assert: 0 == 1</strong>” or page after page of stack traces.</p>

<p>A good test does not explode on failure but prints a clear and succinct description of the symptom of the problem, and perhaps other relevant facts about the context. Ideally, the maintainer should not need to read the source code to decipher a test failure. A good test should not give up after one failure but should try to report several errors in a single run, since the pattern of failures may itself be revealing.</p>

<p>The assertion function below compares two values, constructs a generic error message, and stops the program. It’s easy to use and it’s correct, but when it fails, the error message is almost useless.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"strings"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="c">// A poor assertion function.</span>
<span class="k">func</span> <span class="n">assertEqual</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%d != %d"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">TestSplit</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">words</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="s">"a:b:c"</span><span class="p">,</span> <span class="s">":"</span><span class="p">)</span>
	<span class="n">assertEqual</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">),</span> <span class="m">3</span><span class="p">)</span>
	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this sense, assertion functions suffer from <em>premature abstraction</em>: by treating the failure of this particular test as a mere difference of two integers, we forfeit the opportunity to provide meaningful context. We can provide a better message by starting from the concrete details, as in the example below.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
	<span class="s">"strings"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">TestSplit</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">tests</span> <span class="o">=</span> <span class="p">[]</span><span class="k">struct</span> <span class="p">{</span>
		<span class="n">s</span>    <span class="kt">string</span>
		<span class="n">sep</span>  <span class="kt">string</span>
		<span class="n">want</span> <span class="kt">int</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">"a:b:c"</span><span class="p">,</span> <span class="s">":"</span><span class="p">,</span> <span class="m">3</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tests</span> <span class="p">{</span>
		<span class="n">words</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">got</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">);</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"Split(%q, %q) returned %d words, want %d"</span><span class="p">,</span>
				<span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now the test reports the function that was called, its inputs, and the significance of the results; it explicitly identifies the actual value and the expectation; and it continues to execute even if this assertion should fail.</p>

<h3 id="avoiding-brittle-tests">Avoiding Brittle Tests</h3>

<p>An application that often fails when it encounters new but valid inputs is called <em>buggy</em>; a test that spuriously fails when a sound change was made to the program is called <em>brittle</em>. Just as a buggy program frustrates its users, a brittle test exasperates its maintainers. The most brittle tests, which fail from almost any change to the production code, good or bad, are sometimes called <em>change detector</em> or <em>status quo</em> tests, and the time dealing with them can quickly deplete any benefit they once seemed to provide.</p>

<p>The easiest way to avoid brittle tests is to check only the properties you care about. Test your program’s simpler and more stable interfaces in preference to its internal functions. Be selective in your assertions. Don’t check for exact string matches, for example, but look for relevant substrings that remain unchanged as the program evolves. It’s often worth writing a substantial function to distill a complex output down to its essence so that assertions will be reliable. Even though that may seem like a lot of up-front effort, it can pay for itself quickly in time that would otherwise be spent fixing spuriously failing tests.</p>

<h3 id="coverage">Coverage</h3>

<p>No quantity of tests can ever prove a package free of bugs. At best, they increase our confidence that the package works well in a wide range of important scenarios.</p>

<p>The degree to which a test exercises the package under test is called the test’s <strong><em>coverage</em></strong>. <strong><em>Statement coverage</em></strong> is the simplest and most widely used of these heuristics. The statement coverage of a test suite is the fraction of source statements that are executed at least once during the test. We’ll use the Go’s <strong>cover</strong> tool, which is integrated into <strong>go test</strong>, to measure statement coverage and help identify obvious gaps in the tests.</p>

<p>This command displays the usage message of the coverage tool:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go tool cover
Usage of <span class="s1">'go tool cover'</span>:
Given a coverage profile produced by <span class="s1">'go test'</span>:
        go <span class="nb">test</span> <span class="nt">-coverprofile</span><span class="o">=</span>c.out

Open a web browser displaying annotated <span class="nb">source </span>code:
        go tool cover <span class="nt">-html</span><span class="o">=</span>c.out

Write out an HTML file instead of launching a web browser:
        go tool cover <span class="nt">-html</span><span class="o">=</span>c.out <span class="nt">-o</span> coverage.html

Display coverage percentages to stdout <span class="k">for </span>each <span class="k">function</span>:
        go tool cover <span class="nt">-func</span><span class="o">=</span>c.out
</code></pre></div></div>

<p>The <strong>go tool</strong> command runs one of the executable from the Go toolchain. These programs live in the directory <strong>$GOROOT/pkg/tool/${GOOS}_${GOARCH}</strong>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">cover</span>

<span class="k">func</span> <span class="n">foo</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">bar</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">cover</span>

<span class="k">import</span> <span class="s">"testing"</span>

<span class="k">func</span> <span class="n">TestFoo</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">var</span> <span class="n">tests</span> <span class="o">=</span> <span class="p">[]</span><span class="k">struct</span> <span class="p">{</span>
                <span class="n">s</span>    <span class="kt">string</span>
                <span class="n">want</span> <span class="kt">string</span>
        <span class="p">}{</span>
                <span class="p">{</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">},</span>
                <span class="p">{</span><span class="s">"world"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">},</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tests</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">got</span> <span class="o">:=</span> <span class="n">foo</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">);</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span> <span class="p">{</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"foo(%q) == %q, want %q"</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-covermode</span><span class="o">=</span>count
PASS
coverage: 50.0% of statements
ok      gopl.io/ch11/cover      0.002s
<span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-coverprofile</span><span class="o">=</span>c.out
PASS
coverage: 50.0% of statements
ok      gopl.io/ch11/cover      0.002s
<span class="nv">$ </span>go tool cover <span class="nt">-func</span><span class="o">=</span>c.out
gopl.io/ch11/cover/cover.go:3:  foo             100.0%
gopl.io/ch11/cover/cover.go:7:  bar             0.0%
total:                          <span class="o">(</span>statements<span class="o">)</span>    50.0%
</code></pre></div></div>

<h3 id="benchmark-functions">Benchmark Functions</h3>

<p>Benchmarking is the practice of measuring the performance of a program on a fixed workload. In Go, a benchmark function looks like a test function, but with the <strong>Benchmark</strong> prefix and a <strong>*testing.B</strong> parameter that provides most of the same methods as a <strong>*testing.T</strong>, plus a few extra related to performance measurement. It also exposes an integer filed <strong>N</strong>, which specifies the number of times to perform the operation being measured.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">foo</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">letters</span> <span class="p">[]</span><span class="kt">rune</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
		<span class="n">letters</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">letters</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kt">string</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">bar</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="c">// pre-allocate a sufficiently large array for use by letters,</span>
	<span class="c">// rather than expand it by successive calls to append</span>
	<span class="n">letters</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
		<span class="n">letters</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">letters</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kt">string</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkFoo</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">foo</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkBar</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">bar</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Unlike tests, by default no benchmarks are run. The argument to the <strong>-bench</strong> flag selects which benchmarks to run. It is a regular expression matching the names of <strong>Benchmark</strong> functions, with a default value that matches none of them. The “.” pattern causes it to match all benchmarks.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BenchmarkFoo-2           5000000               339 ns/op
BenchmarkBar-2          10000000               188 ns/op
PASS
ok      _/tmp   4.123s
</code></pre></div></div>

<p>The benchmark names’s numeric suffix, <strong>2</strong> here, indicates the value of <strong>GOMAXPROCS</strong>, which is important for concurrent benchmarks.</p>

<p>The report tells us that each call to <strong>foo</strong> took about 0.339 microseconds, averaged over 5000000 runs.</p>

<p>The <strong>-benchmem</strong> command-line flag will include memory allocation statistics in its report.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span><span class="nb">.</span> <span class="nt">-benchmem</span>
BenchmarkFoo-2           5000000               333 ns/op             136 B/op          5 allocs/op
BenchmarkBar-2          10000000               188 ns/op              64 B/op          2 allocs/op
PASS
ok      _/tmp   4.088s
</code></pre></div></div>

<p>Benchmarks like this tell us the absolute time required for a given operation, but in many settings the interesting performance questions are about the <em>relative</em> timings of two different operations. For example, if a function takes 1ms to process 1,000 elements, how long will it take to process 10,000 or a million?</p>

<p>Comarative benchmarks are just regular code. They typically take the form os a single parameterized function, called from several <strong>Benchmark</strong> function with different values, like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">benchmark</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">Benchmark10</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>         <span class="p">{</span> <span class="n">benchmark</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">Benchmark100</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>        <span class="p">{</span> <span class="n">benchmark</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">Benchmark1000</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>       <span class="p">{</span> <span class="n">benchmark</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="m">1000</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="profiling">Profiling</h3>

<p>Benchmarks are useful for measuring the performance of specific operations, but when we’re trying to make a slow program faster, we often have no idea where to begin.</p>

<p>Programmer waste enormous amounts of time thinking about, or worry about, the speed of noncritical parts of their programs. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.</p>

<p>When we wish to look carefully at the speed of our programs, the best technique for identifying the critical code is <strong><em>profiling</em></strong>. Profiling is an automated approach to performance measurement based on sampling a number of profile <strong><em>events</em></strong> during execution, then extrapolating from them during a post-processing step; the resutling statistical summary is called a <strong><em>profile</em></strong>.</p>

<p>The <strong>go test</strong> tool has built-in support for serval kinds of profiling.</p>

<p>A <strong><em>CPU profile</em></strong> identifies the functions whose executation reuqires the most CPU time. The currently running thread on each CPU is interrupted periodically by the operating system every few milliseconds, with each interruption recording once profile event before normal execution resumes.</p>

<p>A <strong><em>heap profile</em></strong> identifies the statements responsible for allocating the most memory. The profiling library samples calls to the internal memory allocation routines so that on average, on profile event is recorded per 512KB of allocated memory.</p>

<p>A <strong><em>blocking profile</em></strong> identifies the operations resposible for blocking goroutines the longest, such system calls, channel sends and receives, and acquisitions of locks. The profiling library records an event every time a goroutine is blocked by one the these operations.</p>

<p>Gathering a profile for code under test is as easy as enabling one of the flags below. Be careful when using more than one flag at a time, however: the machinery for gathering one kind of profile may skew the results of others.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-cpuprofile</span><span class="o">=</span>cpu.log
<span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-blockprofile</span><span class="o">=</span>block.log
<span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-memprofile</span><span class="o">=</span>mem.log
</code></pre></div></div>

<p>Profiling is especially useful in lonng-running applications, so the Go runtime’s profiling features can be eanbled under programmer control using the <strong>runtime</strong> API.</p>

<p>Once we’ve gathered a profile, we need to analyze it using the <strong>pprof</strong> tool. This is a standard part of the Go distribution, but since it’s not an everyday tool, it’s accessed indirectly using <strong>go tool pprof</strong>.</p>

<p>To make profiling efficient and save space, the log does not include function names; instead, functions are identified by their address. This mean that <strong>pprof</strong> needs the executalbe in order to make sense of the log. Although <strong>go test</strong> usually discards the test executable once the test is complete, when profiling is enabled it saves the executable as <strong>foo.test</strong>, where <strong>foo</strong> is the name of the tested package.</p>

<p>The command below show how to gather and display a simple CPU profile. We’ve selected one of the benchmarks from the <strong>net/http</strong> package. It is usually better to profile specific benchmarks that have been constuctured to be representative of workloads one cares about. Benchmarking test cases is almost never representative, which is why we disabled them by using the filter <strong>-run=NONE</strong>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-run</span><span class="o">=</span>NONE <span class="nt">-bench</span><span class="o">=</span>ClientServerParallelTLS64 <span class="nt">-cpuprofile</span><span class="o">=</span>cpu.log net/http
BenchmarkClientServerParallelTLS64-2       30000             47156 ns/op           5201 B/op          67 allocs/op
PASS
ok      net/http        2.726s
<span class="nv">$ </span>go tool pprof <span class="nt">-text</span> <span class="nt">-nodecount</span><span class="o">=</span>5 ./http.test cpu.log
1380ms of 4870ms total <span class="o">(</span>28.34%<span class="o">)</span>
Dropped 203 nodes <span class="o">(</span>cum &lt;<span class="o">=</span> 24.35ms<span class="o">)</span>
Showing top 5 nodes out of 223 <span class="o">(</span>cum <span class="o">&gt;=</span> 140ms<span class="o">)</span>
      flat  flat%   <span class="nb">sum</span>%        cum   cum%
     760ms 15.61% 15.61%      840ms 17.25%  syscall.Syscall
     170ms  3.49% 19.10%      490ms 10.06%  runtime.mallocgc
     170ms  3.49% 22.59%      170ms  3.49%  runtime.memmove
     140ms  2.87% 25.46%      320ms  6.57%  runtime.pcvalue
     140ms  2.87% 28.34%      140ms  2.87%  vendor/golang_org/x/crypto/curve25519.ladderstep
</code></pre></div></div>

<h3 id="example-functions">Example Functions</h3>

<p>The third kind of function treated specially by <strong>go test</strong> is an example function, one whose name starts with <strong>Exmaple</strong>. It has neither parameters nor results. Here’s an example function for <strong>IsPalindrome</strong>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ExampleIsPalindrome</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">IsPalindrome</span><span class="p">(</span><span class="s">"A man, a plan, a canal: Panama"</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">IsPalindrome</span><span class="p">(</span><span class="s">"palindrome"</span><span class="p">))</span>
	<span class="c">// Output:</span>
	<span class="c">// true</span>
	<span class="c">// false</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Example functions serve three purposes. The primary one is documentation: a good example can be a more succinct or intuitive way to convey the behavior of a library function than its prose description, especially when used as a reminder or quick reference. An example can also demostrate the interaction between several types and functions belonging to one API, whereas prose documentation must always be attached to one place, like a type or function declaration or the package as a whole. And unlike exmpales within comments, example functions are real Go code, subject to compile-time checking, so they don’t become stale as the code evolves.</p>

<p>Based on the suffix of the <strong>Example</strong> function, the web-based documentation server <strong>godoc</strong> associates example functions with the function or package they exemplify, so <strong>ExampleIsPanlidrome</strong> would be shown with the documentation for the <strong>IsPalindrome</strong> function, and an example called just <strong>Example</strong> would be associated with the <strong>word</strong> package as a whole.</p>

<p>The second purpose is that examples are executable tests run by <strong>go test</strong>. If the exaple function contains a final <strong>// Output:</strong> comment like the one above, the test driver will execute the function and check that what it printed to its standard output matches the text within the comment.</p>

<p>The third purpose of an example is hands-on experimentation. The <strong>godoc</strong> server at <strong>golang.org</strong> uses the Go Playground to let the user edit and run each example function from within a web browser.</p>

<hr />

<h3 id="references">References</h3>

<ol>
  <li>Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11.</li>
  <li><a href="https://golang.org/pkg/testing/">testing</a> - The Go Programming Language</li>
  <li><a href="https://github.com/golang/go/wiki/TableDrivenTests">TableDrivenTests</a> · golang/go Wiki</li>
  <li><a href="https://blog.golang.org/profiling-go-programs">Profiling Go Programs</a> - The Go Blog</li>
  <li><a href="https://go.dev/blog/cover">The cover story</a> - The Go Programming Language</li>
</ol>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
