<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Keywords in C Language | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Keywords in C Language" />
<meta property="og:locale" content="en" />
<meta name="description" content="Keywords are special identifiers reserved for use as part of the programming language itself. You cannot use them for any other purpose. Here is a list of 32 keywords recognized by ANSI C89: auto register static extern const volatile int short long float double char unsigned signed void if else switch case default for do while goto break continue struct union enum typedef return sizeof ISO C99 adds the followinig keywords: inline _Bool _Complex _Imaginary and GNU extensions add these keywords: __FUNCTION__ __PRETTY_FUNCTION__ __alignof __alignof__ __asm __asm__ __attribute __attribute__ __builtin_offsetof __builtin_va_arg __complex __complex__ __const __extension__ __func__ __imag __imag__ __inline __inline__ __label__ __null __real __real__ __restrict __restrict__ __signed __signed__ __thread __typeof __volatile __volatile__ In both ISO C99 and C89 with GNU extensions, the following is also recognized as a keyword: restrict Storage Class Specifiers There are four storage class specifiers that you can prepend to your variable declarations which change how the variables are stored in memory: auto, extern, register, and static. You use auto for variables which are local to a function, and whose values should be discarded upon return from the function in which they are declared. This is the default behavior for variables declared within functions. void foo(int value) { auto int x = value; ... return; } register is nearly identical in purpose to auto, except that it also suggests to the compiler that the variable will be heavily used, and, if possible, should be stored in a register. You cannot use the address-of operator to obtain the address of a variable declared with register. This means that you cannot refer to the elements of an array declared with storage class register. In fact the only thing you can do with such an array is measure its size with sizeof. GCC normally makes good choices about which values to hold in regiseters, and so register is not often used. static is essentially the opposite of auto: when applied to variables within a function or block, these variables will retain their value even when the function or block is finised. This is know as static storage duration. int sum(int x) { static int sumSoFar = 0; sumSoFar = sumSoFar + x; return sumSoFar; } You can alos declare variables (or functions) at the top level (that is, not inside a function) to be static; such variables are visible (global) to the current source file (but not other source file). This gives an unfortunate double meaning to static; this second meaning is known as static linkage. Two functions or variables having static linkage in separate files are entirely separate; neither is visiable outside the file in which it is declared. Uninitialized variables are declared as extern are given default value of 0, 0.0, or NULL, depending on the type. Unintialized variables that are declared as auto or register (including the default usage of auto) are left uninitialized, and hence should be assumed to hold any particular value. extern is useful for declaring variables that you want to be visible to all source files that are linked into your project. You cannot initialize a variable in an extern declaration,as no space is actually allocated during the declaration. You must make both an extern declaration (typically in a header file that is included by the other source files which need to access the variable) and a non-extern declartion which is where space is actually to store the variable. The extern declaration may be repeated multiple times. extern int numberOfClients; . . . int numberOfClients = 0; References https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html" />
<meta property="og:description" content="Keywords are special identifiers reserved for use as part of the programming language itself. You cannot use them for any other purpose. Here is a list of 32 keywords recognized by ANSI C89: auto register static extern const volatile int short long float double char unsigned signed void if else switch case default for do while goto break continue struct union enum typedef return sizeof ISO C99 adds the followinig keywords: inline _Bool _Complex _Imaginary and GNU extensions add these keywords: __FUNCTION__ __PRETTY_FUNCTION__ __alignof __alignof__ __asm __asm__ __attribute __attribute__ __builtin_offsetof __builtin_va_arg __complex __complex__ __const __extension__ __func__ __imag __imag__ __inline __inline__ __label__ __null __real __real__ __restrict __restrict__ __signed __signed__ __thread __typeof __volatile __volatile__ In both ISO C99 and C89 with GNU extensions, the following is also recognized as a keyword: restrict Storage Class Specifiers There are four storage class specifiers that you can prepend to your variable declarations which change how the variables are stored in memory: auto, extern, register, and static. You use auto for variables which are local to a function, and whose values should be discarded upon return from the function in which they are declared. This is the default behavior for variables declared within functions. void foo(int value) { auto int x = value; ... return; } register is nearly identical in purpose to auto, except that it also suggests to the compiler that the variable will be heavily used, and, if possible, should be stored in a register. You cannot use the address-of operator to obtain the address of a variable declared with register. This means that you cannot refer to the elements of an array declared with storage class register. In fact the only thing you can do with such an array is measure its size with sizeof. GCC normally makes good choices about which values to hold in regiseters, and so register is not often used. static is essentially the opposite of auto: when applied to variables within a function or block, these variables will retain their value even when the function or block is finised. This is know as static storage duration. int sum(int x) { static int sumSoFar = 0; sumSoFar = sumSoFar + x; return sumSoFar; } You can alos declare variables (or functions) at the top level (that is, not inside a function) to be static; such variables are visible (global) to the current source file (but not other source file). This gives an unfortunate double meaning to static; this second meaning is known as static linkage. Two functions or variables having static linkage in separate files are entirely separate; neither is visiable outside the file in which it is declared. Uninitialized variables are declared as extern are given default value of 0, 0.0, or NULL, depending on the type. Unintialized variables that are declared as auto or register (including the default usage of auto) are left uninitialized, and hence should be assumed to hold any particular value. extern is useful for declaring variables that you want to be visible to all source files that are linked into your project. You cannot initialize a variable in an extern declaration,as no space is actually allocated during the declaration. You must make both an extern declaration (typically in a header file that is included by the other source files which need to access the variable) and a non-extern declartion which is where space is actually to store the variable. The extern declaration may be repeated multiple times. extern int numberOfClients; . . . int numberOfClients = 0; References https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html" />
<link rel="canonical" href="https://blog.codefarm.me/2017/02/26/keywords-in-c-language/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/02/26/keywords-in-c-language/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-02-26T09:32:02+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Keywords in C Language" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-02-26T09:32:02+08:00","datePublished":"2017-02-26T09:32:02+08:00","description":"Keywords are special identifiers reserved for use as part of the programming language itself. You cannot use them for any other purpose. Here is a list of 32 keywords recognized by ANSI C89: auto register static extern const volatile int short long float double char unsigned signed void if else switch case default for do while goto break continue struct union enum typedef return sizeof ISO C99 adds the followinig keywords: inline _Bool _Complex _Imaginary and GNU extensions add these keywords: __FUNCTION__ __PRETTY_FUNCTION__ __alignof __alignof__ __asm __asm__ __attribute __attribute__ __builtin_offsetof __builtin_va_arg __complex __complex__ __const __extension__ __func__ __imag __imag__ __inline __inline__ __label__ __null __real __real__ __restrict __restrict__ __signed __signed__ __thread __typeof __volatile __volatile__ In both ISO C99 and C89 with GNU extensions, the following is also recognized as a keyword: restrict Storage Class Specifiers There are four storage class specifiers that you can prepend to your variable declarations which change how the variables are stored in memory: auto, extern, register, and static. You use auto for variables which are local to a function, and whose values should be discarded upon return from the function in which they are declared. This is the default behavior for variables declared within functions. void foo(int value) { auto int x = value; ... return; } register is nearly identical in purpose to auto, except that it also suggests to the compiler that the variable will be heavily used, and, if possible, should be stored in a register. You cannot use the address-of operator to obtain the address of a variable declared with register. This means that you cannot refer to the elements of an array declared with storage class register. In fact the only thing you can do with such an array is measure its size with sizeof. GCC normally makes good choices about which values to hold in regiseters, and so register is not often used. static is essentially the opposite of auto: when applied to variables within a function or block, these variables will retain their value even when the function or block is finised. This is know as static storage duration. int sum(int x) { static int sumSoFar = 0; sumSoFar = sumSoFar + x; return sumSoFar; } You can alos declare variables (or functions) at the top level (that is, not inside a function) to be static; such variables are visible (global) to the current source file (but not other source file). This gives an unfortunate double meaning to static; this second meaning is known as static linkage. Two functions or variables having static linkage in separate files are entirely separate; neither is visiable outside the file in which it is declared. Uninitialized variables are declared as extern are given default value of 0, 0.0, or NULL, depending on the type. Unintialized variables that are declared as auto or register (including the default usage of auto) are left uninitialized, and hence should be assumed to hold any particular value. extern is useful for declaring variables that you want to be visible to all source files that are linked into your project. You cannot initialize a variable in an extern declaration,as no space is actually allocated during the declaration. You must make both an extern declaration (typically in a header file that is included by the other source files which need to access the variable) and a non-extern declartion which is where space is actually to store the variable. The extern declaration may be repeated multiple times. extern int numberOfClients; . . . int numberOfClients = 0; References https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html","headline":"Keywords in C Language","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/02/26/keywords-in-c-language/"},"url":"https://blog.codefarm.me/2017/02/26/keywords-in-c-language/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Keywords in C Language</h1><p class="c-post-meta">26 Feb 2017</p>
  </header>

  <div class="c-post-content">
    <p>Keywords are special identifiers reserved for use as part of the programming language itself. You cannot use them for any other purpose.</p>

<p>Here is a list of 32 keywords recognized by <strong>ANSI C89</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span>      <span class="k">register</span>  <span class="k">static</span>    <span class="k">extern</span>    <span class="k">const</span>     <span class="k">volatile</span>
<span class="kt">int</span>       <span class="kt">short</span>     <span class="kt">long</span>      <span class="kt">float</span>     <span class="kt">double</span>    <span class="kt">char</span>      <span class="kt">unsigned</span>  <span class="kt">signed</span>    <span class="kt">void</span>
<span class="k">if</span>        <span class="k">else</span>
<span class="k">switch</span>    <span class="k">case</span>      <span class="k">default</span>
<span class="k">for</span>       <span class="k">do</span>        <span class="k">while</span>
<span class="k">goto</span>
<span class="k">break</span>     <span class="k">continue</span>
<span class="k">struct</span>    <span class="k">union</span>     <span class="k">enum</span>      <span class="k">typedef</span>
<span class="k">return</span>
<span class="k">sizeof</span>
</code></pre></div></div>

<p><strong>ISO C99</strong> adds the followinig keywords:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span>  <span class="kt">_Bool</span>   <span class="kt">_Complex</span>    <span class="k">_Imaginary</span>
</code></pre></div></div>

<p>and <strong>GNU extensions</strong> add these keywords:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__FUNCTION__</span>    <span class="n">__PRETTY_FUNCTION__</span>    <span class="n">__alignof</span>    <span class="n">__alignof__</span>
<span class="kr">__asm</span>    <span class="n">__asm__</span>    <span class="n">__attribute</span>    <span class="n">__attribute__</span>
<span class="n">__builtin_offsetof</span>    <span class="n">__builtin_va_arg</span>    <span class="n">__complex</span>    <span class="n">__complex__</span>
<span class="n">__const</span>    <span class="n">__extension__</span>    <span class="n">__func__</span>
<span class="n">__imag</span>    <span class="n">__imag__</span>        <span class="kr">__inline</span>    <span class="n">__inline__</span>
<span class="n">__label__</span>    <span class="n">__null</span>    <span class="n">__real</span>    <span class="n">__real__</span>
<span class="kr">__restrict</span>    <span class="n">__restrict__</span>    <span class="n">__signed</span>    <span class="n">__signed__</span>
<span class="kr">__thread</span>    <span class="n">__typeof</span>    <span class="n">__volatile</span>    <span class="n">__volatile__</span>
</code></pre></div></div>

<p>In both ISO C99 and C89 with GNU extensions, the following is also recognized as a keyword:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">restrict</span>
</code></pre></div></div>

<h4 id="storage-class-specifiers">Storage Class Specifiers</h4>

<p>There are four storage class specifiers that you can prepend to your variable declarations which change how the variables are stored in memory: <code class="language-plaintext highlighter-rouge">auto</code>, <code class="language-plaintext highlighter-rouge">extern</code>, <code class="language-plaintext highlighter-rouge">register</code>, and <code class="language-plaintext highlighter-rouge">static</code>.</p>

<p>You use <code class="language-plaintext highlighter-rouge">auto</code> for variables which are local to a function, and whose values should be discarded upon return from the function in which they are declared. This is the default behavior for variables declared within functions.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">register</code> is nearly identical in purpose to <code class="language-plaintext highlighter-rouge">auto</code>, except that it also suggests to the compiler that the variable will be heavily used, and, if possible, should be stored in a register. You cannot use the address-of operator to obtain the address of a variable declared with <code class="language-plaintext highlighter-rouge">register</code>. This means that you cannot refer to the elements of an array declared with storage class <code class="language-plaintext highlighter-rouge">register</code>. In fact the only thing you can do with such an array is measure its size with <code class="language-plaintext highlighter-rouge">sizeof</code>. GCC normally makes good choices about which values to hold in regiseters, and so <code class="language-plaintext highlighter-rouge">register</code> is not often used.</p>

<p><code class="language-plaintext highlighter-rouge">static</code> is essentially the opposite of <code class="language-plaintext highlighter-rouge">auto</code>: when applied to variables within a function or block, these variables will retain their value even when the function or block is finised. This is know as <code class="language-plaintext highlighter-rouge">static storage duration</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">sumSoFar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumSoFar</span> <span class="o">=</span> <span class="n">sumSoFar</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sumSoFar</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can alos declare variables (or functions) at the top level (that is, not inside a function) to be <code class="language-plaintext highlighter-rouge">static</code>; such variables are visible (global) to the current source file (but not other source file). This gives an unfortunate double meaning to <code class="language-plaintext highlighter-rouge">static</code>; this second meaning is known as <em><code class="language-plaintext highlighter-rouge">static linkage</code></em>. Two functions or variables having static linkage in separate files are entirely separate; neither is visiable outside the file in which it is declared.</p>

<p>Uninitialized variables are declared as <code class="language-plaintext highlighter-rouge">extern</code> are given default value of <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">0.0</code>, or <code class="language-plaintext highlighter-rouge">NULL</code>, depending on the type. Unintialized variables that are declared as <code class="language-plaintext highlighter-rouge">auto</code> or <code class="language-plaintext highlighter-rouge">register</code> (including the default usage of <code class="language-plaintext highlighter-rouge">auto</code>) are left uninitialized, and hence should be assumed to hold any particular value.</p>

<p><code class="language-plaintext highlighter-rouge">extern</code> is useful for declaring variables that you want to be visible to all source files that are linked into your project. You cannot initialize a variable in an <code class="language-plaintext highlighter-rouge">extern</code> declaration,as no space is actually allocated during the declaration. You must make both an <code class="language-plaintext highlighter-rouge">extern</code> declaration (typically in a header file that is included by the other source files which need to access the variable) and a non-<code class="language-plaintext highlighter-rouge">extern</code> declartion which is where space is actually to store the variable. The <code class="language-plaintext highlighter-rouge">extern</code> declaration may be repeated multiple times.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="n">numberOfClients</span><span class="p">;</span>
<span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
<span class="kt">int</span> <span class="n">numberOfClients</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h3 id="references">References</h3>

<ol>
  <li><a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Keywords">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html</a></li>
</ol>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
