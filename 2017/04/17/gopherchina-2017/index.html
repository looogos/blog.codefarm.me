<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>GopherChina 2017 | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="GopherChina 2017" />
<meta property="og:locale" content="en" />
<meta name="description" content="1.1 Go在大数据开发中的经验总结 七牛云 # 成熟而复杂的大数据生态 # Pandora 的理念 # 关键字 # protobuf 序列化协议 # 变长的失败等待时间 1.2 Go in TiDB PingCAP # What is TiDB Scalability High Availability SQL ACID # Architecture # Example - SQL # Challenges in Buiding a Distributed Database # Parallel Data Scan Operator # Parallel HashJoin Operator # Goroutine leak : Block profile Timeout Context # Memory &amp;&amp; GC 1.3 Go coding in go way Neusoft 1.4 interface.presented @francesc 1.5 NSQ-重塑之路 1.6 Aliyun ApasaDB Go 微服务架构 阿里云 # Dubbo background # Micro-services complexity # Profound of Java vs. Golang (Spring vs. Go Tooling) # Introducting of gRPC (https://grpc.io/] # Dubbo vs. Go kit # Micro-services best practices 1.7 Automate App Operation @coreos # How to Deploy # etcd Operator # Deploy App Container 1.8 Go 微服务实战 @哔哩哔哩 # 微服务演进 分解单块系统 # 高可用 # 中间件 # 持续集成和交付 # 运维体系 # 引用&amp;参考 2.1 Go 打造亿级实时分布式平台 Grab # Distributed Tracing 2.2 Go 语言在讯联扫码支付系统中的成功实践 讯联 2.3 Golang 在百万级搜索中的应用 360 2.4 Go’s Hidden Pragrams @davecheney 2.5 跨境电商的 Go 服务治理实践 2.6 ContainerOps DevOps Orchestration 2.7 Harbor 开源项目容器镜像远程复制的实现 2.8 Go 在证券行情系统中的应用 2.9 Go 语言在证券期货行情系统中的实践 1.1 Go在大数据开发中的经验总结 七牛云 一站式大数据服务平台 - Pandora # 成熟而复杂的大数据生态 数据可视化 Zeppelin HUE Kibana 数据检索/分析平台 Apache Spark Apache Hadoop Hive Elastic 集群调度 Yarn Apache MESOS 存储/消息队列 Kafka HDFS 数据收集/管道 Logstash Telegraf Flume 监控 Prometheus influx data Grafana # Pandora 的理念 将多样的大数据工具整合 将复杂的大数据管理简化 构建完整的大数据生命周期闭环 收集 加工 分析 管理 消费 冷冻 # 关键字 『日志』『消息队列』『计算任务』『导出任务』『聚合』『压缩』『时序数据库』『日志检索服务』『对象存储服务』 『Log』『SDK』『WEB』『IoT』『Pipeline』『Transform』『Export』『TSDB』『LogDB』『Parquet』『ORC』『Text gzip』『Grafana』『Kibana』『Xspark 离线分析』『Spark Streaming』『MongoDB』『HTTP』 『实时数据增量』『海量数据导出时延』『数据传输模型 PULL PUSH』『上下游吞吐量』『链路损耗』『网卡』『内存』『网络』 『上下游解耦』『拉取与推送解耦』『数据预取』『队列暂存』『拉取与发送并行』 『任务分割』『水平扩展』『任务标准化：每个任务承载固定的流量』 『资源利用率』『调度』『平衡』 『任务管理』『运维』『运营』『监控』 『buffer』『channel』『process』『thread』『goroutine』『schedule』『admin』『Golang』 『source』『transaction pool』『transaction put queue』『memory queue』『transaction send queue』『sink』『local file queue』『checkpoint sink』『restart workflow』『offset,check』『replay』『task statemachine』 『分布式一致性』『zookeeper/etcd』『最终一致性：pull 系统 + 版本戳』 『平衡调度算法』『Key hash』 『数据重复』『数据丢失』『写入：平滑&amp;毛刺』『低延时』 # protobuf 序列化协议 通过 protobuf 协议与上游通信 不重复解析数据，去除 json 等解析的 cpu 消耗 # 变长的失败等待时间 向下游写入失败，则休眠 1s 再重试，依然失败则休眠时间增加，一直到 10s 为止 如写入成功，则失败的休眠时间重置为 1s 有效减少下游压力 1.2 Go in TiDB PingCAP # What is TiDB Scalability High Availability SQL ACID A Distributed, Consistent, Scablable, SQL Database that supports the best features of both traditional RDBMS and NoSQL. # Architecture The Whole World Applications -&gt; Load Balancer (LVS, HAproxy, F5, ...) -&gt; TiDB Servers -&gt; TiKV Cluster TiDB Server &lt;-&gt; PD Server &lt;-&gt; TiKV Server SQL Layer Protocol Layer Client - Packet -&gt; Listener - Packet -&gt; Connection Context - Command -&gt; Protocol Decode -&gt; SQL -&gt; SQL Core Layer -&gt; Data -&gt; Protocol Encode - Data -&gt; Connection Context - Packet -&gt; Client SQL Core Layer Protocol Layer - SQL -&gt; Session Context - SQL -&gt; Parser - AST -&gt; Validator - AST -&gt; Type infer - AST -&gt; Logical Optimizer - Logical Plan -&gt; Physical Optimizer - Physical Plan -&gt; Executor: Local &amp;&amp; Distributed -&gt; TiKV -&gt; Executor: Distributed - Data -&gt; Session Context - Data -&gt; Protocol Encode - Data -&gt; Connection Context - Packet -&gt; Client # Example - SQL Schema: CREATE TABLE t (c1 INT, c2 varchar(32)), INDEX idx1 (c1)); Query: SELECT COUNT(c1) FROM t WHERE c1 &gt; 10 AND c2 = &quot;gopherchina&quot;; Logical Plan AST: SelectStmt Node -&gt; Logica Plan &lt;&gt; DataSource: from t -&gt; Where: c1 &gt; 10 and c2 = &quot;gopherchina&quot; -&gt; Projection: count(c1) Physical Plan Logical Plan -&gt; Physical Plan &lt;&gt; IndexScan: idx1: (10, +∞) -&gt; Filter: c2 = &quot;gopherchina&quot; -&gt; Aggregation: count(c1) Distributed Physical Plan Phisical Plan on TiKV: Read Index: idx1: (10, +∞ ) - RowID -&gt; Read Row Data by RowID - Row -&gt; Filter: c2=gopherchina - Row -&gt; Partial Aggregate: count(c1) - count(c1) -&gt; Physical Plan on TiDB: DistSQL Scan - count(c1) -&gt; Final Aggregate: sum(count(c1)) # Challenges in Buiding a Distributed Database A very complex distributed system A lot of RPC work High performance Tons of data Huge amount of OLTP queries Very complex OLAP queries Why Go? goroutine channel GC concurrent multi-core # Parallel Data Scan Operator Executor - Index Ranges -&gt; IndexScan Executor: Split Task by range -&gt; Task Pool &lt;- Pick Task -&gt; Woker Pool &lt;-&gt; TiKV IndexScan Executor - Row IDs -&gt; TableScan Executor - Tasks -&gt; Task Pool Worker Pool - Rows -&gt; TableScan Executor - Rows -&gt; Executor # Parallel HashJoin Operator TiKV =&gt; Tables: (Left &amp;&amp; Right) Left Table -&gt; Build HashTable - Hash Table Right Table -*&gt; Join Wokers -&gt; Left: Hash Table -&gt; Joined Table # Goroutine leak : Block profile Timeout Context # Memory &amp;&amp; GC Reduce the Number of Allocation Get enough memory in one allocation operation Reuse Object Introduce a cache in goyacc Share a stack for all queries in one session sync.Pool Thread safe Reuse objects to relieve pressure on the GC gogo/protobuf Fast marshalling and unmarshalling Fields without pointers cause less time in the garbage collector Monitor the Memory Usage Monitor the memory usage of the server is easy rutime.MemProfile() Monitor the memory usage of a session is hard Account for large memory allocation Account for memory consuming operators 1.3 Go coding in go way Neusoft “Language influences/determines thought” - Sapir-Whorf hypotheisi “A language that doesn’t affect the way you think about programming is not worth knowing.” - Alan J. Perlis 1.4 interface.presented @francesc “interface{} says nothing” - Rob Pike in his Go Proverbs “The bigger the interface, the weaker the abstraction” - Rob Pike in his Go Proverbs // what function do you prefer? // Cons: // - how would you test it? // - what if you want to write to memory? // Pros: // - ? func WriteTo(f *os.File) error // Write, Read, Close: // Which one does WriteTo really need? func WriteTo(w io.ReadWriterCloser) error func WriteTo(w io.Writer) error // winner // Cons: // - how do you even write to interface{}? // - probably requires runtimes checks // Pros: // - you can write really bad code func WriteTo(w interface{}) error “Be conservative in what you do, be liberal in what you accept from others” - Robustness Principle “Be conservative in what you send, be liberal in what you accept” - Robustness Principle “Return concrete types, receive interfaces as paramters, unless hiding immplementaion detail” - Robustness Principle applied to Go (me) // what function do you prefer? func New() *os.File // winner func New() io.ReadWriteCloser func New() io.Writer func New() interface{} 1.5 NSQ-重塑之路 MQ NSQ Replication HA Auto-Balance Delivery in Order Tracing Consume History Messages Leader Follower Writer Buffer Group Commit Cursor Offset Channel Optimize channel timeout in Go timer goroutine timeout event chan Worker Goroutine Pool etcd State Machine Jespen 分布式跟踪 分布式测试 1.6 Aliyun ApasaDB Go 微服务架构 阿里云 # Dubbo background 分布式 RPC 框架 Play nice with Java Spring application (J2EE) Features: 服务动态注册&amp;服务发现 SOA 服务治理 软负载均衡 熔断、服务降级 服务分层 服务授权 服务容器 服务编排 软负载均衡 服务质量协定 服务容量评估 服务路由 服务测试 服务降级 服务注册与发现 调度中心 监控中心 注册中心 治理中心 # Micro-services complexity Testing is still HARD! DevOps culture? Security? Distributed Tracing? Huge payload (Dubbo specific) Java is “SO DYNAMIC”! Spring IoC (DI) AoP # Profound of Java vs. Golang (Spring vs. Go Tooling) Java No all Java Applications are Spring Application (and not all Java Developers are Spring Developers) Spring is BIG (Spring 2~4), and too much magics happening Dubbo’s IDL is a Java interface class JVM is a memory hog (0.5~6GB per micro-service JVM) Golang Simple, Elegant (i.e., defer vs finnaly) and forced to bundle 3rd part sources codes Go tooling: go test/go test -bench &amp; go tool &lt;pprof/vet/cover/…&gt; go-torch (by Uber) Memory (&lt;=0.5GB per application container) # Introducting of gRPC (https://grpc.io/] Open sourced version of Google “Stubby RPC” IDL for the service APIs “HTTP/2” &amp; “Bi-Directional streaming”! Working with Protobuf3 Generated both client and server in 9 languages, offically (other with C language binding are available) # Dubbo vs. Go kit   Dubbo &amp; Spring Go kit Service Discovery &amp; LB Dubbo Registry &amp; Dubbo Subscriber github.com/go-kit/kit/sd/(zk/consul/etcd/dnssrv/lb) google.golang.org/grpc/naming (lack of structured versioning) “Structured” Logging Log4j/Slf4j github.com/go-kit/kit/log Metrics Spring Actuator (many others) github.com/go-kit/kit/metrics Circuit Breaker Dubbo/Netflix Hystrix github.com/go-kit/kit/circuitbreaker Transports HTTP(JSON)/Dubbo/(gRPC) github.com/go-kit/kit/transport/(grpc/http/httprp) Caching layer Dubbo/Spring Cache - Distributed Tracing ELK/(天象全链路路) github.com/go-kit/kit/tracing (OpenTracing project) # Micro-services best practices Design with “Single” domain in mind (DB) Strong DevOps culture - CI/CD Logging, Metrics and Tracing Logging Options - Aliyun Logging Services/Apache Kafka/ELK A trace ID to co-relate all the requests that’s been made Transactional requests with idempotences handing in mind/Eventual Consistency Think twice if you need to propagate your requests to a number of micro-services request in “parallel” Provider servies governance and versioning Circuit Breaker/Fallbacks Multi-region cluster/failover Employ Container/Docker technologies (DevOps) Docker-compose swarm k8s Be very careful when introduce a whole new set of framework/library (shoot yourself in the foot) SIMPLE is the BEST 1.7 Automate App Operation @coreos main.go package main import ( &quot;log&quot; &quot;net/http&quot; ) func main() { fs := http.FileServer(http.Dir(&quot;static&quot;)) http.Handle(&quot;/&quot;, fs) log.Println(&quot;Listening on 0.0.0.0:30080&quot;) http.ListenAndServe(&quot;0.0.0.0:30080&quot;, nil) } Development - idea + code -&gt; 程序 打包 发布: docker build/docker push -&gt; Deployment - DNS LB # How to Deploy Database: PostgreSQL, MySQL, TiDB Coordination service: etcd, ZooKeeper Streaming: Kafka, Heron Big data: Spark, Hadoop Storage: Ceph, GlusterFS Logging: ElasticSearch Monitoring: Prometheus # etcd Operator Common Tasks Resize Upgrade Backup Failover Advanced Restore TLS Monitoring/Alerting # Deploy App Container Docker/OCI Standard app packaging format Kubernetes/Swarm Resource scheduling, cluster management Operator App specific operation automation Automation Declarative Version-controlled Cloud-native Customizable Composable 1.8 Go 微服务实战 @哔哩哔哩 推荐：纽曼(Sam Newman) 的 《微服务设计》 # 微服务演进 分解单块系统 梳理业务边界 资源隔离部署 内外网服务隔离 RPC 框架 序列化 (GOB) 上下文管理 (超时控制) 拦截器 (鉴权、统计、限流) 服务注册 (Zookeeper) 负载均衡 (客户端) API Gateway 统一&amp;聚合协议 errgroup 并行调用 业务隔离 熔断、降级、限流等高可用 # 高可用 隔离 服务 轻重 物理 超时 连接 读取 写入 限流 流量 accept connection thread 资源 connection pool thread pool 请求 总数 时间窗口 平滑限流 分布式 redis + lua nginx + lua 接入层 nginx limit_req nginx limit_conn 降级 链路 自动 手动 容错 重试容错 简单重试 主备重试 成功率重试 快速失败 熔断容错 动态剔除 异常恢复 # 中间件 databus (Kafka) canal (MySQL Replication) bilitw (Twemproxy) bfs (facebook haystac, opencv) config-service dapper (google dapper) # 持续集成和交付 版本管理 (语义化） Semantic Versioning 2.0.0 分支管理 (gitlab+mr review) A successful Git branching model 环境管理 (集成环境) 测试 (单元测试，服务测试) 发布 (冒烟、灰度、蓝绿) # 运维体系 服务日志收集、分发、存储、UI 分布式跟踪 Zabbix Dapper ELK: (Elastic Search, Logstash, Kibana) # 引用&amp;参考 [英] 纽曼（Sam Newman） (作者), 崔力强 张骏 (译者)《微服务设计》 http://semver.org/#semantic-versioning-200 http://nvie.com/posts/a-successful-git-branching-model/ 2.1 Go 打造亿级实时分布式平台 Grab RAILS NodeJS amazon web services Travis CI GitHub MySQL GitHub MySQL redis amazon web services PHABRICATOR Jenkins etcd k8s docker Kafka Spark Presto Amazon KINESIS DATADOG SCALYR LIGHTSTEP Go # Distributed Tracing 应用场景 一个请求耗时三秒才能完成，如何诊断何处耗时最多？ 如何定位 Single Point of Failure？ 如何检测并避免循环依赖关系？ 如何定位 Fan In，Fan Out？ 实现原理 在 API Gateway 生成一个全局唯一的 traceID，并将其注入请求的 Header 里 在该请求的每个耗时节点生成一个 spanID，以 traceID+spanID 为索引计时，并记录其他元数据 将 tacing 信息自动传入每个耗时操作 最后一 traceID 为 key 来聚合所有的诊断信息 context.Context func (s Server) Handler(ctx context.Context, req Request) error { // ... } OpenTracing http://opentracing.io 2.2 Go 语言在讯联扫码支付系统中的成功实践 讯联 略… 2.3 Golang 在百万级搜索中的应用 360 C++ C++ -&gt; C -&gt; CGO -&gt; Go ProtoBuffer gdb core dump 简单、有效、够用 连接池 熔断 2.4 Go’s Hidden Pragrams @davecheney 2.5 跨境电商的 Go 服务治理实践 2.6 ContainerOps DevOps Orchestration 2.7 Harbor 开源项目容器镜像远程复制的实现 2.8 Go 在证券行情系统中的应用 2.9 Go 语言在证券期货行情系统中的实践" />
<meta property="og:description" content="1.1 Go在大数据开发中的经验总结 七牛云 # 成熟而复杂的大数据生态 # Pandora 的理念 # 关键字 # protobuf 序列化协议 # 变长的失败等待时间 1.2 Go in TiDB PingCAP # What is TiDB Scalability High Availability SQL ACID # Architecture # Example - SQL # Challenges in Buiding a Distributed Database # Parallel Data Scan Operator # Parallel HashJoin Operator # Goroutine leak : Block profile Timeout Context # Memory &amp;&amp; GC 1.3 Go coding in go way Neusoft 1.4 interface.presented @francesc 1.5 NSQ-重塑之路 1.6 Aliyun ApasaDB Go 微服务架构 阿里云 # Dubbo background # Micro-services complexity # Profound of Java vs. Golang (Spring vs. Go Tooling) # Introducting of gRPC (https://grpc.io/] # Dubbo vs. Go kit # Micro-services best practices 1.7 Automate App Operation @coreos # How to Deploy # etcd Operator # Deploy App Container 1.8 Go 微服务实战 @哔哩哔哩 # 微服务演进 分解单块系统 # 高可用 # 中间件 # 持续集成和交付 # 运维体系 # 引用&amp;参考 2.1 Go 打造亿级实时分布式平台 Grab # Distributed Tracing 2.2 Go 语言在讯联扫码支付系统中的成功实践 讯联 2.3 Golang 在百万级搜索中的应用 360 2.4 Go’s Hidden Pragrams @davecheney 2.5 跨境电商的 Go 服务治理实践 2.6 ContainerOps DevOps Orchestration 2.7 Harbor 开源项目容器镜像远程复制的实现 2.8 Go 在证券行情系统中的应用 2.9 Go 语言在证券期货行情系统中的实践 1.1 Go在大数据开发中的经验总结 七牛云 一站式大数据服务平台 - Pandora # 成熟而复杂的大数据生态 数据可视化 Zeppelin HUE Kibana 数据检索/分析平台 Apache Spark Apache Hadoop Hive Elastic 集群调度 Yarn Apache MESOS 存储/消息队列 Kafka HDFS 数据收集/管道 Logstash Telegraf Flume 监控 Prometheus influx data Grafana # Pandora 的理念 将多样的大数据工具整合 将复杂的大数据管理简化 构建完整的大数据生命周期闭环 收集 加工 分析 管理 消费 冷冻 # 关键字 『日志』『消息队列』『计算任务』『导出任务』『聚合』『压缩』『时序数据库』『日志检索服务』『对象存储服务』 『Log』『SDK』『WEB』『IoT』『Pipeline』『Transform』『Export』『TSDB』『LogDB』『Parquet』『ORC』『Text gzip』『Grafana』『Kibana』『Xspark 离线分析』『Spark Streaming』『MongoDB』『HTTP』 『实时数据增量』『海量数据导出时延』『数据传输模型 PULL PUSH』『上下游吞吐量』『链路损耗』『网卡』『内存』『网络』 『上下游解耦』『拉取与推送解耦』『数据预取』『队列暂存』『拉取与发送并行』 『任务分割』『水平扩展』『任务标准化：每个任务承载固定的流量』 『资源利用率』『调度』『平衡』 『任务管理』『运维』『运营』『监控』 『buffer』『channel』『process』『thread』『goroutine』『schedule』『admin』『Golang』 『source』『transaction pool』『transaction put queue』『memory queue』『transaction send queue』『sink』『local file queue』『checkpoint sink』『restart workflow』『offset,check』『replay』『task statemachine』 『分布式一致性』『zookeeper/etcd』『最终一致性：pull 系统 + 版本戳』 『平衡调度算法』『Key hash』 『数据重复』『数据丢失』『写入：平滑&amp;毛刺』『低延时』 # protobuf 序列化协议 通过 protobuf 协议与上游通信 不重复解析数据，去除 json 等解析的 cpu 消耗 # 变长的失败等待时间 向下游写入失败，则休眠 1s 再重试，依然失败则休眠时间增加，一直到 10s 为止 如写入成功，则失败的休眠时间重置为 1s 有效减少下游压力 1.2 Go in TiDB PingCAP # What is TiDB Scalability High Availability SQL ACID A Distributed, Consistent, Scablable, SQL Database that supports the best features of both traditional RDBMS and NoSQL. # Architecture The Whole World Applications -&gt; Load Balancer (LVS, HAproxy, F5, ...) -&gt; TiDB Servers -&gt; TiKV Cluster TiDB Server &lt;-&gt; PD Server &lt;-&gt; TiKV Server SQL Layer Protocol Layer Client - Packet -&gt; Listener - Packet -&gt; Connection Context - Command -&gt; Protocol Decode -&gt; SQL -&gt; SQL Core Layer -&gt; Data -&gt; Protocol Encode - Data -&gt; Connection Context - Packet -&gt; Client SQL Core Layer Protocol Layer - SQL -&gt; Session Context - SQL -&gt; Parser - AST -&gt; Validator - AST -&gt; Type infer - AST -&gt; Logical Optimizer - Logical Plan -&gt; Physical Optimizer - Physical Plan -&gt; Executor: Local &amp;&amp; Distributed -&gt; TiKV -&gt; Executor: Distributed - Data -&gt; Session Context - Data -&gt; Protocol Encode - Data -&gt; Connection Context - Packet -&gt; Client # Example - SQL Schema: CREATE TABLE t (c1 INT, c2 varchar(32)), INDEX idx1 (c1)); Query: SELECT COUNT(c1) FROM t WHERE c1 &gt; 10 AND c2 = &quot;gopherchina&quot;; Logical Plan AST: SelectStmt Node -&gt; Logica Plan &lt;&gt; DataSource: from t -&gt; Where: c1 &gt; 10 and c2 = &quot;gopherchina&quot; -&gt; Projection: count(c1) Physical Plan Logical Plan -&gt; Physical Plan &lt;&gt; IndexScan: idx1: (10, +∞) -&gt; Filter: c2 = &quot;gopherchina&quot; -&gt; Aggregation: count(c1) Distributed Physical Plan Phisical Plan on TiKV: Read Index: idx1: (10, +∞ ) - RowID -&gt; Read Row Data by RowID - Row -&gt; Filter: c2=gopherchina - Row -&gt; Partial Aggregate: count(c1) - count(c1) -&gt; Physical Plan on TiDB: DistSQL Scan - count(c1) -&gt; Final Aggregate: sum(count(c1)) # Challenges in Buiding a Distributed Database A very complex distributed system A lot of RPC work High performance Tons of data Huge amount of OLTP queries Very complex OLAP queries Why Go? goroutine channel GC concurrent multi-core # Parallel Data Scan Operator Executor - Index Ranges -&gt; IndexScan Executor: Split Task by range -&gt; Task Pool &lt;- Pick Task -&gt; Woker Pool &lt;-&gt; TiKV IndexScan Executor - Row IDs -&gt; TableScan Executor - Tasks -&gt; Task Pool Worker Pool - Rows -&gt; TableScan Executor - Rows -&gt; Executor # Parallel HashJoin Operator TiKV =&gt; Tables: (Left &amp;&amp; Right) Left Table -&gt; Build HashTable - Hash Table Right Table -*&gt; Join Wokers -&gt; Left: Hash Table -&gt; Joined Table # Goroutine leak : Block profile Timeout Context # Memory &amp;&amp; GC Reduce the Number of Allocation Get enough memory in one allocation operation Reuse Object Introduce a cache in goyacc Share a stack for all queries in one session sync.Pool Thread safe Reuse objects to relieve pressure on the GC gogo/protobuf Fast marshalling and unmarshalling Fields without pointers cause less time in the garbage collector Monitor the Memory Usage Monitor the memory usage of the server is easy rutime.MemProfile() Monitor the memory usage of a session is hard Account for large memory allocation Account for memory consuming operators 1.3 Go coding in go way Neusoft “Language influences/determines thought” - Sapir-Whorf hypotheisi “A language that doesn’t affect the way you think about programming is not worth knowing.” - Alan J. Perlis 1.4 interface.presented @francesc “interface{} says nothing” - Rob Pike in his Go Proverbs “The bigger the interface, the weaker the abstraction” - Rob Pike in his Go Proverbs // what function do you prefer? // Cons: // - how would you test it? // - what if you want to write to memory? // Pros: // - ? func WriteTo(f *os.File) error // Write, Read, Close: // Which one does WriteTo really need? func WriteTo(w io.ReadWriterCloser) error func WriteTo(w io.Writer) error // winner // Cons: // - how do you even write to interface{}? // - probably requires runtimes checks // Pros: // - you can write really bad code func WriteTo(w interface{}) error “Be conservative in what you do, be liberal in what you accept from others” - Robustness Principle “Be conservative in what you send, be liberal in what you accept” - Robustness Principle “Return concrete types, receive interfaces as paramters, unless hiding immplementaion detail” - Robustness Principle applied to Go (me) // what function do you prefer? func New() *os.File // winner func New() io.ReadWriteCloser func New() io.Writer func New() interface{} 1.5 NSQ-重塑之路 MQ NSQ Replication HA Auto-Balance Delivery in Order Tracing Consume History Messages Leader Follower Writer Buffer Group Commit Cursor Offset Channel Optimize channel timeout in Go timer goroutine timeout event chan Worker Goroutine Pool etcd State Machine Jespen 分布式跟踪 分布式测试 1.6 Aliyun ApasaDB Go 微服务架构 阿里云 # Dubbo background 分布式 RPC 框架 Play nice with Java Spring application (J2EE) Features: 服务动态注册&amp;服务发现 SOA 服务治理 软负载均衡 熔断、服务降级 服务分层 服务授权 服务容器 服务编排 软负载均衡 服务质量协定 服务容量评估 服务路由 服务测试 服务降级 服务注册与发现 调度中心 监控中心 注册中心 治理中心 # Micro-services complexity Testing is still HARD! DevOps culture? Security? Distributed Tracing? Huge payload (Dubbo specific) Java is “SO DYNAMIC”! Spring IoC (DI) AoP # Profound of Java vs. Golang (Spring vs. Go Tooling) Java No all Java Applications are Spring Application (and not all Java Developers are Spring Developers) Spring is BIG (Spring 2~4), and too much magics happening Dubbo’s IDL is a Java interface class JVM is a memory hog (0.5~6GB per micro-service JVM) Golang Simple, Elegant (i.e., defer vs finnaly) and forced to bundle 3rd part sources codes Go tooling: go test/go test -bench &amp; go tool &lt;pprof/vet/cover/…&gt; go-torch (by Uber) Memory (&lt;=0.5GB per application container) # Introducting of gRPC (https://grpc.io/] Open sourced version of Google “Stubby RPC” IDL for the service APIs “HTTP/2” &amp; “Bi-Directional streaming”! Working with Protobuf3 Generated both client and server in 9 languages, offically (other with C language binding are available) # Dubbo vs. Go kit   Dubbo &amp; Spring Go kit Service Discovery &amp; LB Dubbo Registry &amp; Dubbo Subscriber github.com/go-kit/kit/sd/(zk/consul/etcd/dnssrv/lb) google.golang.org/grpc/naming (lack of structured versioning) “Structured” Logging Log4j/Slf4j github.com/go-kit/kit/log Metrics Spring Actuator (many others) github.com/go-kit/kit/metrics Circuit Breaker Dubbo/Netflix Hystrix github.com/go-kit/kit/circuitbreaker Transports HTTP(JSON)/Dubbo/(gRPC) github.com/go-kit/kit/transport/(grpc/http/httprp) Caching layer Dubbo/Spring Cache - Distributed Tracing ELK/(天象全链路路) github.com/go-kit/kit/tracing (OpenTracing project) # Micro-services best practices Design with “Single” domain in mind (DB) Strong DevOps culture - CI/CD Logging, Metrics and Tracing Logging Options - Aliyun Logging Services/Apache Kafka/ELK A trace ID to co-relate all the requests that’s been made Transactional requests with idempotences handing in mind/Eventual Consistency Think twice if you need to propagate your requests to a number of micro-services request in “parallel” Provider servies governance and versioning Circuit Breaker/Fallbacks Multi-region cluster/failover Employ Container/Docker technologies (DevOps) Docker-compose swarm k8s Be very careful when introduce a whole new set of framework/library (shoot yourself in the foot) SIMPLE is the BEST 1.7 Automate App Operation @coreos main.go package main import ( &quot;log&quot; &quot;net/http&quot; ) func main() { fs := http.FileServer(http.Dir(&quot;static&quot;)) http.Handle(&quot;/&quot;, fs) log.Println(&quot;Listening on 0.0.0.0:30080&quot;) http.ListenAndServe(&quot;0.0.0.0:30080&quot;, nil) } Development - idea + code -&gt; 程序 打包 发布: docker build/docker push -&gt; Deployment - DNS LB # How to Deploy Database: PostgreSQL, MySQL, TiDB Coordination service: etcd, ZooKeeper Streaming: Kafka, Heron Big data: Spark, Hadoop Storage: Ceph, GlusterFS Logging: ElasticSearch Monitoring: Prometheus # etcd Operator Common Tasks Resize Upgrade Backup Failover Advanced Restore TLS Monitoring/Alerting # Deploy App Container Docker/OCI Standard app packaging format Kubernetes/Swarm Resource scheduling, cluster management Operator App specific operation automation Automation Declarative Version-controlled Cloud-native Customizable Composable 1.8 Go 微服务实战 @哔哩哔哩 推荐：纽曼(Sam Newman) 的 《微服务设计》 # 微服务演进 分解单块系统 梳理业务边界 资源隔离部署 内外网服务隔离 RPC 框架 序列化 (GOB) 上下文管理 (超时控制) 拦截器 (鉴权、统计、限流) 服务注册 (Zookeeper) 负载均衡 (客户端) API Gateway 统一&amp;聚合协议 errgroup 并行调用 业务隔离 熔断、降级、限流等高可用 # 高可用 隔离 服务 轻重 物理 超时 连接 读取 写入 限流 流量 accept connection thread 资源 connection pool thread pool 请求 总数 时间窗口 平滑限流 分布式 redis + lua nginx + lua 接入层 nginx limit_req nginx limit_conn 降级 链路 自动 手动 容错 重试容错 简单重试 主备重试 成功率重试 快速失败 熔断容错 动态剔除 异常恢复 # 中间件 databus (Kafka) canal (MySQL Replication) bilitw (Twemproxy) bfs (facebook haystac, opencv) config-service dapper (google dapper) # 持续集成和交付 版本管理 (语义化） Semantic Versioning 2.0.0 分支管理 (gitlab+mr review) A successful Git branching model 环境管理 (集成环境) 测试 (单元测试，服务测试) 发布 (冒烟、灰度、蓝绿) # 运维体系 服务日志收集、分发、存储、UI 分布式跟踪 Zabbix Dapper ELK: (Elastic Search, Logstash, Kibana) # 引用&amp;参考 [英] 纽曼（Sam Newman） (作者), 崔力强 张骏 (译者)《微服务设计》 http://semver.org/#semantic-versioning-200 http://nvie.com/posts/a-successful-git-branching-model/ 2.1 Go 打造亿级实时分布式平台 Grab RAILS NodeJS amazon web services Travis CI GitHub MySQL GitHub MySQL redis amazon web services PHABRICATOR Jenkins etcd k8s docker Kafka Spark Presto Amazon KINESIS DATADOG SCALYR LIGHTSTEP Go # Distributed Tracing 应用场景 一个请求耗时三秒才能完成，如何诊断何处耗时最多？ 如何定位 Single Point of Failure？ 如何检测并避免循环依赖关系？ 如何定位 Fan In，Fan Out？ 实现原理 在 API Gateway 生成一个全局唯一的 traceID，并将其注入请求的 Header 里 在该请求的每个耗时节点生成一个 spanID，以 traceID+spanID 为索引计时，并记录其他元数据 将 tacing 信息自动传入每个耗时操作 最后一 traceID 为 key 来聚合所有的诊断信息 context.Context func (s Server) Handler(ctx context.Context, req Request) error { // ... } OpenTracing http://opentracing.io 2.2 Go 语言在讯联扫码支付系统中的成功实践 讯联 略… 2.3 Golang 在百万级搜索中的应用 360 C++ C++ -&gt; C -&gt; CGO -&gt; Go ProtoBuffer gdb core dump 简单、有效、够用 连接池 熔断 2.4 Go’s Hidden Pragrams @davecheney 2.5 跨境电商的 Go 服务治理实践 2.6 ContainerOps DevOps Orchestration 2.7 Harbor 开源项目容器镜像远程复制的实现 2.8 Go 在证券行情系统中的应用 2.9 Go 语言在证券期货行情系统中的实践" />
<link rel="canonical" href="https://blog.codefarm.me/2017/04/17/gopherchina-2017/" />
<meta property="og:url" content="https://blog.codefarm.me/2017/04/17/gopherchina-2017/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-17T09:07:17+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GopherChina 2017" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-04-17T09:07:17+08:00","datePublished":"2017-04-17T09:07:17+08:00","description":"1.1 Go在大数据开发中的经验总结 七牛云 # 成熟而复杂的大数据生态 # Pandora 的理念 # 关键字 # protobuf 序列化协议 # 变长的失败等待时间 1.2 Go in TiDB PingCAP # What is TiDB Scalability High Availability SQL ACID # Architecture # Example - SQL # Challenges in Buiding a Distributed Database # Parallel Data Scan Operator # Parallel HashJoin Operator # Goroutine leak : Block profile Timeout Context # Memory &amp;&amp; GC 1.3 Go coding in go way Neusoft 1.4 interface.presented @francesc 1.5 NSQ-重塑之路 1.6 Aliyun ApasaDB Go 微服务架构 阿里云 # Dubbo background # Micro-services complexity # Profound of Java vs. Golang (Spring vs. Go Tooling) # Introducting of gRPC (https://grpc.io/] # Dubbo vs. Go kit # Micro-services best practices 1.7 Automate App Operation @coreos # How to Deploy # etcd Operator # Deploy App Container 1.8 Go 微服务实战 @哔哩哔哩 # 微服务演进 分解单块系统 # 高可用 # 中间件 # 持续集成和交付 # 运维体系 # 引用&amp;参考 2.1 Go 打造亿级实时分布式平台 Grab # Distributed Tracing 2.2 Go 语言在讯联扫码支付系统中的成功实践 讯联 2.3 Golang 在百万级搜索中的应用 360 2.4 Go’s Hidden Pragrams @davecheney 2.5 跨境电商的 Go 服务治理实践 2.6 ContainerOps DevOps Orchestration 2.7 Harbor 开源项目容器镜像远程复制的实现 2.8 Go 在证券行情系统中的应用 2.9 Go 语言在证券期货行情系统中的实践 1.1 Go在大数据开发中的经验总结 七牛云 一站式大数据服务平台 - Pandora # 成熟而复杂的大数据生态 数据可视化 Zeppelin HUE Kibana 数据检索/分析平台 Apache Spark Apache Hadoop Hive Elastic 集群调度 Yarn Apache MESOS 存储/消息队列 Kafka HDFS 数据收集/管道 Logstash Telegraf Flume 监控 Prometheus influx data Grafana # Pandora 的理念 将多样的大数据工具整合 将复杂的大数据管理简化 构建完整的大数据生命周期闭环 收集 加工 分析 管理 消费 冷冻 # 关键字 『日志』『消息队列』『计算任务』『导出任务』『聚合』『压缩』『时序数据库』『日志检索服务』『对象存储服务』 『Log』『SDK』『WEB』『IoT』『Pipeline』『Transform』『Export』『TSDB』『LogDB』『Parquet』『ORC』『Text gzip』『Grafana』『Kibana』『Xspark 离线分析』『Spark Streaming』『MongoDB』『HTTP』 『实时数据增量』『海量数据导出时延』『数据传输模型 PULL PUSH』『上下游吞吐量』『链路损耗』『网卡』『内存』『网络』 『上下游解耦』『拉取与推送解耦』『数据预取』『队列暂存』『拉取与发送并行』 『任务分割』『水平扩展』『任务标准化：每个任务承载固定的流量』 『资源利用率』『调度』『平衡』 『任务管理』『运维』『运营』『监控』 『buffer』『channel』『process』『thread』『goroutine』『schedule』『admin』『Golang』 『source』『transaction pool』『transaction put queue』『memory queue』『transaction send queue』『sink』『local file queue』『checkpoint sink』『restart workflow』『offset,check』『replay』『task statemachine』 『分布式一致性』『zookeeper/etcd』『最终一致性：pull 系统 + 版本戳』 『平衡调度算法』『Key hash』 『数据重复』『数据丢失』『写入：平滑&amp;毛刺』『低延时』 # protobuf 序列化协议 通过 protobuf 协议与上游通信 不重复解析数据，去除 json 等解析的 cpu 消耗 # 变长的失败等待时间 向下游写入失败，则休眠 1s 再重试，依然失败则休眠时间增加，一直到 10s 为止 如写入成功，则失败的休眠时间重置为 1s 有效减少下游压力 1.2 Go in TiDB PingCAP # What is TiDB Scalability High Availability SQL ACID A Distributed, Consistent, Scablable, SQL Database that supports the best features of both traditional RDBMS and NoSQL. # Architecture The Whole World Applications -&gt; Load Balancer (LVS, HAproxy, F5, ...) -&gt; TiDB Servers -&gt; TiKV Cluster TiDB Server &lt;-&gt; PD Server &lt;-&gt; TiKV Server SQL Layer Protocol Layer Client - Packet -&gt; Listener - Packet -&gt; Connection Context - Command -&gt; Protocol Decode -&gt; SQL -&gt; SQL Core Layer -&gt; Data -&gt; Protocol Encode - Data -&gt; Connection Context - Packet -&gt; Client SQL Core Layer Protocol Layer - SQL -&gt; Session Context - SQL -&gt; Parser - AST -&gt; Validator - AST -&gt; Type infer - AST -&gt; Logical Optimizer - Logical Plan -&gt; Physical Optimizer - Physical Plan -&gt; Executor: Local &amp;&amp; Distributed -&gt; TiKV -&gt; Executor: Distributed - Data -&gt; Session Context - Data -&gt; Protocol Encode - Data -&gt; Connection Context - Packet -&gt; Client # Example - SQL Schema: CREATE TABLE t (c1 INT, c2 varchar(32)), INDEX idx1 (c1)); Query: SELECT COUNT(c1) FROM t WHERE c1 &gt; 10 AND c2 = &quot;gopherchina&quot;; Logical Plan AST: SelectStmt Node -&gt; Logica Plan &lt;&gt; DataSource: from t -&gt; Where: c1 &gt; 10 and c2 = &quot;gopherchina&quot; -&gt; Projection: count(c1) Physical Plan Logical Plan -&gt; Physical Plan &lt;&gt; IndexScan: idx1: (10, +∞) -&gt; Filter: c2 = &quot;gopherchina&quot; -&gt; Aggregation: count(c1) Distributed Physical Plan Phisical Plan on TiKV: Read Index: idx1: (10, +∞ ) - RowID -&gt; Read Row Data by RowID - Row -&gt; Filter: c2=gopherchina - Row -&gt; Partial Aggregate: count(c1) - count(c1) -&gt; Physical Plan on TiDB: DistSQL Scan - count(c1) -&gt; Final Aggregate: sum(count(c1)) # Challenges in Buiding a Distributed Database A very complex distributed system A lot of RPC work High performance Tons of data Huge amount of OLTP queries Very complex OLAP queries Why Go? goroutine channel GC concurrent multi-core # Parallel Data Scan Operator Executor - Index Ranges -&gt; IndexScan Executor: Split Task by range -&gt; Task Pool &lt;- Pick Task -&gt; Woker Pool &lt;-&gt; TiKV IndexScan Executor - Row IDs -&gt; TableScan Executor - Tasks -&gt; Task Pool Worker Pool - Rows -&gt; TableScan Executor - Rows -&gt; Executor # Parallel HashJoin Operator TiKV =&gt; Tables: (Left &amp;&amp; Right) Left Table -&gt; Build HashTable - Hash Table Right Table -*&gt; Join Wokers -&gt; Left: Hash Table -&gt; Joined Table # Goroutine leak : Block profile Timeout Context # Memory &amp;&amp; GC Reduce the Number of Allocation Get enough memory in one allocation operation Reuse Object Introduce a cache in goyacc Share a stack for all queries in one session sync.Pool Thread safe Reuse objects to relieve pressure on the GC gogo/protobuf Fast marshalling and unmarshalling Fields without pointers cause less time in the garbage collector Monitor the Memory Usage Monitor the memory usage of the server is easy rutime.MemProfile() Monitor the memory usage of a session is hard Account for large memory allocation Account for memory consuming operators 1.3 Go coding in go way Neusoft “Language influences/determines thought” - Sapir-Whorf hypotheisi “A language that doesn’t affect the way you think about programming is not worth knowing.” - Alan J. Perlis 1.4 interface.presented @francesc “interface{} says nothing” - Rob Pike in his Go Proverbs “The bigger the interface, the weaker the abstraction” - Rob Pike in his Go Proverbs // what function do you prefer? // Cons: // - how would you test it? // - what if you want to write to memory? // Pros: // - ? func WriteTo(f *os.File) error // Write, Read, Close: // Which one does WriteTo really need? func WriteTo(w io.ReadWriterCloser) error func WriteTo(w io.Writer) error // winner // Cons: // - how do you even write to interface{}? // - probably requires runtimes checks // Pros: // - you can write really bad code func WriteTo(w interface{}) error “Be conservative in what you do, be liberal in what you accept from others” - Robustness Principle “Be conservative in what you send, be liberal in what you accept” - Robustness Principle “Return concrete types, receive interfaces as paramters, unless hiding immplementaion detail” - Robustness Principle applied to Go (me) // what function do you prefer? func New() *os.File // winner func New() io.ReadWriteCloser func New() io.Writer func New() interface{} 1.5 NSQ-重塑之路 MQ NSQ Replication HA Auto-Balance Delivery in Order Tracing Consume History Messages Leader Follower Writer Buffer Group Commit Cursor Offset Channel Optimize channel timeout in Go timer goroutine timeout event chan Worker Goroutine Pool etcd State Machine Jespen 分布式跟踪 分布式测试 1.6 Aliyun ApasaDB Go 微服务架构 阿里云 # Dubbo background 分布式 RPC 框架 Play nice with Java Spring application (J2EE) Features: 服务动态注册&amp;服务发现 SOA 服务治理 软负载均衡 熔断、服务降级 服务分层 服务授权 服务容器 服务编排 软负载均衡 服务质量协定 服务容量评估 服务路由 服务测试 服务降级 服务注册与发现 调度中心 监控中心 注册中心 治理中心 # Micro-services complexity Testing is still HARD! DevOps culture? Security? Distributed Tracing? Huge payload (Dubbo specific) Java is “SO DYNAMIC”! Spring IoC (DI) AoP # Profound of Java vs. Golang (Spring vs. Go Tooling) Java No all Java Applications are Spring Application (and not all Java Developers are Spring Developers) Spring is BIG (Spring 2~4), and too much magics happening Dubbo’s IDL is a Java interface class JVM is a memory hog (0.5~6GB per micro-service JVM) Golang Simple, Elegant (i.e., defer vs finnaly) and forced to bundle 3rd part sources codes Go tooling: go test/go test -bench &amp; go tool &lt;pprof/vet/cover/…&gt; go-torch (by Uber) Memory (&lt;=0.5GB per application container) # Introducting of gRPC (https://grpc.io/] Open sourced version of Google “Stubby RPC” IDL for the service APIs “HTTP/2” &amp; “Bi-Directional streaming”! Working with Protobuf3 Generated both client and server in 9 languages, offically (other with C language binding are available) # Dubbo vs. Go kit   Dubbo &amp; Spring Go kit Service Discovery &amp; LB Dubbo Registry &amp; Dubbo Subscriber github.com/go-kit/kit/sd/(zk/consul/etcd/dnssrv/lb) google.golang.org/grpc/naming (lack of structured versioning) “Structured” Logging Log4j/Slf4j github.com/go-kit/kit/log Metrics Spring Actuator (many others) github.com/go-kit/kit/metrics Circuit Breaker Dubbo/Netflix Hystrix github.com/go-kit/kit/circuitbreaker Transports HTTP(JSON)/Dubbo/(gRPC) github.com/go-kit/kit/transport/(grpc/http/httprp) Caching layer Dubbo/Spring Cache - Distributed Tracing ELK/(天象全链路路) github.com/go-kit/kit/tracing (OpenTracing project) # Micro-services best practices Design with “Single” domain in mind (DB) Strong DevOps culture - CI/CD Logging, Metrics and Tracing Logging Options - Aliyun Logging Services/Apache Kafka/ELK A trace ID to co-relate all the requests that’s been made Transactional requests with idempotences handing in mind/Eventual Consistency Think twice if you need to propagate your requests to a number of micro-services request in “parallel” Provider servies governance and versioning Circuit Breaker/Fallbacks Multi-region cluster/failover Employ Container/Docker technologies (DevOps) Docker-compose swarm k8s Be very careful when introduce a whole new set of framework/library (shoot yourself in the foot) SIMPLE is the BEST 1.7 Automate App Operation @coreos main.go package main import ( &quot;log&quot; &quot;net/http&quot; ) func main() { fs := http.FileServer(http.Dir(&quot;static&quot;)) http.Handle(&quot;/&quot;, fs) log.Println(&quot;Listening on 0.0.0.0:30080&quot;) http.ListenAndServe(&quot;0.0.0.0:30080&quot;, nil) } Development - idea + code -&gt; 程序 打包 发布: docker build/docker push -&gt; Deployment - DNS LB # How to Deploy Database: PostgreSQL, MySQL, TiDB Coordination service: etcd, ZooKeeper Streaming: Kafka, Heron Big data: Spark, Hadoop Storage: Ceph, GlusterFS Logging: ElasticSearch Monitoring: Prometheus # etcd Operator Common Tasks Resize Upgrade Backup Failover Advanced Restore TLS Monitoring/Alerting # Deploy App Container Docker/OCI Standard app packaging format Kubernetes/Swarm Resource scheduling, cluster management Operator App specific operation automation Automation Declarative Version-controlled Cloud-native Customizable Composable 1.8 Go 微服务实战 @哔哩哔哩 推荐：纽曼(Sam Newman) 的 《微服务设计》 # 微服务演进 分解单块系统 梳理业务边界 资源隔离部署 内外网服务隔离 RPC 框架 序列化 (GOB) 上下文管理 (超时控制) 拦截器 (鉴权、统计、限流) 服务注册 (Zookeeper) 负载均衡 (客户端) API Gateway 统一&amp;聚合协议 errgroup 并行调用 业务隔离 熔断、降级、限流等高可用 # 高可用 隔离 服务 轻重 物理 超时 连接 读取 写入 限流 流量 accept connection thread 资源 connection pool thread pool 请求 总数 时间窗口 平滑限流 分布式 redis + lua nginx + lua 接入层 nginx limit_req nginx limit_conn 降级 链路 自动 手动 容错 重试容错 简单重试 主备重试 成功率重试 快速失败 熔断容错 动态剔除 异常恢复 # 中间件 databus (Kafka) canal (MySQL Replication) bilitw (Twemproxy) bfs (facebook haystac, opencv) config-service dapper (google dapper) # 持续集成和交付 版本管理 (语义化） Semantic Versioning 2.0.0 分支管理 (gitlab+mr review) A successful Git branching model 环境管理 (集成环境) 测试 (单元测试，服务测试) 发布 (冒烟、灰度、蓝绿) # 运维体系 服务日志收集、分发、存储、UI 分布式跟踪 Zabbix Dapper ELK: (Elastic Search, Logstash, Kibana) # 引用&amp;参考 [英] 纽曼（Sam Newman） (作者), 崔力强 张骏 (译者)《微服务设计》 http://semver.org/#semantic-versioning-200 http://nvie.com/posts/a-successful-git-branching-model/ 2.1 Go 打造亿级实时分布式平台 Grab RAILS NodeJS amazon web services Travis CI GitHub MySQL GitHub MySQL redis amazon web services PHABRICATOR Jenkins etcd k8s docker Kafka Spark Presto Amazon KINESIS DATADOG SCALYR LIGHTSTEP Go # Distributed Tracing 应用场景 一个请求耗时三秒才能完成，如何诊断何处耗时最多？ 如何定位 Single Point of Failure？ 如何检测并避免循环依赖关系？ 如何定位 Fan In，Fan Out？ 实现原理 在 API Gateway 生成一个全局唯一的 traceID，并将其注入请求的 Header 里 在该请求的每个耗时节点生成一个 spanID，以 traceID+spanID 为索引计时，并记录其他元数据 将 tacing 信息自动传入每个耗时操作 最后一 traceID 为 key 来聚合所有的诊断信息 context.Context func (s Server) Handler(ctx context.Context, req Request) error { // ... } OpenTracing http://opentracing.io 2.2 Go 语言在讯联扫码支付系统中的成功实践 讯联 略… 2.3 Golang 在百万级搜索中的应用 360 C++ C++ -&gt; C -&gt; CGO -&gt; Go ProtoBuffer gdb core dump 简单、有效、够用 连接池 熔断 2.4 Go’s Hidden Pragrams @davecheney 2.5 跨境电商的 Go 服务治理实践 2.6 ContainerOps DevOps Orchestration 2.7 Harbor 开源项目容器镜像远程复制的实现 2.8 Go 在证券行情系统中的应用 2.9 Go 语言在证券期货行情系统中的实践","headline":"GopherChina 2017","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2017/04/17/gopherchina-2017/"},"url":"https://blog.codefarm.me/2017/04/17/gopherchina-2017/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">GopherChina 2017</h1><p class="c-post-meta">17 Apr 2017</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#11-go在大数据开发中的经验总结-七牛云" id="markdown-toc-11-go在大数据开发中的经验总结-七牛云">1.1 Go在大数据开发中的经验总结 <sub>七牛云</sub></a>    <ul>
      <li><a href="#-成熟而复杂的大数据生态" id="markdown-toc--成熟而复杂的大数据生态"># 成熟而复杂的大数据生态</a></li>
      <li><a href="#-pandora-的理念" id="markdown-toc--pandora-的理念"># Pandora 的理念</a></li>
      <li><a href="#-关键字" id="markdown-toc--关键字"># 关键字</a></li>
      <li><a href="#-protobuf-序列化协议" id="markdown-toc--protobuf-序列化协议"># protobuf 序列化协议</a></li>
      <li><a href="#-变长的失败等待时间" id="markdown-toc--变长的失败等待时间"># 变长的失败等待时间</a></li>
    </ul>
  </li>
  <li><a href="#12-go-in-tidb-pingcap" id="markdown-toc-12-go-in-tidb-pingcap">1.2 Go in TiDB <sub>PingCAP</sub></a>    <ul>
      <li><a href="#-what-is-tidb-scalability-high-availability-sql-acid" id="markdown-toc--what-is-tidb-scalability-high-availability-sql-acid"># What is TiDB <code class="language-plaintext highlighter-rouge">Scalability</code> <code class="language-plaintext highlighter-rouge">High Availability</code> <code class="language-plaintext highlighter-rouge">SQL</code> <code class="language-plaintext highlighter-rouge">ACID</code></a></li>
      <li><a href="#-architecture" id="markdown-toc--architecture"># Architecture</a></li>
      <li><a href="#-example---sql" id="markdown-toc--example---sql"># Example - SQL</a></li>
      <li><a href="#-challenges-in-buiding-a-distributed-database" id="markdown-toc--challenges-in-buiding-a-distributed-database"># Challenges in Buiding a Distributed Database</a></li>
      <li><a href="#-parallel-data-scan-operator" id="markdown-toc--parallel-data-scan-operator"># Parallel Data Scan Operator</a></li>
      <li><a href="#-parallel-hashjoin-operator" id="markdown-toc--parallel-hashjoin-operator"># Parallel HashJoin Operator</a></li>
      <li><a href="#-goroutine-leak--block-profile-timeout-context" id="markdown-toc--goroutine-leak--block-profile-timeout-context"># Goroutine <em>leak</em> : <code class="language-plaintext highlighter-rouge">Block profile</code> <code class="language-plaintext highlighter-rouge">Timeout</code> <code class="language-plaintext highlighter-rouge">Context</code></a></li>
      <li><a href="#-memory--gc" id="markdown-toc--memory--gc"># Memory &amp;&amp; GC</a></li>
    </ul>
  </li>
  <li><a href="#13-go-coding-in-go-way-neusoft" id="markdown-toc-13-go-coding-in-go-way-neusoft">1.3 Go coding in go way <sub>Neusoft</sub></a></li>
  <li><a href="#14-interfacepresented-francesc" id="markdown-toc-14-interfacepresented-francesc">1.4 interface.presented <sub>@francesc</sub></a></li>
  <li><a href="#15-nsq-重塑之路" id="markdown-toc-15-nsq-重塑之路">1.5 NSQ-重塑之路</a></li>
  <li><a href="#16-aliyun-apasadb-go-微服务架构-阿里云" id="markdown-toc-16-aliyun-apasadb-go-微服务架构-阿里云">1.6 Aliyun ApasaDB Go 微服务架构 <sub>阿里云</sub></a>    <ul>
      <li><a href="#-dubbo-background" id="markdown-toc--dubbo-background"># Dubbo background</a></li>
      <li><a href="#-micro-services-complexity" id="markdown-toc--micro-services-complexity"># Micro-services complexity</a></li>
      <li><a href="#-profound-of-java-vs-golang-spring-vs-go-tooling" id="markdown-toc--profound-of-java-vs-golang-spring-vs-go-tooling"># Profound of Java vs. Golang (Spring vs. Go Tooling)</a></li>
      <li><a href="#-introducting-of-grpc-httpsgrpcio" id="markdown-toc--introducting-of-grpc-httpsgrpcio"># Introducting of gRPC (https://grpc.io/]</a></li>
      <li><a href="#-dubbo-vs-go-kit" id="markdown-toc--dubbo-vs-go-kit"># Dubbo vs. Go kit</a></li>
      <li><a href="#-micro-services-best-practices" id="markdown-toc--micro-services-best-practices"># Micro-services best practices</a></li>
    </ul>
  </li>
  <li><a href="#17-automate-app-operation-coreos" id="markdown-toc-17-automate-app-operation-coreos">1.7 Automate App Operation <sub>@coreos</sub></a>    <ul>
      <li><a href="#-how-to-deploy" id="markdown-toc--how-to-deploy"># How to Deploy</a></li>
      <li><a href="#-etcd-operator" id="markdown-toc--etcd-operator"># etcd Operator</a></li>
      <li><a href="#-deploy-app-container" id="markdown-toc--deploy-app-container"># Deploy App Container</a></li>
    </ul>
  </li>
  <li><a href="#18-go-微服务实战-哔哩哔哩" id="markdown-toc-18-go-微服务实战-哔哩哔哩">1.8 Go 微服务实战 <sub>@哔哩哔哩</sub></a>    <ul>
      <li><a href="#-微服务演进-分解单块系统" id="markdown-toc--微服务演进-分解单块系统"># 微服务演进 <sub>分解单块系统</sub></a></li>
      <li><a href="#-高可用" id="markdown-toc--高可用"># 高可用</a></li>
      <li><a href="#-中间件" id="markdown-toc--中间件"># 中间件</a></li>
      <li><a href="#-持续集成和交付" id="markdown-toc--持续集成和交付"># 持续集成和交付</a></li>
      <li><a href="#-运维体系" id="markdown-toc--运维体系"># 运维体系</a></li>
      <li><a href="#-引用参考" id="markdown-toc--引用参考"># 引用&amp;参考</a></li>
    </ul>
  </li>
  <li><a href="#21-go-打造亿级实时分布式平台-grab" id="markdown-toc-21-go-打造亿级实时分布式平台-grab">2.1 Go 打造亿级实时分布式平台 <sub>Grab</sub></a>    <ul>
      <li><a href="#-distributed-tracing" id="markdown-toc--distributed-tracing"># Distributed Tracing</a></li>
    </ul>
  </li>
  <li><a href="#22-go-语言在讯联扫码支付系统中的成功实践-讯联" id="markdown-toc-22-go-语言在讯联扫码支付系统中的成功实践-讯联">2.2 Go 语言在讯联扫码支付系统中的成功实践 <sub>讯联</sub></a></li>
  <li><a href="#23-golang-在百万级搜索中的应用-360" id="markdown-toc-23-golang-在百万级搜索中的应用-360">2.3 Golang 在百万级搜索中的应用 <sub>360</sub></a></li>
  <li><a href="#24-gos-hidden-pragrams-davecheney" id="markdown-toc-24-gos-hidden-pragrams-davecheney">2.4 Go’s Hidden Pragrams <sub>@davecheney</sub></a></li>
  <li><a href="#25-跨境电商的-go-服务治理实践" id="markdown-toc-25-跨境电商的-go-服务治理实践">2.5 跨境电商的 Go 服务治理实践</a></li>
  <li><a href="#26-containerops-devops-orchestration" id="markdown-toc-26-containerops-devops-orchestration">2.6 ContainerOps DevOps Orchestration</a></li>
  <li><a href="#27-harbor-开源项目容器镜像远程复制的实现" id="markdown-toc-27-harbor-开源项目容器镜像远程复制的实现">2.7 Harbor 开源项目容器镜像远程复制的实现</a></li>
  <li><a href="#28-go-在证券行情系统中的应用" id="markdown-toc-28-go-在证券行情系统中的应用">2.8 Go 在证券行情系统中的应用</a></li>
  <li><a href="#29-go-语言在证券期货行情系统中的实践" id="markdown-toc-29-go-语言在证券期货行情系统中的实践">2.9 Go 语言在证券期货行情系统中的实践</a></li>
</ul>

<hr />

<h3 id="11-go在大数据开发中的经验总结-七牛云">1.1 Go在大数据开发中的经验总结 <sub>七牛云</sub></h3>

<p>一站式大数据服务平台 - <strong>Pandora</strong></p>

<h4 id="-成熟而复杂的大数据生态"># 成熟而复杂的大数据生态</h4>

<ul>
  <li>数据可视化        <code class="language-plaintext highlighter-rouge">Zeppelin</code> <code class="language-plaintext highlighter-rouge">HUE</code> <code class="language-plaintext highlighter-rouge">Kibana</code></li>
  <li>数据检索/分析平台 <code class="language-plaintext highlighter-rouge">Apache Spark</code> <code class="language-plaintext highlighter-rouge">Apache Hadoop</code> <code class="language-plaintext highlighter-rouge">Hive</code> <code class="language-plaintext highlighter-rouge">Elastic</code></li>
  <li>集群调度          <code class="language-plaintext highlighter-rouge">Yarn</code> <code class="language-plaintext highlighter-rouge">Apache MESOS</code></li>
  <li>存储/消息队列     <code class="language-plaintext highlighter-rouge">Kafka</code> <code class="language-plaintext highlighter-rouge">HDFS</code></li>
  <li>数据收集/管道     <code class="language-plaintext highlighter-rouge">Logstash</code> <code class="language-plaintext highlighter-rouge">Telegraf</code> <code class="language-plaintext highlighter-rouge">Flume</code></li>
  <li>监控              <code class="language-plaintext highlighter-rouge">Prometheus</code> <code class="language-plaintext highlighter-rouge">influx data</code> <code class="language-plaintext highlighter-rouge">Grafana</code></li>
</ul>

<h4 id="-pandora-的理念"># Pandora 的理念</h4>

<ul>
  <li>将多样的大数据工具整合</li>
  <li>将复杂的大数据管理简化</li>
  <li>构建完整的大数据生命周期闭环 <code class="language-plaintext highlighter-rouge">收集</code> <code class="language-plaintext highlighter-rouge">加工</code> <code class="language-plaintext highlighter-rouge">分析</code> <code class="language-plaintext highlighter-rouge">管理</code> <code class="language-plaintext highlighter-rouge">消费</code> <code class="language-plaintext highlighter-rouge">冷冻</code></li>
</ul>

<h4 id="-关键字"># 关键字</h4>

<p>『日志』『消息队列』『计算任务』『导出任务』『聚合』『压缩』『时序数据库』『日志检索服务』『对象存储服务』</p>

<p>『Log』『SDK』『WEB』『IoT』『Pipeline』『Transform』『Export』『TSDB』『LogDB』『Parquet』『ORC』『Text gzip』『Grafana』『Kibana』『Xspark 离线分析』『Spark Streaming』『MongoDB』『HTTP』</p>

<p>『实时数据增量』『海量数据导出时延』『数据传输模型 PULL PUSH』『上下游吞吐量』『链路损耗』『网卡』『内存』『网络』</p>

<p>『上下游解耦』『拉取与推送解耦』『数据预取』『队列暂存』『拉取与发送并行』</p>

<p>『任务分割』『水平扩展』『任务标准化：每个任务承载固定的流量』</p>

<p>『资源利用率』『调度』『平衡』</p>

<p>『任务管理』『运维』『运营』『监控』</p>

<p>『buffer』『channel』『process』『thread』『goroutine』『schedule』『admin』『Golang』</p>

<p>『source』『transaction pool』『transaction put queue』『memory queue』『transaction send queue』『sink』『local file queue』『checkpoint sink』『restart workflow』『offset,check』『replay』『task statemachine』</p>

<p>『分布式一致性』『zookeeper/etcd』『最终一致性：pull 系统 + 版本戳』</p>

<p>『平衡调度算法』『Key hash』</p>

<p>『数据重复』『数据丢失』『写入：平滑&amp;毛刺』『低延时』</p>

<h4 id="-protobuf-序列化协议"># protobuf 序列化协议</h4>

<ul>
  <li>通过 protobuf 协议与上游通信</li>
  <li>不重复解析数据，去除 json 等解析的 cpu 消耗</li>
</ul>

<h4 id="-变长的失败等待时间"># 变长的失败等待时间</h4>

<ul>
  <li>向下游写入失败，则休眠 1s 再重试，依然失败则休眠时间增加，一直到 10s 为止</li>
  <li>如写入成功，则失败的休眠时间重置为 1s</li>
  <li>有效减少下游压力</li>
</ul>

<h3 id="12-go-in-tidb-pingcap">1.2 Go in TiDB <sub>PingCAP</sub></h3>

<h4 id="-what-is-tidb-scalability-high-availability-sql-acid"># What is TiDB <code class="language-plaintext highlighter-rouge">Scalability</code> <code class="language-plaintext highlighter-rouge">High Availability</code> <code class="language-plaintext highlighter-rouge">SQL</code> <code class="language-plaintext highlighter-rouge">ACID</code></h4>

<p>A <strong>Distributed, Consistent, Scablable, SQL</strong> Database that supports the best features of both traditional RDBMS and NoSQL.</p>

<h4 id="-architecture"># Architecture</h4>

<ul>
  <li>
    <p>The Whole World</p>

    <p><code class="language-plaintext highlighter-rouge">Applications</code> -&gt; <code class="language-plaintext highlighter-rouge">Load Balancer (LVS, HAproxy, F5, ...)</code> -&gt; <code class="language-plaintext highlighter-rouge">TiDB Servers</code> -&gt; <code class="language-plaintext highlighter-rouge">TiKV Cluster</code></p>

    <p><code class="language-plaintext highlighter-rouge">TiDB Server</code> &lt;-&gt; <code class="language-plaintext highlighter-rouge">PD Server</code> &lt;-&gt; <code class="language-plaintext highlighter-rouge">TiKV Server</code></p>
  </li>
  <li>
    <p>SQL Layer</p>

    <ul>
      <li>
        <p><strong>Protocol Layer</strong></p>

        <p><code class="language-plaintext highlighter-rouge">Client</code> - <em>Packet</em> -&gt; <code class="language-plaintext highlighter-rouge">Listener</code> - <em>Packet</em> -&gt; <code class="language-plaintext highlighter-rouge">Connection Context</code> - <em>Command</em> -&gt; <code class="language-plaintext highlighter-rouge">Protocol Decode</code> -&gt; <em>SQL</em> -&gt; <strong><em>SQL Core Layer</em></strong> -&gt; <em>Data</em> -&gt; <code class="language-plaintext highlighter-rouge">Protocol Encode</code> - <em>Data</em> -&gt; <code class="language-plaintext highlighter-rouge">Connection Context</code> - <em>Packet</em> -&gt; <code class="language-plaintext highlighter-rouge">Client</code></p>
      </li>
      <li>
        <p><strong>SQL Core Layer</strong></p>

        <p><strong><em>Protocol Layer</em></strong> - <em>SQL</em> -&gt; <code class="language-plaintext highlighter-rouge">Session Context</code> - <em>SQL</em> -&gt; <code class="language-plaintext highlighter-rouge">Parser</code> - <em>AST</em> -&gt; <code class="language-plaintext highlighter-rouge">Validator</code> - <em>AST</em> -&gt; <code class="language-plaintext highlighter-rouge">Type infer</code> - <em>AST</em> -&gt; <code class="language-plaintext highlighter-rouge">Logical Optimizer</code> - <em>Logical Plan</em> -&gt; <code class="language-plaintext highlighter-rouge">Physical Optimizer</code> - <em>Physical Plan</em> -&gt; <code class="language-plaintext highlighter-rouge">Executor: Local &amp;&amp; Distributed</code> -&gt; <code class="language-plaintext highlighter-rouge">TiKV</code> -&gt; <code class="language-plaintext highlighter-rouge">Executor: Distributed</code> - <em>Data</em> -&gt; <code class="language-plaintext highlighter-rouge">Session Context</code> - <em>Data</em> -&gt; <em>Protocol Encode</em> - <em>Data</em> -&gt; <code class="language-plaintext highlighter-rouge">Connection Context</code> - <em>Packet</em> -&gt; <code class="language-plaintext highlighter-rouge">Client</code></p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="-example---sql"># Example - SQL</h4>

<p><strong>Schema:</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t</span> <span class="p">(</span><span class="n">c1</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">c2</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)),</span> <span class="k">INDEX</span> <span class="n">idx1</span> <span class="p">(</span><span class="n">c1</span><span class="p">));</span>
</code></pre></div></div>

<p><strong>Query:</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">c1</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">AND</span> <span class="n">c2</span> <span class="o">=</span> <span class="nv">"gopherchina"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p><em>Logical Plan</em></p>

    <p><code class="language-plaintext highlighter-rouge">AST: SelectStmt Node</code> -&gt; <code class="language-plaintext highlighter-rouge">Logica Plan</code> &lt;&gt; <strong>DataSource</strong>: <code class="language-plaintext highlighter-rouge">from t</code> -&gt; <strong>Where</strong>: <code class="language-plaintext highlighter-rouge">c1 &gt; 10 and c2 = "gopherchina"</code> -&gt; <strong>Projection</strong>: <code class="language-plaintext highlighter-rouge">count(c1)</code></p>
  </li>
  <li>
    <p><em>Physical Plan</em></p>

    <p><code class="language-plaintext highlighter-rouge">Logical Plan</code> -&gt; <code class="language-plaintext highlighter-rouge">Physical Plan</code> &lt;&gt; <strong>IndexScan</strong>: <code class="language-plaintext highlighter-rouge">idx1: (10, +∞)</code> -&gt; <strong>Filter</strong>: <code class="language-plaintext highlighter-rouge">c2 = "gopherchina"</code> -&gt; <strong>Aggregation</strong>: <code class="language-plaintext highlighter-rouge">count(c1)</code></p>
  </li>
  <li>
    <p><em>Distributed Physical Plan</em></p>
  </li>
</ul>

<p><strong><em>Phisical Plan on TiKV</em></strong>: <strong>Read Index</strong>: <code class="language-plaintext highlighter-rouge">idx1: (10, +∞ )</code> - <em>RowID</em> -&gt; <strong>Read Row Data</strong> by RowID - <em>Row</em> -&gt; <strong>Filter</strong>: <code class="language-plaintext highlighter-rouge">c2=gopherchina</code> - <em>Row</em> -&gt; <strong>Partial Aggregate</strong>: <code class="language-plaintext highlighter-rouge">count(c1)</code> - <code class="language-plaintext highlighter-rouge">count(c1)</code> -&gt; <strong><em>Physical Plan on TiDB</em></strong>: <strong>DistSQL Scan</strong> - <em>count(c1)</em> -&gt; <strong>Final Aggregate</strong>: <code class="language-plaintext highlighter-rouge">sum(count(c1))</code></p>

<h4 id="-challenges-in-buiding-a-distributed-database"># Challenges in Buiding a Distributed Database</h4>

<ul>
  <li>A very complex distributed system</li>
  <li>A lot of RPC work</li>
  <li>High performance</li>
  <li>Tons of data</li>
  <li>Huge amount of OLTP queries</li>
  <li>Very complex OLAP queries</li>
  <li>Why Go? <code class="language-plaintext highlighter-rouge">goroutine</code> <code class="language-plaintext highlighter-rouge">channel</code> <code class="language-plaintext highlighter-rouge">GC</code> <code class="language-plaintext highlighter-rouge">concurrent</code> <code class="language-plaintext highlighter-rouge">multi-core</code></li>
</ul>

<h4 id="-parallel-data-scan-operator"># Parallel Data Scan Operator</h4>

<p><code class="language-plaintext highlighter-rouge">Executor</code> - <em>Index Ranges</em> -&gt; <code class="language-plaintext highlighter-rouge">IndexScan Executor</code>: <em>Split Task by range</em> -&gt; <code class="language-plaintext highlighter-rouge">Task Pool</code> &lt;- Pick Task -&gt; <code class="language-plaintext highlighter-rouge">Woker Pool</code> &lt;-&gt; <code class="language-plaintext highlighter-rouge">TiKV</code></p>

<p><code class="language-plaintext highlighter-rouge">IndexScan Executor</code> - <em>Row IDs</em> -&gt; <code class="language-plaintext highlighter-rouge">TableScan Executor</code> - <em>Tasks</em> -&gt; <code class="language-plaintext highlighter-rouge">Task Pool</code></p>

<p><code class="language-plaintext highlighter-rouge">Worker Pool</code> - <em>Rows</em> -&gt; <code class="language-plaintext highlighter-rouge">TableScan Executor</code> - <em>Rows</em> -&gt; <code class="language-plaintext highlighter-rouge">Executor</code></p>

<h4 id="-parallel-hashjoin-operator"># Parallel HashJoin Operator</h4>

<p><code class="language-plaintext highlighter-rouge">TiKV</code> =&gt; <strong>Tables: (Left &amp;&amp; Right)</strong></p>

<p><code class="language-plaintext highlighter-rouge">Left Table</code> -&gt; <code class="language-plaintext highlighter-rouge">Build HashTable</code> - <em>Hash Table</em></p>

<p><code class="language-plaintext highlighter-rouge">Right Table</code> -*&gt; <code class="language-plaintext highlighter-rouge">Join Wokers</code> -&gt; <code class="language-plaintext highlighter-rouge">Left</code>: <em>Hash Table</em> -&gt; <code class="language-plaintext highlighter-rouge">Joined Table</code></p>

<h4 id="-goroutine-leak--block-profile-timeout-context"># Goroutine <em>leak</em> : <code class="language-plaintext highlighter-rouge">Block profile</code> <code class="language-plaintext highlighter-rouge">Timeout</code> <code class="language-plaintext highlighter-rouge">Context</code></h4>

<h4 id="-memory--gc"># Memory &amp;&amp; GC</h4>

<ul>
  <li>
    <p>Reduce the Number of Allocation</p>

    <ul>
      <li>Get enough memory in one allocation operation</li>
    </ul>
  </li>
  <li>
    <p>Reuse Object</p>

    <ul>
      <li>Introduce a cache in goyacc</li>
      <li>Share a stack for all queries in one session</li>
    </ul>
  </li>
  <li>
    <p><strong>sync.Pool</strong></p>

    <ul>
      <li>Thread safe</li>
      <li>Reuse objects to relieve pressure on the GC</li>
    </ul>
  </li>
  <li>
    <p><strong>gogo/protobuf</strong></p>

    <ul>
      <li>Fast marshalling and unmarshalling</li>
      <li>Fields without pointers cause less time in the garbage collector</li>
    </ul>
  </li>
  <li>
    <p>Monitor the Memory Usage</p>

    <ul>
      <li>
        <p>Monitor the memory usage of the server is easy</p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">rutime.MemProfile()</code></li>
        </ul>
      </li>
      <li>
        <p>Monitor the memory usage of a session is hard</p>

        <ul>
          <li>Account for large memory allocation</li>
          <li>Account for memory consuming operators</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="13-go-coding-in-go-way-neusoft">1.3 Go coding in go way <sub>Neusoft</sub></h3>

<ul>
  <li>“Language influences/determines thought” - Sapir-Whorf hypotheisi</li>
  <li>“A language that doesn’t affect the way you think about programming is not worth knowing.” - Alan J. Perlis</li>
</ul>

<hr />

<h3 id="14-interfacepresented-francesc">1.4 interface.presented <sub><a href="https://github.com/campoy">@francesc</a></sub></h3>

<p>“interface{} says <strong>nothing</strong>” - Rob Pike in his Go Proverbs</p>

<p>“The <strong>bigger</strong> the interface, the <strong>weaker</strong> the abstraction”  - Rob Pike in his Go Proverbs</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// what function do you prefer?</span>

<span class="c">// Cons:</span>
<span class="c">// - how would you test it?</span>
<span class="c">// - what if you want to write to memory?</span>
<span class="c">// Pros:</span>
<span class="c">// - ?</span>
<span class="k">func</span> <span class="n">WriteTo</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">)</span> <span class="kt">error</span>

<span class="c">// Write, Read, Close:</span>
<span class="c">// Which one does WriteTo really need?</span>
<span class="k">func</span> <span class="n">WriteTo</span><span class="p">(</span><span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadWriterCloser</span><span class="p">)</span> <span class="kt">error</span>

<span class="k">func</span> <span class="n">WriteTo</span><span class="p">(</span><span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="p">)</span> <span class="kt">error</span> <span class="c">// winner</span>

<span class="c">// Cons:</span>
<span class="c">// - how do you even write to interface{}?</span>
<span class="c">// - probably requires runtimes checks</span>
<span class="c">// Pros:</span>
<span class="c">// - you can write really bad code</span>
<span class="k">func</span> <span class="n">WriteTo</span><span class="p">(</span><span class="n">w</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div></div>

<p>“Be conservative in what you do, be liberal in what you accept from others” - Robustness Principle</p>

<p>“Be conservative in what you send, be liberal in what you accept” - Robustness Principle</p>

<p>“Return <strong>concrete types</strong>, receive <strong>interfaces</strong> as paramters, unless hiding immplementaion detail” - Robustness Principle applied to Go (me)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// what function do you prefer?</span>

<span class="k">func</span> <span class="n">New</span><span class="p">()</span> <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span> <span class="c">// winner</span>

<span class="k">func</span> <span class="n">New</span><span class="p">()</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadWriteCloser</span>

<span class="k">func</span> <span class="n">New</span><span class="p">()</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>

<span class="k">func</span> <span class="n">New</span><span class="p">()</span> <span class="k">interface</span><span class="p">{}</span>
</code></pre></div></div>

<h3 id="15-nsq-重塑之路">1.5 NSQ-重塑之路</h3>

<p><code class="language-plaintext highlighter-rouge">MQ</code> <code class="language-plaintext highlighter-rouge">NSQ</code> <code class="language-plaintext highlighter-rouge">Replication</code> <code class="language-plaintext highlighter-rouge">HA</code> <code class="language-plaintext highlighter-rouge">Auto-Balance</code> <code class="language-plaintext highlighter-rouge">Delivery in Order</code> <code class="language-plaintext highlighter-rouge">Tracing</code> <code class="language-plaintext highlighter-rouge">Consume History Messages</code></p>

<p><code class="language-plaintext highlighter-rouge">Leader</code> <code class="language-plaintext highlighter-rouge">Follower</code></p>

<p><code class="language-plaintext highlighter-rouge">Writer Buffer</code> <code class="language-plaintext highlighter-rouge">Group Commit</code> <code class="language-plaintext highlighter-rouge">Cursor</code> <code class="language-plaintext highlighter-rouge">Offset</code> <code class="language-plaintext highlighter-rouge">Channel</code></p>

<p><code class="language-plaintext highlighter-rouge">Optimize channel timeout in Go</code> <code class="language-plaintext highlighter-rouge">timer goroutine</code> <code class="language-plaintext highlighter-rouge">timeout event chan</code> <code class="language-plaintext highlighter-rouge">Worker Goroutine Pool</code></p>

<p><code class="language-plaintext highlighter-rouge">etcd</code> <code class="language-plaintext highlighter-rouge">State Machine</code> <code class="language-plaintext highlighter-rouge">Jespen</code></p>

<p><code class="language-plaintext highlighter-rouge">分布式跟踪</code> <code class="language-plaintext highlighter-rouge">分布式测试</code></p>

<h3 id="16-aliyun-apasadb-go-微服务架构-阿里云">1.6 Aliyun ApasaDB Go 微服务架构 <sub>阿里云</sub></h3>

<h4 id="-dubbo-background"># Dubbo background</h4>

<ul>
  <li>分布式 RPC 框架</li>
  <li>Play nice with Java Spring application (J2EE)</li>
  <li>Features:
    <ul>
      <li>服务动态注册&amp;服务发现</li>
      <li>SOA 服务治理</li>
      <li>软负载均衡</li>
      <li>熔断、服务降级</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">服务分层</code> <code class="language-plaintext highlighter-rouge">服务授权</code> <code class="language-plaintext highlighter-rouge">服务容器</code> <code class="language-plaintext highlighter-rouge">服务编排</code> <code class="language-plaintext highlighter-rouge">软负载均衡</code> <code class="language-plaintext highlighter-rouge">服务质量协定</code> <code class="language-plaintext highlighter-rouge">服务容量评估</code> <code class="language-plaintext highlighter-rouge">服务路由</code> <code class="language-plaintext highlighter-rouge">服务测试</code> <code class="language-plaintext highlighter-rouge">服务降级</code> <code class="language-plaintext highlighter-rouge">服务注册与发现</code></p>

<p><code class="language-plaintext highlighter-rouge">调度中心</code> <code class="language-plaintext highlighter-rouge">监控中心</code> <code class="language-plaintext highlighter-rouge">注册中心</code> <code class="language-plaintext highlighter-rouge">治理中心</code></p>

<hr />

<h4 id="-micro-services-complexity"># Micro-services complexity</h4>

<ul>
  <li>Testing is still HARD!</li>
  <li>DevOps culture?</li>
  <li>Security?</li>
  <li>Distributed Tracing?</li>
  <li>Huge payload (Dubbo specific)</li>
</ul>

<p><strong><em>Java is “SO DYNAMIC”!</em></strong> <code class="language-plaintext highlighter-rouge">Spring</code> <code class="language-plaintext highlighter-rouge">IoC (DI)</code> <code class="language-plaintext highlighter-rouge">AoP</code></p>

<h4 id="-profound-of-java-vs-golang-spring-vs-go-tooling"># Profound of Java vs. Golang (Spring vs. Go Tooling)</h4>

<ul>
  <li><strong>Java</strong>
    <ul>
      <li>No all Java Applications are Spring Application (and not all Java Developers are Spring Developers)</li>
      <li>Spring is BIG (Spring 2~4), and too much magics happening</li>
      <li>Dubbo’s IDL is a Java interface class</li>
      <li>JVM is a memory hog (0.5~6GB per micro-service JVM)</li>
    </ul>
  </li>
  <li><strong>Golang</strong>
    <ul>
      <li>Simple, Elegant (i.e., defer vs finnaly) and forced to bundle 3rd part sources codes</li>
      <li>Go tooling:
        <ul>
          <li>go test/go test -bench &amp; go tool &lt;pprof/vet/cover/…&gt;</li>
          <li>go-torch (by Uber)</li>
        </ul>
      </li>
      <li>Memory (&lt;=0.5GB per application container)</li>
    </ul>
  </li>
</ul>

<h4 id="-introducting-of-grpc-httpsgrpcio"># Introducting of gRPC (<a href="grpc.io">https://grpc.io/</a>]</h4>

<ul>
  <li>Open sourced version of Google “Stubby RPC”</li>
  <li>IDL for the service APIs</li>
  <li>“HTTP/2” &amp; “Bi-Directional streaming”!</li>
  <li>Working with Protobuf3</li>
  <li>Generated both client and server in 9 languages, offically (other with C language binding are available)</li>
</ul>

<h4 id="-dubbo-vs-go-kit"># Dubbo vs. Go kit</h4>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Dubbo &amp; Spring</th>
      <th>Go kit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Service Discovery &amp; LB</td>
      <td>Dubbo Registry &amp; Dubbo Subscriber</td>
      <td>github.com/go-kit/kit/sd/(zk/consul/etcd/dnssrv/lb) google.golang.org/grpc/naming (lack of structured versioning)</td>
    </tr>
    <tr>
      <td>“Structured” Logging</td>
      <td>Log4j/Slf4j</td>
      <td>github.com/go-kit/kit/log</td>
    </tr>
    <tr>
      <td>Metrics</td>
      <td>Spring Actuator (many others)</td>
      <td>github.com/go-kit/kit/metrics</td>
    </tr>
    <tr>
      <td>Circuit Breaker</td>
      <td>Dubbo/Netflix Hystrix</td>
      <td>github.com/go-kit/kit/circuitbreaker</td>
    </tr>
    <tr>
      <td>Transports</td>
      <td>HTTP(JSON)/Dubbo/(gRPC)</td>
      <td>github.com/go-kit/kit/transport/(grpc/http/httprp)</td>
    </tr>
    <tr>
      <td>Caching layer</td>
      <td>Dubbo/Spring Cache</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Distributed Tracing</td>
      <td>ELK/(天象全链路路)</td>
      <td>github.com/go-kit/kit/tracing (OpenTracing project)</td>
    </tr>
  </tbody>
</table>

<h4 id="-micro-services-best-practices"># Micro-services best practices</h4>

<ul>
  <li>Design with “Single” domain in mind (DB)</li>
  <li>Strong DevOps culture - CI/CD</li>
  <li>Logging, Metrics and Tracing
    <ul>
      <li>Logging Options - Aliyun Logging Services/Apache Kafka/ELK</li>
      <li>A trace ID to co-relate all the requests that’s been made</li>
    </ul>
  </li>
  <li>Transactional requests with idempotences handing in mind/Eventual Consistency</li>
  <li>Think twice if you need to propagate your requests to a number of micro-services request in “parallel”</li>
  <li>Provider servies governance and versioning</li>
  <li>Circuit Breaker/Fallbacks</li>
  <li>Multi-region cluster/failover</li>
  <li>Employ Container/Docker technologies (DevOps)
    <ul>
      <li>Docker-compose</li>
      <li>swarm</li>
      <li>k8s</li>
    </ul>
  </li>
  <li>Be very careful when introduce a whole new set of framework/library (shoot yourself in the foot)</li>
  <li>SIMPLE is the BEST</li>
</ul>

<h3 id="17-automate-app-operation-coreos">1.7 Automate App Operation <sub><a href="https://coreos.com/">@coreos</a></sub></h3>

<p><em>main.go</em></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"log"</span>
	<span class="s">"net/http"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fs</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">FileServer</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">Dir</span><span class="p">(</span><span class="s">"static"</span><span class="p">))</span>
	<span class="n">http</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="s">"/"</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

	<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Listening on 0.0.0.0:30080"</span><span class="p">)</span>
	<span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">"0.0.0.0:30080"</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Development</em></strong> - <code class="language-plaintext highlighter-rouge">idea</code> + <code class="language-plaintext highlighter-rouge">code</code> -&gt; <code class="language-plaintext highlighter-rouge">程序</code> <code class="language-plaintext highlighter-rouge">打包</code> <code class="language-plaintext highlighter-rouge">发布</code>: <code class="language-plaintext highlighter-rouge">docker build/docker push</code> -&gt; <strong><em>Deployment</em></strong> - <code class="language-plaintext highlighter-rouge">DNS</code> <code class="language-plaintext highlighter-rouge">LB</code></p>

<h4 id="-how-to-deploy"># How to Deploy</h4>

<ul>
  <li>Database: PostgreSQL, MySQL, TiDB</li>
  <li>Coordination service: etcd, ZooKeeper</li>
  <li>Streaming: Kafka, Heron</li>
  <li>Big data: Spark, Hadoop</li>
  <li>Storage: Ceph, GlusterFS</li>
  <li>Logging: ElasticSearch</li>
  <li>Monitoring: Prometheus</li>
</ul>

<h4 id="-etcd-operator"># etcd Operator</h4>

<p><strong>Common Tasks</strong></p>

<ul>
  <li>Resize</li>
  <li>Upgrade</li>
  <li>Backup</li>
  <li>Failover</li>
</ul>

<p><strong>Advanced</strong></p>

<ul>
  <li>Restore</li>
  <li>TLS</li>
  <li>Monitoring/Alerting</li>
</ul>

<h4 id="-deploy-app-container"># Deploy App Container</h4>

<ul>
  <li>Docker/OCI
    <ul>
      <li>Standard app packaging format</li>
    </ul>
  </li>
  <li>Kubernetes/Swarm
    <ul>
      <li>Resource scheduling, cluster management</li>
    </ul>
  </li>
  <li>Operator
    <ul>
      <li>App specific operation automation
        <ul>
          <li>Automation</li>
          <li>Declarative</li>
          <li>Version-controlled</li>
          <li>Cloud-native</li>
          <li>Customizable</li>
          <li>Composable</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="18-go-微服务实战-哔哩哔哩">1.8 Go 微服务实战 <sub>@哔哩哔哩</sub></h3>

<p>推荐：纽曼(Sam Newman) 的 《微服务设计》</p>

<h4 id="-微服务演进-分解单块系统"># 微服务演进 <sub>分解单块系统</sub></h4>

<ul>
  <li>梳理业务边界</li>
  <li>资源隔离部署</li>
  <li>内外网服务隔离</li>
  <li>RPC 框架
    <ul>
      <li>序列化 (GOB)</li>
      <li>上下文管理 (超时控制)</li>
      <li>拦截器 (鉴权、统计、限流)</li>
      <li>服务注册 (Zookeeper)</li>
      <li>负载均衡 (客户端)</li>
    </ul>
  </li>
  <li>API Gateway
    <ul>
      <li>统一&amp;聚合协议</li>
      <li>errgroup 并行调用</li>
      <li>业务隔离</li>
      <li>熔断、降级、限流等高可用</li>
    </ul>
  </li>
</ul>

<h4 id="-高可用"># 高可用</h4>

<ul>
  <li>隔离 <code class="language-plaintext highlighter-rouge">服务</code> <code class="language-plaintext highlighter-rouge">轻重</code> <code class="language-plaintext highlighter-rouge">物理</code></li>
  <li>超时 <code class="language-plaintext highlighter-rouge">连接</code> <code class="language-plaintext highlighter-rouge">读取</code> <code class="language-plaintext highlighter-rouge">写入</code></li>
  <li>限流
    <ul>
      <li>流量 <code class="language-plaintext highlighter-rouge">accept</code> <code class="language-plaintext highlighter-rouge">connection</code> <code class="language-plaintext highlighter-rouge">thread</code></li>
      <li>资源 <code class="language-plaintext highlighter-rouge">connection pool</code> <code class="language-plaintext highlighter-rouge">thread pool</code></li>
      <li>请求 <code class="language-plaintext highlighter-rouge">总数</code> <code class="language-plaintext highlighter-rouge">时间窗口</code> <code class="language-plaintext highlighter-rouge">平滑限流</code></li>
      <li>分布式 <code class="language-plaintext highlighter-rouge">redis + lua</code> <code class="language-plaintext highlighter-rouge">nginx + lua</code></li>
      <li>接入层 <code class="language-plaintext highlighter-rouge">nginx limit_req</code> <code class="language-plaintext highlighter-rouge">nginx limit_conn</code></li>
    </ul>
  </li>
  <li>降级 <code class="language-plaintext highlighter-rouge">链路</code> <code class="language-plaintext highlighter-rouge">自动</code> <code class="language-plaintext highlighter-rouge">手动</code></li>
  <li>容错
    <ul>
      <li>重试容错 <code class="language-plaintext highlighter-rouge">简单重试</code> <code class="language-plaintext highlighter-rouge">主备重试</code> <code class="language-plaintext highlighter-rouge">成功率重试</code> <code class="language-plaintext highlighter-rouge">快速失败</code></li>
      <li>熔断容错 <code class="language-plaintext highlighter-rouge">动态剔除</code> <code class="language-plaintext highlighter-rouge">异常恢复</code></li>
    </ul>
  </li>
</ul>

<h4 id="-中间件"># 中间件</h4>

<ul>
  <li>databus (Kafka)</li>
  <li>canal   (MySQL Replication)</li>
  <li>bilitw  (Twemproxy)</li>
  <li>bfs (facebook haystac, opencv)</li>
  <li>config-service</li>
  <li>dapper (google dapper)</li>
</ul>

<h4 id="-持续集成和交付"># 持续集成和交付</h4>

<ul>
  <li>版本管理 (语义化） <a href="http://semver.org/#semantic-versioning-200">Semantic Versioning 2.0.0</a></li>
  <li>分支管理 (gitlab+mr review) <a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></li>
  <li>环境管理 (集成环境)</li>
  <li>测试 (单元测试，服务测试)</li>
  <li>发布 (冒烟、灰度、蓝绿)</li>
</ul>

<h4 id="-运维体系"># 运维体系</h4>

<ul>
  <li>
    <p>服务日志收集、分发、存储、UI</p>
  </li>
  <li>
    <p>分布式跟踪</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Zabbix</code> <code class="language-plaintext highlighter-rouge">Dapper</code> <code class="language-plaintext highlighter-rouge">ELK: (Elastic Search, Logstash, Kibana)</code></p>
  </li>
</ul>

<h4 id="-引用参考"># 引用&amp;参考</h4>

<ul>
  <li>[英] 纽曼（Sam Newman） (作者), 崔力强 张骏 (译者)《微服务设计》</li>
  <li><a href="http://semver.org/#semantic-versioning-200" title="Semantic Versioning 2.0.0">http://semver.org/#semantic-versioning-200</a></li>
  <li><a href="http://nvie.com/posts/a-successful-git-branching-model/" title="A successful Git branching model">http://nvie.com/posts/a-successful-git-branching-model/</a></li>
</ul>

<hr />

<h3 id="21-go-打造亿级实时分布式平台-grab">2.1 Go 打造亿级实时分布式平台 <sub>Grab</sub></h3>

<p><code class="language-plaintext highlighter-rouge">RAILS</code> <code class="language-plaintext highlighter-rouge">NodeJS</code> <code class="language-plaintext highlighter-rouge">amazon web services</code> <code class="language-plaintext highlighter-rouge">Travis CI</code> <code class="language-plaintext highlighter-rouge">GitHub</code> <code class="language-plaintext highlighter-rouge">MySQL</code></p>

<hr />

<p><code class="language-plaintext highlighter-rouge">GitHub</code> <code class="language-plaintext highlighter-rouge">MySQL</code> <code class="language-plaintext highlighter-rouge">redis</code> <code class="language-plaintext highlighter-rouge">amazon web services</code> <code class="language-plaintext highlighter-rouge">PHABRICATOR</code> <code class="language-plaintext highlighter-rouge">Jenkins</code> <code class="language-plaintext highlighter-rouge">etcd</code> <code class="language-plaintext highlighter-rouge">k8s</code> <code class="language-plaintext highlighter-rouge">docker</code> <code class="language-plaintext highlighter-rouge">Kafka</code> <code class="language-plaintext highlighter-rouge">Spark</code> <code class="language-plaintext highlighter-rouge">Presto</code> <code class="language-plaintext highlighter-rouge">Amazon KINESIS</code> <code class="language-plaintext highlighter-rouge">DATADOG</code> <code class="language-plaintext highlighter-rouge">SCALYR</code> <code class="language-plaintext highlighter-rouge">LIGHTSTEP</code> <code class="language-plaintext highlighter-rouge">Go</code></p>

<hr />

<h4 id="-distributed-tracing"># Distributed Tracing</h4>

<ul>
  <li><strong>应用场景</strong>
    <ul>
      <li>一个请求耗时三秒才能完成，如何诊断何处耗时最多？</li>
      <li>如何定位 Single Point of Failure？</li>
      <li>如何检测并避免循环依赖关系？</li>
      <li>如何定位 Fan In，Fan Out？</li>
    </ul>
  </li>
  <li><strong>实现原理</strong>
    <ul>
      <li>在 API Gateway 生成一个全局唯一的 traceID，并将其注入请求的 Header 里</li>
      <li>在该请求的每个耗时节点生成一个 spanID，以 traceID+spanID 为索引计时，并记录其他元数据</li>
      <li>将 tacing 信息自动传入每个耗时操作</li>
      <li>最后一 traceID 为 key 来聚合所有的诊断信息</li>
    </ul>
  </li>
  <li>
    <p><strong>context.Context</strong></p>

    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">Server</span><span class="p">)</span> <span class="n">Handler</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">req</span> <span class="n">Request</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
      <span class="c">// ...</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>OpenTracing</strong> <a href="http://opentracing.io">http://opentracing.io</a></li>
</ul>

<h3 id="22-go-语言在讯联扫码支付系统中的成功实践-讯联">2.2 Go 语言在讯联扫码支付系统中的成功实践 <sub>讯联</sub></h3>

<p>略…</p>

<h3 id="23-golang-在百万级搜索中的应用-360">2.3 Golang 在百万级搜索中的应用 <sub>360</sub></h3>

<p><code class="language-plaintext highlighter-rouge">C++</code> <code class="language-plaintext highlighter-rouge">C++ -&gt; C -&gt; CGO -&gt; Go</code> <code class="language-plaintext highlighter-rouge">ProtoBuffer</code> <code class="language-plaintext highlighter-rouge">gdb</code> <code class="language-plaintext highlighter-rouge">core dump</code> <code class="language-plaintext highlighter-rouge">简单、有效、够用</code> <code class="language-plaintext highlighter-rouge">连接池</code> <code class="language-plaintext highlighter-rouge">熔断</code></p>

<hr />

<h3 id="24-gos-hidden-pragrams-davecheney">2.4 Go’s Hidden Pragrams <sub><a href="https://dave.cheney.net/">@davecheney</a></sub></h3>

<h3 id="25-跨境电商的-go-服务治理实践">2.5 跨境电商的 Go 服务治理实践</h3>

<h3 id="26-containerops-devops-orchestration">2.6 ContainerOps DevOps Orchestration</h3>

<h3 id="27-harbor-开源项目容器镜像远程复制的实现">2.7 Harbor 开源项目容器镜像远程复制的实现</h3>

<h3 id="28-go-在证券行情系统中的应用">2.8 Go 在证券行情系统中的应用</h3>

<h3 id="29-go-语言在证券期货行情系统中的实践">2.9 Go 语言在证券期货行情系统中的实践</h3>

<hr />

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
