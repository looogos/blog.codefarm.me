<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Tour of Go - Methods and interfaces | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Tour of Go - Methods and interfaces" />
<meta property="og:locale" content="en" />
<meta name="description" content="Methods and interfaces Methods Go does not have classes. However, you can define methods on struct types. The method receiver appears in its own argument list between the func keyword and the method name. package main import ( &quot;fmt&quot; &quot;math&quot; ) type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &amp;Vertex{3, 4} fmt.Println(v.Abs()) } Methods continued You can declare a method on any type that is declared in your package, not just struct types. However, you cannot define a method on a type from another package (including built in types). package main import ( &quot;fmt&quot; &quot;math&quot; ) type MyFloat float64 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) fmt.Printf(&quot;%T,%v&quot;, f, f) } Methods with pointer receivers Methods can be associated with a named type or a pointer to a named type. We just saw two Abs methods. One on the *Vertex pointer type and the other on the MyFloat value type. There are two reasons to use a pointer receiver. First, to avoid copying the value on each method call (more efficient if the value type is a large struct). Second, so that the method can modify the value that its receiver points to. Try changing the declarations of the Abs and Scale methods to use Vertex as the receiver, instead of *Vertex. The Scale method has no effect when v is a Vertex. Scale mutates v. When v is a value (non-pointer) type, the method sees a copy of the Vertex and cannot mutate the original value. Abs works either way. It only reads v. It doesn’t matter whether it is reading the original value (through a pointer) or a copy of that value. package main import ( &quot;fmt&quot; &quot;math&quot; ) type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &amp;Vertex{3, 4} fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs()) v.Scale(5) fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs()) } Interfaces An interface type is defined by a set of methods. A value of interface type can hold any value that implements those methods. Note: There is an error in the example code on line 22. Vertex (the value type) doesn’t satisfy Abser because the Abs method is defined only on *Vertex (the pointer type). package main import ( &quot;fmt&quot; &quot;math&quot; ) type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser a = &amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } Interfaces are satisfied implicitly A type implements an interface by implementing the methods. There is no explicit declaration of intent; no “implements” keyword. Implicit interfaces decouple implementation packages from the packages that define the interfaces: neither depends on the other. It also encourages the definition of precise interfaces, because you don’t have to find every implementation and tag it with the new interface name. Package io defines Reader and Writer; you don’t have to. package main import ( &quot;fmt&quot; &quot;os&quot; ) type Reader interface { Read(b []byte) (n int, err error) } type Writer interface { Write(b []byte) (n int, err error) } type ReadWriter interface { Reader Writer } func main() { var w Writer // os.Stdout implements Writer w = os.Stdout fmt.Fprintf(w, &quot;hello, writer\n&quot;) } Stringers One of the most ubiquitous interfaces is Stringer defined by the fmt package. type Stringer interface { String() string } A Stringer is a type that can describe itself as a string. The fmt package (and many others) look for this interface to print values. package main import &quot;fmt&quot; type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age) } func main() { a := Person{&quot;Arthur Dent&quot;, 42} z := Person{&quot;Zaphod Beeblebrox&quot;, 9001} fmt.Println(a, z) } Errors Go programs express error state with error values. The error type is a built-in interface similar to fmt.Stringer: type error interface { Error() string } (As with fmt.Stringer, the fmt package looks for the error interface when printing values.) Functions often return an error value, and calling code should handle errors by testing whether the error equals nil. i, err := strconv.Atoi(&quot;42&quot;) if err != nil { fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err) } fmt.Println(&quot;Converted integer:&quot;, i) A nil error denotes success; a non-nil error denotes failure. package main import ( &quot;fmt&quot; &quot;time&quot; ) type MyError struct { When time.Time What string } func (e *MyError) Error() string { return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What) } func run() error { return &amp;MyError{ time.Now(), &quot;it didn&#39;t work&quot;, } } func main() { if err := run(); err != nil { fmt.Println(err) } } Readers The io package specifies the io.Reader interface, which represents the read end of a stream of data. The Go standard library contains many implementations of these interfaces, including files, network connections, compressors, ciphers, and others. The io.Reader interface has a Read method: func (T) Read(b []byte) (n int, err error) Read populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an io.EOF error when the stream ends. The example code creates a strings.Reader. and consumes its output 8 bytes at a time. package main import ( &quot;fmt&quot; &quot;io&quot; &quot;strings&quot; ) func main() { r := strings.NewReader(&quot;Hello, Reader!&quot;) b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b) fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n]) if err == io.EOF { break } } } #Web servers# Package http serves HTTP requests using any value that implements http.Handler: package http type Handler interface { ServeHTTP(w ResponseWriter, r *Request) } In this example, the type Hello implements http.Handler. Visit http://localhost:4000/ to see the greeting. Note: This example won’t run through the web-based tour user interface. To try writing web servers you may want to Install Go. package main import ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; ) type Hello struct{} func (h Hello) ServeHTTP( w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, &quot;Hello&quot;) } func main() { var h Hello err := http.ListenAndServe(&quot;localhost:4000&quot;, h) if err != nil { log.Fatal(err) } } #Exercise: HTTP Handlers# Implement the following types and define ServeHTTP methods on them. Register them to handle specific paths in your web server. type String string type Struct struct { Greeting string Punct string Who string } For example, you should be able to register handlers using: http.Handle(&quot;/string&quot;, String(&quot;I&#39;m a frayed knot.&quot;)) http.Handle(&quot;/struct&quot;, &amp;Struct{&quot;Hello&quot;, &quot;:&quot;, &quot;Gophers!&quot;}) Note: This example won’t run through the web-based tour user interface. To try writing web servers you may want to Install Go. package main import ( &quot;log&quot; &quot;net/http&quot; ) func main() { // your http.Handle calls here log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil)) } Images Package image defines the Image interface: package image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } Note: the Rectangle return value of the Bounds method is actually an image.Rectangle, as the declaration is inside package image. (See the documentation for all the details.) The color.Color and color.Model types are also interfaces, but we’ll ignore that by using the predefined implementations color.RGBA and color.RGBAModel. These interfaces and types are specified by the image/color package package main import ( &quot;fmt&quot; &quot;image&quot; ) func main() { m := image.NewRGBA(image.Rect(0, 0, 100, 100)) fmt.Println(m.Bounds()) fmt.Println(m.At(0, 0).RGBA()) } References Tour of Go,http://tour.golang.org/" />
<meta property="og:description" content="Methods and interfaces Methods Go does not have classes. However, you can define methods on struct types. The method receiver appears in its own argument list between the func keyword and the method name. package main import ( &quot;fmt&quot; &quot;math&quot; ) type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &amp;Vertex{3, 4} fmt.Println(v.Abs()) } Methods continued You can declare a method on any type that is declared in your package, not just struct types. However, you cannot define a method on a type from another package (including built in types). package main import ( &quot;fmt&quot; &quot;math&quot; ) type MyFloat float64 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) fmt.Printf(&quot;%T,%v&quot;, f, f) } Methods with pointer receivers Methods can be associated with a named type or a pointer to a named type. We just saw two Abs methods. One on the *Vertex pointer type and the other on the MyFloat value type. There are two reasons to use a pointer receiver. First, to avoid copying the value on each method call (more efficient if the value type is a large struct). Second, so that the method can modify the value that its receiver points to. Try changing the declarations of the Abs and Scale methods to use Vertex as the receiver, instead of *Vertex. The Scale method has no effect when v is a Vertex. Scale mutates v. When v is a value (non-pointer) type, the method sees a copy of the Vertex and cannot mutate the original value. Abs works either way. It only reads v. It doesn’t matter whether it is reading the original value (through a pointer) or a copy of that value. package main import ( &quot;fmt&quot; &quot;math&quot; ) type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &amp;Vertex{3, 4} fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs()) v.Scale(5) fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs()) } Interfaces An interface type is defined by a set of methods. A value of interface type can hold any value that implements those methods. Note: There is an error in the example code on line 22. Vertex (the value type) doesn’t satisfy Abser because the Abs method is defined only on *Vertex (the pointer type). package main import ( &quot;fmt&quot; &quot;math&quot; ) type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser a = &amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } Interfaces are satisfied implicitly A type implements an interface by implementing the methods. There is no explicit declaration of intent; no “implements” keyword. Implicit interfaces decouple implementation packages from the packages that define the interfaces: neither depends on the other. It also encourages the definition of precise interfaces, because you don’t have to find every implementation and tag it with the new interface name. Package io defines Reader and Writer; you don’t have to. package main import ( &quot;fmt&quot; &quot;os&quot; ) type Reader interface { Read(b []byte) (n int, err error) } type Writer interface { Write(b []byte) (n int, err error) } type ReadWriter interface { Reader Writer } func main() { var w Writer // os.Stdout implements Writer w = os.Stdout fmt.Fprintf(w, &quot;hello, writer\n&quot;) } Stringers One of the most ubiquitous interfaces is Stringer defined by the fmt package. type Stringer interface { String() string } A Stringer is a type that can describe itself as a string. The fmt package (and many others) look for this interface to print values. package main import &quot;fmt&quot; type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age) } func main() { a := Person{&quot;Arthur Dent&quot;, 42} z := Person{&quot;Zaphod Beeblebrox&quot;, 9001} fmt.Println(a, z) } Errors Go programs express error state with error values. The error type is a built-in interface similar to fmt.Stringer: type error interface { Error() string } (As with fmt.Stringer, the fmt package looks for the error interface when printing values.) Functions often return an error value, and calling code should handle errors by testing whether the error equals nil. i, err := strconv.Atoi(&quot;42&quot;) if err != nil { fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err) } fmt.Println(&quot;Converted integer:&quot;, i) A nil error denotes success; a non-nil error denotes failure. package main import ( &quot;fmt&quot; &quot;time&quot; ) type MyError struct { When time.Time What string } func (e *MyError) Error() string { return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What) } func run() error { return &amp;MyError{ time.Now(), &quot;it didn&#39;t work&quot;, } } func main() { if err := run(); err != nil { fmt.Println(err) } } Readers The io package specifies the io.Reader interface, which represents the read end of a stream of data. The Go standard library contains many implementations of these interfaces, including files, network connections, compressors, ciphers, and others. The io.Reader interface has a Read method: func (T) Read(b []byte) (n int, err error) Read populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an io.EOF error when the stream ends. The example code creates a strings.Reader. and consumes its output 8 bytes at a time. package main import ( &quot;fmt&quot; &quot;io&quot; &quot;strings&quot; ) func main() { r := strings.NewReader(&quot;Hello, Reader!&quot;) b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b) fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n]) if err == io.EOF { break } } } #Web servers# Package http serves HTTP requests using any value that implements http.Handler: package http type Handler interface { ServeHTTP(w ResponseWriter, r *Request) } In this example, the type Hello implements http.Handler. Visit http://localhost:4000/ to see the greeting. Note: This example won’t run through the web-based tour user interface. To try writing web servers you may want to Install Go. package main import ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; ) type Hello struct{} func (h Hello) ServeHTTP( w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, &quot;Hello&quot;) } func main() { var h Hello err := http.ListenAndServe(&quot;localhost:4000&quot;, h) if err != nil { log.Fatal(err) } } #Exercise: HTTP Handlers# Implement the following types and define ServeHTTP methods on them. Register them to handle specific paths in your web server. type String string type Struct struct { Greeting string Punct string Who string } For example, you should be able to register handlers using: http.Handle(&quot;/string&quot;, String(&quot;I&#39;m a frayed knot.&quot;)) http.Handle(&quot;/struct&quot;, &amp;Struct{&quot;Hello&quot;, &quot;:&quot;, &quot;Gophers!&quot;}) Note: This example won’t run through the web-based tour user interface. To try writing web servers you may want to Install Go. package main import ( &quot;log&quot; &quot;net/http&quot; ) func main() { // your http.Handle calls here log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil)) } Images Package image defines the Image interface: package image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } Note: the Rectangle return value of the Bounds method is actually an image.Rectangle, as the declaration is inside package image. (See the documentation for all the details.) The color.Color and color.Model types are also interfaces, but we’ll ignore that by using the predefined implementations color.RGBA and color.RGBAModel. These interfaces and types are specified by the image/color package package main import ( &quot;fmt&quot; &quot;image&quot; ) func main() { m := image.NewRGBA(image.Rect(0, 0, 100, 100)) fmt.Println(m.Bounds()) fmt.Println(m.At(0, 0).RGBA()) } References Tour of Go,http://tour.golang.org/" />
<link rel="canonical" href="https://blog.codefarm.me/2015/09/18/tour-of-go-methods-and-interfaces/" />
<meta property="og:url" content="https://blog.codefarm.me/2015/09/18/tour-of-go-methods-and-interfaces/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-09-18T19:41:03+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Tour of Go - Methods and interfaces" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-09-18T19:41:03+08:00","datePublished":"2015-09-18T19:41:03+08:00","description":"Methods and interfaces Methods Go does not have classes. However, you can define methods on struct types. The method receiver appears in its own argument list between the func keyword and the method name. package main import ( &quot;fmt&quot; &quot;math&quot; ) type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &amp;Vertex{3, 4} fmt.Println(v.Abs()) } Methods continued You can declare a method on any type that is declared in your package, not just struct types. However, you cannot define a method on a type from another package (including built in types). package main import ( &quot;fmt&quot; &quot;math&quot; ) type MyFloat float64 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) fmt.Printf(&quot;%T,%v&quot;, f, f) } Methods with pointer receivers Methods can be associated with a named type or a pointer to a named type. We just saw two Abs methods. One on the *Vertex pointer type and the other on the MyFloat value type. There are two reasons to use a pointer receiver. First, to avoid copying the value on each method call (more efficient if the value type is a large struct). Second, so that the method can modify the value that its receiver points to. Try changing the declarations of the Abs and Scale methods to use Vertex as the receiver, instead of *Vertex. The Scale method has no effect when v is a Vertex. Scale mutates v. When v is a value (non-pointer) type, the method sees a copy of the Vertex and cannot mutate the original value. Abs works either way. It only reads v. It doesn’t matter whether it is reading the original value (through a pointer) or a copy of that value. package main import ( &quot;fmt&quot; &quot;math&quot; ) type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &amp;Vertex{3, 4} fmt.Printf(&quot;Before scaling: %+v, Abs: %v\\n&quot;, v, v.Abs()) v.Scale(5) fmt.Printf(&quot;After scaling: %+v, Abs: %v\\n&quot;, v, v.Abs()) } Interfaces An interface type is defined by a set of methods. A value of interface type can hold any value that implements those methods. Note: There is an error in the example code on line 22. Vertex (the value type) doesn’t satisfy Abser because the Abs method is defined only on *Vertex (the pointer type). package main import ( &quot;fmt&quot; &quot;math&quot; ) type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser a = &amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } Interfaces are satisfied implicitly A type implements an interface by implementing the methods. There is no explicit declaration of intent; no “implements” keyword. Implicit interfaces decouple implementation packages from the packages that define the interfaces: neither depends on the other. It also encourages the definition of precise interfaces, because you don’t have to find every implementation and tag it with the new interface name. Package io defines Reader and Writer; you don’t have to. package main import ( &quot;fmt&quot; &quot;os&quot; ) type Reader interface { Read(b []byte) (n int, err error) } type Writer interface { Write(b []byte) (n int, err error) } type ReadWriter interface { Reader Writer } func main() { var w Writer // os.Stdout implements Writer w = os.Stdout fmt.Fprintf(w, &quot;hello, writer\\n&quot;) } Stringers One of the most ubiquitous interfaces is Stringer defined by the fmt package. type Stringer interface { String() string } A Stringer is a type that can describe itself as a string. The fmt package (and many others) look for this interface to print values. package main import &quot;fmt&quot; type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age) } func main() { a := Person{&quot;Arthur Dent&quot;, 42} z := Person{&quot;Zaphod Beeblebrox&quot;, 9001} fmt.Println(a, z) } Errors Go programs express error state with error values. The error type is a built-in interface similar to fmt.Stringer: type error interface { Error() string } (As with fmt.Stringer, the fmt package looks for the error interface when printing values.) Functions often return an error value, and calling code should handle errors by testing whether the error equals nil. i, err := strconv.Atoi(&quot;42&quot;) if err != nil { fmt.Printf(&quot;couldn&#39;t convert number: %v\\n&quot;, err) } fmt.Println(&quot;Converted integer:&quot;, i) A nil error denotes success; a non-nil error denotes failure. package main import ( &quot;fmt&quot; &quot;time&quot; ) type MyError struct { When time.Time What string } func (e *MyError) Error() string { return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What) } func run() error { return &amp;MyError{ time.Now(), &quot;it didn&#39;t work&quot;, } } func main() { if err := run(); err != nil { fmt.Println(err) } } Readers The io package specifies the io.Reader interface, which represents the read end of a stream of data. The Go standard library contains many implementations of these interfaces, including files, network connections, compressors, ciphers, and others. The io.Reader interface has a Read method: func (T) Read(b []byte) (n int, err error) Read populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an io.EOF error when the stream ends. The example code creates a strings.Reader. and consumes its output 8 bytes at a time. package main import ( &quot;fmt&quot; &quot;io&quot; &quot;strings&quot; ) func main() { r := strings.NewReader(&quot;Hello, Reader!&quot;) b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(&quot;n = %v err = %v b = %v\\n&quot;, n, err, b) fmt.Printf(&quot;b[:n] = %q\\n&quot;, b[:n]) if err == io.EOF { break } } } #Web servers# Package http serves HTTP requests using any value that implements http.Handler: package http type Handler interface { ServeHTTP(w ResponseWriter, r *Request) } In this example, the type Hello implements http.Handler. Visit http://localhost:4000/ to see the greeting. Note: This example won’t run through the web-based tour user interface. To try writing web servers you may want to Install Go. package main import ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; ) type Hello struct{} func (h Hello) ServeHTTP( w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, &quot;Hello&quot;) } func main() { var h Hello err := http.ListenAndServe(&quot;localhost:4000&quot;, h) if err != nil { log.Fatal(err) } } #Exercise: HTTP Handlers# Implement the following types and define ServeHTTP methods on them. Register them to handle specific paths in your web server. type String string type Struct struct { Greeting string Punct string Who string } For example, you should be able to register handlers using: http.Handle(&quot;/string&quot;, String(&quot;I&#39;m a frayed knot.&quot;)) http.Handle(&quot;/struct&quot;, &amp;Struct{&quot;Hello&quot;, &quot;:&quot;, &quot;Gophers!&quot;}) Note: This example won’t run through the web-based tour user interface. To try writing web servers you may want to Install Go. package main import ( &quot;log&quot; &quot;net/http&quot; ) func main() { // your http.Handle calls here log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil)) } Images Package image defines the Image interface: package image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } Note: the Rectangle return value of the Bounds method is actually an image.Rectangle, as the declaration is inside package image. (See the documentation for all the details.) The color.Color and color.Model types are also interfaces, but we’ll ignore that by using the predefined implementations color.RGBA and color.RGBAModel. These interfaces and types are specified by the image/color package package main import ( &quot;fmt&quot; &quot;image&quot; ) func main() { m := image.NewRGBA(image.Rect(0, 0, 100, 100)) fmt.Println(m.Bounds()) fmt.Println(m.At(0, 0).RGBA()) } References Tour of Go,http://tour.golang.org/","headline":"Tour of Go - Methods and interfaces","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2015/09/18/tour-of-go-methods-and-interfaces/"},"url":"https://blog.codefarm.me/2015/09/18/tour-of-go-methods-and-interfaces/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Tour of Go - Methods and interfaces</h1><p class="c-post-meta">18 Sep 2015</p>
  </header>

  <div class="c-post-content">
    <h2 id="methods-and-interfaces">Methods and interfaces</h2>

<h3 id="methods">Methods</h3>

<p>Go does not have classes. However, you can define methods on struct types.</p>

<p>The method receiver appears in its own argument list between the <code class="language-plaintext highlighter-rouge">func</code> keyword and the method name.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">X</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Vertex</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Abs</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure>

<h3 id="methods-continued">Methods continued</h3>

<p>You can declare a method on any type that is declared in your package, not just struct types.</p>

<p>However, you cannot define a method on a type from another package (including built in types).</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">MyFloat</span> <span class="kt">float64</span>

<span class="k">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">MyFloat</span><span class="p">)</span> <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kt">float64</span><span class="p">(</span><span class="o">-</span><span class="n">f</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kt">float64</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">MyFloat</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">Sqrt2</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Abs</span><span class="p">())</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T,%v"</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h3 id="methods-with-pointer-receivers">Methods with pointer receivers</h3>

<p>Methods can be associated with a named type or a pointer to a named type.</p>

<p>We just saw two Abs methods. One on the <code class="language-plaintext highlighter-rouge">*Vertex</code> pointer type and the other on the <code class="language-plaintext highlighter-rouge">MyFloat</code> value type.</p>

<p>There are two reasons to use a pointer receiver. First, to avoid copying the value on each method call (more efficient if the value type is a large struct). Second, so that the method can modify the value that its receiver points to.</p>

<p>Try changing the declarations of the <code class="language-plaintext highlighter-rouge">Abs</code> and <code class="language-plaintext highlighter-rouge">Scale</code> methods to use <code class="language-plaintext highlighter-rouge">Vertex</code> as the receiver, instead of <code class="language-plaintext highlighter-rouge">*Vertex</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">Scale</code> method has no effect when <code class="language-plaintext highlighter-rouge">v</code> is a <code class="language-plaintext highlighter-rouge">Vertex</code>. <code class="language-plaintext highlighter-rouge">Scale</code> mutates <code class="language-plaintext highlighter-rouge">v</code>. When <code class="language-plaintext highlighter-rouge">v</code> is a value (non-pointer) type, the method sees a copy of the <code class="language-plaintext highlighter-rouge">Vertex</code> and cannot mutate the original value.</p>

<p><code class="language-plaintext highlighter-rouge">Abs</code> works either way. It only reads <code class="language-plaintext highlighter-rouge">v</code>. It doesn’t matter whether it is reading the original value (through a pointer) or a copy of that value.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="n">Scale</span><span class="p">(</span><span class="n">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">f</span>
	<span class="n">v</span><span class="o">.</span><span class="n">Y</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">Y</span> <span class="o">*</span> <span class="n">f</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">X</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Vertex</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Before scaling: %+v, Abs: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">Abs</span><span class="p">())</span>
	<span class="n">v</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="m">5</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"After scaling: %+v, Abs: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">Abs</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure>

<h3 id="interfaces">Interfaces</h3>

<p>An interface type is defined by a set of methods.</p>

<p>A value of interface type can hold any value that implements those methods.</p>

<p><strong>Note</strong>: There is an error in the example code on line 22. <code class="language-plaintext highlighter-rouge">Vertex</code> (the value type) doesn’t satisfy <code class="language-plaintext highlighter-rouge">Abser</code> because the <code class="language-plaintext highlighter-rouge">Abs</code> method is defined only on <code class="language-plaintext highlighter-rouge">*Vertex</code> (the pointer type).</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Abser</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">a</span> <span class="n">Abser</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">MyFloat</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">Sqrt2</span><span class="p">)</span>
	<span class="n">v</span> <span class="o">:=</span> <span class="n">Vertex</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>

	<span class="n">a</span> <span class="o">=</span> <span class="n">f</span>  <span class="c">// a MyFloat implements Abser</span>
	<span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span> <span class="c">// a *Vertex implements Abser</span>

	<span class="c">// In the following line, v is a Vertex (not *Vertex)</span>
	<span class="c">// and does NOT implement Abser.</span>
	<span class="c">// a = v</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Abs</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">MyFloat</span> <span class="kt">float64</span>

<span class="k">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">MyFloat</span><span class="p">)</span> <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kt">float64</span><span class="p">(</span><span class="o">-</span><span class="n">f</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kt">float64</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">X</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h3 id="interfaces-are-satisfied-implicitly">Interfaces are satisfied implicitly</h3>

<p>A type implements an interface by implementing the methods. There is no explicit declaration of intent; no “implements” keyword.</p>

<p>Implicit interfaces decouple implementation packages from the packages that define the interfaces: neither depends on the other.</p>

<p>It also encourages the definition of precise interfaces, because you don’t have to find every implementation and tag it with the new interface name.</p>

<p><a href="http://golang.org/pkg/io/">Package io</a> defines <code class="language-plaintext highlighter-rouge">Reader</code> and <code class="language-plaintext highlighter-rouge">Writer</code>; you don’t have to.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"os"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Read</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Write</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>
	<span class="n">Writer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">w</span> <span class="n">Writer</span>

	<span class="c">// os.Stdout implements Writer</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s">"hello, writer</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h3 id="stringers">Stringers</h3>

<p>One of the most ubiquitous interfaces is <code class="language-plaintext highlighter-rouge">Stringer</code> defined by the <code class="language-plaintext highlighter-rouge">fmt</code> package.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Stringer interface {
    String() string
}
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">Stringer</code> is a type that can describe itself as a string. The <code class="language-plaintext highlighter-rouge">fmt</code> package (and many others) look for this interface to print values.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
	<span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Person</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%v (%v years)"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Arthur Dent"</span><span class="p">,</span> <span class="m">42</span><span class="p">}</span>
	<span class="n">z</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Zaphod Beeblebrox"</span><span class="p">,</span> <span class="m">9001</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h3 id="errors">Errors</h3>

<p>Go programs express error state with error values.</p>

<p>The error type is a built-in interface similar to <code class="language-plaintext highlighter-rouge">fmt.Stringer</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type error interface {
    Error() string
}
</code></pre></div></div>

<p>(As with <code class="language-plaintext highlighter-rouge">fmt.Stringer</code>, the <code class="language-plaintext highlighter-rouge">fmt</code> package looks for the <code class="language-plaintext highlighter-rouge">error</code> interface when printing values.)</p>

<p>Functions often return an <code class="language-plaintext highlighter-rouge">error</code> value, and calling code should handle errors by testing whether the error equals <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
}
fmt.Println("Converted integer:", i)
</code></pre></div></div>

<p>A nil <code class="language-plaintext highlighter-rouge">error</code> denotes success; a non-nil error denotes failure.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">MyError</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">When</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span>
	<span class="n">What</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span><span class="n">MyError</span><span class="p">)</span> <span class="n">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"at %v, %s"</span><span class="p">,</span>
		<span class="n">e</span><span class="o">.</span><span class="n">When</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">What</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">MyError</span><span class="p">{</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">(),</span>
		<span class="s">"it didn't work"</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">run</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h3 id="readers">Readers</h3>

<p>The <code class="language-plaintext highlighter-rouge">io</code> package specifies the <code class="language-plaintext highlighter-rouge">io.Reader</code> interface, which represents the read end of a stream of data.</p>

<p>The Go standard library contains <a href="http://golang.org/search?q=Read#Global">many implementations</a> of these interfaces, including files, network connections, compressors, ciphers, and others.</p>

<p>The <code class="language-plaintext highlighter-rouge">io.Reader</code> interface has a <code class="language-plaintext highlighter-rouge">Read</code> method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (T) Read(b []byte) (n int, err error)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Read</code> populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an <code class="language-plaintext highlighter-rouge">io.EOF</code> error when the stream ends.</p>

<p>The example code creates a <code class="language-plaintext highlighter-rouge">strings.Reader</code>. and consumes its output 8 bytes at a time.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"io"</span>
	<span class="s">"strings"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="s">"Hello, Reader!"</span><span class="p">)</span>

	<span class="n">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="m">8</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"n = %v err = %v b = %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"b[:n] = %q</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="o">:</span><span class="n">n</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">io</span><span class="o">.</span><span class="n">EOF</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>#Web servers#</p>

<p><a href="http://golang.org/pkg/net/http/">Package http</a> serves HTTP requests using any value that implements <code class="language-plaintext highlighter-rouge">http.Handler</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package http

type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}
</code></pre></div></div>

<p>In this example, the type <code class="language-plaintext highlighter-rouge">Hello</code> implements <code class="language-plaintext highlighter-rouge">http.Handler</code>.</p>

<p>Visit <a href="http://localhost:4000/">http://localhost:4000/</a> to see the greeting.</p>

<p><strong>Note</strong>: This example won’t run through the web-based tour user interface. To try writing web servers you may want to <a href="http://golang.org/doc/install/">Install Go</a>.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"log"</span>
	<span class="s">"net/http"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Hello</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="n">Hello</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span>
	<span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span>
	<span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">h</span> <span class="n">Hello</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">"localhost:4000"</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>#Exercise: HTTP Handlers#</p>

<p>Implement the following types and define <code class="language-plaintext highlighter-rouge">ServeHTTP</code> methods on them. Register them to handle specific paths in your web server.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type String string

type Struct struct {
    Greeting string
    Punct    string
    Who      string
}
</code></pre></div></div>

<p>For example, you should be able to register handlers using:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http.Handle("/string", String("I'm a frayed knot."))
http.Handle("/struct", &amp;Struct{"Hello", ":", "Gophers!"})
</code></pre></div></div>

<p><strong>Note</strong>: This example won’t run through the web-based tour user interface. To try writing web servers you may want to <a href="http://golang.org/doc/install/">Install Go</a>.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"log"</span>
	<span class="s">"net/http"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// your http.Handle calls here</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">"localhost:4000"</span><span class="p">,</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure>

<h3 id="images">Images</h3>

<p><a href="http://golang.org/pkg/image/#Image">Package image</a> defines the <code class="language-plaintext highlighter-rouge">Image</code> interface:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package image

type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}
</code></pre></div></div>

<p><strong>Note</strong>: the <code class="language-plaintext highlighter-rouge">Rectangle</code> return value of the <code class="language-plaintext highlighter-rouge">Bounds</code> method is actually an <code class="language-plaintext highlighter-rouge">image.Rectangle</code>, as the declaration is inside package <code class="language-plaintext highlighter-rouge">image</code>.</p>

<p>(See <a href="http://golang.org/pkg/image/#Image">the documentation</a> for all the details.)</p>

<p>The <code class="language-plaintext highlighter-rouge">color.Color</code> and <code class="language-plaintext highlighter-rouge">color.Model</code> types are also interfaces, but we’ll ignore that by using the predefined implementations <code class="language-plaintext highlighter-rouge">color.RGBA</code> and <code class="language-plaintext highlighter-rouge">color.RGBAModel</code>. These interfaces and types are specified by the <a href="http://golang.org/pkg/image/color/">image/color package</a></p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"image"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m</span> <span class="o">:=</span> <span class="n">image</span><span class="o">.</span><span class="n">NewRGBA</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="m">100</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">Bounds</span><span class="p">())</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">At</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span><span class="o">.</span><span class="n">RGBA</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure>

<hr />

<h3 id="references">References</h3>

<ul>
  <li>Tour of Go,<a href="http://tour.golang.org/">http://tour.golang.org/</a></li>
</ul>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
