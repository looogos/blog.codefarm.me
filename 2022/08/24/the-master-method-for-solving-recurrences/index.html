<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The master method for solving recurrences | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="The master method for solving recurrences" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. Mathematical Induction 2. Recursiveness 3. Divide and Conquer 3.1. Analyzing divide-and-conquer algorithms 3.2. Proof of the master theorem 3.3. The maximum-subarray problem 4. References 1. Mathematical Induction Principle of Mathematical Induction: Let P be a property of positive integers such that: Basis step: P(1) is true, and Inductive step: if P(k) is true for all 1 ≤ k ≤ n then P(n + 1) is true. Then P(n) is true for all positive integers. The premise P(n) in the inductive step is called Induction Hypothesis. The validity of the Principle of Mathematical Induction is obvious. The basis step states that P(1) is true. Then the inductive step implies that P(2) is also true. By the inductive step again we see that P(3) is true, and so on. Consequently the property is true for all positive integers. In the basis step we may replace 1 with some other integer m. Then the conclusion is that the property is true for every integer n greater than or equal to m. Example: Prove that the sum of the n first odd positive integers is n2, i.e., 1 + 3 + 5 + · · · + (2n − 1) = n2 Proof: n=1, S(1) = 12 = 1 (1); n=k, S(k) = (k)2 &#8658; n=2k+1, S(k+1) = S(k) + 2k + 1 = k2 + 2k + 1 = (k+1)2 (2); 2. Recursiveness A definition such that the object defined occurs in the definition is called a recursive definition. For instance, consider the Fibonacci sequence 0, 1, 1, 2, 3, 5, 8, 13, . . . It can be defined as a sequence whose two first terms are F0 = 0, F1 = 1 and each subsequent term is the sum of the two previous ones: Fn = Fn−1 + Fn−2 (for n ≥ 2). Other examples: Factorial: 0! = 1 n! = n · (n − 1)! (n ≥ 1) Power: a0 = 1 an = an−1 a (n ≥ 1) In all these examples we have: A basis, where the function is explicitly evaluated for one or more values of its argument. A recursive step, stating how to compute the function from its previous values. 3. Divide and Conquer Many useful algorithms are recursive in structure: to solve a given problem, they call themselves recursively one or more times to deal with closely related subproblems. These algorithms typically follow a divide-and-conquer approach: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem. The divide-and-conquer paradigm involves three steps at each level of the recursion: Divide the problem into a number of subproblems that are smaller instances of the same problem. Conquer the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner. Combine the solutions to the subproblems into the solution for the original problem. MERGE-SORT(A, p, r) 1 if p &lt; r 2 q = ⌊(p + r) / 2 ⌋ 3 MERGE-SORT(A, p, q) 4 MERGE-SORT(A, q, r) 5 MERGE(A, p, q, r) MERGE(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 let L[1..n1 + 1] and R[1..n2] be new arrays 4 for i = 1 to n1 5 L[i] = A[p + i - 1] 6 for j = 1 to n2 7 R[j] = A[q + j] 8 L[n1 + 1] = ∞ 9 R[n2 + 1] = ∞ 10 i = 1 11 j = 1 12 for k = p to r 13 if L[i] ≤ R[j] 14 A[k] = L[i] 15 i = i + 1 16 else A[k] = R[j] 17 j = j + 1 3.1. Analyzing divide-and-conquer algorithms When an algorithm contains a recursive call to itself, we can often describe its running time by a recurrence equation or recurrence, which describes the overall running time on a problem of size n in terms of the running time on smaller inputs. We can then use mathematical tools to solve the recurrence and provide bounds on the performance of the algorithm. A recurrence for the running time of a divide-and-conquer algorithm falls out from the three steps of the basic paradigm. We let T(n) be the running time on a problem of size n. If the problem size is small enough, say n ≤ c for some constant c, the straightforward solution takes constant time, which we write as Θ(1). Suppose that our division of the problem yields a subproblems, each of which is 1/b the size of the original. For merge sort, both a and b are 2, but we shall see many divide-and-conquer algorithms in which a ≠ b. It takes time T(n/b) to solve one subproblem of size n/b, and so it takes time a.T(n/b) to solve a of them. If we take D(n) time to divide the problem into subproblems and _C(n) time to combine the solutions to the subproblems into the solution to the original problem, we get the recurrence T(n) = &nbsp;&nbsp;&nbsp;&nbsp;O(1) if n ≤ c, &nbsp;&nbsp;&nbsp;&nbsp;a.T(n/b) + D(n) + C(n) otherwise. 3.2. Proof of the master theorem The master method provides a “cookbook” method for solving recurrences of the form T(n) = a.T(n/b) + f(n) where a ≥ 1 and b &gt; 1 are constants and f(n) is an asymptotically positive function. For merge sort, we see the T(n) that roughly: T(n) = 2T(n/2) + n Replacing n with n/2 we have T(n/2) = 2T(n/4) + n/2, hence: T(n) = 2T(n/2) + n = 2(2T(n/4) + n/2) + n = 4T(n/4) + 2n Repeating k times we get: T(n) = 2kT(n/2k) + k.n So for k = log2n we have: T(n) = nT(1) + nlog2n = Θ(n.lgn) 3.3. The maximum-subarray problem // 53. Maximum Subarray // Medium // // Given an integer array nums, find the contiguous subarray (containing at least one number) which // has the largest sum and return its sum. // // A subarray is a contiguous part of an array. // // Example 1: // // Input: nums = [-2,1,-3,4,-1,2,1,-5,4] // Output: 6 // Explanation: [4,-1,2,1] has the largest sum = 6. // // Example 2: // // Input: nums = [1] // Output: 1 // // Example 3: // // Input: nums = [5,4,-1,7,8] // Output: 23 // // // // Constraints: // // 1 &lt;= nums.length &lt;= 10^5 // -10^4 &lt;= nums[i] &lt;= 10^4 // // // // Follow up: If you have figured out the O(n) solution, try coding another solution // using the divide and conquer approach, which is more subtle. package maxSubArray import ( &quot;math&quot; ) // divide-and-conquer // nums[low, mid, high] // nums[low,...,mid], nums[low,...,mid,...,high], nums[mid,...,high] func maxSubArray(nums []int) int { var findMaxCrossSubArray func(nums []int, low, mid, high int) int findMaxCrossSubArray = func(nums []int, low, mid, high int) int { leftMax := math.MinInt sum := 0 for i := mid - 1; i &gt;= low; i-- { sum += nums[i] if leftMax &lt; sum { leftMax = sum } } sum = 0 rightMax := math.MinInt for i := mid; i &lt; high; i++ { sum += nums[i] if rightMax &lt; sum { rightMax = sum } } return leftMax + rightMax } var findMaxSubArray func(nums []int, low, high int) int findMaxSubArray = func(nums []int, low, high int) int { if high-low &lt;= 1 { // bottom-out, base-case, only one number, O(1) return nums[low] } mid := (low + high) / 2 left := findMaxSubArray(nums, low, mid) // T(n/2) cross := findMaxCrossSubArray(nums, low, mid, high) // O(n), n = high - low right := findMaxSubArray(nums, mid, high) // T(n/2) // fmt.Println(left, cross, right) if left &gt;= right &amp;&amp; left &gt;= cross { // O(1) return left } else if right &gt;= left &amp;&amp; right &gt;= cross { return right } return cross } // T(n) = O(1) + 2T(n/2) + O(n) + O(1) = 2T(n/2) + O(n) =&gt; O(nlgn), n &gt; 1 // T(n) = O(1), n == 1 return findMaxSubArray(nums, 0, len(nums)) } // brute-force O(n^2) // func maxSubArray(nums []int) int { // max := nums[0] // for i := 0; i &lt; len(nums); i++ { // sum := 0 // for j := i; j &lt; len(nums); j++ { // sum += nums[j] // if max &lt; sum { // max = sum // } // } // } // return max // } 4. References Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest: Introduction to Algorithms, The MIT Press; 4th edition (April 5, 2022) CHAPTER 3 Algorithms, Integers, https://sites.math.northwestern.edu/~mlerma/courses/cs310-05s/notes/dm-algor" />
<meta property="og:description" content="1. Mathematical Induction 2. Recursiveness 3. Divide and Conquer 3.1. Analyzing divide-and-conquer algorithms 3.2. Proof of the master theorem 3.3. The maximum-subarray problem 4. References 1. Mathematical Induction Principle of Mathematical Induction: Let P be a property of positive integers such that: Basis step: P(1) is true, and Inductive step: if P(k) is true for all 1 ≤ k ≤ n then P(n + 1) is true. Then P(n) is true for all positive integers. The premise P(n) in the inductive step is called Induction Hypothesis. The validity of the Principle of Mathematical Induction is obvious. The basis step states that P(1) is true. Then the inductive step implies that P(2) is also true. By the inductive step again we see that P(3) is true, and so on. Consequently the property is true for all positive integers. In the basis step we may replace 1 with some other integer m. Then the conclusion is that the property is true for every integer n greater than or equal to m. Example: Prove that the sum of the n first odd positive integers is n2, i.e., 1 + 3 + 5 + · · · + (2n − 1) = n2 Proof: n=1, S(1) = 12 = 1 (1); n=k, S(k) = (k)2 &#8658; n=2k+1, S(k+1) = S(k) + 2k + 1 = k2 + 2k + 1 = (k+1)2 (2); 2. Recursiveness A definition such that the object defined occurs in the definition is called a recursive definition. For instance, consider the Fibonacci sequence 0, 1, 1, 2, 3, 5, 8, 13, . . . It can be defined as a sequence whose two first terms are F0 = 0, F1 = 1 and each subsequent term is the sum of the two previous ones: Fn = Fn−1 + Fn−2 (for n ≥ 2). Other examples: Factorial: 0! = 1 n! = n · (n − 1)! (n ≥ 1) Power: a0 = 1 an = an−1 a (n ≥ 1) In all these examples we have: A basis, where the function is explicitly evaluated for one or more values of its argument. A recursive step, stating how to compute the function from its previous values. 3. Divide and Conquer Many useful algorithms are recursive in structure: to solve a given problem, they call themselves recursively one or more times to deal with closely related subproblems. These algorithms typically follow a divide-and-conquer approach: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem. The divide-and-conquer paradigm involves three steps at each level of the recursion: Divide the problem into a number of subproblems that are smaller instances of the same problem. Conquer the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner. Combine the solutions to the subproblems into the solution for the original problem. MERGE-SORT(A, p, r) 1 if p &lt; r 2 q = ⌊(p + r) / 2 ⌋ 3 MERGE-SORT(A, p, q) 4 MERGE-SORT(A, q, r) 5 MERGE(A, p, q, r) MERGE(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 let L[1..n1 + 1] and R[1..n2] be new arrays 4 for i = 1 to n1 5 L[i] = A[p + i - 1] 6 for j = 1 to n2 7 R[j] = A[q + j] 8 L[n1 + 1] = ∞ 9 R[n2 + 1] = ∞ 10 i = 1 11 j = 1 12 for k = p to r 13 if L[i] ≤ R[j] 14 A[k] = L[i] 15 i = i + 1 16 else A[k] = R[j] 17 j = j + 1 3.1. Analyzing divide-and-conquer algorithms When an algorithm contains a recursive call to itself, we can often describe its running time by a recurrence equation or recurrence, which describes the overall running time on a problem of size n in terms of the running time on smaller inputs. We can then use mathematical tools to solve the recurrence and provide bounds on the performance of the algorithm. A recurrence for the running time of a divide-and-conquer algorithm falls out from the three steps of the basic paradigm. We let T(n) be the running time on a problem of size n. If the problem size is small enough, say n ≤ c for some constant c, the straightforward solution takes constant time, which we write as Θ(1). Suppose that our division of the problem yields a subproblems, each of which is 1/b the size of the original. For merge sort, both a and b are 2, but we shall see many divide-and-conquer algorithms in which a ≠ b. It takes time T(n/b) to solve one subproblem of size n/b, and so it takes time a.T(n/b) to solve a of them. If we take D(n) time to divide the problem into subproblems and _C(n) time to combine the solutions to the subproblems into the solution to the original problem, we get the recurrence T(n) = &nbsp;&nbsp;&nbsp;&nbsp;O(1) if n ≤ c, &nbsp;&nbsp;&nbsp;&nbsp;a.T(n/b) + D(n) + C(n) otherwise. 3.2. Proof of the master theorem The master method provides a “cookbook” method for solving recurrences of the form T(n) = a.T(n/b) + f(n) where a ≥ 1 and b &gt; 1 are constants and f(n) is an asymptotically positive function. For merge sort, we see the T(n) that roughly: T(n) = 2T(n/2) + n Replacing n with n/2 we have T(n/2) = 2T(n/4) + n/2, hence: T(n) = 2T(n/2) + n = 2(2T(n/4) + n/2) + n = 4T(n/4) + 2n Repeating k times we get: T(n) = 2kT(n/2k) + k.n So for k = log2n we have: T(n) = nT(1) + nlog2n = Θ(n.lgn) 3.3. The maximum-subarray problem // 53. Maximum Subarray // Medium // // Given an integer array nums, find the contiguous subarray (containing at least one number) which // has the largest sum and return its sum. // // A subarray is a contiguous part of an array. // // Example 1: // // Input: nums = [-2,1,-3,4,-1,2,1,-5,4] // Output: 6 // Explanation: [4,-1,2,1] has the largest sum = 6. // // Example 2: // // Input: nums = [1] // Output: 1 // // Example 3: // // Input: nums = [5,4,-1,7,8] // Output: 23 // // // // Constraints: // // 1 &lt;= nums.length &lt;= 10^5 // -10^4 &lt;= nums[i] &lt;= 10^4 // // // // Follow up: If you have figured out the O(n) solution, try coding another solution // using the divide and conquer approach, which is more subtle. package maxSubArray import ( &quot;math&quot; ) // divide-and-conquer // nums[low, mid, high] // nums[low,...,mid], nums[low,...,mid,...,high], nums[mid,...,high] func maxSubArray(nums []int) int { var findMaxCrossSubArray func(nums []int, low, mid, high int) int findMaxCrossSubArray = func(nums []int, low, mid, high int) int { leftMax := math.MinInt sum := 0 for i := mid - 1; i &gt;= low; i-- { sum += nums[i] if leftMax &lt; sum { leftMax = sum } } sum = 0 rightMax := math.MinInt for i := mid; i &lt; high; i++ { sum += nums[i] if rightMax &lt; sum { rightMax = sum } } return leftMax + rightMax } var findMaxSubArray func(nums []int, low, high int) int findMaxSubArray = func(nums []int, low, high int) int { if high-low &lt;= 1 { // bottom-out, base-case, only one number, O(1) return nums[low] } mid := (low + high) / 2 left := findMaxSubArray(nums, low, mid) // T(n/2) cross := findMaxCrossSubArray(nums, low, mid, high) // O(n), n = high - low right := findMaxSubArray(nums, mid, high) // T(n/2) // fmt.Println(left, cross, right) if left &gt;= right &amp;&amp; left &gt;= cross { // O(1) return left } else if right &gt;= left &amp;&amp; right &gt;= cross { return right } return cross } // T(n) = O(1) + 2T(n/2) + O(n) + O(1) = 2T(n/2) + O(n) =&gt; O(nlgn), n &gt; 1 // T(n) = O(1), n == 1 return findMaxSubArray(nums, 0, len(nums)) } // brute-force O(n^2) // func maxSubArray(nums []int) int { // max := nums[0] // for i := 0; i &lt; len(nums); i++ { // sum := 0 // for j := i; j &lt; len(nums); j++ { // sum += nums[j] // if max &lt; sum { // max = sum // } // } // } // return max // } 4. References Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest: Introduction to Algorithms, The MIT Press; 4th edition (April 5, 2022) CHAPTER 3 Algorithms, Integers, https://sites.math.northwestern.edu/~mlerma/courses/cs310-05s/notes/dm-algor" />
<link rel="canonical" href="https://blog.codefarm.me/2022/08/24/the-master-method-for-solving-recurrences/" />
<meta property="og:url" content="https://blog.codefarm.me/2022/08/24/the-master-method-for-solving-recurrences/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-24T19:32:33+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The master method for solving recurrences" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-24T19:32:33+08:00","datePublished":"2022-08-24T19:32:33+08:00","description":"1. Mathematical Induction 2. Recursiveness 3. Divide and Conquer 3.1. Analyzing divide-and-conquer algorithms 3.2. Proof of the master theorem 3.3. The maximum-subarray problem 4. References 1. Mathematical Induction Principle of Mathematical Induction: Let P be a property of positive integers such that: Basis step: P(1) is true, and Inductive step: if P(k) is true for all 1 ≤ k ≤ n then P(n + 1) is true. Then P(n) is true for all positive integers. The premise P(n) in the inductive step is called Induction Hypothesis. The validity of the Principle of Mathematical Induction is obvious. The basis step states that P(1) is true. Then the inductive step implies that P(2) is also true. By the inductive step again we see that P(3) is true, and so on. Consequently the property is true for all positive integers. In the basis step we may replace 1 with some other integer m. Then the conclusion is that the property is true for every integer n greater than or equal to m. Example: Prove that the sum of the n first odd positive integers is n2, i.e., 1 + 3 + 5 + · · · + (2n − 1) = n2 Proof: n=1, S(1) = 12 = 1 (1); n=k, S(k) = (k)2 &#8658; n=2k+1, S(k+1) = S(k) + 2k + 1 = k2 + 2k + 1 = (k+1)2 (2); 2. Recursiveness A definition such that the object defined occurs in the definition is called a recursive definition. For instance, consider the Fibonacci sequence 0, 1, 1, 2, 3, 5, 8, 13, . . . It can be defined as a sequence whose two first terms are F0 = 0, F1 = 1 and each subsequent term is the sum of the two previous ones: Fn = Fn−1 + Fn−2 (for n ≥ 2). Other examples: Factorial: 0! = 1 n! = n · (n − 1)! (n ≥ 1) Power: a0 = 1 an = an−1 a (n ≥ 1) In all these examples we have: A basis, where the function is explicitly evaluated for one or more values of its argument. A recursive step, stating how to compute the function from its previous values. 3. Divide and Conquer Many useful algorithms are recursive in structure: to solve a given problem, they call themselves recursively one or more times to deal with closely related subproblems. These algorithms typically follow a divide-and-conquer approach: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem. The divide-and-conquer paradigm involves three steps at each level of the recursion: Divide the problem into a number of subproblems that are smaller instances of the same problem. Conquer the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner. Combine the solutions to the subproblems into the solution for the original problem. MERGE-SORT(A, p, r) 1 if p &lt; r 2 q = ⌊(p + r) / 2 ⌋ 3 MERGE-SORT(A, p, q) 4 MERGE-SORT(A, q, r) 5 MERGE(A, p, q, r) MERGE(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 let L[1..n1 + 1] and R[1..n2] be new arrays 4 for i = 1 to n1 5 L[i] = A[p + i - 1] 6 for j = 1 to n2 7 R[j] = A[q + j] 8 L[n1 + 1] = ∞ 9 R[n2 + 1] = ∞ 10 i = 1 11 j = 1 12 for k = p to r 13 if L[i] ≤ R[j] 14 A[k] = L[i] 15 i = i + 1 16 else A[k] = R[j] 17 j = j + 1 3.1. Analyzing divide-and-conquer algorithms When an algorithm contains a recursive call to itself, we can often describe its running time by a recurrence equation or recurrence, which describes the overall running time on a problem of size n in terms of the running time on smaller inputs. We can then use mathematical tools to solve the recurrence and provide bounds on the performance of the algorithm. A recurrence for the running time of a divide-and-conquer algorithm falls out from the three steps of the basic paradigm. We let T(n) be the running time on a problem of size n. If the problem size is small enough, say n ≤ c for some constant c, the straightforward solution takes constant time, which we write as Θ(1). Suppose that our division of the problem yields a subproblems, each of which is 1/b the size of the original. For merge sort, both a and b are 2, but we shall see many divide-and-conquer algorithms in which a ≠ b. It takes time T(n/b) to solve one subproblem of size n/b, and so it takes time a.T(n/b) to solve a of them. If we take D(n) time to divide the problem into subproblems and _C(n) time to combine the solutions to the subproblems into the solution to the original problem, we get the recurrence T(n) = &nbsp;&nbsp;&nbsp;&nbsp;O(1) if n ≤ c, &nbsp;&nbsp;&nbsp;&nbsp;a.T(n/b) + D(n) + C(n) otherwise. 3.2. Proof of the master theorem The master method provides a “cookbook” method for solving recurrences of the form T(n) = a.T(n/b) + f(n) where a ≥ 1 and b &gt; 1 are constants and f(n) is an asymptotically positive function. For merge sort, we see the T(n) that roughly: T(n) = 2T(n/2) + n Replacing n with n/2 we have T(n/2) = 2T(n/4) + n/2, hence: T(n) = 2T(n/2) + n = 2(2T(n/4) + n/2) + n = 4T(n/4) + 2n Repeating k times we get: T(n) = 2kT(n/2k) + k.n So for k = log2n we have: T(n) = nT(1) + nlog2n = Θ(n.lgn) 3.3. The maximum-subarray problem // 53. Maximum Subarray // Medium // // Given an integer array nums, find the contiguous subarray (containing at least one number) which // has the largest sum and return its sum. // // A subarray is a contiguous part of an array. // // Example 1: // // Input: nums = [-2,1,-3,4,-1,2,1,-5,4] // Output: 6 // Explanation: [4,-1,2,1] has the largest sum = 6. // // Example 2: // // Input: nums = [1] // Output: 1 // // Example 3: // // Input: nums = [5,4,-1,7,8] // Output: 23 // // // // Constraints: // // 1 &lt;= nums.length &lt;= 10^5 // -10^4 &lt;= nums[i] &lt;= 10^4 // // // // Follow up: If you have figured out the O(n) solution, try coding another solution // using the divide and conquer approach, which is more subtle. package maxSubArray import ( &quot;math&quot; ) // divide-and-conquer // nums[low, mid, high] // nums[low,...,mid], nums[low,...,mid,...,high], nums[mid,...,high] func maxSubArray(nums []int) int { var findMaxCrossSubArray func(nums []int, low, mid, high int) int findMaxCrossSubArray = func(nums []int, low, mid, high int) int { leftMax := math.MinInt sum := 0 for i := mid - 1; i &gt;= low; i-- { sum += nums[i] if leftMax &lt; sum { leftMax = sum } } sum = 0 rightMax := math.MinInt for i := mid; i &lt; high; i++ { sum += nums[i] if rightMax &lt; sum { rightMax = sum } } return leftMax + rightMax } var findMaxSubArray func(nums []int, low, high int) int findMaxSubArray = func(nums []int, low, high int) int { if high-low &lt;= 1 { // bottom-out, base-case, only one number, O(1) return nums[low] } mid := (low + high) / 2 left := findMaxSubArray(nums, low, mid) // T(n/2) cross := findMaxCrossSubArray(nums, low, mid, high) // O(n), n = high - low right := findMaxSubArray(nums, mid, high) // T(n/2) // fmt.Println(left, cross, right) if left &gt;= right &amp;&amp; left &gt;= cross { // O(1) return left } else if right &gt;= left &amp;&amp; right &gt;= cross { return right } return cross } // T(n) = O(1) + 2T(n/2) + O(n) + O(1) = 2T(n/2) + O(n) =&gt; O(nlgn), n &gt; 1 // T(n) = O(1), n == 1 return findMaxSubArray(nums, 0, len(nums)) } // brute-force O(n^2) // func maxSubArray(nums []int) int { // max := nums[0] // for i := 0; i &lt; len(nums); i++ { // sum := 0 // for j := i; j &lt; len(nums); j++ { // sum += nums[j] // if max &lt; sum { // max = sum // } // } // } // return max // } 4. References Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest: Introduction to Algorithms, The MIT Press; 4th edition (April 5, 2022) CHAPTER 3 Algorithms, Integers, https://sites.math.northwestern.edu/~mlerma/courses/cs310-05s/notes/dm-algor","headline":"The master method for solving recurrences","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2022/08/24/the-master-method-for-solving-recurrences/"},"url":"https://blog.codefarm.me/2022/08/24/the-master-method-for-solving-recurrences/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">The master method for solving recurrences</h1><p class="c-post-meta">24 Aug 2022</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#mathematical-induction">1. Mathematical Induction</a></li>
<li><a href="#recursiveness">2. Recursiveness</a></li>
<li><a href="#divide-and-conquer">3. Divide and Conquer</a>
<ul class="sectlevel2">
<li><a href="#analyzing-divide-and-conquer-algorithms">3.1. Analyzing divide-and-conquer algorithms</a></li>
<li><a href="#proof-of-the-master-theorem">3.2. Proof of the master theorem</a></li>
<li><a href="#the-maximum-subarray-problem">3.3. The maximum-subarray problem</a></li>
</ul>
</li>
<li><a href="#references">4. References</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="mathematical-induction">1. Mathematical Induction</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Principle of Mathematical Induction</strong>:</p>
</div>
<div class="paragraph">
<p>Let <em>P</em> be a property of positive integers such that:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Basis</em> step: <em>P(1)</em> is true, and</p>
</li>
<li>
<p><em>Inductive</em> step: if <em>P(k)</em> is true for all <em>1 ≤ k ≤ n</em> then <em>P(n + 1)</em> is true.</p>
</li>
</ol>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Then <em>P(n)</em> is true for all positive integers.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The premise <em>P(n)</em> in the inductive step is called <strong>Induction Hypothesis</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The validity of the Principle of Mathematical Induction is obvious. The basis step states that <em>P(1)</em> is true. Then the inductive step implies that <em>P(2)</em> is also true. By the inductive step again we see that <em>P(3)</em> is true, and so on. Consequently the property is true for all positive integers.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In the basis step we may replace <em>1</em> with some other integer <em>m</em>. Then the conclusion is that the property is true for every integer <em>n</em> greater than or equal to <em>m</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Example: Prove that the sum of the <em>n</em> first odd positive integers is <em>n<sup>2</sup></em>, i.e., <em>1 + 3 + 5 + · · · + (2n − 1) = n<sup>2</sup></em></p>
</div>
<div class="paragraph">
<p>Proof: <em>n=1, S(1) = 1<sup>2</sup> = 1</em> (1); <em>n=k, S(k) = (k)<sup>2</sup> &#8658; n=2k+1, S(k+1) = S(k) + 2k + 1 = k<sup>2</sup> + 2k + 1 = (k+1)<sup>2</sup></em> (2);</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="recursiveness">2. Recursiveness</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A definition such that the object defined occurs in the definition is called a <strong>recursive definition</strong>.</p>
</div>
<div class="paragraph">
<p>For instance, consider the <em>Fibonacci sequence</em></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>0, 1, 1, 2, 3, 5, 8, 13, . . .</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>It can be defined as a sequence whose two first terms are <em>F0 = 0</em>, <em>F1 = 1</em> and each subsequent term is the sum of the two previous ones:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>Fn = Fn−1 + Fn−2 (for n ≥ 2).</em></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Other examples:</p>
</div>
<div class="paragraph">
<p><em>Factorial</em>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>0! = 1</em></p>
</li>
<li>
<p><em>n! = n · (n − 1)! (n ≥ 1)</em></p>
</li>
</ol>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><em>Power</em>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>a<sup>0</sup> = 1</em></p>
</li>
<li>
<p><em>a<sup>n</sup> = an−1 a (n ≥ 1)</em></p>
</li>
</ol>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In all these examples we have:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <strong>basis</strong>, where the function is explicitly evaluated for one or more values of its argument.</p>
</li>
<li>
<p>A <strong>recursive step</strong>, stating how to compute the function from its previous values.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="divide-and-conquer">3. Divide and Conquer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many useful algorithms are <strong>recursive</strong> in structure: to solve a given problem, they call themselves recursively one or more times to deal with closely related subproblems.</p>
</div>
<div class="paragraph">
<p>These algorithms typically follow a <strong>divide-and-conquer</strong> approach: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem.</p>
</div>
<div class="paragraph">
<p>The divide-and-conquer paradigm involves three steps at each level of the recursion:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Divide</strong> the problem into a number of subproblems that are smaller instances of the same problem.</p>
</li>
<li>
<p><strong>Conquer</strong> the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner.</p>
</li>
<li>
<p><strong>Combine</strong> the solutions to the subproblems into the solution for the original problem.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">MERGE-SORT(A, p, r)
1  if p &lt; r
2    q = ⌊(p + r) / 2 ⌋
3    MERGE-SORT(A, p, q)
4    MERGE-SORT(A, q, r)
5    MERGE(A, p, q, r)

MERGE(A, p, q, r)
1  n1 = q - p + 1
2  n2 = r - q
3  let L[1..n1 + 1] and R[1..n2] be new arrays
4  for i = 1 to n1
5      L[i] = A[p + i - 1]
6  for j = 1 to n2
7      R[j] = A[q + j]
8  L[n1 + 1] =  ∞
9  R[n2 + 1] =  ∞
10 i = 1
11 j = 1
12 for k = p to r
13     if L[i] ≤ R[j]
14         A[k] = L[i]
15         i = i + 1
16     else A[k] = R[j]
17         j = j + 1</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="analyzing-divide-and-conquer-algorithms">3.1. Analyzing divide-and-conquer algorithms</h3>
<div class="paragraph">
<p>When an algorithm contains a recursive call to itself, we can often describe its running time by a <strong>recurrence equation</strong> or <strong>recurrence</strong>, which describes the overall running time on a problem of size <em>n</em> in terms of the running time on smaller inputs. We can then use mathematical tools to solve the recurrence and provide bounds on the performance of the algorithm.</p>
</div>
<div class="paragraph">
<p>A recurrence for the running time of a divide-and-conquer algorithm falls out from the three steps of the basic paradigm.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We let <em>T(n)</em> be the running time on a problem of size <em>n</em>. If the problem size is small enough, say <em>n ≤ c</em> for some constant <em>c</em>, the straightforward solution takes constant time, which we write as Θ(1).</p>
</li>
<li>
<p>Suppose that our division of the problem yields <em>a</em> subproblems, each of which is <em>1/b</em> the size of the original.</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>For <em>merge sort</em>, both <em>a</em> and <em>b</em> are <em>2</em>, but we shall see many divide-and-conquer algorithms in which <em>a ≠ b</em>.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>It takes time <em>T(n/b)</em> to solve one subproblem of size <em>n/b</em>, and so it takes time <em>a.T(n/b)</em> to solve a of them.</p>
</div>
</li>
<li>
<p>If we take <em>D(n) time to divide the problem into subproblems and _C(n)</em> time to combine the solutions to the subproblems into the solution to the original problem, we get the recurrence</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>T(n)</em> =</p>
</div>
<div class="paragraph">
<p>&nbsp;&nbsp;&nbsp;&nbsp;<em>O(1) if n ≤ c</em>,</p>
</div>
<div class="paragraph">
<p>&nbsp;&nbsp;&nbsp;&nbsp;<em>a.T(n/b) + D(n) + C(n) otherwise</em>.</p>
</div>
</blockquote>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="proof-of-the-master-theorem">3.2. Proof of the master theorem</h3>
<div class="paragraph">
<p>The master method provides a “cookbook” method for solving recurrences of the form</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>T(n) = a.T(n/b) + f(n)</em></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>where <em>a ≥ 1</em> and <em>b &gt; 1</em> are constants and <em>f(n)</em> is an asymptotically positive function.</p>
</div>
<div class="paragraph">
<p>For <em>merge sort</em>, we see the <em>T(n)</em> that roughly:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>T(n) = 2T(n/2) + n</em></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Replacing <em>n</em> with <em>n/2</em> we have <em>T(n/2) = 2T(n/4) + n/2</em>, hence:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>T(n) = 2T(n/2) + n = 2(2T(n/4) + n/2) + n = 4T(n/4) + 2n</em></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Repeating <em>k</em> times we get:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>T(n) = 2<sup>k</sup>T(n/2<sup>k</sup>) + k.n</em></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>So for <em>k = log<sub>2</sub>n</em> we have:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>T(n) = nT(1) + nlog<sub>2</sub>n = Θ(n.lgn)</em></p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="the-maximum-subarray-problem">3.3. The maximum-subarray problem</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// 53. Maximum Subarray</span>
<span class="c">// Medium</span>
<span class="c">//</span>
<span class="c">// Given an integer array nums, find the contiguous subarray (containing at least one number) which</span>
<span class="c">//   has the largest sum and return its sum.</span>
<span class="c">//</span>
<span class="c">// A subarray is a contiguous part of an array.</span>
<span class="c">//</span>
<span class="c">// Example 1:</span>
<span class="c">//</span>
<span class="c">// Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span>
<span class="c">// Output: 6</span>
<span class="c">// Explanation: [4,-1,2,1] has the largest sum = 6.</span>
<span class="c">//</span>
<span class="c">// Example 2:</span>
<span class="c">//</span>
<span class="c">// Input: nums = [1]</span>
<span class="c">// Output: 1</span>
<span class="c">//</span>
<span class="c">// Example 3:</span>
<span class="c">//</span>
<span class="c">// Input: nums = [5,4,-1,7,8]</span>
<span class="c">// Output: 23</span>
<span class="c">//</span>
<span class="c">//</span>
<span class="c">//</span>
<span class="c">// Constraints:</span>
<span class="c">//</span>
<span class="c">//     1 &lt;= nums.length &lt;= 10^5</span>
<span class="c">//     -10^4 &lt;= nums[i] &lt;= 10^4</span>
<span class="c">//</span>
<span class="c">//</span>
<span class="c">//</span>
<span class="c">// Follow up: If you have figured out the O(n) solution, try coding another solution</span>
<span class="c">//    using the divide and conquer approach, which is more subtle.</span>

<span class="k">package</span> <span class="n">maxSubArray</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"math"</span>
<span class="p">)</span>

<span class="c">// divide-and-conquer</span>
<span class="c">// nums[low, mid, high]</span>
<span class="c">// nums[low,...,mid], nums[low,...,mid,...,high], nums[mid,...,high]</span>
<span class="k">func</span> <span class="n">maxSubArray</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">findMaxCrossSubArray</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">findMaxCrossSubArray</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="n">leftMax</span> <span class="o">:=</span> <span class="n">math</span><span class="o">.</span><span class="n">MinInt</span>
		<span class="n">sum</span> <span class="o">:=</span> <span class="m">0</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">mid</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">low</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
			<span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">leftMax</span> <span class="o">&lt;</span> <span class="n">sum</span> <span class="p">{</span>
				<span class="n">leftMax</span> <span class="o">=</span> <span class="n">sum</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">sum</span> <span class="o">=</span> <span class="m">0</span>
		<span class="n">rightMax</span> <span class="o">:=</span> <span class="n">math</span><span class="o">.</span><span class="n">MinInt</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">rightMax</span> <span class="o">&lt;</span> <span class="n">sum</span> <span class="p">{</span>
				<span class="n">rightMax</span> <span class="o">=</span> <span class="n">sum</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">leftMax</span> <span class="o">+</span> <span class="n">rightMax</span>
	<span class="p">}</span>

	<span class="k">var</span> <span class="n">findMaxSubArray</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">findMaxSubArray</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">high</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span> <span class="c">// bottom-out, base-case, only one number, O(1)</span>
			<span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">low</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="n">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>

		<span class="n">left</span> <span class="o">:=</span> <span class="n">findMaxSubArray</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>             <span class="c">// T(n/2)</span>
		<span class="n">cross</span> <span class="o">:=</span> <span class="n">findMaxCrossSubArray</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span> <span class="c">// O(n), n = high - low</span>
		<span class="n">right</span> <span class="o">:=</span> <span class="n">findMaxSubArray</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>           <span class="c">// T(n/2)</span>
		<span class="c">// fmt.Println(left, cross, right)</span>
		<span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">cross</span> <span class="p">{</span> <span class="c">// O(1)</span>
			<span class="k">return</span> <span class="n">left</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">right</span> <span class="o">&gt;=</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&gt;=</span> <span class="n">cross</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">right</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">cross</span>
	<span class="p">}</span>

	<span class="c">// T(n) = O(1) + 2T(n/2) + O(n) + O(1) = 2T(n/2) + O(n) =&gt; O(nlgn), n &gt; 1</span>
	<span class="c">// T(n) = O(1), n == 1</span>
	<span class="k">return</span> <span class="n">findMaxSubArray</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
<span class="p">}</span>

<span class="c">// brute-force O(n^2)</span>
<span class="c">// func maxSubArray(nums []int) int {</span>
<span class="c">// 	max := nums[0]</span>
<span class="c">// 	for i := 0; i &lt; len(nums); i++ {</span>
<span class="c">// 		sum := 0</span>
<span class="c">// 		for j := i; j &lt; len(nums); j++ {</span>
<span class="c">// 			sum += nums[j]</span>
<span class="c">// 			if max &lt; sum {</span>
<span class="c">// 				max = sum</span>
<span class="c">// 			}</span>
<span class="c">// 		}</span>
<span class="c">// 	}</span>
<span class="c">// 	return max</span>
<span class="c">// }</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">4. References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest: Introduction to Algorithms, The MIT Press; 4th edition (April 5, 2022)</p>
</li>
<li>
<p>CHAPTER 3 Algorithms, Integers, <a href="https://sites.math.northwestern.edu/~mlerma/courses/cs310-05s/notes/dm-algor" class="bare">https://sites.math.northwestern.edu/~mlerma/courses/cs310-05s/notes/dm-algor</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
