<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>What is OAuth2 | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="What is OAuth2" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. What is OAuth2 1.1. Roles 1.2. Protocol Flow 1.3. Client Types 1.4. Authorization Grant 1.4.1. Authorization Code Grant 1.4.2. Implicit Grant 1.4.3. Resource Owner Password Credentials Grant 1.4.4. Client Credentials Grant 1.5. Access Token 1.6. Refresh Token 1.7. OpenID Connect 2. What is JSON Web Token? 2.1. JSON Web Token (JWT) Overview 2.2. What is the JSON Web Token structure? 2.2.1. Header 2.2.2. Payload 2.2.3. Signature 2.2.4. Putting all together 3. Microsoft identity platform 3.1. Authentication vs. authorization [msadauthnz] 3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform 3.2.1. Roles in OAuth 2.0 3.2.2. Tokens 3.2.3. App registration 3.2.4. Endpoints 3.3. OpenID Connect on the Microsoft identity platform 3.4. Authentication flows and application scenarios 3.4.1. Application categories 3.4.1.1. Protected resources vs. client applications 3.4.1.2. With users or without users 3.4.1.3. Single-page, public client, and confidential client applications 4. Keycloak References 1. What is OAuth2 In the traditional client-server authentication model, the client requests an access-restricted or protected resource on the server by authenticating with the server using the resource owner&#8217;s credentials. [RFC6749] In order to provide third-party applications access to restricted resources, the resource owner shares its credentials with the third party. This creates several problems and limitations: Third-party applications are required to store the resource owner&#8217;s credentials for future use, typically a password in clear-text. Servers are required to support password authentication, despite the security weaknesses inherent in passwords. Third-party applications gain overly broad access to the resource owner&#8217;s protected resources, leaving resource owners without any ability to restrict duration or access to a limited subset of resources. Resource owners cannot revoke access to an individual third party without revoking access to all third parties, and must do so by changing the third party&#8217;s password. Compromise of any third-party application results in compromise of the end-user&#8217;s password and all of the data protected by that password. OAuth addresses these issues by introducing an authorization layer and separating the role of the client from that of the resource owner. In OAuth, the client requests access to resources controlled by the resource owner and hosted by the resource server, and is issued a different set of credentials than those of the resource owner. Instead of using the resource owner&#8217;s credentials to access protected resources, the client obtains an access token&#8201;&#8212;&#8201;a string denoting a specific scope, lifetime, and other access attributes. Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner. The client uses the access token to access the protected resources hosted by the resource server. For example, an end-user (resource owner) can grant a printing service (client) access to her protected photos stored at a photo-sharing service (resource server), without sharing her username and password with the printing service. Instead, she authenticates directly with a server trusted by the photo-sharing service (authorization server), which issues the printing service delegation-specific credentials (access token). The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. The steps to grant permission, or consent, are often referred to as authorization or even delegated authorization. You authorize one application to access your data, or use features in another application on your behalf, without giving them your password. OAuth is about how to get a token and how to use a token. OAuth is a delegation framework that provides authorization across systems. OAuth replaces the password-sharing anti-pattern with a delegation protocol that&#8217;s simultaneously more secure and more usable. OAuth is focused on solving a small set of problems and solving them well, which makes it a suitable component within larger security systems. 1.1. Roles OAuth defines four roles: resource owner An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. resource server The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens. client An application making protected resource requests on behalf of the resource owner and with its authorization. The term &quot;client&quot; does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices). authorization server The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization. The authorization server may be the same server as the resource server or a separate entity. A single authorization server may issue access tokens accepted by multiple resource servers. 1.2. Protocol Flow +--------+ +---------------+ | |--(A)- Authorization Request -&gt;| Resource | | | | Owner | | |&lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --&gt;| Authorization | | Client | | Server | | |&lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------&gt;| Resource | | | | Server | | |&lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ The abstract OAuth 2.0 flow describes the interaction between the four roles and includes the following steps: The client requests authorization from the resource owner. The authorization request can be made directly to the resource owner (as shown), or preferably indirectly via the authorization server as an intermediary. The client receives an authorization grant, which is a credential representing the resource owner&#8217;s authorization, expressed using one of four grant types defined in this specification (authorization code, implicit, password, client credential) or using an extension grant type. The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server. The client requests an access token by authenticating with the authorization server and presenting the authorization grant. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token. The client requests the protected resource from the resource server and authenticates by presenting the access token. The resource server validates the access token, and if valid, serves the request. 1.3. Client Types OAuth defines two client types, based on their ability to authenticate securely with the authorization server (i.e., ability to maintain the confidentiality of their client credentials): confidential Clients capable of maintaining the confidentiality of their credentials (e.g., client implemented on a secure server with restricted access to the client credentials), or capable of secure client authentication using other means. public Clients incapable of maintaining the confidentiality of their credentials (e.g., clients executing on the device used by the resource owner, such as an installed native application or a web browser-based application), and incapable of secure client authentication via any other means. This specification has been designed around the following client profiles: web application A web application is a confidential client running on a web server. Resource owners access the client via an HTML user interface rendered in a user-agent on the device used by the resource owner. The client credentials as well as any access token issued to the client are stored on the web server and are not exposed to or accessible by the resource owner. user-agent-based application A user-agent-based application is a public client in which the client code is downloaded from a web server and executes within a user-agent (e.g., web browser) on the device used by the resource owner. Protocol data and credentials are easily accessible (and often visible) to the resource owner. Since such applications reside within the user-agent, they can make seamless use of the user-agent capabilities when requesting authorization. native application A native application is a public client installed and executed on the device used by the resource owner. Protocol data and credentials are accessible to the resource owner. It is assumed that any client authentication credentials included in the application can be extracted. On the other hand, dynamically issued credentials such as access tokens or refresh tokens can receive an acceptable level of protection. At a minimum, these credentials are protected from hostile servers with which the application may interact. On some platforms, these credentials might be protected from other applications residing on the same device. 1.4. Authorization Grant An authorization grant is a credential representing the resource owner&#8217;s authorization (to access its protected resources) used by the client to obtain an access token. This specification defines four grant types&#8201;&#8212;&#8201;authorization code, implicit, resource owner password credentials, and client credentials&#8201;&#8212;&#8201;as well as an extensibility mechanism for defining additional types. [RFC6749] 1.4.1. Authorization Code Grant The authorization code grant type is used to obtain both access tokens and refresh tokens and is optimized for confidential clients. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ----&gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&gt;| Server | | | | | | -+----(C)-- Authorization Code ---&lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&gt;---(D)-- Authorization Code ---------&#39; | | Client | &amp; Redirection URI | | | | | |&lt;---(E)----- Access Token -------------------&#39; +---------+ (w/ Optional Refresh Token) The flow includes the following steps: The client initiates the flow by directing the resource owner&#8217;s user-agent to the authorization endpoint. The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied). The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client&#8217;s access request. Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier (in the request or during client registration). The redirection URI includes an authorization code and any local state provided by the client earlier. The client requests an access token from the authorization server&#8217;s token endpoint by including the authorization code received in the previous step. When making the request, the client authenticates with the authorization server. The client includes the redirection URI used to obtain the authorization code for verification. The authorization server authenticates the client, validates the authorization code, and ensures that the redirection URI received matches the URI used to redirect the client in step (C). If valid, the authorization server responds back with an access token and, optionally, a refresh token. 1.4.2. Implicit Grant The implicit grant type is used to obtain access tokens (it does not support the issuance of refresh tokens) and is optimized for public clients known to operate a particular redirection URI. These clients are typically implemented in a browser using a scripting language such as JavaScript. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server. Unlike the authorization code grant type, in which the client makes separate requests for authorization and for an access token, the client receives the access token as the result of the authorization request. The implicit grant type does not include client authentication, and relies on the presence of the resource owner and the registration of the redirection URI. Because the access token is encoded into the redirection URI, it may be exposed to the resource owner and other applications residing on the same device. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ---&gt;| | | User- | | Authorization | | Agent -|----(B)-- User authenticates --&gt;| Server | | | | | | |&lt;---(C)--- Redirection URI ----&lt;| | | | with Access Token +---------------+ | | in Fragment | | +---------------+ | |----(D)--- Redirection URI ----&gt;| Web-Hosted | | | without Fragment | Client | | | | Resource | | (F) |&lt;---(E)------- Script ---------&lt;| | | | +---------------+ +-|--------+ | | (A) (G) Access Token | | ^ v +---------+ | | | Client | | | +---------+ The flow includes the following steps: The client initiates the flow by directing the resource owner&#8217;s user-agent to the authorization endpoint. The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied). The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client&#8217;s access request. Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier. The redirection URI includes the access token in the URI fragment. The user-agent follows the redirection instructions by making a request to the web-hosted client resource (which does not include the fragment per [RFC2616]). The user-agent retains the fragment information locally. The web-hosted client resource returns a web page (typically an HTML document with an embedded script) capable of accessing the full redirection URI including the fragment retained by the user-agent, and extracting the access token (and other parameters) contained in the fragment. The user-agent executes the script provided by the web-hosted client resource locally, which extracts the access token. The user-agent passes the access token to the client. 1.4.3. Resource Owner Password Credentials Grant The resource owner password credentials grant type is suitable in cases where the resource owner has a trust relationship with the client, such as the device operating system or a highly privileged application. The authorization server should take special care when enabling this grant type and only allow it when other flows are not viable. This grant type is suitable for clients capable of obtaining the resource owner&#8217;s credentials (username and password, typically using an interactive form). It is also used to migrate existing clients using direct authentication schemes such as HTTP Basic or Digest authentication to OAuth by converting the stored credentials to an access token. +----------+ | Resource | | Owner | | | +----------+ v | Resource Owner (A) Password Credentials | v +---------+ +---------------+ | |&gt;--(B)---- Resource Owner -------&gt;| | | | Password Credentials | Authorization | | Client | | Server | | |&lt;--(C)---- Access Token ---------&lt;| | | | (w/ Optional Refresh Token) | | +---------+ +---------------+ The flow includes the following steps: The resource owner provides the client with its username and password. The client requests an access token from the authorization server&#8217;s token endpoint by including the credentials received from the resource owner. When making the request, the client authenticates with the authorization server. The authorization server authenticates the client and validates the resource owner credentials, and if valid, issues an access token. 1.4.4. Client Credentials Grant The client can request an access token using only its client credentials (or other supported means of authentication) when the client is requesting access to the protected resources under its control, or those of another resource owner that have been previously arranged with the authorization server (the method of which is beyond the scope of this specification). The client credentials grant type MUST only be used by confidential clients. +---------+ +---------------+ | | | | | |&gt;--(A)- Client Authentication ---&gt;| Authorization | | Client | | Server | | |&lt;--(B)---- Access Token ---------&lt;| | | | | | +---------+ +---------------+ The flow includes the following steps: The client authenticates with the authorization server and requests an access token from the token endpoint. The authorization server authenticates the client, and if valid, issues an access token. 1.5. Access Token Access tokens are credentials used to access protected resources. An access token is a string representing an authorization issued to the client. The string is usually opaque to the client. Tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server. The token may denote an identifier used to retrieve the authorization information or may self-contain the authorization information in a verifiable manner (i.e., a token string consisting of some data and a signature). The access token provides an abstraction layer, replacing different authorization constructs (e.g., username and password) with a single token understood by the resource server. This abstraction enables issuing access tokens more restrictive than the authorization grant used to obtain them, as well as removing the resource server&#8217;s need to understand a wide range of authentication methods. Access tokens can have different formats, structures, and methods of utilization (e.g., cryptographic properties) based on the resource server security requirements. Access token attributes and the methods used to access protected resources are beyond the scope of this specification and are defined by companion specifications such as [RFC6750]. 1.6. Refresh Token Refresh tokens are credentials used to obtain access tokens. Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner). Issuing a refresh token is optional at the discretion of the authorization server. If the authorization server issues a refresh token, it is included when issuing an access token (i.e., step (D) in the above protocol flow). A refresh token is a string representing the authorization granted to the client by the resource owner. The string is usually opaque to the client. The token denotes an identifier used to retrieve the authorization information. Unlike access tokens, refresh tokens are intended for use only with authorization servers and are never sent to resource servers. +--------+ +---------------+ | |--(A)------- Authorization Grant ---------&gt;| | | | | | | |&lt;-(B)----------- Access Token -------------| | | | &amp; Refresh Token | | | | | | | | +----------+ | | | |--(C)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(D)- Protected Resource --| Resource | | Authorization | | Client | | Server | | Server | | |--(E)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(F)- Invalid Token Error -| | | | | | +----------+ | | | | | | | |--(G)----------- Refresh Token -----------&gt;| | | | | | | |&lt;-(H)----------- Access Token -------------| | +--------+ &amp; Optional Refresh Token +---------------+ The flow refreshing an expired access token includes the following steps: The client requests an access token by authenticating with the authorization server and presenting an authorization grant. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token and a refresh token. The client makes a protected resource request to the resource server by presenting the access token. The resource server validates the access token, and if valid, serves the request. Steps (C) and (D) repeat until the access token expires. If the client knows the access token expired, it skips to step (G); otherwise, it makes another protected resource request. Since the access token is invalid, the resource server returns an invalid token error. The client requests a new access token by authenticating with the authorization server and presenting the refresh token. The client authentication requirements are based on the client type and on the authorization server policies. The authorization server authenticates the client and validates the refresh token, and if valid, issues a new access token (and, optionally, a new refresh token). 1.7. OpenID Connect OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. [OIDC] The OpenID Connect flow looks the same as OAuth. The only differences are, in the initial request, a specific scope of openid is used, and in the final exchange the client receives both an access token and an id token. [IGOID] The primary extension that OpenID Connect makes to OAuth 2.0 to enable End-Users to be Authenticated is the ID Token data structure. [OIDCT] The ID Token is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when using a Client, and potentially other requested Claims. The ID Token is represented as a JSON Web Token (JWT) [JWTIO]. 2. What is JSON Web Token? JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS [RFC7515]) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. [RFC7519] The suggested pronunciation of JWT is the same as the English word &quot;jot&quot;. Terminology JSON Web Token (JWT) A string representing a set of claims as a JSON object that is encoded in a JWS or JWE, enabling the claims to be digitally signed or MACed and/or encrypted. JWT Claims Set A JSON object that contains the claims conveyed by the JWT. Claim A piece of information asserted about a subject. A claim is represented as a name/value pair consisting of a Claim Name and a Claim Value. Claim Name The name portion of a claim representation. A Claim Name is always a string. Claim Value The value portion of a claim representation. A Claim Value can be any JSON value. Base64url Encoding [RFC7515] Base64 encoding using the URL- and filename-safe character set defined in Section 5 of RFC 4648 [RFC4648], with all trailing &#39;=&#39; characters omitted (as permitted by Section 3.2) and without the inclusion of any line breaks, whitespace, or other additional characters. Note that the base64url encoding of the empty octet sequence is the empty string. (See Appendix C for notes on implementing base64url encoding without padding.) 2.1. JSON Web Token (JWT) Overview JWTs represent a set of claims as a JSON object (i.e. JWT Claims Set) that is encoded in a JWS and/or JWE structure. The JSON object consists of zero or more name/value pairs (or members), where the names are strings and the values are arbitrary JSON values. These members are the claims represented by the JWT. The member names within the JWT Claims Set are referred to as Claim Names. The corresponding values are referred to as Claim Values. The contents of the JOSE Header describe the cryptographic operations applied to the JWT Claims Set. If the JOSE Header is for a JWS, the JWT is represented as a JWS and the claims are digitally signed or MACed, with the JWT Claims Set being the JWS Payload. If the JOSE Header is for a JWE, the JWT is represented as a JWE and the claims are encrypted, with the JWT Claims Set being the plaintext encrypted by the JWE. A JWT may be enclosed in another JWE or JWS structure to create a Nested JWT, enabling nested signing and encryption to be performed. A JWT is represented as a sequence of URL-safe parts separated by period (.) characters. Each part contains a base64url-encoded value. The number of parts in the JWT is dependent upon the representation of the resulting JWS using the JWS Compact Serialization or JWE using the JWE Compact Serialization. 2.2. What is the JSON Web Token structure? In its compact form, JSON Web Tokens consist of three parts separated by dots (.), which are: [JWTIO] Header Payload Signature Therefore, a JWT typically looks like the following. xxxxx.yyyyy.zzzzz Let&#8217;s break down the different parts. 2.2.1. Header The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA. For example: { &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; } Then, this JSON is Base64Url encoded to form the first part of the JWT. $ cat header.json | jq -cj | base64 -w0 | tr -d &#39;=&#39; eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 2.2.2. Payload The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims. Registered claims These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others. Notice that the claim names are only three characters long as JWT is meant to be compact. Public claims These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace. Private claims These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims. An example payload could be: { &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true } The payload is then Base64Url encoded to form the second part of the JSON Web Token. $ cat payload.json | jq -cj | base64 -w0 | tr -d &#39;=&#39; eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 Do note that for signed tokens this information, though protected against tampering, is readable by anyone. Do not put secret information in the payload or header elements of a JWT unless it is encrypted. 2.2.3. Signature To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that. For example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way: HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) The signature is used to verify the message wasn&#8217;t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is. 2.2.4. Putting all together The output is three Base64-URL strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML. The following shows a JWT that has the previous header and payload encoded, and it is signed with a secret (123456). eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.Wwu4TUUE86MPyFGhmv3D0Ct4GqkthRQDPKBwOQAAwJc 3. Microsoft identity platform The Microsoft identity platform helps you build applications your users and customers can sign in to using their Microsoft identities or social accounts. It authorizes access to your own APIs or Microsoft APIs like Microsoft Graph. There are several components that make up the Microsoft identity platform: OAuth 2.0 and OpenID Connect standard-compliant authentication service enabling developers to authenticate several identity types, including: Work or school accounts, provisioned through Azure AD Personal Microsoft accounts (Skype, Xbox, Outlook.com) Social or local accounts, by using Azure AD B2C Open-source libraries: Microsoft Authentication Library (MSAL) and support for other standards-compliant libraries. Application management portal: A registration and configuration experience in the Azure portal, along with the other Azure management capabilities. Application configuration API and PowerShell: Programmatic configuration of your applications through the Microsoft Graph API and PowerShell so you can automate your DevOps tasks. Developer content: Technical documentation including quickstarts, tutorials, how-to guides, and code samples. 3.1. Authentication vs. authorization [msadauthnz] Authentication is the process of proving that you are who you say you are. This is achieved by verification of the identity of a person or device. It&#8217;s sometimes shortened to AuthN. The Microsoft identity platform uses the OpenID Connect protocol for handling authentication. Authorization is the act of granting an authenticated party permission to do something. It specifies what data you&#8217;re allowed to access and what you can do with that data. Authorization is sometimes shortened to AuthZ. The Microsoft identity platform uses the OAuth 2.0 protocol for handling authorization. Multifactor authentication is the act of providing an additional factor of authentication to an account. This is often used to protect against brute force attacks. It is sometimes shortened to MFA or 2FA. The Microsoft Authenticator can be used as an app for handling two-factor authentication. For more information, see multifactor authentication. 3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform 3.2.1. Roles in OAuth 2.0 Four parties are generally involved in an OAuth 2.0 and OpenID Connect authentication and authorization exchange. These exchanges are often called authentication flows or auth flows. [msadouth2] Authorization server - The identity platform is the authorization server. Also called an identity provider or IdP, it securely handles the end-user&#8217;s information, their access, and the trust relationships between the parties in the auth flow. The authorization server issues the security tokens your apps and APIs use for granting, denying, or revoking access to resources (authorization) after the user has signed in (authenticated). Client - The client in an OAuth exchange is the application requesting access to a protected resource. The client could be a web app running on a server, a single-page web app running in a user&#8217;s web browser, or a web API that calls another web API. You&#8217;ll often see the client referred to as client application, application, or app. Resource owner - The resource owner in an auth flow is usually the application user, or end-user in OAuth terminology. The end-user &quot;owns&quot; the protected resource (their data) which your app accesses on their behalf. The resource owner can grant or deny your app (the client) access to the resources they own. For example, your app might call an external system&#8217;s API to get a user&#8217;s email address from their profile on that system. Their profile data is a resource the end-user owns on the external system, and the end-user can consent to or deny your app&#8217;s request to access their data. Resource server - The resource server hosts or provides access to a resource owner&#8217;s data. Most often, the resource server is a web API fronting a data store. The resource server relies on the authorization server to perform authentication and uses information in bearer tokens issued by the authorization server to grant or deny access to resources. 3.2.2. Tokens The parties in an authentication flow use bearer tokens to assure, verify, and authenticate a principal (user, host, or service) and to grant or deny access to protected resources (authorization). Bearer tokens in the identity platform are formatted as JSON Web Tokens (JWT). Three types of bearer tokens are used by the identity platform as security tokens: Access tokens - Access tokens are issued by the authorization server to the client application. The client passes access tokens to the resource server. Access tokens contain the permissions the client has been granted by the authorization server. ID tokens - ID tokens are issued by the authorization server to the client application. Clients use ID tokens when signing in users and to get basic information about them. Refresh tokens - The client uses a refresh token, or RT, to request new access and ID tokens from the authorization server. Your code should treat refresh tokens and their string content as sensitive data because they&#8217;re intended for use only by authorization server. 3.2.3. App registration Your client app needs a way to trust the security tokens issued to it by the identity platform. The first step in establishing trust is by registering your app. When you register your app, the identity platform automatically assigns it some values, while others you configure based on the application&#8217;s type. Two of the most commonly referenced app registration settings are: Application (client) ID - Also called application ID and client ID, this value is assigned to your app by the identity platform. The client ID uniquely identifies your app in the identity platform and is included in the security tokens the platform issues. Redirect URI - The authorization server uses a redirect URI to direct the resource owner&#8217;s user-agent (web browser, mobile app) to another destination after completing their interaction. For example, after the end-user authenticates with the authorization server. Not all client types use redirect URIs. Your app&#8217;s registration also holds information about the authentication and authorization endpoints you&#8217;ll use in your code to get ID and access tokens. 3.2.4. Endpoints The identity platform offers authentication and authorization services using standards-compliant implementations of OAuth 2.0 and OpenID Connect (OIDC) 1.0. Standards-compliant authorization servers like the identity platform provide a set of HTTP endpoints for use by the parties in an auth flow to execute the flow. The endpoint URIs for your app are generated automatically when you register or configure your app. The endpoints you use in your app&#8217;s code depend on the application&#8217;s type and the identities (account types) it should support. Two commonly used endpoints are the authorization endpoint and token endpoint. Here are examples of the authorize and token endpoints: # Authorization endpoint - used by client to obtain authorization from the resource owner. https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/authorize # Token endpoint - used by client to exchange an authorization grant or refresh token for an access token. https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/token # NOTE: # These are examples. Endpoint URI format may vary based on application type, # sign-in audience, and Azure cloud instance (global or national cloud). # The {issuer} value in the path of the request can be used to control who can sign into the application. # The allowed values are **common** for both Microsoft accounts and work or school accounts, # **organizations** for work or school accounts only, **consumers** for Microsoft accounts only, # and **tenant identifiers** such as the tenant ID or domain name. To find the endpoints for an application you&#8217;ve registered, in the Azure portal navigate to: Azure Active Directory &gt; App registrations &gt; &lt;YOUR-APPLICATION&gt; &gt; Endpoints. 3.3. OpenID Connect on the Microsoft identity platform OpenID Connect (OIDC) extends the OAuth 2.0 authorization protocol for use as an additional authentication protocol. You can use OIDC to enable single sign-on (SSO) between your OAuth-enabled applications by using a security token called an ID token. [msadoidc] Figure 1. The basic OpenID Connect sign-in flow The ID token introduced by OpenID Connect is issued by the authorization server, the Microsoft identity platform, when the client application requests one during user authentication. The ID token enables a client application to verify the identity of the user and to get other information (claims) about them. ID tokens aren&#8217;t issued by default for an application registered with the Microsoft identity platform. ID tokens for an application are enabled by using one of the following methods: Navigate to the Azure portal and select Azure Active Directory &gt; App registrations &gt; &lt;your application&gt; &gt; Authentication. Under Implicit grant and hybrid flows, select the ID tokens (used for implicit and hybrid flows) checkbox. Or: Select Azure Active Directory &gt; App registrations &gt; &lt;your application&gt; &gt; Manifest. Set oauth2AllowIdTokenImplicitFlow to true in the app registration&#8217;s application manifest. If ID tokens are not enabled for your app and one is requested, the Microsoft identity platform returns an unsupported_response error similar to: The provided value for the input parameter &#39;response_type&#39; isn&#8217;t allowed for this client. Expected value is &#39;code&#39;. 3.4. Authentication flows and application scenarios The Microsoft identity platform supports authentication for different kinds of modern application architectures. All of the architectures are based on the industry-standard protocols OAuth 2.0 and OpenID Connect. By using the authentication libraries for the Microsoft identity platform, applications authenticate identities and acquire tokens to access protected APIs. This article describes authentication flows and the application scenarios that they&#8217;re used in. [msadscene] 3.4.1. Application categories Tokens can be acquired from several types of applications, including: Web apps Mobile apps Desktop apps Web APIs Tokens can also be acquired by apps running on devices that don&#8217;t have a browser or are running on the Internet of Things (IoT). The following sections describe the categories of applications. 3.4.1.1. Protected resources vs. client applications Authentication scenarios involve two activities: Acquiring security tokens for a protected web API: We recommend that you use the Microsoft Authentication Library (MSAL), developed and supported by Microsoft. Protecting a web API or a web app: One challenge of protecting these resources is validating the security token. On some platforms, Microsoft offers middleware libraries. 3.4.1.2. With users or without users Most authentication scenarios acquire tokens on behalf of signed-in users. However, there are also daemon apps. In these scenarios, applications acquire tokens on behalf of themselves with no user. 3.4.1.3. Single-page, public client, and confidential client applications Security tokens can be acquired by multiple types of applications. These applications tend to be separated into the following three categories. Each is used with different libraries and objects. Single-page applications: Also known as SPAs, these are web apps in which tokens are acquired by a JavaScript or TypeScript app running in the browser. Many modern apps have a single-page application at the front end that&#8217;s primarily written in JavaScript. The application often uses a framework like Angular, React, or Vue. MSAL.js is the only Microsoft Authentication Library that supports single-page applications. Public client applications: Apps in this category, like the following types, always sign in users: Desktop apps that call web APIs on behalf of signed-in users Mobile apps Apps running on devices that don&#8217;t have a browser, like those running on IoT Confidential client applications: Apps in this category include: Web apps that call a web API Web APIs that call a web API Daemon apps, even when implemented as a console service like a Linux daemon or a Windows service 4. Keycloak Keycloak is an open-source software product that provides identity and access management (IAM) capabilities for modern applications and services. It offers a comprehensive solution for managing user authentication, authorization, and single sign-on (SSO). To start Keycloak from a terminal, enter the following command: docker run \ -d \ --name keycloak \ -p 8080:8080 \ -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \ -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \ quay.io/keycloak/keycloak:26.0.7 \ start-dev References [RFC6749] D. Hardt, Ed., The OAuth 2.0 Authorization Framework, Internet RFC 6749, Oct 2012. [RFC6750] M. Jones, D. Hardt, The OAuth 2.0 Authorization Framework: Bearer Token Usage, Internet RFC 6750, Oct 2012. [RFC7519] M. Jones, J. Bradley, N. Sakimura, JSON Web Token (JWT), Internet RFC 7519, May 2015. [OIDC] https://openid.net/connect/ [IGOID] An Illustrated Guide to OAuth and OpenID Connect [online]. https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc [RFC7515] Jones, M., Bradley, J., and N. Sakimura, JSON Web Signature (JWS), RFC 7515, DOI 10.17487/RFC, May 2015. [JWTIO] https://jwt.io/introduction [OIDCT] https://openid.net/specs/openid-connect-core-1_0.html#IDToken [msadauthnz] https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-vs-authorization [msadouth2] https://learn.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols [msadoidc] https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc [msadscene] https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-flows-app-scenarios OAuth 2 Simplified • Aaron Parecki [online]. https://aaronparecki.com/oauth-2-simplified/ OAuth.com - OAuth 2.0 Simplified [online]. https://www.oauth.com https://stackoverflow.com/questions/6916805/why-does-a-base64-encoded-string-have-an-sign-at-the-end https://superuser.com/questions/1225134/why-does-the-base64-of-a-string-contain-n" />
<meta property="og:description" content="1. What is OAuth2 1.1. Roles 1.2. Protocol Flow 1.3. Client Types 1.4. Authorization Grant 1.4.1. Authorization Code Grant 1.4.2. Implicit Grant 1.4.3. Resource Owner Password Credentials Grant 1.4.4. Client Credentials Grant 1.5. Access Token 1.6. Refresh Token 1.7. OpenID Connect 2. What is JSON Web Token? 2.1. JSON Web Token (JWT) Overview 2.2. What is the JSON Web Token structure? 2.2.1. Header 2.2.2. Payload 2.2.3. Signature 2.2.4. Putting all together 3. Microsoft identity platform 3.1. Authentication vs. authorization [msadauthnz] 3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform 3.2.1. Roles in OAuth 2.0 3.2.2. Tokens 3.2.3. App registration 3.2.4. Endpoints 3.3. OpenID Connect on the Microsoft identity platform 3.4. Authentication flows and application scenarios 3.4.1. Application categories 3.4.1.1. Protected resources vs. client applications 3.4.1.2. With users or without users 3.4.1.3. Single-page, public client, and confidential client applications 4. Keycloak References 1. What is OAuth2 In the traditional client-server authentication model, the client requests an access-restricted or protected resource on the server by authenticating with the server using the resource owner&#8217;s credentials. [RFC6749] In order to provide third-party applications access to restricted resources, the resource owner shares its credentials with the third party. This creates several problems and limitations: Third-party applications are required to store the resource owner&#8217;s credentials for future use, typically a password in clear-text. Servers are required to support password authentication, despite the security weaknesses inherent in passwords. Third-party applications gain overly broad access to the resource owner&#8217;s protected resources, leaving resource owners without any ability to restrict duration or access to a limited subset of resources. Resource owners cannot revoke access to an individual third party without revoking access to all third parties, and must do so by changing the third party&#8217;s password. Compromise of any third-party application results in compromise of the end-user&#8217;s password and all of the data protected by that password. OAuth addresses these issues by introducing an authorization layer and separating the role of the client from that of the resource owner. In OAuth, the client requests access to resources controlled by the resource owner and hosted by the resource server, and is issued a different set of credentials than those of the resource owner. Instead of using the resource owner&#8217;s credentials to access protected resources, the client obtains an access token&#8201;&#8212;&#8201;a string denoting a specific scope, lifetime, and other access attributes. Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner. The client uses the access token to access the protected resources hosted by the resource server. For example, an end-user (resource owner) can grant a printing service (client) access to her protected photos stored at a photo-sharing service (resource server), without sharing her username and password with the printing service. Instead, she authenticates directly with a server trusted by the photo-sharing service (authorization server), which issues the printing service delegation-specific credentials (access token). The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. The steps to grant permission, or consent, are often referred to as authorization or even delegated authorization. You authorize one application to access your data, or use features in another application on your behalf, without giving them your password. OAuth is about how to get a token and how to use a token. OAuth is a delegation framework that provides authorization across systems. OAuth replaces the password-sharing anti-pattern with a delegation protocol that&#8217;s simultaneously more secure and more usable. OAuth is focused on solving a small set of problems and solving them well, which makes it a suitable component within larger security systems. 1.1. Roles OAuth defines four roles: resource owner An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. resource server The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens. client An application making protected resource requests on behalf of the resource owner and with its authorization. The term &quot;client&quot; does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices). authorization server The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization. The authorization server may be the same server as the resource server or a separate entity. A single authorization server may issue access tokens accepted by multiple resource servers. 1.2. Protocol Flow +--------+ +---------------+ | |--(A)- Authorization Request -&gt;| Resource | | | | Owner | | |&lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --&gt;| Authorization | | Client | | Server | | |&lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------&gt;| Resource | | | | Server | | |&lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ The abstract OAuth 2.0 flow describes the interaction between the four roles and includes the following steps: The client requests authorization from the resource owner. The authorization request can be made directly to the resource owner (as shown), or preferably indirectly via the authorization server as an intermediary. The client receives an authorization grant, which is a credential representing the resource owner&#8217;s authorization, expressed using one of four grant types defined in this specification (authorization code, implicit, password, client credential) or using an extension grant type. The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server. The client requests an access token by authenticating with the authorization server and presenting the authorization grant. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token. The client requests the protected resource from the resource server and authenticates by presenting the access token. The resource server validates the access token, and if valid, serves the request. 1.3. Client Types OAuth defines two client types, based on their ability to authenticate securely with the authorization server (i.e., ability to maintain the confidentiality of their client credentials): confidential Clients capable of maintaining the confidentiality of their credentials (e.g., client implemented on a secure server with restricted access to the client credentials), or capable of secure client authentication using other means. public Clients incapable of maintaining the confidentiality of their credentials (e.g., clients executing on the device used by the resource owner, such as an installed native application or a web browser-based application), and incapable of secure client authentication via any other means. This specification has been designed around the following client profiles: web application A web application is a confidential client running on a web server. Resource owners access the client via an HTML user interface rendered in a user-agent on the device used by the resource owner. The client credentials as well as any access token issued to the client are stored on the web server and are not exposed to or accessible by the resource owner. user-agent-based application A user-agent-based application is a public client in which the client code is downloaded from a web server and executes within a user-agent (e.g., web browser) on the device used by the resource owner. Protocol data and credentials are easily accessible (and often visible) to the resource owner. Since such applications reside within the user-agent, they can make seamless use of the user-agent capabilities when requesting authorization. native application A native application is a public client installed and executed on the device used by the resource owner. Protocol data and credentials are accessible to the resource owner. It is assumed that any client authentication credentials included in the application can be extracted. On the other hand, dynamically issued credentials such as access tokens or refresh tokens can receive an acceptable level of protection. At a minimum, these credentials are protected from hostile servers with which the application may interact. On some platforms, these credentials might be protected from other applications residing on the same device. 1.4. Authorization Grant An authorization grant is a credential representing the resource owner&#8217;s authorization (to access its protected resources) used by the client to obtain an access token. This specification defines four grant types&#8201;&#8212;&#8201;authorization code, implicit, resource owner password credentials, and client credentials&#8201;&#8212;&#8201;as well as an extensibility mechanism for defining additional types. [RFC6749] 1.4.1. Authorization Code Grant The authorization code grant type is used to obtain both access tokens and refresh tokens and is optimized for confidential clients. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ----&gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&gt;| Server | | | | | | -+----(C)-- Authorization Code ---&lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&gt;---(D)-- Authorization Code ---------&#39; | | Client | &amp; Redirection URI | | | | | |&lt;---(E)----- Access Token -------------------&#39; +---------+ (w/ Optional Refresh Token) The flow includes the following steps: The client initiates the flow by directing the resource owner&#8217;s user-agent to the authorization endpoint. The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied). The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client&#8217;s access request. Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier (in the request or during client registration). The redirection URI includes an authorization code and any local state provided by the client earlier. The client requests an access token from the authorization server&#8217;s token endpoint by including the authorization code received in the previous step. When making the request, the client authenticates with the authorization server. The client includes the redirection URI used to obtain the authorization code for verification. The authorization server authenticates the client, validates the authorization code, and ensures that the redirection URI received matches the URI used to redirect the client in step (C). If valid, the authorization server responds back with an access token and, optionally, a refresh token. 1.4.2. Implicit Grant The implicit grant type is used to obtain access tokens (it does not support the issuance of refresh tokens) and is optimized for public clients known to operate a particular redirection URI. These clients are typically implemented in a browser using a scripting language such as JavaScript. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server. Unlike the authorization code grant type, in which the client makes separate requests for authorization and for an access token, the client receives the access token as the result of the authorization request. The implicit grant type does not include client authentication, and relies on the presence of the resource owner and the registration of the redirection URI. Because the access token is encoded into the redirection URI, it may be exposed to the resource owner and other applications residing on the same device. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ---&gt;| | | User- | | Authorization | | Agent -|----(B)-- User authenticates --&gt;| Server | | | | | | |&lt;---(C)--- Redirection URI ----&lt;| | | | with Access Token +---------------+ | | in Fragment | | +---------------+ | |----(D)--- Redirection URI ----&gt;| Web-Hosted | | | without Fragment | Client | | | | Resource | | (F) |&lt;---(E)------- Script ---------&lt;| | | | +---------------+ +-|--------+ | | (A) (G) Access Token | | ^ v +---------+ | | | Client | | | +---------+ The flow includes the following steps: The client initiates the flow by directing the resource owner&#8217;s user-agent to the authorization endpoint. The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied). The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client&#8217;s access request. Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier. The redirection URI includes the access token in the URI fragment. The user-agent follows the redirection instructions by making a request to the web-hosted client resource (which does not include the fragment per [RFC2616]). The user-agent retains the fragment information locally. The web-hosted client resource returns a web page (typically an HTML document with an embedded script) capable of accessing the full redirection URI including the fragment retained by the user-agent, and extracting the access token (and other parameters) contained in the fragment. The user-agent executes the script provided by the web-hosted client resource locally, which extracts the access token. The user-agent passes the access token to the client. 1.4.3. Resource Owner Password Credentials Grant The resource owner password credentials grant type is suitable in cases where the resource owner has a trust relationship with the client, such as the device operating system or a highly privileged application. The authorization server should take special care when enabling this grant type and only allow it when other flows are not viable. This grant type is suitable for clients capable of obtaining the resource owner&#8217;s credentials (username and password, typically using an interactive form). It is also used to migrate existing clients using direct authentication schemes such as HTTP Basic or Digest authentication to OAuth by converting the stored credentials to an access token. +----------+ | Resource | | Owner | | | +----------+ v | Resource Owner (A) Password Credentials | v +---------+ +---------------+ | |&gt;--(B)---- Resource Owner -------&gt;| | | | Password Credentials | Authorization | | Client | | Server | | |&lt;--(C)---- Access Token ---------&lt;| | | | (w/ Optional Refresh Token) | | +---------+ +---------------+ The flow includes the following steps: The resource owner provides the client with its username and password. The client requests an access token from the authorization server&#8217;s token endpoint by including the credentials received from the resource owner. When making the request, the client authenticates with the authorization server. The authorization server authenticates the client and validates the resource owner credentials, and if valid, issues an access token. 1.4.4. Client Credentials Grant The client can request an access token using only its client credentials (or other supported means of authentication) when the client is requesting access to the protected resources under its control, or those of another resource owner that have been previously arranged with the authorization server (the method of which is beyond the scope of this specification). The client credentials grant type MUST only be used by confidential clients. +---------+ +---------------+ | | | | | |&gt;--(A)- Client Authentication ---&gt;| Authorization | | Client | | Server | | |&lt;--(B)---- Access Token ---------&lt;| | | | | | +---------+ +---------------+ The flow includes the following steps: The client authenticates with the authorization server and requests an access token from the token endpoint. The authorization server authenticates the client, and if valid, issues an access token. 1.5. Access Token Access tokens are credentials used to access protected resources. An access token is a string representing an authorization issued to the client. The string is usually opaque to the client. Tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server. The token may denote an identifier used to retrieve the authorization information or may self-contain the authorization information in a verifiable manner (i.e., a token string consisting of some data and a signature). The access token provides an abstraction layer, replacing different authorization constructs (e.g., username and password) with a single token understood by the resource server. This abstraction enables issuing access tokens more restrictive than the authorization grant used to obtain them, as well as removing the resource server&#8217;s need to understand a wide range of authentication methods. Access tokens can have different formats, structures, and methods of utilization (e.g., cryptographic properties) based on the resource server security requirements. Access token attributes and the methods used to access protected resources are beyond the scope of this specification and are defined by companion specifications such as [RFC6750]. 1.6. Refresh Token Refresh tokens are credentials used to obtain access tokens. Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner). Issuing a refresh token is optional at the discretion of the authorization server. If the authorization server issues a refresh token, it is included when issuing an access token (i.e., step (D) in the above protocol flow). A refresh token is a string representing the authorization granted to the client by the resource owner. The string is usually opaque to the client. The token denotes an identifier used to retrieve the authorization information. Unlike access tokens, refresh tokens are intended for use only with authorization servers and are never sent to resource servers. +--------+ +---------------+ | |--(A)------- Authorization Grant ---------&gt;| | | | | | | |&lt;-(B)----------- Access Token -------------| | | | &amp; Refresh Token | | | | | | | | +----------+ | | | |--(C)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(D)- Protected Resource --| Resource | | Authorization | | Client | | Server | | Server | | |--(E)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(F)- Invalid Token Error -| | | | | | +----------+ | | | | | | | |--(G)----------- Refresh Token -----------&gt;| | | | | | | |&lt;-(H)----------- Access Token -------------| | +--------+ &amp; Optional Refresh Token +---------------+ The flow refreshing an expired access token includes the following steps: The client requests an access token by authenticating with the authorization server and presenting an authorization grant. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token and a refresh token. The client makes a protected resource request to the resource server by presenting the access token. The resource server validates the access token, and if valid, serves the request. Steps (C) and (D) repeat until the access token expires. If the client knows the access token expired, it skips to step (G); otherwise, it makes another protected resource request. Since the access token is invalid, the resource server returns an invalid token error. The client requests a new access token by authenticating with the authorization server and presenting the refresh token. The client authentication requirements are based on the client type and on the authorization server policies. The authorization server authenticates the client and validates the refresh token, and if valid, issues a new access token (and, optionally, a new refresh token). 1.7. OpenID Connect OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. [OIDC] The OpenID Connect flow looks the same as OAuth. The only differences are, in the initial request, a specific scope of openid is used, and in the final exchange the client receives both an access token and an id token. [IGOID] The primary extension that OpenID Connect makes to OAuth 2.0 to enable End-Users to be Authenticated is the ID Token data structure. [OIDCT] The ID Token is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when using a Client, and potentially other requested Claims. The ID Token is represented as a JSON Web Token (JWT) [JWTIO]. 2. What is JSON Web Token? JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS [RFC7515]) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. [RFC7519] The suggested pronunciation of JWT is the same as the English word &quot;jot&quot;. Terminology JSON Web Token (JWT) A string representing a set of claims as a JSON object that is encoded in a JWS or JWE, enabling the claims to be digitally signed or MACed and/or encrypted. JWT Claims Set A JSON object that contains the claims conveyed by the JWT. Claim A piece of information asserted about a subject. A claim is represented as a name/value pair consisting of a Claim Name and a Claim Value. Claim Name The name portion of a claim representation. A Claim Name is always a string. Claim Value The value portion of a claim representation. A Claim Value can be any JSON value. Base64url Encoding [RFC7515] Base64 encoding using the URL- and filename-safe character set defined in Section 5 of RFC 4648 [RFC4648], with all trailing &#39;=&#39; characters omitted (as permitted by Section 3.2) and without the inclusion of any line breaks, whitespace, or other additional characters. Note that the base64url encoding of the empty octet sequence is the empty string. (See Appendix C for notes on implementing base64url encoding without padding.) 2.1. JSON Web Token (JWT) Overview JWTs represent a set of claims as a JSON object (i.e. JWT Claims Set) that is encoded in a JWS and/or JWE structure. The JSON object consists of zero or more name/value pairs (or members), where the names are strings and the values are arbitrary JSON values. These members are the claims represented by the JWT. The member names within the JWT Claims Set are referred to as Claim Names. The corresponding values are referred to as Claim Values. The contents of the JOSE Header describe the cryptographic operations applied to the JWT Claims Set. If the JOSE Header is for a JWS, the JWT is represented as a JWS and the claims are digitally signed or MACed, with the JWT Claims Set being the JWS Payload. If the JOSE Header is for a JWE, the JWT is represented as a JWE and the claims are encrypted, with the JWT Claims Set being the plaintext encrypted by the JWE. A JWT may be enclosed in another JWE or JWS structure to create a Nested JWT, enabling nested signing and encryption to be performed. A JWT is represented as a sequence of URL-safe parts separated by period (.) characters. Each part contains a base64url-encoded value. The number of parts in the JWT is dependent upon the representation of the resulting JWS using the JWS Compact Serialization or JWE using the JWE Compact Serialization. 2.2. What is the JSON Web Token structure? In its compact form, JSON Web Tokens consist of three parts separated by dots (.), which are: [JWTIO] Header Payload Signature Therefore, a JWT typically looks like the following. xxxxx.yyyyy.zzzzz Let&#8217;s break down the different parts. 2.2.1. Header The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA. For example: { &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; } Then, this JSON is Base64Url encoded to form the first part of the JWT. $ cat header.json | jq -cj | base64 -w0 | tr -d &#39;=&#39; eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 2.2.2. Payload The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims. Registered claims These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others. Notice that the claim names are only three characters long as JWT is meant to be compact. Public claims These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace. Private claims These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims. An example payload could be: { &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true } The payload is then Base64Url encoded to form the second part of the JSON Web Token. $ cat payload.json | jq -cj | base64 -w0 | tr -d &#39;=&#39; eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 Do note that for signed tokens this information, though protected against tampering, is readable by anyone. Do not put secret information in the payload or header elements of a JWT unless it is encrypted. 2.2.3. Signature To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that. For example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way: HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) The signature is used to verify the message wasn&#8217;t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is. 2.2.4. Putting all together The output is three Base64-URL strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML. The following shows a JWT that has the previous header and payload encoded, and it is signed with a secret (123456). eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.Wwu4TUUE86MPyFGhmv3D0Ct4GqkthRQDPKBwOQAAwJc 3. Microsoft identity platform The Microsoft identity platform helps you build applications your users and customers can sign in to using their Microsoft identities or social accounts. It authorizes access to your own APIs or Microsoft APIs like Microsoft Graph. There are several components that make up the Microsoft identity platform: OAuth 2.0 and OpenID Connect standard-compliant authentication service enabling developers to authenticate several identity types, including: Work or school accounts, provisioned through Azure AD Personal Microsoft accounts (Skype, Xbox, Outlook.com) Social or local accounts, by using Azure AD B2C Open-source libraries: Microsoft Authentication Library (MSAL) and support for other standards-compliant libraries. Application management portal: A registration and configuration experience in the Azure portal, along with the other Azure management capabilities. Application configuration API and PowerShell: Programmatic configuration of your applications through the Microsoft Graph API and PowerShell so you can automate your DevOps tasks. Developer content: Technical documentation including quickstarts, tutorials, how-to guides, and code samples. 3.1. Authentication vs. authorization [msadauthnz] Authentication is the process of proving that you are who you say you are. This is achieved by verification of the identity of a person or device. It&#8217;s sometimes shortened to AuthN. The Microsoft identity platform uses the OpenID Connect protocol for handling authentication. Authorization is the act of granting an authenticated party permission to do something. It specifies what data you&#8217;re allowed to access and what you can do with that data. Authorization is sometimes shortened to AuthZ. The Microsoft identity platform uses the OAuth 2.0 protocol for handling authorization. Multifactor authentication is the act of providing an additional factor of authentication to an account. This is often used to protect against brute force attacks. It is sometimes shortened to MFA or 2FA. The Microsoft Authenticator can be used as an app for handling two-factor authentication. For more information, see multifactor authentication. 3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform 3.2.1. Roles in OAuth 2.0 Four parties are generally involved in an OAuth 2.0 and OpenID Connect authentication and authorization exchange. These exchanges are often called authentication flows or auth flows. [msadouth2] Authorization server - The identity platform is the authorization server. Also called an identity provider or IdP, it securely handles the end-user&#8217;s information, their access, and the trust relationships between the parties in the auth flow. The authorization server issues the security tokens your apps and APIs use for granting, denying, or revoking access to resources (authorization) after the user has signed in (authenticated). Client - The client in an OAuth exchange is the application requesting access to a protected resource. The client could be a web app running on a server, a single-page web app running in a user&#8217;s web browser, or a web API that calls another web API. You&#8217;ll often see the client referred to as client application, application, or app. Resource owner - The resource owner in an auth flow is usually the application user, or end-user in OAuth terminology. The end-user &quot;owns&quot; the protected resource (their data) which your app accesses on their behalf. The resource owner can grant or deny your app (the client) access to the resources they own. For example, your app might call an external system&#8217;s API to get a user&#8217;s email address from their profile on that system. Their profile data is a resource the end-user owns on the external system, and the end-user can consent to or deny your app&#8217;s request to access their data. Resource server - The resource server hosts or provides access to a resource owner&#8217;s data. Most often, the resource server is a web API fronting a data store. The resource server relies on the authorization server to perform authentication and uses information in bearer tokens issued by the authorization server to grant or deny access to resources. 3.2.2. Tokens The parties in an authentication flow use bearer tokens to assure, verify, and authenticate a principal (user, host, or service) and to grant or deny access to protected resources (authorization). Bearer tokens in the identity platform are formatted as JSON Web Tokens (JWT). Three types of bearer tokens are used by the identity platform as security tokens: Access tokens - Access tokens are issued by the authorization server to the client application. The client passes access tokens to the resource server. Access tokens contain the permissions the client has been granted by the authorization server. ID tokens - ID tokens are issued by the authorization server to the client application. Clients use ID tokens when signing in users and to get basic information about them. Refresh tokens - The client uses a refresh token, or RT, to request new access and ID tokens from the authorization server. Your code should treat refresh tokens and their string content as sensitive data because they&#8217;re intended for use only by authorization server. 3.2.3. App registration Your client app needs a way to trust the security tokens issued to it by the identity platform. The first step in establishing trust is by registering your app. When you register your app, the identity platform automatically assigns it some values, while others you configure based on the application&#8217;s type. Two of the most commonly referenced app registration settings are: Application (client) ID - Also called application ID and client ID, this value is assigned to your app by the identity platform. The client ID uniquely identifies your app in the identity platform and is included in the security tokens the platform issues. Redirect URI - The authorization server uses a redirect URI to direct the resource owner&#8217;s user-agent (web browser, mobile app) to another destination after completing their interaction. For example, after the end-user authenticates with the authorization server. Not all client types use redirect URIs. Your app&#8217;s registration also holds information about the authentication and authorization endpoints you&#8217;ll use in your code to get ID and access tokens. 3.2.4. Endpoints The identity platform offers authentication and authorization services using standards-compliant implementations of OAuth 2.0 and OpenID Connect (OIDC) 1.0. Standards-compliant authorization servers like the identity platform provide a set of HTTP endpoints for use by the parties in an auth flow to execute the flow. The endpoint URIs for your app are generated automatically when you register or configure your app. The endpoints you use in your app&#8217;s code depend on the application&#8217;s type and the identities (account types) it should support. Two commonly used endpoints are the authorization endpoint and token endpoint. Here are examples of the authorize and token endpoints: # Authorization endpoint - used by client to obtain authorization from the resource owner. https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/authorize # Token endpoint - used by client to exchange an authorization grant or refresh token for an access token. https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/token # NOTE: # These are examples. Endpoint URI format may vary based on application type, # sign-in audience, and Azure cloud instance (global or national cloud). # The {issuer} value in the path of the request can be used to control who can sign into the application. # The allowed values are **common** for both Microsoft accounts and work or school accounts, # **organizations** for work or school accounts only, **consumers** for Microsoft accounts only, # and **tenant identifiers** such as the tenant ID or domain name. To find the endpoints for an application you&#8217;ve registered, in the Azure portal navigate to: Azure Active Directory &gt; App registrations &gt; &lt;YOUR-APPLICATION&gt; &gt; Endpoints. 3.3. OpenID Connect on the Microsoft identity platform OpenID Connect (OIDC) extends the OAuth 2.0 authorization protocol for use as an additional authentication protocol. You can use OIDC to enable single sign-on (SSO) between your OAuth-enabled applications by using a security token called an ID token. [msadoidc] Figure 1. The basic OpenID Connect sign-in flow The ID token introduced by OpenID Connect is issued by the authorization server, the Microsoft identity platform, when the client application requests one during user authentication. The ID token enables a client application to verify the identity of the user and to get other information (claims) about them. ID tokens aren&#8217;t issued by default for an application registered with the Microsoft identity platform. ID tokens for an application are enabled by using one of the following methods: Navigate to the Azure portal and select Azure Active Directory &gt; App registrations &gt; &lt;your application&gt; &gt; Authentication. Under Implicit grant and hybrid flows, select the ID tokens (used for implicit and hybrid flows) checkbox. Or: Select Azure Active Directory &gt; App registrations &gt; &lt;your application&gt; &gt; Manifest. Set oauth2AllowIdTokenImplicitFlow to true in the app registration&#8217;s application manifest. If ID tokens are not enabled for your app and one is requested, the Microsoft identity platform returns an unsupported_response error similar to: The provided value for the input parameter &#39;response_type&#39; isn&#8217;t allowed for this client. Expected value is &#39;code&#39;. 3.4. Authentication flows and application scenarios The Microsoft identity platform supports authentication for different kinds of modern application architectures. All of the architectures are based on the industry-standard protocols OAuth 2.0 and OpenID Connect. By using the authentication libraries for the Microsoft identity platform, applications authenticate identities and acquire tokens to access protected APIs. This article describes authentication flows and the application scenarios that they&#8217;re used in. [msadscene] 3.4.1. Application categories Tokens can be acquired from several types of applications, including: Web apps Mobile apps Desktop apps Web APIs Tokens can also be acquired by apps running on devices that don&#8217;t have a browser or are running on the Internet of Things (IoT). The following sections describe the categories of applications. 3.4.1.1. Protected resources vs. client applications Authentication scenarios involve two activities: Acquiring security tokens for a protected web API: We recommend that you use the Microsoft Authentication Library (MSAL), developed and supported by Microsoft. Protecting a web API or a web app: One challenge of protecting these resources is validating the security token. On some platforms, Microsoft offers middleware libraries. 3.4.1.2. With users or without users Most authentication scenarios acquire tokens on behalf of signed-in users. However, there are also daemon apps. In these scenarios, applications acquire tokens on behalf of themselves with no user. 3.4.1.3. Single-page, public client, and confidential client applications Security tokens can be acquired by multiple types of applications. These applications tend to be separated into the following three categories. Each is used with different libraries and objects. Single-page applications: Also known as SPAs, these are web apps in which tokens are acquired by a JavaScript or TypeScript app running in the browser. Many modern apps have a single-page application at the front end that&#8217;s primarily written in JavaScript. The application often uses a framework like Angular, React, or Vue. MSAL.js is the only Microsoft Authentication Library that supports single-page applications. Public client applications: Apps in this category, like the following types, always sign in users: Desktop apps that call web APIs on behalf of signed-in users Mobile apps Apps running on devices that don&#8217;t have a browser, like those running on IoT Confidential client applications: Apps in this category include: Web apps that call a web API Web APIs that call a web API Daemon apps, even when implemented as a console service like a Linux daemon or a Windows service 4. Keycloak Keycloak is an open-source software product that provides identity and access management (IAM) capabilities for modern applications and services. It offers a comprehensive solution for managing user authentication, authorization, and single sign-on (SSO). To start Keycloak from a terminal, enter the following command: docker run \ -d \ --name keycloak \ -p 8080:8080 \ -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \ -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \ quay.io/keycloak/keycloak:26.0.7 \ start-dev References [RFC6749] D. Hardt, Ed., The OAuth 2.0 Authorization Framework, Internet RFC 6749, Oct 2012. [RFC6750] M. Jones, D. Hardt, The OAuth 2.0 Authorization Framework: Bearer Token Usage, Internet RFC 6750, Oct 2012. [RFC7519] M. Jones, J. Bradley, N. Sakimura, JSON Web Token (JWT), Internet RFC 7519, May 2015. [OIDC] https://openid.net/connect/ [IGOID] An Illustrated Guide to OAuth and OpenID Connect [online]. https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc [RFC7515] Jones, M., Bradley, J., and N. Sakimura, JSON Web Signature (JWS), RFC 7515, DOI 10.17487/RFC, May 2015. [JWTIO] https://jwt.io/introduction [OIDCT] https://openid.net/specs/openid-connect-core-1_0.html#IDToken [msadauthnz] https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-vs-authorization [msadouth2] https://learn.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols [msadoidc] https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc [msadscene] https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-flows-app-scenarios OAuth 2 Simplified • Aaron Parecki [online]. https://aaronparecki.com/oauth-2-simplified/ OAuth.com - OAuth 2.0 Simplified [online]. https://www.oauth.com https://stackoverflow.com/questions/6916805/why-does-a-base64-encoded-string-have-an-sign-at-the-end https://superuser.com/questions/1225134/why-does-the-base64-of-a-string-contain-n" />
<link rel="canonical" href="https://blog.codefarm.me/2022/05/21/what-is-oauth2/" />
<meta property="og:url" content="https://blog.codefarm.me/2022/05/21/what-is-oauth2/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-21T09:28:55+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="What is OAuth2" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-21T09:28:55+08:00","datePublished":"2022-05-21T09:28:55+08:00","description":"1. What is OAuth2 1.1. Roles 1.2. Protocol Flow 1.3. Client Types 1.4. Authorization Grant 1.4.1. Authorization Code Grant 1.4.2. Implicit Grant 1.4.3. Resource Owner Password Credentials Grant 1.4.4. Client Credentials Grant 1.5. Access Token 1.6. Refresh Token 1.7. OpenID Connect 2. What is JSON Web Token? 2.1. JSON Web Token (JWT) Overview 2.2. What is the JSON Web Token structure? 2.2.1. Header 2.2.2. Payload 2.2.3. Signature 2.2.4. Putting all together 3. Microsoft identity platform 3.1. Authentication vs. authorization [msadauthnz] 3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform 3.2.1. Roles in OAuth 2.0 3.2.2. Tokens 3.2.3. App registration 3.2.4. Endpoints 3.3. OpenID Connect on the Microsoft identity platform 3.4. Authentication flows and application scenarios 3.4.1. Application categories 3.4.1.1. Protected resources vs. client applications 3.4.1.2. With users or without users 3.4.1.3. Single-page, public client, and confidential client applications 4. Keycloak References 1. What is OAuth2 In the traditional client-server authentication model, the client requests an access-restricted or protected resource on the server by authenticating with the server using the resource owner&#8217;s credentials. [RFC6749] In order to provide third-party applications access to restricted resources, the resource owner shares its credentials with the third party. This creates several problems and limitations: Third-party applications are required to store the resource owner&#8217;s credentials for future use, typically a password in clear-text. Servers are required to support password authentication, despite the security weaknesses inherent in passwords. Third-party applications gain overly broad access to the resource owner&#8217;s protected resources, leaving resource owners without any ability to restrict duration or access to a limited subset of resources. Resource owners cannot revoke access to an individual third party without revoking access to all third parties, and must do so by changing the third party&#8217;s password. Compromise of any third-party application results in compromise of the end-user&#8217;s password and all of the data protected by that password. OAuth addresses these issues by introducing an authorization layer and separating the role of the client from that of the resource owner. In OAuth, the client requests access to resources controlled by the resource owner and hosted by the resource server, and is issued a different set of credentials than those of the resource owner. Instead of using the resource owner&#8217;s credentials to access protected resources, the client obtains an access token&#8201;&#8212;&#8201;a string denoting a specific scope, lifetime, and other access attributes. Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner. The client uses the access token to access the protected resources hosted by the resource server. For example, an end-user (resource owner) can grant a printing service (client) access to her protected photos stored at a photo-sharing service (resource server), without sharing her username and password with the printing service. Instead, she authenticates directly with a server trusted by the photo-sharing service (authorization server), which issues the printing service delegation-specific credentials (access token). The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. The steps to grant permission, or consent, are often referred to as authorization or even delegated authorization. You authorize one application to access your data, or use features in another application on your behalf, without giving them your password. OAuth is about how to get a token and how to use a token. OAuth is a delegation framework that provides authorization across systems. OAuth replaces the password-sharing anti-pattern with a delegation protocol that&#8217;s simultaneously more secure and more usable. OAuth is focused on solving a small set of problems and solving them well, which makes it a suitable component within larger security systems. 1.1. Roles OAuth defines four roles: resource owner An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. resource server The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens. client An application making protected resource requests on behalf of the resource owner and with its authorization. The term &quot;client&quot; does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices). authorization server The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization. The authorization server may be the same server as the resource server or a separate entity. A single authorization server may issue access tokens accepted by multiple resource servers. 1.2. Protocol Flow +--------+ +---------------+ | |--(A)- Authorization Request -&gt;| Resource | | | | Owner | | |&lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --&gt;| Authorization | | Client | | Server | | |&lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------&gt;| Resource | | | | Server | | |&lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ The abstract OAuth 2.0 flow describes the interaction between the four roles and includes the following steps: The client requests authorization from the resource owner. The authorization request can be made directly to the resource owner (as shown), or preferably indirectly via the authorization server as an intermediary. The client receives an authorization grant, which is a credential representing the resource owner&#8217;s authorization, expressed using one of four grant types defined in this specification (authorization code, implicit, password, client credential) or using an extension grant type. The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server. The client requests an access token by authenticating with the authorization server and presenting the authorization grant. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token. The client requests the protected resource from the resource server and authenticates by presenting the access token. The resource server validates the access token, and if valid, serves the request. 1.3. Client Types OAuth defines two client types, based on their ability to authenticate securely with the authorization server (i.e., ability to maintain the confidentiality of their client credentials): confidential Clients capable of maintaining the confidentiality of their credentials (e.g., client implemented on a secure server with restricted access to the client credentials), or capable of secure client authentication using other means. public Clients incapable of maintaining the confidentiality of their credentials (e.g., clients executing on the device used by the resource owner, such as an installed native application or a web browser-based application), and incapable of secure client authentication via any other means. This specification has been designed around the following client profiles: web application A web application is a confidential client running on a web server. Resource owners access the client via an HTML user interface rendered in a user-agent on the device used by the resource owner. The client credentials as well as any access token issued to the client are stored on the web server and are not exposed to or accessible by the resource owner. user-agent-based application A user-agent-based application is a public client in which the client code is downloaded from a web server and executes within a user-agent (e.g., web browser) on the device used by the resource owner. Protocol data and credentials are easily accessible (and often visible) to the resource owner. Since such applications reside within the user-agent, they can make seamless use of the user-agent capabilities when requesting authorization. native application A native application is a public client installed and executed on the device used by the resource owner. Protocol data and credentials are accessible to the resource owner. It is assumed that any client authentication credentials included in the application can be extracted. On the other hand, dynamically issued credentials such as access tokens or refresh tokens can receive an acceptable level of protection. At a minimum, these credentials are protected from hostile servers with which the application may interact. On some platforms, these credentials might be protected from other applications residing on the same device. 1.4. Authorization Grant An authorization grant is a credential representing the resource owner&#8217;s authorization (to access its protected resources) used by the client to obtain an access token. This specification defines four grant types&#8201;&#8212;&#8201;authorization code, implicit, resource owner password credentials, and client credentials&#8201;&#8212;&#8201;as well as an extensibility mechanism for defining additional types. [RFC6749] 1.4.1. Authorization Code Grant The authorization code grant type is used to obtain both access tokens and refresh tokens and is optimized for confidential clients. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ----&gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&gt;| Server | | | | | | -+----(C)-- Authorization Code ---&lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&gt;---(D)-- Authorization Code ---------&#39; | | Client | &amp; Redirection URI | | | | | |&lt;---(E)----- Access Token -------------------&#39; +---------+ (w/ Optional Refresh Token) The flow includes the following steps: The client initiates the flow by directing the resource owner&#8217;s user-agent to the authorization endpoint. The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied). The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client&#8217;s access request. Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier (in the request or during client registration). The redirection URI includes an authorization code and any local state provided by the client earlier. The client requests an access token from the authorization server&#8217;s token endpoint by including the authorization code received in the previous step. When making the request, the client authenticates with the authorization server. The client includes the redirection URI used to obtain the authorization code for verification. The authorization server authenticates the client, validates the authorization code, and ensures that the redirection URI received matches the URI used to redirect the client in step (C). If valid, the authorization server responds back with an access token and, optionally, a refresh token. 1.4.2. Implicit Grant The implicit grant type is used to obtain access tokens (it does not support the issuance of refresh tokens) and is optimized for public clients known to operate a particular redirection URI. These clients are typically implemented in a browser using a scripting language such as JavaScript. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server. Unlike the authorization code grant type, in which the client makes separate requests for authorization and for an access token, the client receives the access token as the result of the authorization request. The implicit grant type does not include client authentication, and relies on the presence of the resource owner and the registration of the redirection URI. Because the access token is encoded into the redirection URI, it may be exposed to the resource owner and other applications residing on the same device. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ---&gt;| | | User- | | Authorization | | Agent -|----(B)-- User authenticates --&gt;| Server | | | | | | |&lt;---(C)--- Redirection URI ----&lt;| | | | with Access Token +---------------+ | | in Fragment | | +---------------+ | |----(D)--- Redirection URI ----&gt;| Web-Hosted | | | without Fragment | Client | | | | Resource | | (F) |&lt;---(E)------- Script ---------&lt;| | | | +---------------+ +-|--------+ | | (A) (G) Access Token | | ^ v +---------+ | | | Client | | | +---------+ The flow includes the following steps: The client initiates the flow by directing the resource owner&#8217;s user-agent to the authorization endpoint. The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied). The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client&#8217;s access request. Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier. The redirection URI includes the access token in the URI fragment. The user-agent follows the redirection instructions by making a request to the web-hosted client resource (which does not include the fragment per [RFC2616]). The user-agent retains the fragment information locally. The web-hosted client resource returns a web page (typically an HTML document with an embedded script) capable of accessing the full redirection URI including the fragment retained by the user-agent, and extracting the access token (and other parameters) contained in the fragment. The user-agent executes the script provided by the web-hosted client resource locally, which extracts the access token. The user-agent passes the access token to the client. 1.4.3. Resource Owner Password Credentials Grant The resource owner password credentials grant type is suitable in cases where the resource owner has a trust relationship with the client, such as the device operating system or a highly privileged application. The authorization server should take special care when enabling this grant type and only allow it when other flows are not viable. This grant type is suitable for clients capable of obtaining the resource owner&#8217;s credentials (username and password, typically using an interactive form). It is also used to migrate existing clients using direct authentication schemes such as HTTP Basic or Digest authentication to OAuth by converting the stored credentials to an access token. +----------+ | Resource | | Owner | | | +----------+ v | Resource Owner (A) Password Credentials | v +---------+ +---------------+ | |&gt;--(B)---- Resource Owner -------&gt;| | | | Password Credentials | Authorization | | Client | | Server | | |&lt;--(C)---- Access Token ---------&lt;| | | | (w/ Optional Refresh Token) | | +---------+ +---------------+ The flow includes the following steps: The resource owner provides the client with its username and password. The client requests an access token from the authorization server&#8217;s token endpoint by including the credentials received from the resource owner. When making the request, the client authenticates with the authorization server. The authorization server authenticates the client and validates the resource owner credentials, and if valid, issues an access token. 1.4.4. Client Credentials Grant The client can request an access token using only its client credentials (or other supported means of authentication) when the client is requesting access to the protected resources under its control, or those of another resource owner that have been previously arranged with the authorization server (the method of which is beyond the scope of this specification). The client credentials grant type MUST only be used by confidential clients. +---------+ +---------------+ | | | | | |&gt;--(A)- Client Authentication ---&gt;| Authorization | | Client | | Server | | |&lt;--(B)---- Access Token ---------&lt;| | | | | | +---------+ +---------------+ The flow includes the following steps: The client authenticates with the authorization server and requests an access token from the token endpoint. The authorization server authenticates the client, and if valid, issues an access token. 1.5. Access Token Access tokens are credentials used to access protected resources. An access token is a string representing an authorization issued to the client. The string is usually opaque to the client. Tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server. The token may denote an identifier used to retrieve the authorization information or may self-contain the authorization information in a verifiable manner (i.e., a token string consisting of some data and a signature). The access token provides an abstraction layer, replacing different authorization constructs (e.g., username and password) with a single token understood by the resource server. This abstraction enables issuing access tokens more restrictive than the authorization grant used to obtain them, as well as removing the resource server&#8217;s need to understand a wide range of authentication methods. Access tokens can have different formats, structures, and methods of utilization (e.g., cryptographic properties) based on the resource server security requirements. Access token attributes and the methods used to access protected resources are beyond the scope of this specification and are defined by companion specifications such as [RFC6750]. 1.6. Refresh Token Refresh tokens are credentials used to obtain access tokens. Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner). Issuing a refresh token is optional at the discretion of the authorization server. If the authorization server issues a refresh token, it is included when issuing an access token (i.e., step (D) in the above protocol flow). A refresh token is a string representing the authorization granted to the client by the resource owner. The string is usually opaque to the client. The token denotes an identifier used to retrieve the authorization information. Unlike access tokens, refresh tokens are intended for use only with authorization servers and are never sent to resource servers. +--------+ +---------------+ | |--(A)------- Authorization Grant ---------&gt;| | | | | | | |&lt;-(B)----------- Access Token -------------| | | | &amp; Refresh Token | | | | | | | | +----------+ | | | |--(C)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(D)- Protected Resource --| Resource | | Authorization | | Client | | Server | | Server | | |--(E)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(F)- Invalid Token Error -| | | | | | +----------+ | | | | | | | |--(G)----------- Refresh Token -----------&gt;| | | | | | | |&lt;-(H)----------- Access Token -------------| | +--------+ &amp; Optional Refresh Token +---------------+ The flow refreshing an expired access token includes the following steps: The client requests an access token by authenticating with the authorization server and presenting an authorization grant. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token and a refresh token. The client makes a protected resource request to the resource server by presenting the access token. The resource server validates the access token, and if valid, serves the request. Steps (C) and (D) repeat until the access token expires. If the client knows the access token expired, it skips to step (G); otherwise, it makes another protected resource request. Since the access token is invalid, the resource server returns an invalid token error. The client requests a new access token by authenticating with the authorization server and presenting the refresh token. The client authentication requirements are based on the client type and on the authorization server policies. The authorization server authenticates the client and validates the refresh token, and if valid, issues a new access token (and, optionally, a new refresh token). 1.7. OpenID Connect OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. [OIDC] The OpenID Connect flow looks the same as OAuth. The only differences are, in the initial request, a specific scope of openid is used, and in the final exchange the client receives both an access token and an id token. [IGOID] The primary extension that OpenID Connect makes to OAuth 2.0 to enable End-Users to be Authenticated is the ID Token data structure. [OIDCT] The ID Token is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when using a Client, and potentially other requested Claims. The ID Token is represented as a JSON Web Token (JWT) [JWTIO]. 2. What is JSON Web Token? JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS [RFC7515]) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. [RFC7519] The suggested pronunciation of JWT is the same as the English word &quot;jot&quot;. Terminology JSON Web Token (JWT) A string representing a set of claims as a JSON object that is encoded in a JWS or JWE, enabling the claims to be digitally signed or MACed and/or encrypted. JWT Claims Set A JSON object that contains the claims conveyed by the JWT. Claim A piece of information asserted about a subject. A claim is represented as a name/value pair consisting of a Claim Name and a Claim Value. Claim Name The name portion of a claim representation. A Claim Name is always a string. Claim Value The value portion of a claim representation. A Claim Value can be any JSON value. Base64url Encoding [RFC7515] Base64 encoding using the URL- and filename-safe character set defined in Section 5 of RFC 4648 [RFC4648], with all trailing &#39;=&#39; characters omitted (as permitted by Section 3.2) and without the inclusion of any line breaks, whitespace, or other additional characters. Note that the base64url encoding of the empty octet sequence is the empty string. (See Appendix C for notes on implementing base64url encoding without padding.) 2.1. JSON Web Token (JWT) Overview JWTs represent a set of claims as a JSON object (i.e. JWT Claims Set) that is encoded in a JWS and/or JWE structure. The JSON object consists of zero or more name/value pairs (or members), where the names are strings and the values are arbitrary JSON values. These members are the claims represented by the JWT. The member names within the JWT Claims Set are referred to as Claim Names. The corresponding values are referred to as Claim Values. The contents of the JOSE Header describe the cryptographic operations applied to the JWT Claims Set. If the JOSE Header is for a JWS, the JWT is represented as a JWS and the claims are digitally signed or MACed, with the JWT Claims Set being the JWS Payload. If the JOSE Header is for a JWE, the JWT is represented as a JWE and the claims are encrypted, with the JWT Claims Set being the plaintext encrypted by the JWE. A JWT may be enclosed in another JWE or JWS structure to create a Nested JWT, enabling nested signing and encryption to be performed. A JWT is represented as a sequence of URL-safe parts separated by period (.) characters. Each part contains a base64url-encoded value. The number of parts in the JWT is dependent upon the representation of the resulting JWS using the JWS Compact Serialization or JWE using the JWE Compact Serialization. 2.2. What is the JSON Web Token structure? In its compact form, JSON Web Tokens consist of three parts separated by dots (.), which are: [JWTIO] Header Payload Signature Therefore, a JWT typically looks like the following. xxxxx.yyyyy.zzzzz Let&#8217;s break down the different parts. 2.2.1. Header The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA. For example: { &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; } Then, this JSON is Base64Url encoded to form the first part of the JWT. $ cat header.json | jq -cj | base64 -w0 | tr -d &#39;=&#39; eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 2.2.2. Payload The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims. Registered claims These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others. Notice that the claim names are only three characters long as JWT is meant to be compact. Public claims These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace. Private claims These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims. An example payload could be: { &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true } The payload is then Base64Url encoded to form the second part of the JSON Web Token. $ cat payload.json | jq -cj | base64 -w0 | tr -d &#39;=&#39; eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 Do note that for signed tokens this information, though protected against tampering, is readable by anyone. Do not put secret information in the payload or header elements of a JWT unless it is encrypted. 2.2.3. Signature To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that. For example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way: HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) The signature is used to verify the message wasn&#8217;t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is. 2.2.4. Putting all together The output is three Base64-URL strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML. The following shows a JWT that has the previous header and payload encoded, and it is signed with a secret (123456). eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.Wwu4TUUE86MPyFGhmv3D0Ct4GqkthRQDPKBwOQAAwJc 3. Microsoft identity platform The Microsoft identity platform helps you build applications your users and customers can sign in to using their Microsoft identities or social accounts. It authorizes access to your own APIs or Microsoft APIs like Microsoft Graph. There are several components that make up the Microsoft identity platform: OAuth 2.0 and OpenID Connect standard-compliant authentication service enabling developers to authenticate several identity types, including: Work or school accounts, provisioned through Azure AD Personal Microsoft accounts (Skype, Xbox, Outlook.com) Social or local accounts, by using Azure AD B2C Open-source libraries: Microsoft Authentication Library (MSAL) and support for other standards-compliant libraries. Application management portal: A registration and configuration experience in the Azure portal, along with the other Azure management capabilities. Application configuration API and PowerShell: Programmatic configuration of your applications through the Microsoft Graph API and PowerShell so you can automate your DevOps tasks. Developer content: Technical documentation including quickstarts, tutorials, how-to guides, and code samples. 3.1. Authentication vs. authorization [msadauthnz] Authentication is the process of proving that you are who you say you are. This is achieved by verification of the identity of a person or device. It&#8217;s sometimes shortened to AuthN. The Microsoft identity platform uses the OpenID Connect protocol for handling authentication. Authorization is the act of granting an authenticated party permission to do something. It specifies what data you&#8217;re allowed to access and what you can do with that data. Authorization is sometimes shortened to AuthZ. The Microsoft identity platform uses the OAuth 2.0 protocol for handling authorization. Multifactor authentication is the act of providing an additional factor of authentication to an account. This is often used to protect against brute force attacks. It is sometimes shortened to MFA or 2FA. The Microsoft Authenticator can be used as an app for handling two-factor authentication. For more information, see multifactor authentication. 3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform 3.2.1. Roles in OAuth 2.0 Four parties are generally involved in an OAuth 2.0 and OpenID Connect authentication and authorization exchange. These exchanges are often called authentication flows or auth flows. [msadouth2] Authorization server - The identity platform is the authorization server. Also called an identity provider or IdP, it securely handles the end-user&#8217;s information, their access, and the trust relationships between the parties in the auth flow. The authorization server issues the security tokens your apps and APIs use for granting, denying, or revoking access to resources (authorization) after the user has signed in (authenticated). Client - The client in an OAuth exchange is the application requesting access to a protected resource. The client could be a web app running on a server, a single-page web app running in a user&#8217;s web browser, or a web API that calls another web API. You&#8217;ll often see the client referred to as client application, application, or app. Resource owner - The resource owner in an auth flow is usually the application user, or end-user in OAuth terminology. The end-user &quot;owns&quot; the protected resource (their data) which your app accesses on their behalf. The resource owner can grant or deny your app (the client) access to the resources they own. For example, your app might call an external system&#8217;s API to get a user&#8217;s email address from their profile on that system. Their profile data is a resource the end-user owns on the external system, and the end-user can consent to or deny your app&#8217;s request to access their data. Resource server - The resource server hosts or provides access to a resource owner&#8217;s data. Most often, the resource server is a web API fronting a data store. The resource server relies on the authorization server to perform authentication and uses information in bearer tokens issued by the authorization server to grant or deny access to resources. 3.2.2. Tokens The parties in an authentication flow use bearer tokens to assure, verify, and authenticate a principal (user, host, or service) and to grant or deny access to protected resources (authorization). Bearer tokens in the identity platform are formatted as JSON Web Tokens (JWT). Three types of bearer tokens are used by the identity platform as security tokens: Access tokens - Access tokens are issued by the authorization server to the client application. The client passes access tokens to the resource server. Access tokens contain the permissions the client has been granted by the authorization server. ID tokens - ID tokens are issued by the authorization server to the client application. Clients use ID tokens when signing in users and to get basic information about them. Refresh tokens - The client uses a refresh token, or RT, to request new access and ID tokens from the authorization server. Your code should treat refresh tokens and their string content as sensitive data because they&#8217;re intended for use only by authorization server. 3.2.3. App registration Your client app needs a way to trust the security tokens issued to it by the identity platform. The first step in establishing trust is by registering your app. When you register your app, the identity platform automatically assigns it some values, while others you configure based on the application&#8217;s type. Two of the most commonly referenced app registration settings are: Application (client) ID - Also called application ID and client ID, this value is assigned to your app by the identity platform. The client ID uniquely identifies your app in the identity platform and is included in the security tokens the platform issues. Redirect URI - The authorization server uses a redirect URI to direct the resource owner&#8217;s user-agent (web browser, mobile app) to another destination after completing their interaction. For example, after the end-user authenticates with the authorization server. Not all client types use redirect URIs. Your app&#8217;s registration also holds information about the authentication and authorization endpoints you&#8217;ll use in your code to get ID and access tokens. 3.2.4. Endpoints The identity platform offers authentication and authorization services using standards-compliant implementations of OAuth 2.0 and OpenID Connect (OIDC) 1.0. Standards-compliant authorization servers like the identity platform provide a set of HTTP endpoints for use by the parties in an auth flow to execute the flow. The endpoint URIs for your app are generated automatically when you register or configure your app. The endpoints you use in your app&#8217;s code depend on the application&#8217;s type and the identities (account types) it should support. Two commonly used endpoints are the authorization endpoint and token endpoint. Here are examples of the authorize and token endpoints: # Authorization endpoint - used by client to obtain authorization from the resource owner. https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/authorize # Token endpoint - used by client to exchange an authorization grant or refresh token for an access token. https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/token # NOTE: # These are examples. Endpoint URI format may vary based on application type, # sign-in audience, and Azure cloud instance (global or national cloud). # The {issuer} value in the path of the request can be used to control who can sign into the application. # The allowed values are **common** for both Microsoft accounts and work or school accounts, # **organizations** for work or school accounts only, **consumers** for Microsoft accounts only, # and **tenant identifiers** such as the tenant ID or domain name. To find the endpoints for an application you&#8217;ve registered, in the Azure portal navigate to: Azure Active Directory &gt; App registrations &gt; &lt;YOUR-APPLICATION&gt; &gt; Endpoints. 3.3. OpenID Connect on the Microsoft identity platform OpenID Connect (OIDC) extends the OAuth 2.0 authorization protocol for use as an additional authentication protocol. You can use OIDC to enable single sign-on (SSO) between your OAuth-enabled applications by using a security token called an ID token. [msadoidc] Figure 1. The basic OpenID Connect sign-in flow The ID token introduced by OpenID Connect is issued by the authorization server, the Microsoft identity platform, when the client application requests one during user authentication. The ID token enables a client application to verify the identity of the user and to get other information (claims) about them. ID tokens aren&#8217;t issued by default for an application registered with the Microsoft identity platform. ID tokens for an application are enabled by using one of the following methods: Navigate to the Azure portal and select Azure Active Directory &gt; App registrations &gt; &lt;your application&gt; &gt; Authentication. Under Implicit grant and hybrid flows, select the ID tokens (used for implicit and hybrid flows) checkbox. Or: Select Azure Active Directory &gt; App registrations &gt; &lt;your application&gt; &gt; Manifest. Set oauth2AllowIdTokenImplicitFlow to true in the app registration&#8217;s application manifest. If ID tokens are not enabled for your app and one is requested, the Microsoft identity platform returns an unsupported_response error similar to: The provided value for the input parameter &#39;response_type&#39; isn&#8217;t allowed for this client. Expected value is &#39;code&#39;. 3.4. Authentication flows and application scenarios The Microsoft identity platform supports authentication for different kinds of modern application architectures. All of the architectures are based on the industry-standard protocols OAuth 2.0 and OpenID Connect. By using the authentication libraries for the Microsoft identity platform, applications authenticate identities and acquire tokens to access protected APIs. This article describes authentication flows and the application scenarios that they&#8217;re used in. [msadscene] 3.4.1. Application categories Tokens can be acquired from several types of applications, including: Web apps Mobile apps Desktop apps Web APIs Tokens can also be acquired by apps running on devices that don&#8217;t have a browser or are running on the Internet of Things (IoT). The following sections describe the categories of applications. 3.4.1.1. Protected resources vs. client applications Authentication scenarios involve two activities: Acquiring security tokens for a protected web API: We recommend that you use the Microsoft Authentication Library (MSAL), developed and supported by Microsoft. Protecting a web API or a web app: One challenge of protecting these resources is validating the security token. On some platforms, Microsoft offers middleware libraries. 3.4.1.2. With users or without users Most authentication scenarios acquire tokens on behalf of signed-in users. However, there are also daemon apps. In these scenarios, applications acquire tokens on behalf of themselves with no user. 3.4.1.3. Single-page, public client, and confidential client applications Security tokens can be acquired by multiple types of applications. These applications tend to be separated into the following three categories. Each is used with different libraries and objects. Single-page applications: Also known as SPAs, these are web apps in which tokens are acquired by a JavaScript or TypeScript app running in the browser. Many modern apps have a single-page application at the front end that&#8217;s primarily written in JavaScript. The application often uses a framework like Angular, React, or Vue. MSAL.js is the only Microsoft Authentication Library that supports single-page applications. Public client applications: Apps in this category, like the following types, always sign in users: Desktop apps that call web APIs on behalf of signed-in users Mobile apps Apps running on devices that don&#8217;t have a browser, like those running on IoT Confidential client applications: Apps in this category include: Web apps that call a web API Web APIs that call a web API Daemon apps, even when implemented as a console service like a Linux daemon or a Windows service 4. Keycloak Keycloak is an open-source software product that provides identity and access management (IAM) capabilities for modern applications and services. It offers a comprehensive solution for managing user authentication, authorization, and single sign-on (SSO). To start Keycloak from a terminal, enter the following command: docker run \\ -d \\ --name keycloak \\ -p 8080:8080 \\ -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \\ -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \\ quay.io/keycloak/keycloak:26.0.7 \\ start-dev References [RFC6749] D. Hardt, Ed., The OAuth 2.0 Authorization Framework, Internet RFC 6749, Oct 2012. [RFC6750] M. Jones, D. Hardt, The OAuth 2.0 Authorization Framework: Bearer Token Usage, Internet RFC 6750, Oct 2012. [RFC7519] M. Jones, J. Bradley, N. Sakimura, JSON Web Token (JWT), Internet RFC 7519, May 2015. [OIDC] https://openid.net/connect/ [IGOID] An Illustrated Guide to OAuth and OpenID Connect [online]. https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc [RFC7515] Jones, M., Bradley, J., and N. Sakimura, JSON Web Signature (JWS), RFC 7515, DOI 10.17487/RFC, May 2015. [JWTIO] https://jwt.io/introduction [OIDCT] https://openid.net/specs/openid-connect-core-1_0.html#IDToken [msadauthnz] https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-vs-authorization [msadouth2] https://learn.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols [msadoidc] https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc [msadscene] https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-flows-app-scenarios OAuth 2 Simplified • Aaron Parecki [online]. https://aaronparecki.com/oauth-2-simplified/ OAuth.com - OAuth 2.0 Simplified [online]. https://www.oauth.com https://stackoverflow.com/questions/6916805/why-does-a-base64-encoded-string-have-an-sign-at-the-end https://superuser.com/questions/1225134/why-does-the-base64-of-a-string-contain-n","headline":"What is OAuth2","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2022/05/21/what-is-oauth2/"},"url":"https://blog.codefarm.me/2022/05/21/what-is-oauth2/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">What is OAuth2</h1><p class="c-post-meta">05 Jan 2024</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#what-is-oauth2">1. What is OAuth2</a>
<ul class="sectlevel2">
<li><a href="#roles">1.1. Roles</a></li>
<li><a href="#protocol-flow">1.2. Protocol Flow</a></li>
<li><a href="#client-types">1.3. Client Types</a></li>
<li><a href="#authorization-grant">1.4. Authorization Grant</a>
<ul class="sectlevel3">
<li><a href="#authorization-code-grant">1.4.1. Authorization Code Grant</a></li>
<li><a href="#implicit-grant">1.4.2. Implicit Grant</a></li>
<li><a href="#resource-owner-password-credentials-grant">1.4.3. Resource Owner Password Credentials Grant</a></li>
<li><a href="#client-credentials-grant">1.4.4. Client Credentials Grant</a></li>
</ul>
</li>
<li><a href="#access-token">1.5. Access Token</a></li>
<li><a href="#refresh-token">1.6. Refresh Token</a></li>
<li><a href="#openid-connect">1.7. OpenID Connect</a></li>
</ul>
</li>
<li><a href="#what-is-json-web-token">2. What is JSON Web Token?</a>
<ul class="sectlevel2">
<li><a href="#json-web-token-jwt-overview">2.1. JSON Web Token (JWT) Overview</a></li>
<li><a href="#what-is-the-json-web-token-structure">2.2. What is the JSON Web Token structure?</a>
<ul class="sectlevel3">
<li><a href="#header">2.2.1. Header</a></li>
<li><a href="#payload">2.2.2. Payload</a></li>
<li><a href="#signature">2.2.3. Signature</a></li>
<li><a href="#putting-all-together">2.2.4. Putting all together</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#microsoft-identity-platform">3. Microsoft identity platform</a>
<ul class="sectlevel2">
<li><a href="#authentication-vs-authorization-msadauthnz">3.1. Authentication vs. authorization [msadauthnz]</a></li>
<li><a href="#oauth-2-0-and-openid-connect-oidc-in-the-microsoft-identity-platform">3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform</a>
<ul class="sectlevel3">
<li><a href="#roles-in-oauth-2-0">3.2.1. Roles in OAuth 2.0</a></li>
<li><a href="#tokens">3.2.2. Tokens</a></li>
<li><a href="#app-registration">3.2.3. App registration</a></li>
<li><a href="#endpoints">3.2.4. Endpoints</a></li>
</ul>
</li>
<li><a href="#openid-connect-on-the-microsoft-identity-platform">3.3. OpenID Connect on the Microsoft identity platform</a></li>
<li><a href="#authentication-flows-and-application-scenarios">3.4. Authentication flows and application scenarios</a>
<ul class="sectlevel3">
<li><a href="#application-categories">3.4.1. Application categories</a>
<ul class="sectlevel4">
<li><a href="#protected-resources-vs-client-applications">3.4.1.1. Protected resources vs. client applications</a></li>
<li><a href="#with-users-or-without-users">3.4.1.2. With users or without users</a></li>
<li><a href="#single-page-public-client-and-confidential-client-applications">3.4.1.3. Single-page, public client, and confidential client applications</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#keycloak">4. Keycloak</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="what-is-oauth2">1. What is OAuth2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the traditional client-server authentication model, the client requests an access-restricted or protected resource on the server by authenticating with the server using the resource owner&#8217;s credentials. <a href="#RFC6749">[RFC6749]</a></p>
</div>
<div class="paragraph">
<p>In order to provide third-party applications access to restricted resources, the resource owner shares its credentials with the third party.</p>
</div>
<div class="paragraph">
<p>This creates several problems and limitations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Third-party applications are required to store the resource owner&#8217;s credentials for future use, typically a password in clear-text.</p>
</li>
<li>
<p>Servers are required to support password authentication, despite the security weaknesses inherent in passwords.</p>
</li>
<li>
<p>Third-party applications gain overly broad access to the resource owner&#8217;s protected resources, leaving resource owners without any ability to restrict duration or access to a limited subset of resources.</p>
</li>
<li>
<p>Resource owners cannot revoke access to an individual third party without revoking access to all third parties, and must do so by changing the third party&#8217;s password.</p>
</li>
<li>
<p>Compromise of any third-party application results in compromise of the end-user&#8217;s password and all of the data protected by that password.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>OAuth</em> addresses these issues by introducing an authorization layer and separating the role of the client from that of the resource owner. In OAuth, the <em>client</em> requests access to resources controlled by the <em>resource owner</em> and hosted by the <em>resource server</em>, and is issued a different set of credentials than those of the resource owner.</p>
</div>
<div class="paragraph">
<p>Instead of using the resource owner&#8217;s credentials to access protected resources, the client obtains an <em>access token</em>&#8201;&#8212;&#8201;a string denoting a specific scope, lifetime, and other access attributes. Access tokens are issued to third-party clients by an <em>authorization server</em> with the approval of the resource owner. The client uses the access token to access the protected resources hosted by the resource server.</p>
</div>
<div class="paragraph">
<p>For example, an end-user (resource owner) can grant a printing service (client) access to her protected photos stored at a photo-sharing service (resource server), without sharing her username and password with the printing service. Instead, she authenticates directly with a server trusted by the photo-sharing service (authorization server), which issues the printing service delegation-specific credentials (access token).</p>
</div>
<div class="paragraph">
<p>The <em>OAuth 2.0 authorization framework</em> enables a <em>third-party</em> application to obtain <em>limited access</em> to an HTTP service, either <em>on behalf of a resource owner</em> by orchestrating an approval interaction between the resource owner and the HTTP service, or by <em>allowing the third-party application to obtain access on its own behalf</em>.</p>
</div>
<div class="paragraph">
<p>The steps to grant permission, or <em>consent</em>, are often referred to as <em>authorization</em> or even <em>delegated authorization</em>. You authorize one application to access your data, or use features in another application on your behalf, without giving them your password.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OAuth is about how to get a <em>token</em> and how to use a token.</p>
</li>
<li>
<p>OAuth is a <em>delegation</em> framework that provides authorization across systems.</p>
</li>
<li>
<p>OAuth replaces the password-sharing anti-pattern with a delegation protocol that&#8217;s simultaneously more secure and more usable.</p>
</li>
<li>
<p>OAuth is focused on solving a small set of problems and solving them well, which makes it a suitable component within larger security systems.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="roles">1.1. Roles</h3>
<div class="paragraph">
<p>OAuth defines four roles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>resource owner</p>
<div class="paragraph">
<p>An entity capable of granting access to a protected resource.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When the resource owner is a person, it is referred to as an <em>end-user</em>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>resource server</p>
<div class="paragraph">
<p>The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.</p>
</div>
</li>
<li>
<p>client</p>
<div class="paragraph">
<p>An application making protected resource requests on behalf of the resource owner and with its authorization.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The term "client" does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices).
</td>
</tr>
</table>
</div>
</li>
<li>
<p>authorization server</p>
<div class="paragraph">
<p>The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The authorization server may be the same server as the resource server or a separate entity. A single authorization server may issue access tokens accepted by multiple resource servers.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="protocol-flow">1.2. Protocol Flow</h3>
<div class="listingblock text-left">
<div class="content">
<pre>+--------+                               +---------------+
|        |--(A)- Authorization Request -&gt;|   Resource    |
|        |                               |     Owner     |
|        |&lt;-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant --&gt;| Authorization |
| Client |                               |     Server    |
|        |&lt;-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------&gt;|    Resource   |
|        |                               |     Server    |
|        |&lt;-(F)--- Protected Resource ---|               |
+--------+                               +---------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The abstract OAuth 2.0 flow describes the interaction between the four roles and includes the following steps:</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>The client requests authorization from the resource owner.</p>
<div class="paragraph">
<p>The authorization request can be made directly to the resource owner (as shown), or preferably indirectly via the authorization server as an intermediary.</p>
</div>
</li>
<li>
<p>The client receives an <em>authorization grant</em>, which is a credential representing the resource owner&#8217;s authorization, expressed using one of four <em>grant types</em> defined in this specification (<em>authorization code</em>, <em>implicit</em>, <em>password</em>, <em>client credential</em>) or using an extension grant type.</p>
<div class="paragraph">
<p>The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server.</p>
</div>
</li>
<li>
<p>The client requests an <em>access token</em> by authenticating with the authorization server and presenting the authorization grant.</p>
</li>
<li>
<p>The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token.</p>
</li>
<li>
<p>The client requests the protected resource from the resource server and authenticates by presenting the access token.</p>
</li>
<li>
<p>The resource server validates the access token, and if valid, serves the request.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="client-types">1.3. Client Types</h3>
<div class="paragraph">
<p>OAuth defines two client types, based on their ability to authenticate securely with the authorization server (i.e., ability to maintain the confidentiality of their client credentials):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>confidential</p>
<div class="paragraph">
<p>Clients capable of maintaining the confidentiality of their credentials (e.g., client implemented on a secure server with restricted access to the client credentials), or capable of secure client authentication using other means.</p>
</div>
</li>
<li>
<p>public</p>
<div class="paragraph">
<p>Clients incapable of maintaining the confidentiality of their credentials (e.g., clients executing on the device used by the resource owner, such as an installed native application or a web browser-based application), and incapable of secure client authentication via any other means.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>This specification has been designed around the following client profiles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>web application</p>
<div class="paragraph">
<p>A web application is a confidential client running on a web server.  Resource owners access the client via an HTML user interface rendered in a user-agent on the device used by the resource owner.  The client credentials as well as any access token issued to the client are stored on the web server and are not exposed to or accessible by the resource owner.</p>
</div>
</li>
<li>
<p>user-agent-based application</p>
<div class="paragraph">
<p>A user-agent-based application is a public client in which the client code is downloaded from a web server and executes within a user-agent (e.g., web browser) on the device used by the resource owner.  Protocol data and credentials are easily accessible (and often visible) to the resource owner.  Since such applications reside within the user-agent, they can make seamless use of the user-agent capabilities when requesting authorization.</p>
</div>
</li>
<li>
<p>native application</p>
<div class="paragraph">
<p>A native application is a public client installed and executed on the device used by the resource owner.  Protocol data and credentials are accessible to the resource owner.  It is assumed that any client authentication credentials included in the application can be extracted.  On the other hand, dynamically issued credentials such as access tokens or refresh tokens can receive an acceptable level of protection.  At a minimum, these credentials are protected from hostile servers with which the application may interact.  On some platforms, these credentials might be protected from other applications residing on the same device.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="authorization-grant">1.4. Authorization Grant</h3>
<div class="paragraph">
<p>An authorization grant is a credential representing the resource owner&#8217;s authorization (to access its protected resources) used by the client to obtain an access token.</p>
</div>
<div class="paragraph">
<p>This specification defines four grant types&#8201;&#8212;&#8201;<em>authorization code</em>, <em>implicit</em>, <em>resource owner password credentials</em>, and <em>client credentials</em>&#8201;&#8212;&#8201;as well as an extensibility mechanism for defining additional types. <a href="#RFC6749">[RFC6749]</a></p>
</div>
<div class="sect3">
<h4 id="authorization-code-grant">1.4.1. Authorization Code Grant</h4>
<div class="paragraph">
<p>The authorization code grant type is used to obtain both access tokens and refresh tokens and is optimized for confidential clients. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server.</p>
</div>
<div class="listingblock text-left">
<div class="content">
<pre>+----------+
| Resource |
|   Owner  |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier      +---------------+
|         -+----(A)-- &amp; Redirection URI ----&gt;|               |
|  User-   |                                 | Authorization |
|  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
|          |                                 |               |
|         -+----(C)-- Authorization Code ---&lt;|               |
+-|----|---+                                 +---------------+
  |    |                                         ^      v
 (A)  (C)                                        |      |
  |    |                                         |      |
  ^    v                                         |      |
+---------+                                      |      |
|         |&gt;---(D)-- Authorization Code ---------'      |
|  Client |          &amp; Redirection URI                  |
|         |                                             |
|         |&lt;---(E)----- Access Token -------------------'
+---------+       (w/ Optional Refresh Token)</pre>
</div>
</div>
<div class="paragraph">
<p>The flow includes the following steps:</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>The client initiates the flow by directing the resource owner&#8217;s
user-agent to the authorization endpoint.  The client includes
its client identifier, requested scope, local state, and a
redirection URI to which the authorization server will send the
user-agent back once access is granted (or denied).</p>
</li>
<li>
<p>The authorization server authenticates the resource owner (via
the user-agent) and establishes whether the resource owner
grants or denies the client&#8217;s access request.</p>
</li>
<li>
<p>Assuming the resource owner grants access, the authorization
server redirects the user-agent back to the client using the
redirection URI provided earlier (in the request or during
client registration).  The redirection URI includes an
authorization code and any local state provided by the client
earlier.</p>
</li>
<li>
<p>The client requests an access token from the authorization
server&#8217;s token endpoint by including the authorization code
received in the previous step.  When making the request, the
client authenticates with the authorization server.  The client
includes the redirection URI used to obtain the authorization
code for verification.</p>
</li>
<li>
<p>The authorization server authenticates the client, validates the
authorization code, and ensures that the redirection URI
received matches the URI used to redirect the client in
step (C).  If valid, the authorization server responds back with
an access token and, optionally, a refresh token.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="implicit-grant">1.4.2. Implicit Grant</h4>
<div class="paragraph">
<p>The implicit grant type is used to obtain access tokens (it does not
   support the issuance of refresh tokens) and is optimized for public
   clients known to operate a particular redirection URI.  These clients
   are typically implemented in a browser using a scripting language
   such as JavaScript.</p>
</div>
<div class="paragraph">
<p>Since this is a redirection-based flow, the client must be capable of
   interacting with the resource owner&#8217;s user-agent (typically a web
   browser) and capable of receiving incoming requests (via redirection)
   from the authorization server.</p>
</div>
<div class="paragraph">
<p>Unlike the authorization code grant type, in which the client makes
   separate requests for authorization and for an access token, the
   client receives the access token as the result of the authorization
   request.</p>
</div>
<div class="paragraph">
<p>The implicit grant type does not include client authentication, and
   relies on the presence of the resource owner and the registration of
   the redirection URI.  Because the access token is encoded into the
   redirection URI, it may be exposed to the resource owner and other
   applications residing on the same device.</p>
</div>
<div class="listingblock text-left">
<div class="content">
<pre>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier     +---------------+
|         -+----(A)-- &amp; Redirection URI ---&gt;|               |
|  User-   |                                | Authorization |
|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
|          |                                |               |
|          |&lt;---(C)--- Redirection URI ----&lt;|               |
|          |          with Access Token     +---------------+
|          |            in Fragment
|          |                                +---------------+
|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
|          |          without Fragment      |     Client    |
|          |                                |    Resource   |
|     (F)  |&lt;---(E)------- Script ---------&lt;|               |
|          |                                +---------------+
+-|--------+
  |    |
 (A)  (G) Access Token
  |    |
  ^    v
+---------+
|         |
|  Client |
|         |
+---------+</pre>
</div>
</div>
<div class="paragraph">
<p>The flow includes the following steps:</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>The client initiates the flow by directing the resource owner&#8217;s
user-agent to the authorization endpoint.  The client includes
its client identifier, requested scope, local state, and a
redirection URI to which the authorization server will send the
user-agent back once access is granted (or denied).</p>
</li>
<li>
<p>The authorization server authenticates the resource owner (via
the user-agent) and establishes whether the resource owner
grants or denies the client&#8217;s access request.</p>
</li>
<li>
<p>Assuming the resource owner grants access, the authorization
server redirects the user-agent back to the client using the
redirection URI provided earlier.  The redirection URI includes
the access token in the URI fragment.</p>
</li>
<li>
<p>The user-agent follows the redirection instructions by making a
request to the web-hosted client resource (which does not
include the fragment per [RFC2616]).  The user-agent retains the
fragment information locally.</p>
</li>
<li>
<p>The web-hosted client resource returns a web page (typically an
HTML document with an embedded script) capable of accessing the
full redirection URI including the fragment retained by the
user-agent, and extracting the access token (and other
parameters) contained in the fragment.</p>
</li>
<li>
<p>The user-agent executes the script provided by the web-hosted
client resource locally, which extracts the access token.</p>
</li>
<li>
<p>The user-agent passes the access token to the client.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="resource-owner-password-credentials-grant">1.4.3. Resource Owner Password Credentials Grant</h4>
<div class="paragraph">
<p>The resource owner password credentials grant type is suitable in
   cases where the resource owner has a trust relationship with the
   client, such as the device operating system or a highly privileged
   application.  The authorization server should take special care when
   enabling this grant type and only allow it when other flows are not
   viable.</p>
</div>
<div class="paragraph">
<p>This grant type is suitable for clients capable of obtaining the
   resource owner&#8217;s credentials (username and password, typically using
   an interactive form).  It is also used to migrate existing clients
   using direct authentication schemes such as HTTP Basic or Digest
   authentication to OAuth by converting the stored credentials to an
   access token.</p>
</div>
<div class="listingblock text-left">
<div class="content">
<pre>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     v
     |    Resource Owner
    (A) Password Credentials
     |
     v
+---------+                                  +---------------+
|         |&gt;--(B)---- Resource Owner -------&gt;|               |
|         |         Password Credentials     | Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(C)---- Access Token ---------&lt;|               |
|         |    (w/ Optional Refresh Token)   |               |
+---------+                                  +---------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The flow includes the following steps:</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>The resource owner provides the client with its username and
password.</p>
</li>
<li>
<p>The client requests an access token from the authorization
server&#8217;s token endpoint by including the credentials received
from the resource owner.  When making the request, the client
authenticates with the authorization server.</p>
</li>
<li>
<p>The authorization server authenticates the client and validates
the resource owner credentials, and if valid, issues an access
token.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="client-credentials-grant">1.4.4. Client Credentials Grant</h4>
<div class="paragraph">
<p>The client can request an access token using only its client
   credentials (or other supported means of authentication) when the
   client is requesting access to the protected resources under its
   control, or those of another resource owner that have been previously
   arranged with the authorization server (the method of which is beyond
   the scope of this specification).</p>
</div>
<div class="paragraph">
<p>The client credentials grant type MUST only be used by confidential
   clients.</p>
</div>
<div class="listingblock text-left">
<div class="content">
<pre>+---------+                                  +---------------+
|         |                                  |               |
|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(B)---- Access Token ---------&lt;|               |
|         |                                  |               |
+---------+                                  +---------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The flow includes the following steps:</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>The client authenticates with the authorization server and
requests an access token from the token endpoint.</p>
</li>
<li>
<p>The authorization server authenticates the client, and if valid,
issues an access token.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access-token">1.5. Access Token</h3>
<div class="paragraph">
<p>Access tokens are credentials used to access protected resources.</p>
</div>
<div class="paragraph">
<p>An access token is a string representing an authorization issued to the client. The string is usually opaque to the client.</p>
</div>
<div class="paragraph">
<p>Tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server.</p>
</div>
<div class="paragraph">
<p>The token may denote an identifier used to retrieve the authorization information or may self-contain the authorization information in a verifiable manner (i.e., a token string consisting of some data and a signature).</p>
</div>
<div class="paragraph">
<p>The access token provides an abstraction layer, replacing different authorization constructs (e.g., username and password) with a single token understood by the resource server.</p>
</div>
<div class="paragraph">
<p>This abstraction enables issuing access tokens more restrictive than the authorization grant used to obtain them, as well as removing the resource server&#8217;s need to understand a wide range of authentication methods.</p>
</div>
<div class="paragraph">
<p>Access tokens can have different formats, structures, and methods of utilization (e.g., cryptographic properties) based on the resource server security requirements.</p>
</div>
<div class="paragraph">
<p>Access token attributes and the methods used to access protected resources are beyond the scope of this specification and are defined by companion specifications such as <a href="#RFC6750">[RFC6750]</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="refresh-token">1.6. Refresh Token</h3>
<div class="paragraph">
<p>Refresh tokens are credentials used to obtain access tokens.</p>
</div>
<div class="paragraph">
<p>Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner).</p>
</div>
<div class="paragraph">
<p>Issuing a refresh token is optional at the discretion of the authorization server.</p>
</div>
<div class="paragraph">
<p>If the authorization server issues a refresh token, it is included when issuing an access token (i.e., step (D) in the above protocol flow).</p>
</div>
<div class="paragraph">
<p>A refresh token is a string representing the authorization granted to the client by the resource owner.  The string is usually opaque to the client.</p>
</div>
<div class="paragraph">
<p>The token denotes an identifier used to retrieve the authorization information.</p>
</div>
<div class="paragraph">
<p>Unlike access tokens, refresh tokens are intended for use only with authorization servers and are never sent to resource servers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant ---------&gt;|               |
  |        |                                           |               |
  |        |&lt;-(B)----------- Access Token -------------|               |
  |        |               &amp; Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&lt;-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&lt;-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token -----------&gt;|               |
  |        |                                           |               |
  |        |&lt;-(H)----------- Access Token -------------|               |
  +--------+           &amp; Optional Refresh Token        +---------------+</code></pre>
</div>
</div>
<div class="paragraph">
<p>The flow refreshing an expired access token includes the following steps:</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>The client requests an access token by authenticating with the authorization server and presenting an authorization grant.</p>
</li>
<li>
<p>The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token and a refresh token.</p>
</li>
<li>
<p>The client makes a protected resource request to the resource server by presenting the access token.</p>
</li>
<li>
<p>The resource server validates the access token, and if valid, serves the request.</p>
</li>
<li>
<p>Steps (C) and (D) repeat until the access token expires.</p>
<div class="paragraph">
<p>If the client knows the access token expired, it skips to step (G); otherwise, it makes another protected resource request.</p>
</div>
</li>
<li>
<p>Since the access token is invalid, the resource server returns an invalid token error.</p>
</li>
<li>
<p>The client requests a new access token by authenticating with the authorization server and presenting the refresh token.</p>
<div class="paragraph">
<p>The client authentication requirements are based on the client type and on the authorization server policies.</p>
</div>
</li>
<li>
<p>The authorization server authenticates the client and validates the refresh token, and if valid, issues a new access token (and, optionally, a new refresh token).</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="openid-connect">1.7. OpenID Connect</h3>
<div class="paragraph">
<p>OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. <a href="#OIDC">[OIDC]</a></p>
</div>
<div class="paragraph">
<p>The OpenID Connect flow looks the same as OAuth. The only differences are, in the initial request, a specific scope of <em>openid</em> is used, and in the final exchange the <em>client</em> receives both an <em>access token</em> and an <em>id token</em>. <a href="#IGOID">[IGOID]</a></p>
</div>
<div class="paragraph">
<p>The primary extension that OpenID Connect makes to OAuth 2.0 to enable End-Users to be Authenticated is the ID Token data structure. <a href="#OIDCT">[OIDCT]</a></p>
</div>
<div class="paragraph">
<p>The <strong>ID Token</strong> is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when using a Client, and potentially other requested Claims. The ID Token is represented as a JSON Web Token (JWT) <a href="#JWTIO">[JWTIO]</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="what-is-json-web-token">2. What is JSON Web Token?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS <a href="#RFC7515">[RFC7515]</a>) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. <a href="#RFC7519">[RFC7519]</a></p>
</div>
<div class="paragraph">
<p>The suggested pronunciation of JWT is the same as the English word "jot".</p>
</div>
<div class="listingblock">
<div class="title">Terminology</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="text">JSON Web Token (JWT)
   A string representing a set of claims as a JSON object that is
   encoded in a JWS or JWE, enabling the claims to be digitally
   signed or MACed and/or encrypted.

JWT Claims Set
   A JSON object that contains the claims conveyed by the JWT.

Claim
   A piece of information asserted about a subject.  A claim is
   represented as a name/value pair consisting of a Claim Name and a
   Claim Value.

Claim Name
   The name portion of a claim representation.  A Claim Name is
   always a string.

Claim Value
   The value portion of a claim representation.  A Claim Value can be
   any JSON value.

Base64url Encoding [RFC7515]
   Base64 encoding using the URL- and filename-safe character set
   defined in Section 5 of RFC 4648 [RFC4648], with all trailing '='
   characters omitted (as permitted by Section 3.2) and without the
   inclusion of any line breaks, whitespace, or other additional
   characters.  Note that the base64url encoding of the empty octet
   sequence is the empty string.  (See Appendix C for notes on
   implementing base64url encoding without padding.)</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="json-web-token-jwt-overview">2.1. JSON Web Token (JWT) Overview</h3>
<div class="paragraph">
<p>JWTs represent a set of claims as a JSON object (i.e. JWT Claims Set) that is encoded in a JWS and/or JWE structure.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The JSON object consists of zero or more name/value pairs (or members), where the names are strings and the values are arbitrary JSON values.</p>
<div class="ulist">
<ul>
<li>
<p>These members are the claims represented by the JWT.</p>
</li>
<li>
<p>The member names within the JWT Claims Set are referred to as Claim Names.</p>
<div class="paragraph">
<p>The corresponding values are referred to as Claim Values.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The contents of the JOSE Header describe the cryptographic operations applied to the JWT Claims Set.</p>
<div class="ulist">
<ul>
<li>
<p>If the JOSE Header is for a JWS, the JWT is represented as a JWS and the claims are digitally signed or MACed, with the JWT Claims Set being the JWS Payload.</p>
</li>
<li>
<p>If the JOSE Header is for a JWE, the JWT is represented as a JWE and the claims are encrypted, with the JWT Claims Set being the plaintext encrypted by the JWE.</p>
</li>
<li>
<p>A JWT may be enclosed in another JWE or JWS structure to create a Nested JWT, enabling nested signing and encryption to be performed.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>A JWT is represented as a sequence of URL-safe parts separated by period (<code>.</code>) characters.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each part contains a base64url-encoded value.</p>
</li>
<li>
<p>The number of parts in the JWT is dependent upon the representation of the resulting JWS using the JWS Compact Serialization or JWE using the JWE Compact Serialization.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="what-is-the-json-web-token-structure">2.2. What is the JSON Web Token structure?</h3>
<div class="paragraph">
<p>In its compact form, JSON Web Tokens consist of three parts separated by dots (<code>.</code>), which are: <a href="#JWTIO">[JWTIO]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Header</p>
</li>
<li>
<p>Payload</p>
</li>
<li>
<p>Signature</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore, a JWT typically looks like the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><span class="err">xxxxx.yyyyy.zzzzz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s break down the different parts.</p>
</div>
<div class="sect3">
<h4 id="header">2.2.1. Header</h4>
<div class="paragraph">
<p>The header <em>typically</em> consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"alg"</span><span class="p">:</span><span class="w"> </span><span class="s2">"HS256"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"typ"</span><span class="p">:</span><span class="w"> </span><span class="s2">"JWT"</span><span class="w">
</span><span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, this JSON is <em>Base64Url</em> encoded to form the first part of the JWT.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>header.json | jq <span class="nt">-cj</span> | <span class="nb">base64</span> <span class="nt">-w0</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">'='</span>
<span class="go">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="payload">2.2.2. Payload</h4>
<div class="paragraph">
<p>The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: <em>registered</em>, <em>public</em>, and <em>private</em> claims.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519#section-4.1">Registered claims</a></p>
<div class="paragraph">
<p>These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims.</p>
</div>
<div class="paragraph">
<p>Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and <a href="https://tools.ietf.org/html/rfc7519#section-4.1">others</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Notice that the claim names are only three characters long as JWT is meant to be compact.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519#section-4.2">Public claims</a></p>
<div class="paragraph">
<p>These can be defined at will by those using JWTs.</p>
</div>
<div class="paragraph">
<p>But to avoid collisions they should be defined in the <a href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web Token Registry</a> or be defined as a URI that contains a collision resistant namespace.</p>
</div>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519#section-4.3">Private claims</a></p>
<div class="paragraph">
<p>These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>An example payload could be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"sub"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1234567890"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"John Doe"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"admin"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The payload is then <em>Base64Url</em> encoded to form the second part of the JSON Web Token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>payload.json | jq <span class="nt">-cj</span> | <span class="nb">base64</span> <span class="nt">-w0</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">'='</span>
<span class="go">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do note that for signed tokens this information, though protected against tampering, is readable by anyone. Do not put secret information in the payload or header elements of a JWT unless it is encrypted.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="signature">2.2.3. Signature</h4>
<div class="paragraph">
<p>To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.</p>
</div>
<div class="paragraph">
<p>For example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="js"><span class="nc">HMACSHA256</span><span class="p">(</span>
  <span class="nf">base64UrlEncode</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span> <span class="o">+</span>
  <span class="nf">base64UrlEncode</span><span class="p">(</span><span class="nx">payload</span><span class="p">),</span>
  <span class="nx">secret</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The signature is used to verify the message wasn&#8217;t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is.</p>
</div>
</div>
<div class="sect3">
<h4 id="putting-all-together">2.2.4. Putting all together</h4>
<div class="paragraph">
<p>The output is three Base64-URL strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML.</p>
</div>
<div class="paragraph">
<p>The following shows a JWT that has the previous header and payload encoded, and it is signed with a secret (<code>123456</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.Wwu4TUUE86MPyFGhmv3D0Ct4GqkthRQDPKBwOQAAwJc</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="microsoft-identity-platform">3. Microsoft identity platform</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Microsoft identity platform helps you build applications your users and customers can sign in to using their Microsoft identities or social accounts. It authorizes access to your own APIs or Microsoft APIs like Microsoft Graph.</p>
</div>
<div class="paragraph">
<p>There are several components that make up the Microsoft identity platform:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>OAuth 2.0 and OpenID Connect standard-compliant authentication service</strong> enabling developers to authenticate several identity types, including:</p>
<div class="ulist">
<ul>
<li>
<p>Work or school accounts, provisioned through Azure AD</p>
</li>
<li>
<p>Personal Microsoft accounts (Skype, Xbox, Outlook.com)</p>
</li>
<li>
<p>Social or local accounts, by using Azure AD B2C</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Open-source libraries</strong>: Microsoft Authentication Library (MSAL) and support for other standards-compliant libraries.</p>
</li>
<li>
<p><strong>Application management portal</strong>: A registration and configuration experience in the Azure portal, along with the other Azure management capabilities.</p>
</li>
<li>
<p><strong>Application configuration API and PowerShell</strong>: Programmatic configuration of your applications through the Microsoft Graph API and PowerShell so you can automate your DevOps tasks.</p>
</li>
<li>
<p><strong>Developer content</strong>: Technical documentation including quickstarts, tutorials, how-to guides, and code samples.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="authentication-vs-authorization-msadauthnz">3.1. Authentication vs. authorization <a href="#msadauthnz">[msadauthnz]</a></h3>
<div class="paragraph">
<p><strong><em>Authentication</em></strong> is the process of proving that you are who you say you are. This is achieved by verification of the identity of a person or device. It&#8217;s sometimes shortened to <em>AuthN</em>. The Microsoft identity platform uses the <a href="https://openid.net/connect/">OpenID Connect</a> protocol for handling authentication.</p>
</div>
<div class="paragraph">
<p><strong><em>Authorization</em></strong> is the act of granting an authenticated party permission to do something. It specifies what data you&#8217;re allowed to access and what you can do with that data. Authorization is sometimes shortened to <em>AuthZ</em>. The Microsoft identity platform uses the <a href="https://oauth.net/2/">OAuth 2.0</a> protocol for handling authorization.</p>
</div>
<div class="paragraph">
<p><strong><em>Multifactor authentication</em></strong> is the act of providing an additional factor of authentication to an account. This is often used to protect against brute force attacks. It is sometimes shortened to <em>MFA</em> or <em>2FA</em>. The <a href="https://support.microsoft.com/account-billing/set-up-the-microsoft-authenticator-app-as-your-verification-method-33452159-6af9-438f-8f82-63ce94cf3d29">Microsoft Authenticator</a> can be used as an app for handling two-factor authentication. For more information, see <a href="https://learn.microsoft.com/en-us/azure/active-directory/authentication/concept-mfa-howitworks">multifactor authentication</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="oauth-2-0-and-openid-connect-oidc-in-the-microsoft-identity-platform">3.2. OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform</h3>
<div class="sect3">
<h4 id="roles-in-oauth-2-0">3.2.1. Roles in OAuth 2.0</h4>
<div class="paragraph">
<p>Four parties are generally involved in an OAuth 2.0 and OpenID Connect authentication and authorization exchange. These exchanges are often called <em>authentication flows</em> or <em>auth flows</em>. <a href="#msadouth2">[msadouth2]</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/azure/active-directory/develop/media/active-directory-v2-flows/protocols-roles.svg" alt="Diagram showing the OAuth 2.0 roles" width="35%" height="35%">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Authorization server</strong> - The identity platform is the authorization server. Also called an <em>identity provider</em> or <em>IdP</em>, it securely handles the end-user&#8217;s information, their access, and the trust relationships between the parties in the auth flow. The authorization server issues the security tokens your apps and APIs use for granting, denying, or revoking access to resources (authorization) after the user has signed in (authenticated).</p>
</li>
<li>
<p><strong>Client</strong> - The client in an OAuth exchange is the application requesting access to a protected resource. The client could be a web app running on a server, a single-page web app running in a user&#8217;s web browser, or a web API that calls another web API. You&#8217;ll often see the client referred to as <em>client application</em>, <em>application</em>, or <em>app</em>.</p>
</li>
<li>
<p><strong>Resource owner</strong> - The resource owner in an auth flow is usually the application user, or <em>end-user</em> in OAuth terminology. The end-user "owns" the protected resource (their data) which your app accesses on their behalf. The resource owner can grant or deny your app (the client) access to the resources they own. For example, your app might call an external system&#8217;s API to get a user&#8217;s email address from their profile on that system. Their profile data is a resource the end-user owns on the external system, and the end-user can consent to or deny your app&#8217;s request to access their data.</p>
</li>
<li>
<p><strong>Resource server</strong> - The resource server hosts or provides access to a resource owner&#8217;s data. Most often, the resource server is a web API fronting a data store. The resource server relies on the authorization server to perform authentication and uses information in bearer tokens issued by the authorization server to grant or deny access to resources.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="tokens">3.2.2. Tokens</h4>
<div class="paragraph">
<p>The parties in an authentication flow use <strong>bearer tokens</strong> to assure, verify, and authenticate a principal (user, host, or service) and to grant or deny access to protected resources (authorization). Bearer tokens in the identity platform are formatted as <a href="https://tools.ietf.org/html/rfc7519">JSON Web Tokens</a> (JWT).</p>
</div>
<div class="paragraph">
<p>Three types of bearer tokens are used by the identity platform as <em>security tokens</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/access-tokens">Access tokens</a> - Access tokens are issued by the authorization server to the client application. The client passes access tokens to the resource server. Access tokens contain the permissions the client has been granted by the authorization server.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/id-tokens">ID tokens</a> - ID tokens are issued by the authorization server to the client application. Clients use ID tokens when signing in users and to get basic information about them.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/refresh-tokens">Refresh tokens</a> - The client uses a refresh token, or RT, to request new access and ID tokens from the authorization server. Your code should treat refresh tokens and their string content as sensitive data because they&#8217;re intended for use only by authorization server.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="app-registration">3.2.3. App registration</h4>
<div class="paragraph">
<p>Your client app needs a way to trust the security tokens issued to it by the identity platform. The first step in establishing trust is by <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app">registering your app</a>. When you register your app, the identity platform automatically assigns it some values, while others you configure based on the application&#8217;s type.</p>
</div>
<div class="paragraph">
<p>Two of the most commonly referenced app registration settings are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Application (client) ID</strong> - Also called <em>application ID</em> and <em>client ID</em>, this value is assigned to your app by the identity platform. The client ID uniquely identifies your app in the identity platform and is included in the security tokens the platform issues.</p>
</li>
<li>
<p><strong>Redirect URI</strong> - The authorization server uses a redirect URI to direct the resource owner&#8217;s <em>user-agent</em> (web browser, mobile app) to another destination after completing their interaction. For example, after the end-user authenticates with the authorization server. Not all client types use redirect URIs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Your app&#8217;s registration also holds information about the authentication and authorization <em>endpoints</em> you&#8217;ll use in your code to get ID and access tokens.</p>
</div>
</div>
<div class="sect3">
<h4 id="endpoints">3.2.4. Endpoints</h4>
<div class="paragraph">
<p>The identity platform offers authentication and authorization services using standards-compliant implementations of OAuth 2.0 and OpenID Connect (OIDC) 1.0. Standards-compliant authorization servers like the identity platform provide a set of HTTP endpoints for use by the parties in an auth flow to execute the flow.</p>
</div>
<div class="paragraph">
<p>The endpoint URIs for your app are generated automatically when you register or configure your app. The endpoints you use in your app&#8217;s code depend on the application&#8217;s type and the identities (account types) it should support.</p>
</div>
<div class="paragraph">
<p>Two commonly used endpoints are the <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-authorization-code">authorization endpoint</a> and <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#redeem-a-code-for-an-access-token">token endpoint</a>. Here are examples of the authorize and token endpoints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Authorization endpoint - used by client to obtain authorization from the resource owner.</span>
https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/authorize
<span class="c"># Token endpoint - used by client to exchange an authorization grant or refresh token for an access token.</span>
https://login.microsoftonline.com/&lt;issuer&gt;/oauth2/v2.0/token

<span class="c"># NOTE:</span>
<span class="c">#   These are examples. Endpoint URI format may vary based on application type,</span>
<span class="c">#   sign-in audience, and Azure cloud instance (global or national cloud).</span>

<span class="c">#   The {issuer} value in the path of the request can be used to control who can sign into the application.</span>
<span class="c">#   The allowed values are **common** for both Microsoft accounts and work or school accounts,</span>
<span class="c">#   **organizations** for work or school accounts only, **consumers** for Microsoft accounts only,</span>
<span class="c">#   and **tenant identifiers** such as the tenant ID or domain name.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To find the endpoints for an application you&#8217;ve registered, in the <a href="https://portal.azure.com/">Azure portal</a> navigate to: <strong>Azure Active Directory</strong> &gt; <strong>App registrations</strong> &gt; &lt;YOUR-APPLICATION&gt; &gt; <strong>Endpoints</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="openid-connect-on-the-microsoft-identity-platform">3.3. OpenID Connect on the Microsoft identity platform</h3>
<div class="paragraph">
<p>OpenID Connect (OIDC) extends the OAuth 2.0 authorization protocol for use as an additional authentication protocol. You can use OIDC to enable single sign-on (SSO) between your OAuth-enabled applications by using a security token called an <em>ID token</em>. <a href="#msadoidc">[msadoidc]</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/azure/active-directory/develop/media/v2-protocols-oidc/convergence-scenarios-webapp.svg" alt="Swim-lane diagram showing the OpenID Connect protocol&#8217;s sign-in flow." width="75%" height="75%">
</div>
<div class="title">Figure 1. The basic OpenID Connect sign-in flow</div>
</div>
<div class="paragraph">
<p>The <em>ID token</em> introduced by OpenID Connect is issued by the authorization server, the Microsoft identity platform, when the client application requests one during user authentication. The ID token enables a client application to verify the identity of the user and to get other information (claims) about them.</p>
</div>
<div class="paragraph">
<p>ID tokens aren&#8217;t issued by default for an application registered with the Microsoft identity platform. ID tokens for an application are enabled by using one of the following methods:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Navigate to the <a href="https://portal.azure.com/">Azure portal</a> and select <strong>Azure Active Directory</strong> &gt; <strong>App registrations</strong> &gt; &lt;<em>your application</em>&gt; &gt; <strong>Authentication</strong>.</p>
</li>
<li>
<p>Under <strong>Implicit grant and hybrid flows</strong>, select the <strong>ID tokens (used for implicit and hybrid flows)</strong> checkbox.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Or:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Azure Active Directory</strong> &gt; <strong>App registrations</strong> &gt; &lt;<em>your application</em>&gt; &gt; <strong>Manifest</strong>.</p>
</li>
<li>
<p>Set <code>oauth2AllowIdTokenImplicitFlow</code> to <code>true</code> in the app registration&#8217;s <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/reference-app-manifest">application manifest</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If ID tokens are not enabled for your app and one is requested, the Microsoft identity platform returns an <code>unsupported_response</code> error similar to:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The provided value for the input parameter 'response_type' isn&#8217;t allowed for this client. Expected value is 'code'.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="authentication-flows-and-application-scenarios">3.4. Authentication flows and application scenarios</h3>
<div class="paragraph">
<p>The Microsoft identity platform supports authentication for different kinds of modern application architectures. All of the architectures are based on the industry-standard protocols <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols">OAuth 2.0 and OpenID Connect</a>. By using the authentication libraries for the Microsoft identity platform, applications authenticate identities and acquire tokens to access protected APIs.</p>
</div>
<div class="paragraph">
<p>This article describes authentication flows and the application scenarios that they&#8217;re used in. <a href="#msadscene">[msadscene]</a></p>
</div>
<div class="sect3">
<h4 id="application-categories">3.4.1. Application categories</h4>
<div class="paragraph">
<p>Tokens can be acquired from several types of applications, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Web apps</p>
</li>
<li>
<p>Mobile apps</p>
</li>
<li>
<p>Desktop apps</p>
</li>
<li>
<p>Web APIs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tokens can also be acquired by apps running on devices that don&#8217;t have a browser or are running on the Internet of Things (IoT).</p>
</div>
<div class="paragraph">
<p>The following sections describe the categories of applications.</p>
</div>
<div class="sect4">
<h5 id="protected-resources-vs-client-applications">3.4.1.1. Protected resources vs. client applications</h5>
<div class="paragraph">
<p>Authentication scenarios involve two activities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Acquiring security tokens for a protected web API</strong>: We recommend that you use the <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/reference-v2-libraries">Microsoft Authentication Library (MSAL)</a>, developed and supported by Microsoft.</p>
</li>
<li>
<p><strong>Protecting a web API or a web app</strong>: One challenge of protecting these resources is validating the security token. On some platforms, Microsoft offers <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/reference-v2-libraries">middleware libraries</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="with-users-or-without-users">3.4.1.2. With users or without users</h5>
<div class="paragraph">
<p>Most authentication scenarios acquire tokens on behalf of signed-in users.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/azure/active-directory/develop/media/scenarios/scenarios-with-users.svg" alt="Scenarios with users" width="65%" height="65%">
</div>
</div>
<div class="paragraph">
<p>However, there are also daemon apps. In these scenarios, applications acquire tokens on behalf of themselves with no user.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/azure/active-directory/develop/media/scenarios/daemon-app.svg" alt="Scenarios with daemon apps" width="35%" height="35%">
</div>
</div>
</div>
<div class="sect4">
<h5 id="single-page-public-client-and-confidential-client-applications">3.4.1.3. Single-page, public client, and confidential client applications</h5>
<div class="paragraph">
<p>Security tokens can be acquired by multiple types of applications. These applications tend to be separated into the following three categories. Each is used with different libraries and objects.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Single-page applications</strong>: Also known as SPAs, these are web apps in which tokens are acquired by a JavaScript or TypeScript app running in the browser. Many modern apps have a single-page application at the front end that&#8217;s primarily written in JavaScript. The application often uses a framework like Angular, React, or Vue. MSAL.js is the only <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/reference-v2-libraries">Microsoft Authentication Library</a> that supports single-page applications.</p>
</li>
<li>
<p><strong>Public client applications</strong>: Apps in this category, like the following types, always sign in users:</p>
<div class="ulist">
<ul>
<li>
<p>Desktop apps that call web APIs on behalf of signed-in users</p>
</li>
<li>
<p>Mobile apps</p>
</li>
<li>
<p>Apps running on devices that don&#8217;t have a browser, like those running on IoT</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Confidential client applications</strong>: Apps in this category include:</p>
<div class="ulist">
<ul>
<li>
<p>Web apps that call a web API</p>
</li>
<li>
<p>Web APIs that call a web API</p>
</li>
<li>
<p>Daemon apps, even when implemented as a console service like a Linux daemon or a Windows service</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="keycloak">4. Keycloak</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.keycloak.org/">Keycloak</a> is an open-source software product that provides identity and access management (IAM) capabilities for modern applications and services. It offers a comprehensive solution for managing user authentication, authorization, and single sign-on (SSO).</p>
</div>
<div class="paragraph">
<p>To <a href="https://www.keycloak.org/getting-started/getting-started-docker">start Keycloak</a> from a terminal, enter the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">docker run <span class="se">\</span>
    <span class="nt">-d</span> <span class="se">\</span>
    <span class="nt">--name</span> keycloak <span class="se">\</span>
    <span class="nt">-p</span> 8080:8080 <span class="se">\</span>
    <span class="nt">-e</span> <span class="nv">KC_BOOTSTRAP_ADMIN_USERNAME</span><span class="o">=</span>admin <span class="se">\</span>
    <span class="nt">-e</span> <span class="nv">KC_BOOTSTRAP_ADMIN_PASSWORD</span><span class="o">=</span>admin <span class="se">\</span>
    quay.io/keycloak/keycloak:26.0.7 <span class="se">\</span>
    start-dev</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="RFC6749"></a>[RFC6749] D. Hardt, Ed., <em>The OAuth 2.0 Authorization Framework</em>, Internet <a href="https://datatracker.ietf.org/doc/html/rfc6749">RFC 6749</a>, Oct 2012.</p>
</li>
<li>
<p><a id="RFC6750"></a>[RFC6750] M. Jones, D. Hardt, <em>The OAuth 2.0 Authorization Framework: Bearer Token Usage</em>, Internet RFC 6750, Oct 2012.</p>
</li>
<li>
<p><a id="RFC7519"></a>[RFC7519] M. Jones, J. Bradley, N. Sakimura, <em>JSON Web Token (JWT)</em>, Internet RFC 7519, May 2015.</p>
</li>
<li>
<p><a id="OIDC"></a>[OIDC] <a href="https://openid.net/connect/" class="bare">https://openid.net/connect/</a></p>
</li>
<li>
<p><a id="IGOID"></a>[IGOID] <em>An Illustrated Guide to OAuth and OpenID Connect</em> [online]. <a href="https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc" class="bare">https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc</a></p>
</li>
<li>
<p><a id="RFC7515"></a>[RFC7515] Jones, M., Bradley, J., and N. Sakimura, <em>JSON Web Signature (JWS)</em>, RFC 7515, DOI 10.17487/RFC, May 2015.</p>
</li>
<li>
<p><a id="JWTIO"></a>[JWTIO] <a href="https://jwt.io/introduction" class="bare">https://jwt.io/introduction</a></p>
</li>
<li>
<p><a id="OIDCT"></a>[OIDCT] <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken" class="bare">https://openid.net/specs/openid-connect-core-1_0.html#IDToken</a></p>
</li>
<li>
<p><a id="msadauthnz"></a>[msadauthnz] <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-vs-authorization" class="bare">https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-vs-authorization</a></p>
</li>
<li>
<p><a id="msadouth2"></a>[msadouth2] <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols" class="bare">https://learn.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols</a></p>
</li>
<li>
<p><a id="msadoidc"></a>[msadoidc] <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc" class="bare">https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc</a></p>
</li>
<li>
<p><a id="msadscene"></a>[msadscene] <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-flows-app-scenarios" class="bare">https://learn.microsoft.com/en-us/azure/active-directory/develop/authentication-flows-app-scenarios</a></p>
</li>
<li>
<p><em>OAuth 2 Simplified • Aaron Parecki</em> [online]. <a href="https://aaronparecki.com/oauth-2-simplified/" class="bare">https://aaronparecki.com/oauth-2-simplified/</a></p>
</li>
<li>
<p><em>OAuth.com - OAuth 2.0 Simplified</em> [online]. <a href="https://www.oauth.com" class="bare">https://www.oauth.com</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/6916805/why-does-a-base64-encoded-string-have-an-sign-at-the-end" class="bare">https://stackoverflow.com/questions/6916805/why-does-a-base64-encoded-string-have-an-sign-at-the-end</a></p>
</li>
<li>
<p><a href="https://superuser.com/questions/1225134/why-does-the-base64-of-a-string-contain-n" class="bare">https://superuser.com/questions/1225134/why-does-the-base64-of-a-string-contain-n</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
