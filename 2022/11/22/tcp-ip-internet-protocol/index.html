<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>TCP/IP: Internet Protocol | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="TCP/IP: Internet Protocol" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. IPv4 and IPv6 Headers 1.1. IP Header Fields 1.2. The Internet Checksum 2. IP Forwarding 2.1. Forwarding Table 2.2. IP Forwarding Actions 2.3. Direct delivery and indirect delivery 3. Mobile IP 3.1. The Basic Model for IP Mobility: Bidirectional Tunneling 4. Host Processing of IP Datagrams 4.1. Host Models References IP is the workhorse protocol of the TCP/IP protocol suite. All TCP, UDP, ICMP, and IGMP data gets transmitted as IP datagrams. IP provides a best-effort, connectionless datagram delivery service. 1. IPv4 and IPv6 Headers The normal size of the IPv4 header is 20 bytes, unless options are present (which is rare). The IPv6 header is twice as large but never has any options, may have extension headers. The most significant bit of headers and datagrams is numbered 0 at the left, and the least significant bit of a 32-bit value is numbered 31 on the right. The 4 bytes in a 32-bit value are transmitted in the following order: bits 0–7 first, then bits 8–15, then 16–23, and bits 24–31 last. This is called big endian byte ordering, which is the byte ordering required for all binary integers in the TCP/IP headers as they traverse a network. It is also called network byte order. Computer CPUs that store binary integers in other formats, such as the little endian format, must convert the header values into network byte order for transmission and back again for reception. $ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian Model name: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz Figure 1. The IPv4 datagram format. The header is of variable size, limited to fifteen 32-bit words (60 bytes) by the 4-bit IHL field. A typical IPv4 header contains 20 bytes (no options). The source and destination addresses are 32 bits long. Most of the second 32-bit word is used for the IPv4 fragmentation function. A header checksum helps ensure that the fields in the header are delivered correctly to the proper destination but does not protect the data. Figure 2. The IPv6 datagram format. The IPv6 header is of fixed size (40 bytes) and contains 128-bit source and destination addresses. The Next Header field is used to indicate the presence and types of additional extension headers that follow the IPv6 header, forming a daisy chain of headers that may include special extensions or processing directives. Application data follows the header chain, usually immediately following a transport-layer header. 1.1. IP Header Fields The first field (only 4 bits or one nibble wide) is the Version field. It contains the version number of the IP datagram: 4 for IPv4 and 6 for IPv6. The headers for both IPv4 and IPv6 share the location of the Version field but no others. Thus, the two protocols are not directly interoperable—a host or router must handle either IPv4 or IPv6 (or both, called dual stack) separately. The Internet Header Length (IHL) field is the number of 32-bit words in the IPv4 header, including any options. Because this is also a 4-bit field, the IPv4 header is limited to a maximum of fifteen 32-bit words or 60 bytes. The normal value of this field (when no options are present) is 5. There is no such field in IPv6 because the header length is fixed at 40 bytes. Following the header length, the original specification of IPv4 [RFC0791] specified a Type of Service (ToS) byte, and IPv6 [RFC2460] specified the equivalent Traffic Class byte. Use of these never became widespread, so eventually this 8-bit field was split into two smaller parts and redefined by a set of RFCs ([RFC3260] [RFC3168][RFC2474] and others). The first 6 bits are now called the Differentiated Services Field (DS Field), and the last 2 bits are the Explicit Congestion Notification (ECN) field or indicator bits. These RFCs now apply to both IPv4 and IPv6. These fields are used for special processing of the datagram when it is forwarded. The Total Length field is the total length of the IPv4 datagram in bytes. Using this field and the IHL field, we know where the data portion of the datagram starts, and its length. Because this is a 16-bit field, the maximum size of an IPv4 datagram (including header) is 65,535 bytes. Although it is possible to send a 65,535-byte IP datagram, most link layers (such as Ethernet) are not able to carry one this large without fragmenting it (chopping it up) into smaller pieces. Furthermore, a host is not required to be able to receive an IPv4 datagram larger than 576 bytes. In IPv6 a host must be able to process a datagram at least as large as the MTU of the link to which it is attached, and the minimum link MTU is 1280 bytes. When an IPv4 datagram is fragmented into multiple smaller fragments, each of which itself is an independent IP datagram, the Total Length field reflects the length of the particular fragment. In IPv6, fragmentation is not supported by the header, and the length is instead given by the Payload Length field. This field measures the length of the IPv6 datagram not including the length of the header; extension headers, however, are included in the Payload Length field. The Identification field helps indentify each datagram sent by an IPv4 host. To ensure that the fragments of one datagram are not confused with those of another, the sending host normally increments an internal counter by 1 each time a datagram is sent (from one of its IP addresses) and copies the value of the counter into the IPv4 Identification field. The Identification, Flags and Fragment Offset fields are most important for implementing fragmentation. In IPv6, this field shows up in the Fragmentation extension header. The Time-to-Live field, or TTL, sets an upper limit on the number of routers through which a datagram can pass. It is initialized by the sender to some value (64 is recommended [RFC1122], although 128 or 255 is not uncommon) and decremented by 1 by every router that forwards the datagram. When this field reaches 0, the datagram is thrown away, and the sender is notified with an ICMP message. This prevents packets from getting caught in the network forever should an unwanted routing loop occur. The Protocol field in the IPv4 header contains a number indicating the type of data found in the payload portion of the datagram. The most common values are 17 (for UDP) and 6 (for TCP). This provides a demultiplexing feature so that the IP protocol can be used to carry payloads of more than one protocol type. Although this field originally specified the transport-layer protocol the datagram is encapsulating, it is now understood to identify the encapsulated protocol, which may or not be a transport protocol. For example, other encapsulations are possible, such as IPv4-in-IPv4 (value 4). The official list of the possible values of the Protocol field is given in the assigned numbers page [AN]. The Next Header field in the IPv6 header generalizes the Protocol field from IPv4. It is used to indicate the type of header following the IPv6 header. This field may contain any values defined for the IPv4 Protocol field, or any of the values associated with the IPv6 extension headers. Decimal Keyword Protocol IPv6 Extension Header Reference 0 HOPOPT IPv6 Hop-by-Hop Option Y [RFC8200] 1 ICMP Internet Control Message [RFC792] 2 IGMP Internet Group Management [RFC1112] 3 GGP Gateway-to-Gateway [RFC823] 4 IPv4 IPv4 encapsulation [RFC2003] 6 TCP Transmission Control [RFC9293] 8 EGP Exterior Gateway Protocol [RFC888][David_Mills] 9 IGP any private interior gateway (used by Cisco for their IGRP) [Internet_Assigned_Numbers_Authority] 17 UDP User Datagram [RFC768][Jon_Postel] 33 DCCP Datagram Congestion Control Protocol [RFC4340] 41 IPv6 IPv6 encapsulation [RFC2473] 43 IPv6-Route Routing Header for IPv6 Y [Steve_Deering] 44 IPv6-Frag Fragment Header for IPv6 Y [Steve_Deering] 50 ESP Encap Security Payload Y [RFC4303] 51 AH Authentication Header Y [RFC4302] 58 IPv6-ICMP ICMP for IPv6 [RFC8200] 59 IPv6-NoNxt No Next Header for IPv6 [RFC8200] 60 IPv6-Opts Destination Options for IPv6 Y [RFC8200] 108 IPComp IP Payload Compression Protocol [RFC2393] 115 L2TP Layer Two Tunneling Protocol [RFC3931][Bernard_Aboba] 132 SCTP Stream Control Transmission Protocol [Randall_R_Stewart] The Header Checksum field is calculated over the IPv4 header only. This is important to understand because it means that the payload of the IPv4 datagram (e.g., TCP or UDP data) is not checked for correctness by the IP protocol. Perhaps surprisingly, the IPv6 header does not have any checksum field. Every IP datagram contains the Source IP Address of the sender of the datagram and the Destination IP Address of where the datagram is destined. These are 32-bit values for IPv4 and 128-bit values for IPv6, and they usually identify a single interface on a computer, although multicast and broadcast addresses violate this rule. 1.2. The Internet Checksum The Internet checksum is a 16-bit mathematical sum used to determine, with reasonably high probability, whether a received message or portion of a message matches the one sent. Note that the Internet checksum algorithm is not the same as the common cyclic redundancy check (CRC), which offers stronger protection. To compute the IPv4 header checksum for an outgoing datagram, the value of the datagram&#8217;s Checksum field is first set to 0. Then, the 16-bit one&#8217;s complement sum of the header is calculated (the entire header is considered a sequence of 16-bit words). The 16-bit one&#8217;s complement of this sum is then stored in the Checksum field to make the datagram ready for transmission. One&#8217;s complement addition can be implemented by &quot;end-round-carry addition&quot;: when a carry bit is produced using conventional (two&#8217;s complement) addition, the carry is added back in as a 1 value. When an IPv4 datagram is received, a checksum is computed across the whole header, including the value of the Checksum field itself. Assuming there are no errors, the computed checksum value is always 0 (a one&#8217;s complement of the value FFFF). Note that for any nontrivial packet or header, the value of the Checksum field in the packet can never be FFFF. If it were, the sum (prior to the final one&#8217;s complement operation at the sender) would have to have been 0. No sum can ever be 0 using one&#8217;s complement addition unless all the bytes are 0—something that never happens with any legitimate IPv4 header. When the header is found to be bad (the computed checksum is nonzero), the IPv4 implementation discards the received datagram. No error message is generated. It is up to the higher layers to somehow detect the missing datagram and retransmit if necessary. Figure 3. The Internet checksum is the one&#8217;s complement of a one&#8217;s complement 16-bit sum of the data being checksummed (zero padding is used if the number of bytes being summed is odd). If the data being summed includes a Checksum field, the field is first set to 0 prior to the checksum operation and then filled in with the computed checksum. To check whether an incoming block of data that contains a Checksum field (header, payload, etc.) is valid, the same type of checksum is computed over the whole block (including the Checksum field). Because the Checksum field is essentially the inverse of the checksum of the rest of the data, computing the checksum on correctly received data should produce a value of 0. 45 10 01 48 00 00 00 00 10 11 70 c4 c0 a8 5b fe c0 a8 5b 82 | 45 10 | Version, IHL, DS, ECN | 0100 0101 0001 0000 | 01 48 | Total Length | 0000 0001 0100 1000 =&gt; 0100 0110 0101 1000 | 00 00 | Identification | 0000 0000 0000 0000 =&gt; 0100 0110 0101 1000 | 00 00 | Flags, Fragment Offset | 0000 0000 0000 0000 =&gt; 0100 0110 0101 1000 | 10 11 | TTL, Protocol | 0001 0000 0001 0001 =&gt; 0101 0110 0110 1001 | 70 c4 | Checksum | 0111 0000 1100 0100 =&gt; 0101 0110 0110 1001 | c0 a8 | Source Address | 1100 0000 1010 1000 1 0001 0111 0001 0001 + 1 =&gt; 0001 0111 0001 0010 # round-carry | 5b fe | Source Address | 0101 1011 1111 1110 =&gt; 0111 0011 0001 0000 | c0 a8 | Destination Address | 1100 0000 1010 1000 =&gt; 0011 0011 1011 1001 # round-carry | 5b 82 | Destination Address | 0101 1011 1000 0010 =&gt; 1000 1111 0011 1011 =&gt; 0111 0000 1100 0100 # one&#39;s complement (i.e. checksum) =&gt; 1111 1111 1111 1111 # computed including the Checksum field =&gt; 0000 0000 0000 0000 # one&#39;s complement (correct) 2. IP Forwarding Conceptually, IP forwarding is simple, especially for a host. If the destination is directly connected to the host (e.g., a point-to-point link) or on a shared network (e.g., Ethernet), the IP datagram is sent directly to the destination—a router is not required or used. Otherwise, the host sends the datagram to a single router (called the default router) and lets the router deliver the datagram to its destination. What differentiates a host from a router to IP is how IP datagrams are handled: a host never forwards datagrams it does not originate, whereas routers do. In our general scheme, the IP protocol can receive a datagram either from another protocol on the same machine (TCP, UDP, etc.) or from a network interface. The IP layer has some information in memory, usually called a routing table or forwarding table, which it searches each time it receives a datagram to send. When a datagram is received from a network interface, IP first checks if the destination IP address is one of its own IP addresses (i.e., one of the IP addresses associated with one of its network interfaces) or some other address for which it should receive traffic such as an IP broadcast or multicast address. If so, the datagram is delivered to the protocol module specified by the Protocol field in the IPv4 header or Next Header field in the IPv6 header. If the datagram is not destined for one of the IP addresses being used locally by the IP module, then (1) if the IP layer was configured to act as a router, the datagram is forwarded; or (2) the datagram is silently discarded. Under some circumstances (e.g., no route is known in case 1), an ICMP message may be sent back to the source indicating an error condition. 2.1. Forwarding Table The IP protocol standards do not dictate the precise data required to be in a forwarding table, as this choice is left up to the implementer of the IP protocol. Nevertheless, several key pieces of information are generally required to implement the forwarding table for IP. Destination: This contains a 32-bit field (or 128-bit field for IPv6) used for matching the result of a masking operation. The destination can be as simple as zero, for a default route covering all destinations, or as long as the full length of an IP address, in the case of a host route that describes only a single destination. Mask: This contains a 32-bit field (128-bit field for IPv6) applied as a bitwise AND mask to the destination IP address of a datagram being looked up in the forwarding table. The masked result is compared with the set of destinations in the forwarding table entries. Next-hop: This contains the 32-bit IPv4 address or 128-bit IPv6 address of the next IP entity (router or host) to which the datagram should be sent. The next-hop entity is typically on a network shared with the system performing the forwarding lookup, meaning the two share the same network prefix. Interface: This contains an identifier used by the IP layer to reference the network interface that should be used to send the datagram to its next hop. For example, it could refer to a host&#8217;s 802.11 wireless interface, a wired Ethernet interface, or a PPP interface associated with a serial port. If the forwarding system is also the sender of the IP datagram, this field is used in selecting which source IP address to use on the outgoing datagram. $ sudo route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.91.2 0.0.0.0 UG 0 0 0 ens32 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 192.168.91.0 0.0.0.0 255.255.255.0 U 0 0 0 ens32 192.168.91.0 0.0.0.0 255.255.255.0 U 0 0 0 ens34 $ ip r default via 192.168.91.2 dev ens32 onlink 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 PS C:\&gt; route print -4 =========================================================================== Interface List 10...48 2a e3 94 1e 19 ......Intel(R) Ethernet Connection (10) I219-V 6...02 00 4c 4f 4f 50 ......Microsoft KM-TEST Loopback Adapter 5...8c c6 81 fe 82 c5 ......Microsoft Wi-Fi Direct Virtual Adapter 8...8e c6 81 fe 82 c4 ......Microsoft Wi-Fi Direct Virtual Adapter #2 19...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1 9...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8 13...8c c6 81 fe 82 c4 ......Intel(R) Wireless-AC 9560 160MHz 1...........................Software Loopback Interface 1 =========================================================================== IPv4 Route Table =========================================================================== Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 10.170.109.254 10.170.109.10 35 10.170.108.0 255.255.254.0 On-link 10.170.109.10 291 10.170.109.10 255.255.255.255 On-link 10.170.109.10 291 10.170.109.255 255.255.255.255 On-link 10.170.109.10 291 127.0.0.0 255.0.0.0 On-link 127.0.0.1 331 127.0.0.1 255.255.255.255 On-link 127.0.0.1 331 127.255.255.255 255.255.255.255 On-link 127.0.0.1 331 169.254.0.0 255.255.0.0 On-link 169.254.24.54 281 169.254.24.54 255.255.255.255 On-link 169.254.24.54 281 169.254.255.255 255.255.255.255 On-link 169.254.24.54 281 192.168.56.0 255.255.255.0 On-link 192.168.56.1 291 192.168.56.1 255.255.255.255 On-link 192.168.56.1 291 192.168.56.255 255.255.255.255 On-link 192.168.56.1 291 192.168.91.0 255.255.255.0 On-link 192.168.91.1 291 192.168.91.1 255.255.255.255 On-link 192.168.91.1 291 192.168.91.255 255.255.255.255 On-link 192.168.91.1 291 224.0.0.0 240.0.0.0 On-link 127.0.0.1 331 224.0.0.0 240.0.0.0 On-link 192.168.56.1 291 224.0.0.0 240.0.0.0 On-link 192.168.91.1 291 224.0.0.0 240.0.0.0 On-link 169.254.24.54 281 224.0.0.0 240.0.0.0 On-link 10.170.109.10 291 255.255.255.255 255.255.255.255 On-link 127.0.0.1 331 255.255.255.255 255.255.255.255 On-link 192.168.56.1 291 255.255.255.255 255.255.255.255 On-link 192.168.91.1 291 255.255.255.255 255.255.255.255 On-link 169.254.24.54 281 255.255.255.255 255.255.255.255 On-link 10.170.109.10 291 =========================================================================== Persistent Routes: None IP forwarding is performed on a hop-by-hop basis. The routers and hosts do not contain the complete forwarding path to any destination. IP forwarding provides the IP address of only the next-hop entity to which the datagram is sent. It is assumed that the next hop is really closer to the destination than the forwarding system is, and that the next-hop router is directly connected to (i.e., shares a common network prefix with) the forwarding system. It is also generally assumed that no loops are constructed between the next hops so that a datagram does not circulate around the network until its TTL or hop limit expires. 2.2. IP Forwarding Actions When the IP layer in a host or router needs to send an IP datagram to a next-hop router or host, it first examines the destination IP address (D) in the datagram. Using the value D, the following longest prefix match algorithm is executed on the forwarding table: Search the table for all entries for which the following property holds: (D ^ mj) = dj, where mj is the value of the mask field associated with the forwarding entry ej having index j, and dj is the value of the destination field associated with ej. If the destination IP address D is bitwise ANDed with the mask in each forwarding table entry (mj), and the result is compared against the destination in the same forwarding table entry (dj), the entry (ej here) is a match for the destination IP address. When a match happens, the algorithm notes the entry index (j here) and how many bits in the mask mj were set to 1, and the more bits set to 1, the better the match. The best matching entry ek (i.e., the one with the largest number of 1 bits in its mask mk) is selected, and its next-hop field nk is used as the next-hop IP address in forwarding the datagram. If no matches in the forwarding table are found, the datagram is undeliverable. If the undeliverable datagram was generated locally (on this host), a host unreachable error is normally returned to the application that generated the datagram. On a router, an ICMP message is normally sent back to the host that sent the datagram. In some circumstances, more than one entry may match an equal number of 1 bits. This can happen, for example, when more than one default route is available (e.g., when attached to more than one ISP, called multihoming). The end-system behavior in such cases is not set by standards and is instead specific to the operating system&#8217;s protocol implementation. A common behavior is for the system to simply choose the first match. More sophisticated systems may attempt to load-balance or split traffic across the multiple routes. 2.3. Direct delivery and indirect delivery Routers DO NOT change the source and destination IP addresses within the IP packet itself. Routers DO change the source and destination MAC addresses of the Ethernet frame that encapsulates the IP packet. Where all systems are using the same network prefix, is called direct delivery, and the other case is called indirect delivery. Figure 4. Direct delivery and indirect delivery Direct delivery does not require the presence of a router—IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination. Indirect delivery involves a router—data is forwarded to the router using the router&#8217;s link-layer address as the destination link-layer address. The router&#8217;s IP address does not appear in the IP datagram (unless the router itself is the source or destination, or when source routing is used). In the following table, the destination IPv4 address D (10.0.0.9) matches both the first and second forwarding table entries. Because it matches the second entry better (25 bits instead of none), the gateway or next-hop address is 10.0.0.100, the address S. Thus, the gateway portion of the entry contains the address of the sending host&#8217;s own network interface (no router is referenced), indicating that direct delivery is to be used to send the datagram. Table 1. The (unicast) IPv4 forwarding table at host S contains only two entries. Destination Mask Gateway (Next Hop) Interface 0.0.0.0 0.0.0.0 10.0.0.1 10.0.0.100 10.0.0.0 255.255.255.128 10.0.0.100 10.0.0.100 Host S is configured with IPv4 address and subnet mask 10.0.0.100/25. Datagrams destined for addresses in the range 10.0.0.1 through 10.0.0.126 use the second forwarding table entry and are sent using direct delivery. All other datagrams use the first entry and are given to router R with IPv4 address 10.0.0.1. The datagram is encapsulated in a lower-layer frame destined for the target host D. If the lower-layer address of the target host is unknown, the ARP protocol (for IPv4) or Neighbor Solicitation (for IPv6) operation may be invoked at this point to determine the correct lower-layer address, D. Once known, the destination address in the datagram is D&#39;s IPv4 address (10.0.0.9), and D is placed in the Destination IP Address field in the lower-layer header. The switch delivers the frame to D based solely on the link-layer address D; it pays no attention to the IP addresses. $ ip n 172.17.0.2 dev docker0 lladdr 02:42:ac:11:00:02 STALE 192.168.91.254 dev ens32 lladdr 00:50:56:fc:89:96 STALE 192.168.91.1 dev ens32 lladdr 00:50:56:c0:00:08 REACHABLE 192.168.91.2 dev ens34 lladdr 00:50:56:e9:f6:27 STALE 192.168.91.2 dev ens32 lladdr 00:50:56:e9:f6:27 STALE 192.168.91.138 dev ens32 FAILED fe80::50c2:d6ef:87fb:1b7b dev ens34 lladdr 00:50:56:c0:00:08 STALE $ sudo arp -n Address HWtype HWaddress Flags Mask Iface 172.17.0.2 ether 02:42:ac:11:00:02 C docker0 192.168.91.254 ether 00:50:56:fc:89:96 C ens32 192.168.91.1 ether 00:50:56:c0:00:08 C ens32 192.168.91.2 ether 00:50:56:e9:f6:27 C ens34 192.168.91.2 ether 00:50:56:e9:f6:27 C ens32 192.168.91.138 (incomplete) ens32 Table 2. The (unicast) IPv4 forwarding table at router R1 contains only two entries. Destination Mask Gateway (Next Hop) Interface Note 0.0.0.0 0.0.0.0 70.231.159.254 70.231.132.85 NAT 10.0.0.0 255.255.255.128 10.0.0.100 10.0.0.1 NAT The forwarding table at R1 indicates that address translation should be performed for traffic. The router has a private address on one side (10.0.0.1) and a public address on the other (70.231.132.85). Address translation is used to make datagrams originating on the 10.0.0.0/25 network appear to the Internet as though they had been sent from 70.231.132.85. node-0:~$ ip r default via 192.168.91.2 dev ens32 onlink 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 node-0:~$ sudo ip r del default node-0:~$ sudo ip r add default via 192.168.91.137 dev ens32 node-0:~$ ip r default via 192.168.91.137 dev ens32 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 node-1:~$ ip r default via 192.168.91.2 dev ens32 192.168.56.0/24 dev ens36 proto kernel scope link src 192.168.56.128 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.137 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.131 192.168.91.0/24 dev ens33 proto kernel scope link src 192.168.91.129 node-1:~$ sudo sysctl net.ipv4.ip_forward=1 net.ipv4.ip_forward = 1 PS C:\&gt; ipconfig Wireless LAN adapter Wi-Fi: Connection-specific DNS Suffix . : xxxxxxxxx Link-local IPv6 Address . . . . . : fe80::20b2:4f30:ed18:5956%13 IPv4 Address. . . . . . . . . . . : 10.170.109.10 Subnet Mask . . . . . . . . . . . : 255.255.254.0 Default Gateway . . . . . . . . . : 10.170.109.254 node-0:~$ sudo traceroute -I 10.170.109.10 traceroute to 10.170.109.10 (10.170.109.10), 30 hops max, 60 byte packets 1 node-1 (192.168.91.137) 0.256 ms 0.223 ms 0.252 ms 2 192.168.91.2 (192.168.91.2) 0.269 ms 0.256 ms 0.235 ms 3 10.170.109.10 (10.170.109.10) 0.727 ms 0.871 ms 1.175 ms 3. Mobile IP Mobile IP is based on the idea that a host has a home network but may visit other networks from time to time. While at home, ordinary forwarding is performed. When away from home, the host keeps the IP address it would ordinarily use at home, but some special routing and forwarding tricks are used to make the host appear to the network, and to the other systems with which it communicates, as though it is attached to its home network. The scheme depends on a special type of router called a home agent that helps provide routing for mobile nodes. Most of the complexity in MIPv6 involves signaling messages and how they are secured. These messages use various forms of the Mobility extension header (Next Header field value 135, often just called the mobility header), so Mobile IP is, in effect, a special protocol of its own. 3.1. The Basic Model for IP Mobility: Bidirectional Tunneling The following figure shows the entities involved in making MIPv6 work. Much of the terminology also applies to MIPv4 [RFC5944]. A host that might move is called a mobile node (MN), and the hosts with which it is communicating are called correspondent nodes (CNs). The MN is given an IP address chosen from the network prefix used in its home network. This address is known as its home address (HoA). When it travels to a visited network, it is given an additional address, called its care-of-address (CoA). In the basic model, whenever a CN communicates with an MN, the traffic is routed through the MN&#8217;s home agent (HA). HAs are a special type of router deployed in the network infrastructure like other important systems (e.g., routers and Web servers). The association between an MN&#8217;s HoA and its CoA is called a binding for the MN. Figure 5. Mobile IP supports the ability of nodes to change their point of network attachment and keep network connections operating. The mobile node’s home agent helps to forward traffic for mobiles it serves and also plays a role in route optimization, which can substantially improve routing performance by allowing mobile and correspondent nodes to communicate directly. The basic model works in cases where an MN&#8217;s CNs do not engage in the MIPv6 protocol. This model is also used for network mobility (called NEMO [RFC3963]), when an entire network is mobile. When the MN (or mobile network router) attaches to a new point in the network, it receives its CoA and sends a binding update message to its HA. The HA responds with a binding acknowledgment. Assuming that all goes well, traffic between the MN and CNs is thereafter routed through the MN&#8217;s HA using a two-way form of IPv6 packet tunneling[RFC2473] called bidirectional tunneling. These messages are ordinarily protected using IPsec with the Encapsulating Security Payload (ESP). Doing so ensures that an HA is not fooled into accepting a binding update from a fake MN. 4. Host Processing of IP Datagrams Although routers do not ordinarily have to consider which IP addresses to place in the Source IP Address and Destination IP Address fields of the packets they forward, hosts must consider both. Applications such as Web browsers may attempt to make connections to a named host or server that can have multiple addresses. The client system making such connections may also have multiple addresses. 4.1. Host Models Although it may appear to be a straightforward decision to determine whether a received unicast datagram matches one of a host&#8217;s IP addresses and should be processed, this decision depends on the host model of the receiving system [RFC1122] and is most relevant for multihomed hosts. There are two host models, the strong host model and the weak host model. In the strong host model, a datagram is accepted for delivery to the local protocol stack only if the IP address contained in the Destination IP Address field matches one of those configured on the interface upon which the datagram arrived. In systems implementing the weak host model, the opposite is true—a datagram carrying a destination address matching any of the local addresses may arrive on any interface and is processed by the receiving protocol stack, irrespective of the network interface upon which it arrived. Host models also apply to sending behavior. That is, a host using the strong host model sends datagrams from a particular interface only if one of the interface&#8217;s configured addresses matches the Source IP Address field in the datagram being sent. Figure 6. Hosts may be connected by more than one interface. In such cases, they must decide which addresses to use for the Source IP Address and Destination IP Address fields of the packets they exchange. The addresses used result from a combination of each host&#8217;s forwarding table, application of an address selection algorithm [RFC 3484], and whether hosts are operating using a weak or strong host model. In this example, two hosts (A and B) are connected through the global Internet but also through a local network. If host A is set up to conform to the strong host model, packets it receives destined for 203.0.113.1 from the Internet or destined for 192.0.2.1 from the local network are dropped. This situation can arise, for example, if host B is configured to obey the weak host model. It may choose to send packets to 192.0.2.1 using the local network (e.g., because doing so may be cheaper or faster). This situation seems unfortunate, as A receives what appear to be perfectly legitimate packets, yet drops them merely because it is operating according to the strong host model. The host model, for both sending and receiving behavior, can be configured in some operating systems. In Windows (Vista and later), strong host behavior is the default for sending and receiving for IPv4 and IPv6. In Linux, the IP behavior defaults to the weak host model. BSD (including Mac OS X) uses the strong hostmodel. In Windows, the following commands can be used to configure weak host receive and send behavior, respectively: C:\&gt; netsh interface ipvX set interface &lt;ifname&gt; weakhostreceive=Yabled C:\&gt; netsh interface ipvX set interface &lt;ifname&gt; weakhostsend=Yabled For these commands, &lt;ifname&gt; is replaced with the appropriate interface name; X is replaced with either 4 or 6, depending on which version of IP is being configured; and Y is replaced with either en or dis, depending on whether weak behavior is to be enabled or disabled, respectively. netsh interface ipv4&gt;show interfaces Idx Met MTU State Name --- ---------- ---------- ------------ --------------------------- 1 75 4294967295 connected Loopback Pseudo-Interface 1 13 35 1500 connected Wi-Fi 10 5 1500 disconnected Ethernet netsh interface ipv4&gt;show interfaces interface=&quot;Wi-Fi&quot; Interface Wi-Fi Parameters ---------------------------------------------- Weak Host Sends : disabled Weak Host Receives : disabled References [1] Kevin Fall, W. Stevens TCP/IP Illustrated: The Protocols, Volume 1. 2nd edition, Addison-Wesley Professional, 2011 [AN] https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" />
<meta property="og:description" content="1. IPv4 and IPv6 Headers 1.1. IP Header Fields 1.2. The Internet Checksum 2. IP Forwarding 2.1. Forwarding Table 2.2. IP Forwarding Actions 2.3. Direct delivery and indirect delivery 3. Mobile IP 3.1. The Basic Model for IP Mobility: Bidirectional Tunneling 4. Host Processing of IP Datagrams 4.1. Host Models References IP is the workhorse protocol of the TCP/IP protocol suite. All TCP, UDP, ICMP, and IGMP data gets transmitted as IP datagrams. IP provides a best-effort, connectionless datagram delivery service. 1. IPv4 and IPv6 Headers The normal size of the IPv4 header is 20 bytes, unless options are present (which is rare). The IPv6 header is twice as large but never has any options, may have extension headers. The most significant bit of headers and datagrams is numbered 0 at the left, and the least significant bit of a 32-bit value is numbered 31 on the right. The 4 bytes in a 32-bit value are transmitted in the following order: bits 0–7 first, then bits 8–15, then 16–23, and bits 24–31 last. This is called big endian byte ordering, which is the byte ordering required for all binary integers in the TCP/IP headers as they traverse a network. It is also called network byte order. Computer CPUs that store binary integers in other formats, such as the little endian format, must convert the header values into network byte order for transmission and back again for reception. $ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian Model name: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz Figure 1. The IPv4 datagram format. The header is of variable size, limited to fifteen 32-bit words (60 bytes) by the 4-bit IHL field. A typical IPv4 header contains 20 bytes (no options). The source and destination addresses are 32 bits long. Most of the second 32-bit word is used for the IPv4 fragmentation function. A header checksum helps ensure that the fields in the header are delivered correctly to the proper destination but does not protect the data. Figure 2. The IPv6 datagram format. The IPv6 header is of fixed size (40 bytes) and contains 128-bit source and destination addresses. The Next Header field is used to indicate the presence and types of additional extension headers that follow the IPv6 header, forming a daisy chain of headers that may include special extensions or processing directives. Application data follows the header chain, usually immediately following a transport-layer header. 1.1. IP Header Fields The first field (only 4 bits or one nibble wide) is the Version field. It contains the version number of the IP datagram: 4 for IPv4 and 6 for IPv6. The headers for both IPv4 and IPv6 share the location of the Version field but no others. Thus, the two protocols are not directly interoperable—a host or router must handle either IPv4 or IPv6 (or both, called dual stack) separately. The Internet Header Length (IHL) field is the number of 32-bit words in the IPv4 header, including any options. Because this is also a 4-bit field, the IPv4 header is limited to a maximum of fifteen 32-bit words or 60 bytes. The normal value of this field (when no options are present) is 5. There is no such field in IPv6 because the header length is fixed at 40 bytes. Following the header length, the original specification of IPv4 [RFC0791] specified a Type of Service (ToS) byte, and IPv6 [RFC2460] specified the equivalent Traffic Class byte. Use of these never became widespread, so eventually this 8-bit field was split into two smaller parts and redefined by a set of RFCs ([RFC3260] [RFC3168][RFC2474] and others). The first 6 bits are now called the Differentiated Services Field (DS Field), and the last 2 bits are the Explicit Congestion Notification (ECN) field or indicator bits. These RFCs now apply to both IPv4 and IPv6. These fields are used for special processing of the datagram when it is forwarded. The Total Length field is the total length of the IPv4 datagram in bytes. Using this field and the IHL field, we know where the data portion of the datagram starts, and its length. Because this is a 16-bit field, the maximum size of an IPv4 datagram (including header) is 65,535 bytes. Although it is possible to send a 65,535-byte IP datagram, most link layers (such as Ethernet) are not able to carry one this large without fragmenting it (chopping it up) into smaller pieces. Furthermore, a host is not required to be able to receive an IPv4 datagram larger than 576 bytes. In IPv6 a host must be able to process a datagram at least as large as the MTU of the link to which it is attached, and the minimum link MTU is 1280 bytes. When an IPv4 datagram is fragmented into multiple smaller fragments, each of which itself is an independent IP datagram, the Total Length field reflects the length of the particular fragment. In IPv6, fragmentation is not supported by the header, and the length is instead given by the Payload Length field. This field measures the length of the IPv6 datagram not including the length of the header; extension headers, however, are included in the Payload Length field. The Identification field helps indentify each datagram sent by an IPv4 host. To ensure that the fragments of one datagram are not confused with those of another, the sending host normally increments an internal counter by 1 each time a datagram is sent (from one of its IP addresses) and copies the value of the counter into the IPv4 Identification field. The Identification, Flags and Fragment Offset fields are most important for implementing fragmentation. In IPv6, this field shows up in the Fragmentation extension header. The Time-to-Live field, or TTL, sets an upper limit on the number of routers through which a datagram can pass. It is initialized by the sender to some value (64 is recommended [RFC1122], although 128 or 255 is not uncommon) and decremented by 1 by every router that forwards the datagram. When this field reaches 0, the datagram is thrown away, and the sender is notified with an ICMP message. This prevents packets from getting caught in the network forever should an unwanted routing loop occur. The Protocol field in the IPv4 header contains a number indicating the type of data found in the payload portion of the datagram. The most common values are 17 (for UDP) and 6 (for TCP). This provides a demultiplexing feature so that the IP protocol can be used to carry payloads of more than one protocol type. Although this field originally specified the transport-layer protocol the datagram is encapsulating, it is now understood to identify the encapsulated protocol, which may or not be a transport protocol. For example, other encapsulations are possible, such as IPv4-in-IPv4 (value 4). The official list of the possible values of the Protocol field is given in the assigned numbers page [AN]. The Next Header field in the IPv6 header generalizes the Protocol field from IPv4. It is used to indicate the type of header following the IPv6 header. This field may contain any values defined for the IPv4 Protocol field, or any of the values associated with the IPv6 extension headers. Decimal Keyword Protocol IPv6 Extension Header Reference 0 HOPOPT IPv6 Hop-by-Hop Option Y [RFC8200] 1 ICMP Internet Control Message [RFC792] 2 IGMP Internet Group Management [RFC1112] 3 GGP Gateway-to-Gateway [RFC823] 4 IPv4 IPv4 encapsulation [RFC2003] 6 TCP Transmission Control [RFC9293] 8 EGP Exterior Gateway Protocol [RFC888][David_Mills] 9 IGP any private interior gateway (used by Cisco for their IGRP) [Internet_Assigned_Numbers_Authority] 17 UDP User Datagram [RFC768][Jon_Postel] 33 DCCP Datagram Congestion Control Protocol [RFC4340] 41 IPv6 IPv6 encapsulation [RFC2473] 43 IPv6-Route Routing Header for IPv6 Y [Steve_Deering] 44 IPv6-Frag Fragment Header for IPv6 Y [Steve_Deering] 50 ESP Encap Security Payload Y [RFC4303] 51 AH Authentication Header Y [RFC4302] 58 IPv6-ICMP ICMP for IPv6 [RFC8200] 59 IPv6-NoNxt No Next Header for IPv6 [RFC8200] 60 IPv6-Opts Destination Options for IPv6 Y [RFC8200] 108 IPComp IP Payload Compression Protocol [RFC2393] 115 L2TP Layer Two Tunneling Protocol [RFC3931][Bernard_Aboba] 132 SCTP Stream Control Transmission Protocol [Randall_R_Stewart] The Header Checksum field is calculated over the IPv4 header only. This is important to understand because it means that the payload of the IPv4 datagram (e.g., TCP or UDP data) is not checked for correctness by the IP protocol. Perhaps surprisingly, the IPv6 header does not have any checksum field. Every IP datagram contains the Source IP Address of the sender of the datagram and the Destination IP Address of where the datagram is destined. These are 32-bit values for IPv4 and 128-bit values for IPv6, and they usually identify a single interface on a computer, although multicast and broadcast addresses violate this rule. 1.2. The Internet Checksum The Internet checksum is a 16-bit mathematical sum used to determine, with reasonably high probability, whether a received message or portion of a message matches the one sent. Note that the Internet checksum algorithm is not the same as the common cyclic redundancy check (CRC), which offers stronger protection. To compute the IPv4 header checksum for an outgoing datagram, the value of the datagram&#8217;s Checksum field is first set to 0. Then, the 16-bit one&#8217;s complement sum of the header is calculated (the entire header is considered a sequence of 16-bit words). The 16-bit one&#8217;s complement of this sum is then stored in the Checksum field to make the datagram ready for transmission. One&#8217;s complement addition can be implemented by &quot;end-round-carry addition&quot;: when a carry bit is produced using conventional (two&#8217;s complement) addition, the carry is added back in as a 1 value. When an IPv4 datagram is received, a checksum is computed across the whole header, including the value of the Checksum field itself. Assuming there are no errors, the computed checksum value is always 0 (a one&#8217;s complement of the value FFFF). Note that for any nontrivial packet or header, the value of the Checksum field in the packet can never be FFFF. If it were, the sum (prior to the final one&#8217;s complement operation at the sender) would have to have been 0. No sum can ever be 0 using one&#8217;s complement addition unless all the bytes are 0—something that never happens with any legitimate IPv4 header. When the header is found to be bad (the computed checksum is nonzero), the IPv4 implementation discards the received datagram. No error message is generated. It is up to the higher layers to somehow detect the missing datagram and retransmit if necessary. Figure 3. The Internet checksum is the one&#8217;s complement of a one&#8217;s complement 16-bit sum of the data being checksummed (zero padding is used if the number of bytes being summed is odd). If the data being summed includes a Checksum field, the field is first set to 0 prior to the checksum operation and then filled in with the computed checksum. To check whether an incoming block of data that contains a Checksum field (header, payload, etc.) is valid, the same type of checksum is computed over the whole block (including the Checksum field). Because the Checksum field is essentially the inverse of the checksum of the rest of the data, computing the checksum on correctly received data should produce a value of 0. 45 10 01 48 00 00 00 00 10 11 70 c4 c0 a8 5b fe c0 a8 5b 82 | 45 10 | Version, IHL, DS, ECN | 0100 0101 0001 0000 | 01 48 | Total Length | 0000 0001 0100 1000 =&gt; 0100 0110 0101 1000 | 00 00 | Identification | 0000 0000 0000 0000 =&gt; 0100 0110 0101 1000 | 00 00 | Flags, Fragment Offset | 0000 0000 0000 0000 =&gt; 0100 0110 0101 1000 | 10 11 | TTL, Protocol | 0001 0000 0001 0001 =&gt; 0101 0110 0110 1001 | 70 c4 | Checksum | 0111 0000 1100 0100 =&gt; 0101 0110 0110 1001 | c0 a8 | Source Address | 1100 0000 1010 1000 1 0001 0111 0001 0001 + 1 =&gt; 0001 0111 0001 0010 # round-carry | 5b fe | Source Address | 0101 1011 1111 1110 =&gt; 0111 0011 0001 0000 | c0 a8 | Destination Address | 1100 0000 1010 1000 =&gt; 0011 0011 1011 1001 # round-carry | 5b 82 | Destination Address | 0101 1011 1000 0010 =&gt; 1000 1111 0011 1011 =&gt; 0111 0000 1100 0100 # one&#39;s complement (i.e. checksum) =&gt; 1111 1111 1111 1111 # computed including the Checksum field =&gt; 0000 0000 0000 0000 # one&#39;s complement (correct) 2. IP Forwarding Conceptually, IP forwarding is simple, especially for a host. If the destination is directly connected to the host (e.g., a point-to-point link) or on a shared network (e.g., Ethernet), the IP datagram is sent directly to the destination—a router is not required or used. Otherwise, the host sends the datagram to a single router (called the default router) and lets the router deliver the datagram to its destination. What differentiates a host from a router to IP is how IP datagrams are handled: a host never forwards datagrams it does not originate, whereas routers do. In our general scheme, the IP protocol can receive a datagram either from another protocol on the same machine (TCP, UDP, etc.) or from a network interface. The IP layer has some information in memory, usually called a routing table or forwarding table, which it searches each time it receives a datagram to send. When a datagram is received from a network interface, IP first checks if the destination IP address is one of its own IP addresses (i.e., one of the IP addresses associated with one of its network interfaces) or some other address for which it should receive traffic such as an IP broadcast or multicast address. If so, the datagram is delivered to the protocol module specified by the Protocol field in the IPv4 header or Next Header field in the IPv6 header. If the datagram is not destined for one of the IP addresses being used locally by the IP module, then (1) if the IP layer was configured to act as a router, the datagram is forwarded; or (2) the datagram is silently discarded. Under some circumstances (e.g., no route is known in case 1), an ICMP message may be sent back to the source indicating an error condition. 2.1. Forwarding Table The IP protocol standards do not dictate the precise data required to be in a forwarding table, as this choice is left up to the implementer of the IP protocol. Nevertheless, several key pieces of information are generally required to implement the forwarding table for IP. Destination: This contains a 32-bit field (or 128-bit field for IPv6) used for matching the result of a masking operation. The destination can be as simple as zero, for a default route covering all destinations, or as long as the full length of an IP address, in the case of a host route that describes only a single destination. Mask: This contains a 32-bit field (128-bit field for IPv6) applied as a bitwise AND mask to the destination IP address of a datagram being looked up in the forwarding table. The masked result is compared with the set of destinations in the forwarding table entries. Next-hop: This contains the 32-bit IPv4 address or 128-bit IPv6 address of the next IP entity (router or host) to which the datagram should be sent. The next-hop entity is typically on a network shared with the system performing the forwarding lookup, meaning the two share the same network prefix. Interface: This contains an identifier used by the IP layer to reference the network interface that should be used to send the datagram to its next hop. For example, it could refer to a host&#8217;s 802.11 wireless interface, a wired Ethernet interface, or a PPP interface associated with a serial port. If the forwarding system is also the sender of the IP datagram, this field is used in selecting which source IP address to use on the outgoing datagram. $ sudo route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.91.2 0.0.0.0 UG 0 0 0 ens32 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 192.168.91.0 0.0.0.0 255.255.255.0 U 0 0 0 ens32 192.168.91.0 0.0.0.0 255.255.255.0 U 0 0 0 ens34 $ ip r default via 192.168.91.2 dev ens32 onlink 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 PS C:\&gt; route print -4 =========================================================================== Interface List 10...48 2a e3 94 1e 19 ......Intel(R) Ethernet Connection (10) I219-V 6...02 00 4c 4f 4f 50 ......Microsoft KM-TEST Loopback Adapter 5...8c c6 81 fe 82 c5 ......Microsoft Wi-Fi Direct Virtual Adapter 8...8e c6 81 fe 82 c4 ......Microsoft Wi-Fi Direct Virtual Adapter #2 19...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1 9...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8 13...8c c6 81 fe 82 c4 ......Intel(R) Wireless-AC 9560 160MHz 1...........................Software Loopback Interface 1 =========================================================================== IPv4 Route Table =========================================================================== Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 10.170.109.254 10.170.109.10 35 10.170.108.0 255.255.254.0 On-link 10.170.109.10 291 10.170.109.10 255.255.255.255 On-link 10.170.109.10 291 10.170.109.255 255.255.255.255 On-link 10.170.109.10 291 127.0.0.0 255.0.0.0 On-link 127.0.0.1 331 127.0.0.1 255.255.255.255 On-link 127.0.0.1 331 127.255.255.255 255.255.255.255 On-link 127.0.0.1 331 169.254.0.0 255.255.0.0 On-link 169.254.24.54 281 169.254.24.54 255.255.255.255 On-link 169.254.24.54 281 169.254.255.255 255.255.255.255 On-link 169.254.24.54 281 192.168.56.0 255.255.255.0 On-link 192.168.56.1 291 192.168.56.1 255.255.255.255 On-link 192.168.56.1 291 192.168.56.255 255.255.255.255 On-link 192.168.56.1 291 192.168.91.0 255.255.255.0 On-link 192.168.91.1 291 192.168.91.1 255.255.255.255 On-link 192.168.91.1 291 192.168.91.255 255.255.255.255 On-link 192.168.91.1 291 224.0.0.0 240.0.0.0 On-link 127.0.0.1 331 224.0.0.0 240.0.0.0 On-link 192.168.56.1 291 224.0.0.0 240.0.0.0 On-link 192.168.91.1 291 224.0.0.0 240.0.0.0 On-link 169.254.24.54 281 224.0.0.0 240.0.0.0 On-link 10.170.109.10 291 255.255.255.255 255.255.255.255 On-link 127.0.0.1 331 255.255.255.255 255.255.255.255 On-link 192.168.56.1 291 255.255.255.255 255.255.255.255 On-link 192.168.91.1 291 255.255.255.255 255.255.255.255 On-link 169.254.24.54 281 255.255.255.255 255.255.255.255 On-link 10.170.109.10 291 =========================================================================== Persistent Routes: None IP forwarding is performed on a hop-by-hop basis. The routers and hosts do not contain the complete forwarding path to any destination. IP forwarding provides the IP address of only the next-hop entity to which the datagram is sent. It is assumed that the next hop is really closer to the destination than the forwarding system is, and that the next-hop router is directly connected to (i.e., shares a common network prefix with) the forwarding system. It is also generally assumed that no loops are constructed between the next hops so that a datagram does not circulate around the network until its TTL or hop limit expires. 2.2. IP Forwarding Actions When the IP layer in a host or router needs to send an IP datagram to a next-hop router or host, it first examines the destination IP address (D) in the datagram. Using the value D, the following longest prefix match algorithm is executed on the forwarding table: Search the table for all entries for which the following property holds: (D ^ mj) = dj, where mj is the value of the mask field associated with the forwarding entry ej having index j, and dj is the value of the destination field associated with ej. If the destination IP address D is bitwise ANDed with the mask in each forwarding table entry (mj), and the result is compared against the destination in the same forwarding table entry (dj), the entry (ej here) is a match for the destination IP address. When a match happens, the algorithm notes the entry index (j here) and how many bits in the mask mj were set to 1, and the more bits set to 1, the better the match. The best matching entry ek (i.e., the one with the largest number of 1 bits in its mask mk) is selected, and its next-hop field nk is used as the next-hop IP address in forwarding the datagram. If no matches in the forwarding table are found, the datagram is undeliverable. If the undeliverable datagram was generated locally (on this host), a host unreachable error is normally returned to the application that generated the datagram. On a router, an ICMP message is normally sent back to the host that sent the datagram. In some circumstances, more than one entry may match an equal number of 1 bits. This can happen, for example, when more than one default route is available (e.g., when attached to more than one ISP, called multihoming). The end-system behavior in such cases is not set by standards and is instead specific to the operating system&#8217;s protocol implementation. A common behavior is for the system to simply choose the first match. More sophisticated systems may attempt to load-balance or split traffic across the multiple routes. 2.3. Direct delivery and indirect delivery Routers DO NOT change the source and destination IP addresses within the IP packet itself. Routers DO change the source and destination MAC addresses of the Ethernet frame that encapsulates the IP packet. Where all systems are using the same network prefix, is called direct delivery, and the other case is called indirect delivery. Figure 4. Direct delivery and indirect delivery Direct delivery does not require the presence of a router—IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination. Indirect delivery involves a router—data is forwarded to the router using the router&#8217;s link-layer address as the destination link-layer address. The router&#8217;s IP address does not appear in the IP datagram (unless the router itself is the source or destination, or when source routing is used). In the following table, the destination IPv4 address D (10.0.0.9) matches both the first and second forwarding table entries. Because it matches the second entry better (25 bits instead of none), the gateway or next-hop address is 10.0.0.100, the address S. Thus, the gateway portion of the entry contains the address of the sending host&#8217;s own network interface (no router is referenced), indicating that direct delivery is to be used to send the datagram. Table 1. The (unicast) IPv4 forwarding table at host S contains only two entries. Destination Mask Gateway (Next Hop) Interface 0.0.0.0 0.0.0.0 10.0.0.1 10.0.0.100 10.0.0.0 255.255.255.128 10.0.0.100 10.0.0.100 Host S is configured with IPv4 address and subnet mask 10.0.0.100/25. Datagrams destined for addresses in the range 10.0.0.1 through 10.0.0.126 use the second forwarding table entry and are sent using direct delivery. All other datagrams use the first entry and are given to router R with IPv4 address 10.0.0.1. The datagram is encapsulated in a lower-layer frame destined for the target host D. If the lower-layer address of the target host is unknown, the ARP protocol (for IPv4) or Neighbor Solicitation (for IPv6) operation may be invoked at this point to determine the correct lower-layer address, D. Once known, the destination address in the datagram is D&#39;s IPv4 address (10.0.0.9), and D is placed in the Destination IP Address field in the lower-layer header. The switch delivers the frame to D based solely on the link-layer address D; it pays no attention to the IP addresses. $ ip n 172.17.0.2 dev docker0 lladdr 02:42:ac:11:00:02 STALE 192.168.91.254 dev ens32 lladdr 00:50:56:fc:89:96 STALE 192.168.91.1 dev ens32 lladdr 00:50:56:c0:00:08 REACHABLE 192.168.91.2 dev ens34 lladdr 00:50:56:e9:f6:27 STALE 192.168.91.2 dev ens32 lladdr 00:50:56:e9:f6:27 STALE 192.168.91.138 dev ens32 FAILED fe80::50c2:d6ef:87fb:1b7b dev ens34 lladdr 00:50:56:c0:00:08 STALE $ sudo arp -n Address HWtype HWaddress Flags Mask Iface 172.17.0.2 ether 02:42:ac:11:00:02 C docker0 192.168.91.254 ether 00:50:56:fc:89:96 C ens32 192.168.91.1 ether 00:50:56:c0:00:08 C ens32 192.168.91.2 ether 00:50:56:e9:f6:27 C ens34 192.168.91.2 ether 00:50:56:e9:f6:27 C ens32 192.168.91.138 (incomplete) ens32 Table 2. The (unicast) IPv4 forwarding table at router R1 contains only two entries. Destination Mask Gateway (Next Hop) Interface Note 0.0.0.0 0.0.0.0 70.231.159.254 70.231.132.85 NAT 10.0.0.0 255.255.255.128 10.0.0.100 10.0.0.1 NAT The forwarding table at R1 indicates that address translation should be performed for traffic. The router has a private address on one side (10.0.0.1) and a public address on the other (70.231.132.85). Address translation is used to make datagrams originating on the 10.0.0.0/25 network appear to the Internet as though they had been sent from 70.231.132.85. node-0:~$ ip r default via 192.168.91.2 dev ens32 onlink 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 node-0:~$ sudo ip r del default node-0:~$ sudo ip r add default via 192.168.91.137 dev ens32 node-0:~$ ip r default via 192.168.91.137 dev ens32 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 node-1:~$ ip r default via 192.168.91.2 dev ens32 192.168.56.0/24 dev ens36 proto kernel scope link src 192.168.56.128 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.137 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.131 192.168.91.0/24 dev ens33 proto kernel scope link src 192.168.91.129 node-1:~$ sudo sysctl net.ipv4.ip_forward=1 net.ipv4.ip_forward = 1 PS C:\&gt; ipconfig Wireless LAN adapter Wi-Fi: Connection-specific DNS Suffix . : xxxxxxxxx Link-local IPv6 Address . . . . . : fe80::20b2:4f30:ed18:5956%13 IPv4 Address. . . . . . . . . . . : 10.170.109.10 Subnet Mask . . . . . . . . . . . : 255.255.254.0 Default Gateway . . . . . . . . . : 10.170.109.254 node-0:~$ sudo traceroute -I 10.170.109.10 traceroute to 10.170.109.10 (10.170.109.10), 30 hops max, 60 byte packets 1 node-1 (192.168.91.137) 0.256 ms 0.223 ms 0.252 ms 2 192.168.91.2 (192.168.91.2) 0.269 ms 0.256 ms 0.235 ms 3 10.170.109.10 (10.170.109.10) 0.727 ms 0.871 ms 1.175 ms 3. Mobile IP Mobile IP is based on the idea that a host has a home network but may visit other networks from time to time. While at home, ordinary forwarding is performed. When away from home, the host keeps the IP address it would ordinarily use at home, but some special routing and forwarding tricks are used to make the host appear to the network, and to the other systems with which it communicates, as though it is attached to its home network. The scheme depends on a special type of router called a home agent that helps provide routing for mobile nodes. Most of the complexity in MIPv6 involves signaling messages and how they are secured. These messages use various forms of the Mobility extension header (Next Header field value 135, often just called the mobility header), so Mobile IP is, in effect, a special protocol of its own. 3.1. The Basic Model for IP Mobility: Bidirectional Tunneling The following figure shows the entities involved in making MIPv6 work. Much of the terminology also applies to MIPv4 [RFC5944]. A host that might move is called a mobile node (MN), and the hosts with which it is communicating are called correspondent nodes (CNs). The MN is given an IP address chosen from the network prefix used in its home network. This address is known as its home address (HoA). When it travels to a visited network, it is given an additional address, called its care-of-address (CoA). In the basic model, whenever a CN communicates with an MN, the traffic is routed through the MN&#8217;s home agent (HA). HAs are a special type of router deployed in the network infrastructure like other important systems (e.g., routers and Web servers). The association between an MN&#8217;s HoA and its CoA is called a binding for the MN. Figure 5. Mobile IP supports the ability of nodes to change their point of network attachment and keep network connections operating. The mobile node’s home agent helps to forward traffic for mobiles it serves and also plays a role in route optimization, which can substantially improve routing performance by allowing mobile and correspondent nodes to communicate directly. The basic model works in cases where an MN&#8217;s CNs do not engage in the MIPv6 protocol. This model is also used for network mobility (called NEMO [RFC3963]), when an entire network is mobile. When the MN (or mobile network router) attaches to a new point in the network, it receives its CoA and sends a binding update message to its HA. The HA responds with a binding acknowledgment. Assuming that all goes well, traffic between the MN and CNs is thereafter routed through the MN&#8217;s HA using a two-way form of IPv6 packet tunneling[RFC2473] called bidirectional tunneling. These messages are ordinarily protected using IPsec with the Encapsulating Security Payload (ESP). Doing so ensures that an HA is not fooled into accepting a binding update from a fake MN. 4. Host Processing of IP Datagrams Although routers do not ordinarily have to consider which IP addresses to place in the Source IP Address and Destination IP Address fields of the packets they forward, hosts must consider both. Applications such as Web browsers may attempt to make connections to a named host or server that can have multiple addresses. The client system making such connections may also have multiple addresses. 4.1. Host Models Although it may appear to be a straightforward decision to determine whether a received unicast datagram matches one of a host&#8217;s IP addresses and should be processed, this decision depends on the host model of the receiving system [RFC1122] and is most relevant for multihomed hosts. There are two host models, the strong host model and the weak host model. In the strong host model, a datagram is accepted for delivery to the local protocol stack only if the IP address contained in the Destination IP Address field matches one of those configured on the interface upon which the datagram arrived. In systems implementing the weak host model, the opposite is true—a datagram carrying a destination address matching any of the local addresses may arrive on any interface and is processed by the receiving protocol stack, irrespective of the network interface upon which it arrived. Host models also apply to sending behavior. That is, a host using the strong host model sends datagrams from a particular interface only if one of the interface&#8217;s configured addresses matches the Source IP Address field in the datagram being sent. Figure 6. Hosts may be connected by more than one interface. In such cases, they must decide which addresses to use for the Source IP Address and Destination IP Address fields of the packets they exchange. The addresses used result from a combination of each host&#8217;s forwarding table, application of an address selection algorithm [RFC 3484], and whether hosts are operating using a weak or strong host model. In this example, two hosts (A and B) are connected through the global Internet but also through a local network. If host A is set up to conform to the strong host model, packets it receives destined for 203.0.113.1 from the Internet or destined for 192.0.2.1 from the local network are dropped. This situation can arise, for example, if host B is configured to obey the weak host model. It may choose to send packets to 192.0.2.1 using the local network (e.g., because doing so may be cheaper or faster). This situation seems unfortunate, as A receives what appear to be perfectly legitimate packets, yet drops them merely because it is operating according to the strong host model. The host model, for both sending and receiving behavior, can be configured in some operating systems. In Windows (Vista and later), strong host behavior is the default for sending and receiving for IPv4 and IPv6. In Linux, the IP behavior defaults to the weak host model. BSD (including Mac OS X) uses the strong hostmodel. In Windows, the following commands can be used to configure weak host receive and send behavior, respectively: C:\&gt; netsh interface ipvX set interface &lt;ifname&gt; weakhostreceive=Yabled C:\&gt; netsh interface ipvX set interface &lt;ifname&gt; weakhostsend=Yabled For these commands, &lt;ifname&gt; is replaced with the appropriate interface name; X is replaced with either 4 or 6, depending on which version of IP is being configured; and Y is replaced with either en or dis, depending on whether weak behavior is to be enabled or disabled, respectively. netsh interface ipv4&gt;show interfaces Idx Met MTU State Name --- ---------- ---------- ------------ --------------------------- 1 75 4294967295 connected Loopback Pseudo-Interface 1 13 35 1500 connected Wi-Fi 10 5 1500 disconnected Ethernet netsh interface ipv4&gt;show interfaces interface=&quot;Wi-Fi&quot; Interface Wi-Fi Parameters ---------------------------------------------- Weak Host Sends : disabled Weak Host Receives : disabled References [1] Kevin Fall, W. Stevens TCP/IP Illustrated: The Protocols, Volume 1. 2nd edition, Addison-Wesley Professional, 2011 [AN] https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" />
<link rel="canonical" href="https://blog.codefarm.me/2022/11/22/tcp-ip-internet-protocol/" />
<meta property="og:url" content="https://blog.codefarm.me/2022/11/22/tcp-ip-internet-protocol/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-22T09:17:14+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="TCP/IP: Internet Protocol" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-22T09:17:14+08:00","datePublished":"2022-11-22T09:17:14+08:00","description":"1. IPv4 and IPv6 Headers 1.1. IP Header Fields 1.2. The Internet Checksum 2. IP Forwarding 2.1. Forwarding Table 2.2. IP Forwarding Actions 2.3. Direct delivery and indirect delivery 3. Mobile IP 3.1. The Basic Model for IP Mobility: Bidirectional Tunneling 4. Host Processing of IP Datagrams 4.1. Host Models References IP is the workhorse protocol of the TCP/IP protocol suite. All TCP, UDP, ICMP, and IGMP data gets transmitted as IP datagrams. IP provides a best-effort, connectionless datagram delivery service. 1. IPv4 and IPv6 Headers The normal size of the IPv4 header is 20 bytes, unless options are present (which is rare). The IPv6 header is twice as large but never has any options, may have extension headers. The most significant bit of headers and datagrams is numbered 0 at the left, and the least significant bit of a 32-bit value is numbered 31 on the right. The 4 bytes in a 32-bit value are transmitted in the following order: bits 0–7 first, then bits 8–15, then 16–23, and bits 24–31 last. This is called big endian byte ordering, which is the byte ordering required for all binary integers in the TCP/IP headers as they traverse a network. It is also called network byte order. Computer CPUs that store binary integers in other formats, such as the little endian format, must convert the header values into network byte order for transmission and back again for reception. $ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian Model name: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz Figure 1. The IPv4 datagram format. The header is of variable size, limited to fifteen 32-bit words (60 bytes) by the 4-bit IHL field. A typical IPv4 header contains 20 bytes (no options). The source and destination addresses are 32 bits long. Most of the second 32-bit word is used for the IPv4 fragmentation function. A header checksum helps ensure that the fields in the header are delivered correctly to the proper destination but does not protect the data. Figure 2. The IPv6 datagram format. The IPv6 header is of fixed size (40 bytes) and contains 128-bit source and destination addresses. The Next Header field is used to indicate the presence and types of additional extension headers that follow the IPv6 header, forming a daisy chain of headers that may include special extensions or processing directives. Application data follows the header chain, usually immediately following a transport-layer header. 1.1. IP Header Fields The first field (only 4 bits or one nibble wide) is the Version field. It contains the version number of the IP datagram: 4 for IPv4 and 6 for IPv6. The headers for both IPv4 and IPv6 share the location of the Version field but no others. Thus, the two protocols are not directly interoperable—a host or router must handle either IPv4 or IPv6 (or both, called dual stack) separately. The Internet Header Length (IHL) field is the number of 32-bit words in the IPv4 header, including any options. Because this is also a 4-bit field, the IPv4 header is limited to a maximum of fifteen 32-bit words or 60 bytes. The normal value of this field (when no options are present) is 5. There is no such field in IPv6 because the header length is fixed at 40 bytes. Following the header length, the original specification of IPv4 [RFC0791] specified a Type of Service (ToS) byte, and IPv6 [RFC2460] specified the equivalent Traffic Class byte. Use of these never became widespread, so eventually this 8-bit field was split into two smaller parts and redefined by a set of RFCs ([RFC3260] [RFC3168][RFC2474] and others). The first 6 bits are now called the Differentiated Services Field (DS Field), and the last 2 bits are the Explicit Congestion Notification (ECN) field or indicator bits. These RFCs now apply to both IPv4 and IPv6. These fields are used for special processing of the datagram when it is forwarded. The Total Length field is the total length of the IPv4 datagram in bytes. Using this field and the IHL field, we know where the data portion of the datagram starts, and its length. Because this is a 16-bit field, the maximum size of an IPv4 datagram (including header) is 65,535 bytes. Although it is possible to send a 65,535-byte IP datagram, most link layers (such as Ethernet) are not able to carry one this large without fragmenting it (chopping it up) into smaller pieces. Furthermore, a host is not required to be able to receive an IPv4 datagram larger than 576 bytes. In IPv6 a host must be able to process a datagram at least as large as the MTU of the link to which it is attached, and the minimum link MTU is 1280 bytes. When an IPv4 datagram is fragmented into multiple smaller fragments, each of which itself is an independent IP datagram, the Total Length field reflects the length of the particular fragment. In IPv6, fragmentation is not supported by the header, and the length is instead given by the Payload Length field. This field measures the length of the IPv6 datagram not including the length of the header; extension headers, however, are included in the Payload Length field. The Identification field helps indentify each datagram sent by an IPv4 host. To ensure that the fragments of one datagram are not confused with those of another, the sending host normally increments an internal counter by 1 each time a datagram is sent (from one of its IP addresses) and copies the value of the counter into the IPv4 Identification field. The Identification, Flags and Fragment Offset fields are most important for implementing fragmentation. In IPv6, this field shows up in the Fragmentation extension header. The Time-to-Live field, or TTL, sets an upper limit on the number of routers through which a datagram can pass. It is initialized by the sender to some value (64 is recommended [RFC1122], although 128 or 255 is not uncommon) and decremented by 1 by every router that forwards the datagram. When this field reaches 0, the datagram is thrown away, and the sender is notified with an ICMP message. This prevents packets from getting caught in the network forever should an unwanted routing loop occur. The Protocol field in the IPv4 header contains a number indicating the type of data found in the payload portion of the datagram. The most common values are 17 (for UDP) and 6 (for TCP). This provides a demultiplexing feature so that the IP protocol can be used to carry payloads of more than one protocol type. Although this field originally specified the transport-layer protocol the datagram is encapsulating, it is now understood to identify the encapsulated protocol, which may or not be a transport protocol. For example, other encapsulations are possible, such as IPv4-in-IPv4 (value 4). The official list of the possible values of the Protocol field is given in the assigned numbers page [AN]. The Next Header field in the IPv6 header generalizes the Protocol field from IPv4. It is used to indicate the type of header following the IPv6 header. This field may contain any values defined for the IPv4 Protocol field, or any of the values associated with the IPv6 extension headers. Decimal Keyword Protocol IPv6 Extension Header Reference 0 HOPOPT IPv6 Hop-by-Hop Option Y [RFC8200] 1 ICMP Internet Control Message [RFC792] 2 IGMP Internet Group Management [RFC1112] 3 GGP Gateway-to-Gateway [RFC823] 4 IPv4 IPv4 encapsulation [RFC2003] 6 TCP Transmission Control [RFC9293] 8 EGP Exterior Gateway Protocol [RFC888][David_Mills] 9 IGP any private interior gateway (used by Cisco for their IGRP) [Internet_Assigned_Numbers_Authority] 17 UDP User Datagram [RFC768][Jon_Postel] 33 DCCP Datagram Congestion Control Protocol [RFC4340] 41 IPv6 IPv6 encapsulation [RFC2473] 43 IPv6-Route Routing Header for IPv6 Y [Steve_Deering] 44 IPv6-Frag Fragment Header for IPv6 Y [Steve_Deering] 50 ESP Encap Security Payload Y [RFC4303] 51 AH Authentication Header Y [RFC4302] 58 IPv6-ICMP ICMP for IPv6 [RFC8200] 59 IPv6-NoNxt No Next Header for IPv6 [RFC8200] 60 IPv6-Opts Destination Options for IPv6 Y [RFC8200] 108 IPComp IP Payload Compression Protocol [RFC2393] 115 L2TP Layer Two Tunneling Protocol [RFC3931][Bernard_Aboba] 132 SCTP Stream Control Transmission Protocol [Randall_R_Stewart] The Header Checksum field is calculated over the IPv4 header only. This is important to understand because it means that the payload of the IPv4 datagram (e.g., TCP or UDP data) is not checked for correctness by the IP protocol. Perhaps surprisingly, the IPv6 header does not have any checksum field. Every IP datagram contains the Source IP Address of the sender of the datagram and the Destination IP Address of where the datagram is destined. These are 32-bit values for IPv4 and 128-bit values for IPv6, and they usually identify a single interface on a computer, although multicast and broadcast addresses violate this rule. 1.2. The Internet Checksum The Internet checksum is a 16-bit mathematical sum used to determine, with reasonably high probability, whether a received message or portion of a message matches the one sent. Note that the Internet checksum algorithm is not the same as the common cyclic redundancy check (CRC), which offers stronger protection. To compute the IPv4 header checksum for an outgoing datagram, the value of the datagram&#8217;s Checksum field is first set to 0. Then, the 16-bit one&#8217;s complement sum of the header is calculated (the entire header is considered a sequence of 16-bit words). The 16-bit one&#8217;s complement of this sum is then stored in the Checksum field to make the datagram ready for transmission. One&#8217;s complement addition can be implemented by &quot;end-round-carry addition&quot;: when a carry bit is produced using conventional (two&#8217;s complement) addition, the carry is added back in as a 1 value. When an IPv4 datagram is received, a checksum is computed across the whole header, including the value of the Checksum field itself. Assuming there are no errors, the computed checksum value is always 0 (a one&#8217;s complement of the value FFFF). Note that for any nontrivial packet or header, the value of the Checksum field in the packet can never be FFFF. If it were, the sum (prior to the final one&#8217;s complement operation at the sender) would have to have been 0. No sum can ever be 0 using one&#8217;s complement addition unless all the bytes are 0—something that never happens with any legitimate IPv4 header. When the header is found to be bad (the computed checksum is nonzero), the IPv4 implementation discards the received datagram. No error message is generated. It is up to the higher layers to somehow detect the missing datagram and retransmit if necessary. Figure 3. The Internet checksum is the one&#8217;s complement of a one&#8217;s complement 16-bit sum of the data being checksummed (zero padding is used if the number of bytes being summed is odd). If the data being summed includes a Checksum field, the field is first set to 0 prior to the checksum operation and then filled in with the computed checksum. To check whether an incoming block of data that contains a Checksum field (header, payload, etc.) is valid, the same type of checksum is computed over the whole block (including the Checksum field). Because the Checksum field is essentially the inverse of the checksum of the rest of the data, computing the checksum on correctly received data should produce a value of 0. 45 10 01 48 00 00 00 00 10 11 70 c4 c0 a8 5b fe c0 a8 5b 82 | 45 10 | Version, IHL, DS, ECN | 0100 0101 0001 0000 | 01 48 | Total Length | 0000 0001 0100 1000 =&gt; 0100 0110 0101 1000 | 00 00 | Identification | 0000 0000 0000 0000 =&gt; 0100 0110 0101 1000 | 00 00 | Flags, Fragment Offset | 0000 0000 0000 0000 =&gt; 0100 0110 0101 1000 | 10 11 | TTL, Protocol | 0001 0000 0001 0001 =&gt; 0101 0110 0110 1001 | 70 c4 | Checksum | 0111 0000 1100 0100 =&gt; 0101 0110 0110 1001 | c0 a8 | Source Address | 1100 0000 1010 1000 1 0001 0111 0001 0001 + 1 =&gt; 0001 0111 0001 0010 # round-carry | 5b fe | Source Address | 0101 1011 1111 1110 =&gt; 0111 0011 0001 0000 | c0 a8 | Destination Address | 1100 0000 1010 1000 =&gt; 0011 0011 1011 1001 # round-carry | 5b 82 | Destination Address | 0101 1011 1000 0010 =&gt; 1000 1111 0011 1011 =&gt; 0111 0000 1100 0100 # one&#39;s complement (i.e. checksum) =&gt; 1111 1111 1111 1111 # computed including the Checksum field =&gt; 0000 0000 0000 0000 # one&#39;s complement (correct) 2. IP Forwarding Conceptually, IP forwarding is simple, especially for a host. If the destination is directly connected to the host (e.g., a point-to-point link) or on a shared network (e.g., Ethernet), the IP datagram is sent directly to the destination—a router is not required or used. Otherwise, the host sends the datagram to a single router (called the default router) and lets the router deliver the datagram to its destination. What differentiates a host from a router to IP is how IP datagrams are handled: a host never forwards datagrams it does not originate, whereas routers do. In our general scheme, the IP protocol can receive a datagram either from another protocol on the same machine (TCP, UDP, etc.) or from a network interface. The IP layer has some information in memory, usually called a routing table or forwarding table, which it searches each time it receives a datagram to send. When a datagram is received from a network interface, IP first checks if the destination IP address is one of its own IP addresses (i.e., one of the IP addresses associated with one of its network interfaces) or some other address for which it should receive traffic such as an IP broadcast or multicast address. If so, the datagram is delivered to the protocol module specified by the Protocol field in the IPv4 header or Next Header field in the IPv6 header. If the datagram is not destined for one of the IP addresses being used locally by the IP module, then (1) if the IP layer was configured to act as a router, the datagram is forwarded; or (2) the datagram is silently discarded. Under some circumstances (e.g., no route is known in case 1), an ICMP message may be sent back to the source indicating an error condition. 2.1. Forwarding Table The IP protocol standards do not dictate the precise data required to be in a forwarding table, as this choice is left up to the implementer of the IP protocol. Nevertheless, several key pieces of information are generally required to implement the forwarding table for IP. Destination: This contains a 32-bit field (or 128-bit field for IPv6) used for matching the result of a masking operation. The destination can be as simple as zero, for a default route covering all destinations, or as long as the full length of an IP address, in the case of a host route that describes only a single destination. Mask: This contains a 32-bit field (128-bit field for IPv6) applied as a bitwise AND mask to the destination IP address of a datagram being looked up in the forwarding table. The masked result is compared with the set of destinations in the forwarding table entries. Next-hop: This contains the 32-bit IPv4 address or 128-bit IPv6 address of the next IP entity (router or host) to which the datagram should be sent. The next-hop entity is typically on a network shared with the system performing the forwarding lookup, meaning the two share the same network prefix. Interface: This contains an identifier used by the IP layer to reference the network interface that should be used to send the datagram to its next hop. For example, it could refer to a host&#8217;s 802.11 wireless interface, a wired Ethernet interface, or a PPP interface associated with a serial port. If the forwarding system is also the sender of the IP datagram, this field is used in selecting which source IP address to use on the outgoing datagram. $ sudo route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.91.2 0.0.0.0 UG 0 0 0 ens32 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 192.168.91.0 0.0.0.0 255.255.255.0 U 0 0 0 ens32 192.168.91.0 0.0.0.0 255.255.255.0 U 0 0 0 ens34 $ ip r default via 192.168.91.2 dev ens32 onlink 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 PS C:\\&gt; route print -4 =========================================================================== Interface List 10...48 2a e3 94 1e 19 ......Intel(R) Ethernet Connection (10) I219-V 6...02 00 4c 4f 4f 50 ......Microsoft KM-TEST Loopback Adapter 5...8c c6 81 fe 82 c5 ......Microsoft Wi-Fi Direct Virtual Adapter 8...8e c6 81 fe 82 c4 ......Microsoft Wi-Fi Direct Virtual Adapter #2 19...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1 9...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8 13...8c c6 81 fe 82 c4 ......Intel(R) Wireless-AC 9560 160MHz 1...........................Software Loopback Interface 1 =========================================================================== IPv4 Route Table =========================================================================== Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 10.170.109.254 10.170.109.10 35 10.170.108.0 255.255.254.0 On-link 10.170.109.10 291 10.170.109.10 255.255.255.255 On-link 10.170.109.10 291 10.170.109.255 255.255.255.255 On-link 10.170.109.10 291 127.0.0.0 255.0.0.0 On-link 127.0.0.1 331 127.0.0.1 255.255.255.255 On-link 127.0.0.1 331 127.255.255.255 255.255.255.255 On-link 127.0.0.1 331 169.254.0.0 255.255.0.0 On-link 169.254.24.54 281 169.254.24.54 255.255.255.255 On-link 169.254.24.54 281 169.254.255.255 255.255.255.255 On-link 169.254.24.54 281 192.168.56.0 255.255.255.0 On-link 192.168.56.1 291 192.168.56.1 255.255.255.255 On-link 192.168.56.1 291 192.168.56.255 255.255.255.255 On-link 192.168.56.1 291 192.168.91.0 255.255.255.0 On-link 192.168.91.1 291 192.168.91.1 255.255.255.255 On-link 192.168.91.1 291 192.168.91.255 255.255.255.255 On-link 192.168.91.1 291 224.0.0.0 240.0.0.0 On-link 127.0.0.1 331 224.0.0.0 240.0.0.0 On-link 192.168.56.1 291 224.0.0.0 240.0.0.0 On-link 192.168.91.1 291 224.0.0.0 240.0.0.0 On-link 169.254.24.54 281 224.0.0.0 240.0.0.0 On-link 10.170.109.10 291 255.255.255.255 255.255.255.255 On-link 127.0.0.1 331 255.255.255.255 255.255.255.255 On-link 192.168.56.1 291 255.255.255.255 255.255.255.255 On-link 192.168.91.1 291 255.255.255.255 255.255.255.255 On-link 169.254.24.54 281 255.255.255.255 255.255.255.255 On-link 10.170.109.10 291 =========================================================================== Persistent Routes: None IP forwarding is performed on a hop-by-hop basis. The routers and hosts do not contain the complete forwarding path to any destination. IP forwarding provides the IP address of only the next-hop entity to which the datagram is sent. It is assumed that the next hop is really closer to the destination than the forwarding system is, and that the next-hop router is directly connected to (i.e., shares a common network prefix with) the forwarding system. It is also generally assumed that no loops are constructed between the next hops so that a datagram does not circulate around the network until its TTL or hop limit expires. 2.2. IP Forwarding Actions When the IP layer in a host or router needs to send an IP datagram to a next-hop router or host, it first examines the destination IP address (D) in the datagram. Using the value D, the following longest prefix match algorithm is executed on the forwarding table: Search the table for all entries for which the following property holds: (D ^ mj) = dj, where mj is the value of the mask field associated with the forwarding entry ej having index j, and dj is the value of the destination field associated with ej. If the destination IP address D is bitwise ANDed with the mask in each forwarding table entry (mj), and the result is compared against the destination in the same forwarding table entry (dj), the entry (ej here) is a match for the destination IP address. When a match happens, the algorithm notes the entry index (j here) and how many bits in the mask mj were set to 1, and the more bits set to 1, the better the match. The best matching entry ek (i.e., the one with the largest number of 1 bits in its mask mk) is selected, and its next-hop field nk is used as the next-hop IP address in forwarding the datagram. If no matches in the forwarding table are found, the datagram is undeliverable. If the undeliverable datagram was generated locally (on this host), a host unreachable error is normally returned to the application that generated the datagram. On a router, an ICMP message is normally sent back to the host that sent the datagram. In some circumstances, more than one entry may match an equal number of 1 bits. This can happen, for example, when more than one default route is available (e.g., when attached to more than one ISP, called multihoming). The end-system behavior in such cases is not set by standards and is instead specific to the operating system&#8217;s protocol implementation. A common behavior is for the system to simply choose the first match. More sophisticated systems may attempt to load-balance or split traffic across the multiple routes. 2.3. Direct delivery and indirect delivery Routers DO NOT change the source and destination IP addresses within the IP packet itself. Routers DO change the source and destination MAC addresses of the Ethernet frame that encapsulates the IP packet. Where all systems are using the same network prefix, is called direct delivery, and the other case is called indirect delivery. Figure 4. Direct delivery and indirect delivery Direct delivery does not require the presence of a router—IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination. Indirect delivery involves a router—data is forwarded to the router using the router&#8217;s link-layer address as the destination link-layer address. The router&#8217;s IP address does not appear in the IP datagram (unless the router itself is the source or destination, or when source routing is used). In the following table, the destination IPv4 address D (10.0.0.9) matches both the first and second forwarding table entries. Because it matches the second entry better (25 bits instead of none), the gateway or next-hop address is 10.0.0.100, the address S. Thus, the gateway portion of the entry contains the address of the sending host&#8217;s own network interface (no router is referenced), indicating that direct delivery is to be used to send the datagram. Table 1. The (unicast) IPv4 forwarding table at host S contains only two entries. Destination Mask Gateway (Next Hop) Interface 0.0.0.0 0.0.0.0 10.0.0.1 10.0.0.100 10.0.0.0 255.255.255.128 10.0.0.100 10.0.0.100 Host S is configured with IPv4 address and subnet mask 10.0.0.100/25. Datagrams destined for addresses in the range 10.0.0.1 through 10.0.0.126 use the second forwarding table entry and are sent using direct delivery. All other datagrams use the first entry and are given to router R with IPv4 address 10.0.0.1. The datagram is encapsulated in a lower-layer frame destined for the target host D. If the lower-layer address of the target host is unknown, the ARP protocol (for IPv4) or Neighbor Solicitation (for IPv6) operation may be invoked at this point to determine the correct lower-layer address, D. Once known, the destination address in the datagram is D&#39;s IPv4 address (10.0.0.9), and D is placed in the Destination IP Address field in the lower-layer header. The switch delivers the frame to D based solely on the link-layer address D; it pays no attention to the IP addresses. $ ip n 172.17.0.2 dev docker0 lladdr 02:42:ac:11:00:02 STALE 192.168.91.254 dev ens32 lladdr 00:50:56:fc:89:96 STALE 192.168.91.1 dev ens32 lladdr 00:50:56:c0:00:08 REACHABLE 192.168.91.2 dev ens34 lladdr 00:50:56:e9:f6:27 STALE 192.168.91.2 dev ens32 lladdr 00:50:56:e9:f6:27 STALE 192.168.91.138 dev ens32 FAILED fe80::50c2:d6ef:87fb:1b7b dev ens34 lladdr 00:50:56:c0:00:08 STALE $ sudo arp -n Address HWtype HWaddress Flags Mask Iface 172.17.0.2 ether 02:42:ac:11:00:02 C docker0 192.168.91.254 ether 00:50:56:fc:89:96 C ens32 192.168.91.1 ether 00:50:56:c0:00:08 C ens32 192.168.91.2 ether 00:50:56:e9:f6:27 C ens34 192.168.91.2 ether 00:50:56:e9:f6:27 C ens32 192.168.91.138 (incomplete) ens32 Table 2. The (unicast) IPv4 forwarding table at router R1 contains only two entries. Destination Mask Gateway (Next Hop) Interface Note 0.0.0.0 0.0.0.0 70.231.159.254 70.231.132.85 NAT 10.0.0.0 255.255.255.128 10.0.0.100 10.0.0.1 NAT The forwarding table at R1 indicates that address translation should be performed for traffic. The router has a private address on one side (10.0.0.1) and a public address on the other (70.231.132.85). Address translation is used to make datagrams originating on the 10.0.0.0/25 network appear to the Internet as though they had been sent from 70.231.132.85. node-0:~$ ip r default via 192.168.91.2 dev ens32 onlink 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 node-0:~$ sudo ip r del default node-0:~$ sudo ip r add default via 192.168.91.137 dev ens32 node-0:~$ ip r default via 192.168.91.137 dev ens32 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138 node-1:~$ ip r default via 192.168.91.2 dev ens32 192.168.56.0/24 dev ens36 proto kernel scope link src 192.168.56.128 192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.137 192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.131 192.168.91.0/24 dev ens33 proto kernel scope link src 192.168.91.129 node-1:~$ sudo sysctl net.ipv4.ip_forward=1 net.ipv4.ip_forward = 1 PS C:\\&gt; ipconfig Wireless LAN adapter Wi-Fi: Connection-specific DNS Suffix . : xxxxxxxxx Link-local IPv6 Address . . . . . : fe80::20b2:4f30:ed18:5956%13 IPv4 Address. . . . . . . . . . . : 10.170.109.10 Subnet Mask . . . . . . . . . . . : 255.255.254.0 Default Gateway . . . . . . . . . : 10.170.109.254 node-0:~$ sudo traceroute -I 10.170.109.10 traceroute to 10.170.109.10 (10.170.109.10), 30 hops max, 60 byte packets 1 node-1 (192.168.91.137) 0.256 ms 0.223 ms 0.252 ms 2 192.168.91.2 (192.168.91.2) 0.269 ms 0.256 ms 0.235 ms 3 10.170.109.10 (10.170.109.10) 0.727 ms 0.871 ms 1.175 ms 3. Mobile IP Mobile IP is based on the idea that a host has a home network but may visit other networks from time to time. While at home, ordinary forwarding is performed. When away from home, the host keeps the IP address it would ordinarily use at home, but some special routing and forwarding tricks are used to make the host appear to the network, and to the other systems with which it communicates, as though it is attached to its home network. The scheme depends on a special type of router called a home agent that helps provide routing for mobile nodes. Most of the complexity in MIPv6 involves signaling messages and how they are secured. These messages use various forms of the Mobility extension header (Next Header field value 135, often just called the mobility header), so Mobile IP is, in effect, a special protocol of its own. 3.1. The Basic Model for IP Mobility: Bidirectional Tunneling The following figure shows the entities involved in making MIPv6 work. Much of the terminology also applies to MIPv4 [RFC5944]. A host that might move is called a mobile node (MN), and the hosts with which it is communicating are called correspondent nodes (CNs). The MN is given an IP address chosen from the network prefix used in its home network. This address is known as its home address (HoA). When it travels to a visited network, it is given an additional address, called its care-of-address (CoA). In the basic model, whenever a CN communicates with an MN, the traffic is routed through the MN&#8217;s home agent (HA). HAs are a special type of router deployed in the network infrastructure like other important systems (e.g., routers and Web servers). The association between an MN&#8217;s HoA and its CoA is called a binding for the MN. Figure 5. Mobile IP supports the ability of nodes to change their point of network attachment and keep network connections operating. The mobile node’s home agent helps to forward traffic for mobiles it serves and also plays a role in route optimization, which can substantially improve routing performance by allowing mobile and correspondent nodes to communicate directly. The basic model works in cases where an MN&#8217;s CNs do not engage in the MIPv6 protocol. This model is also used for network mobility (called NEMO [RFC3963]), when an entire network is mobile. When the MN (or mobile network router) attaches to a new point in the network, it receives its CoA and sends a binding update message to its HA. The HA responds with a binding acknowledgment. Assuming that all goes well, traffic between the MN and CNs is thereafter routed through the MN&#8217;s HA using a two-way form of IPv6 packet tunneling[RFC2473] called bidirectional tunneling. These messages are ordinarily protected using IPsec with the Encapsulating Security Payload (ESP). Doing so ensures that an HA is not fooled into accepting a binding update from a fake MN. 4. Host Processing of IP Datagrams Although routers do not ordinarily have to consider which IP addresses to place in the Source IP Address and Destination IP Address fields of the packets they forward, hosts must consider both. Applications such as Web browsers may attempt to make connections to a named host or server that can have multiple addresses. The client system making such connections may also have multiple addresses. 4.1. Host Models Although it may appear to be a straightforward decision to determine whether a received unicast datagram matches one of a host&#8217;s IP addresses and should be processed, this decision depends on the host model of the receiving system [RFC1122] and is most relevant for multihomed hosts. There are two host models, the strong host model and the weak host model. In the strong host model, a datagram is accepted for delivery to the local protocol stack only if the IP address contained in the Destination IP Address field matches one of those configured on the interface upon which the datagram arrived. In systems implementing the weak host model, the opposite is true—a datagram carrying a destination address matching any of the local addresses may arrive on any interface and is processed by the receiving protocol stack, irrespective of the network interface upon which it arrived. Host models also apply to sending behavior. That is, a host using the strong host model sends datagrams from a particular interface only if one of the interface&#8217;s configured addresses matches the Source IP Address field in the datagram being sent. Figure 6. Hosts may be connected by more than one interface. In such cases, they must decide which addresses to use for the Source IP Address and Destination IP Address fields of the packets they exchange. The addresses used result from a combination of each host&#8217;s forwarding table, application of an address selection algorithm [RFC 3484], and whether hosts are operating using a weak or strong host model. In this example, two hosts (A and B) are connected through the global Internet but also through a local network. If host A is set up to conform to the strong host model, packets it receives destined for 203.0.113.1 from the Internet or destined for 192.0.2.1 from the local network are dropped. This situation can arise, for example, if host B is configured to obey the weak host model. It may choose to send packets to 192.0.2.1 using the local network (e.g., because doing so may be cheaper or faster). This situation seems unfortunate, as A receives what appear to be perfectly legitimate packets, yet drops them merely because it is operating according to the strong host model. The host model, for both sending and receiving behavior, can be configured in some operating systems. In Windows (Vista and later), strong host behavior is the default for sending and receiving for IPv4 and IPv6. In Linux, the IP behavior defaults to the weak host model. BSD (including Mac OS X) uses the strong hostmodel. In Windows, the following commands can be used to configure weak host receive and send behavior, respectively: C:\\&gt; netsh interface ipvX set interface &lt;ifname&gt; weakhostreceive=Yabled C:\\&gt; netsh interface ipvX set interface &lt;ifname&gt; weakhostsend=Yabled For these commands, &lt;ifname&gt; is replaced with the appropriate interface name; X is replaced with either 4 or 6, depending on which version of IP is being configured; and Y is replaced with either en or dis, depending on whether weak behavior is to be enabled or disabled, respectively. netsh interface ipv4&gt;show interfaces Idx Met MTU State Name --- ---------- ---------- ------------ --------------------------- 1 75 4294967295 connected Loopback Pseudo-Interface 1 13 35 1500 connected Wi-Fi 10 5 1500 disconnected Ethernet netsh interface ipv4&gt;show interfaces interface=&quot;Wi-Fi&quot; Interface Wi-Fi Parameters ---------------------------------------------- Weak Host Sends : disabled Weak Host Receives : disabled References [1] Kevin Fall, W. Stevens TCP/IP Illustrated: The Protocols, Volume 1. 2nd edition, Addison-Wesley Professional, 2011 [AN] https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml","headline":"TCP/IP: Internet Protocol","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2022/11/22/tcp-ip-internet-protocol/"},"url":"https://blog.codefarm.me/2022/11/22/tcp-ip-internet-protocol/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">TCP/IP: Internet Protocol</h1><p class="c-post-meta">22 Nov 2022</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#ipv4-and-ipv6-headers">1. IPv4 and IPv6 Headers</a>
<ul class="sectlevel2">
<li><a href="#ip-header-fields">1.1. IP Header Fields</a></li>
<li><a href="#the-internet-checksum">1.2. The Internet Checksum</a></li>
</ul>
</li>
<li><a href="#ip-forwarding">2. IP Forwarding</a>
<ul class="sectlevel2">
<li><a href="#forwarding-table">2.1. Forwarding Table</a></li>
<li><a href="#ip-forwarding-actions">2.2. IP Forwarding Actions</a></li>
<li><a href="#direct-delivery-and-indirect-delivery">2.3. Direct delivery and indirect delivery</a></li>
</ul>
</li>
<li><a href="#mobile-ip">3. Mobile IP</a>
<ul class="sectlevel2">
<li><a href="#the-basic-model-for-ip-mobility-bidirectional-tunneling">3.1. The Basic Model for IP Mobility: Bidirectional Tunneling</a></li>
</ul>
</li>
<li><a href="#host-processing-of-ip-datagrams">4. Host Processing of IP Datagrams</a>
<ul class="sectlevel2">
<li><a href="#host-models">4.1. Host Models</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>IP is the workhorse protocol of the TCP/IP protocol suite. All TCP, UDP, ICMP, and IGMP data gets transmitted as IP datagrams. IP provides a <strong><em>best-effort</em></strong>, <strong><em>connectionless</em></strong> datagram delivery service.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ipv4-and-ipv6-headers">1. IPv4 and IPv6 Headers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The normal size of the IPv4 header is 20 bytes, unless <em>options</em> are present (which is rare).</p>
</div>
<div class="paragraph">
<p>The IPv6 header is twice as large but never has any options, may have <em>extension headers</em>.</p>
</div>
<div class="paragraph">
<p>The most significant bit of headers and datagrams is numbered 0 at the left, and the least significant bit of a 32-bit value is numbered 31 on the right.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The 4 bytes in a 32-bit value are transmitted in the following order: bits <em>0–7</em> first, then bits <em>8–15</em>, then <em>16–23</em>, and bits <em>24–31</em> last.</p>
</li>
<li>
<p>This is called <strong>big endian byte ordering</strong>, which is the byte ordering required for all binary integers in the TCP/IP headers as they traverse a network. It is also called <strong>network byte order</strong>.</p>
</li>
<li>
<p>Computer CPUs that store binary integers in other formats, such as the <strong>little endian</strong> format, must convert the header values into network byte order for transmission and back again for reception.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>lscpu
<span class="go">Architecture:                    x86_64</span>
<span class="go">CPU op-mode(s):                  32-bit, 64-bit</span>
<span class="hll"><span class="go">Byte Order:                      Little Endian</span>
</span><span class="go">Model name:                      Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/ipv4-datagram.png" alt="IPv4 Datagram" width="55%" height="55%">
</div>
<div class="title">Figure 1. The IPv4 datagram format.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The header is of variable size, limited to fifteen 32-bit words (60 bytes) by the 4-bit <em>IHL</em> field.</p>
</li>
<li>
<p>A typical IPv4 header contains 20 bytes (no options).</p>
</li>
<li>
<p>The source and destination addresses are 32 bits long.</p>
</li>
<li>
<p>Most of the second 32-bit word is used for the IPv4 <em>fragmentation</em> function.</p>
</li>
<li>
<p>A header <em>checksum</em> helps ensure that the fields in the header are delivered correctly to the proper destination but does not protect the data.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/ipv6-datagram.png" alt="IPv6 Datagram" width="55%" height="55%">
</div>
<div class="title">Figure 2. The IPv6 datagram format.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The IPv6 header is of fixed size (40 bytes) and contains 128-bit <em>source</em> and <em>destination</em> addresses.</p>
</li>
<li>
<p>The <em>Next Header</em> field is used to indicate the presence and types of additional extension headers that follow the IPv6 header, forming a <em>daisy chain of headers</em> that may include special extensions or processing directives.</p>
</li>
<li>
<p>Application data follows the header chain, usually immediately following a transport-layer header.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="ip-header-fields">1.1. IP Header Fields</h3>
<div class="paragraph">
<p>The first field (only 4 bits or one nibble wide) is the <em>Version</em> field.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It contains the version number of the IP datagram: <em>4</em> for IPv4 and <em>6</em> for IPv6.</p>
</li>
<li>
<p>The headers for both IPv4 and IPv6 share the location of the <em>Version</em> field but no others.</p>
</li>
<li>
<p>Thus, the two protocols are not directly interoperable—a host or router must handle either IPv4 or IPv6 (or both, called <strong><em>dual stack</em></strong>) separately.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Internet Header Length (IHL)</em> field is the number of 32-bit words in the IPv4 header, including any options.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because this is also a 4-bit field, the IPv4 header is limited to a maximum of fifteen 32-bit words or 60 bytes.</p>
<div class="paragraph">
<p>The normal value of this field (when no options are present) is 5.</p>
</div>
</li>
<li>
<p>There is no such field in IPv6 because the header length is fixed at 40 bytes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following the header length, the original specification of IPv4 [RFC0791] specified a <em>Type of Service (ToS)</em> byte, and IPv6 [RFC2460] specified the equivalent <em>Traffic Class</em> byte.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use of these never became widespread, so eventually this 8-bit field was split into two smaller parts and redefined by a set of RFCs ([RFC3260] [RFC3168][RFC2474] and others).</p>
<div class="ulist">
<ul>
<li>
<p>The first 6 bits are now called the <em>Differentiated Services</em> Field (<em>DS</em> Field), and the last 2 bits are the <em>Explicit Congestion Notification</em> (<em>ECN</em>) field or indicator bits.</p>
</li>
<li>
<p>These RFCs now apply to both IPv4 and IPv6.</p>
</li>
</ul>
</div>
</li>
<li>
<p>These fields are used for special processing of the datagram when it is forwarded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Total Length</em> field is the total length of the IPv4 datagram in bytes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using this field and the <em>IHL</em> field, we know where the data portion of the datagram starts, and its length.</p>
</li>
<li>
<p>Because this is a 16-bit field, the maximum size of an IPv4 datagram (including header) is 65,535 bytes.</p>
</li>
<li>
<p>Although it is possible to send a 65,535-byte IP datagram, most link layers (such as Ethernet) are not able to carry one this large without fragmenting it (chopping it up) into smaller pieces.</p>
<div class="paragraph">
<p>Furthermore, a host is not required to be able to receive an IPv4 datagram larger than <em>576</em> bytes.</p>
</div>
<div class="paragraph">
<p>In IPv6 a host must be able to process a datagram at least as large as the MTU of the link to which it is attached, and the minimum link MTU is <em>1280</em> bytes.</p>
</div>
<div class="paragraph">
<p>When an IPv4 datagram is fragmented into multiple smaller fragments, each of which itself is an independent IP datagram, the <em>Total Length</em> field reflects the length of the particular fragment.</p>
</div>
<div class="paragraph">
<p>In IPv6, fragmentation is not supported by the header, and the length is instead given by the <em>Payload Length</em> field.</p>
</div>
<div class="paragraph">
<p>This field measures the length of the IPv6 datagram not including the length of the header; extension headers, however, are included in the <em>Payload Length</em> field.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Identification</em> field helps indentify each datagram sent by an IPv4 host.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To ensure that the fragments of one datagram are not confused with those of another, the sending host normally increments an internal counter by 1 each time a datagram is sent (from one of its IP addresses) and copies the value of the counter into the IPv4 <em>Identification</em> field.</p>
</li>
<li>
<p>The <em>Identification</em>, <em>Flags</em> and <em>Fragment Offset</em> fields are most important for implementing fragmentation.</p>
<div class="paragraph">
<p>In IPv6, this field shows up in the <em>Fragmentation extension header</em>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Time-to-Live</em> field, or <em>TTL</em>, sets an upper limit on the number of routers through which a datagram can pass.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is initialized by the sender to some value (<em>64</em> is recommended [RFC1122], although <em>128</em> or <em>255</em> is not uncommon) and decremented by <em>1</em> by every router that forwards the datagram.</p>
</li>
<li>
<p>When this field reaches <em>0</em>, the datagram is thrown away, and the sender is notified with an <em>ICMP</em> message.</p>
<div class="paragraph">
<p>This prevents packets from getting caught in the network forever should an unwanted routing loop occur.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Protocol</em> field in the IPv4 header contains a number indicating the type of data found in the payload portion of the datagram.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The most common values are <em>17</em> (for UDP) and <em>6</em> (for TCP).</p>
</li>
<li>
<p>This provides a demultiplexing feature so that the IP protocol can be used to carry payloads of more than one protocol type.</p>
</li>
<li>
<p>Although this field originally specified the <em>transport-layer protocol</em> the datagram is encapsulating, it is now understood to identify the encapsulated protocol, which may or not be a transport protocol.</p>
<div class="paragraph">
<p>For example, other encapsulations are possible, such as <em>IPv4-in-IPv4</em> (value <em>4</em>).</p>
</div>
</li>
<li>
<p>The official list of the possible values of the Protocol field is given in the assigned numbers page <a href="#AN">[AN]</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Next Header</em> field in the IPv6 header generalizes the <em>Protocol</em> field from IPv4.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is used to indicate the type of header following the IPv6 header.</p>
</li>
<li>
<p>This field may contain any values defined for the IPv4 <em>Protocol</em> field, or any of the values associated with the IPv6 extension headers.</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 10%;">
<col style="width: 15%;">
<col style="width: 35%;">
<col style="width: 5%;">
<col style="width: 35%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Decimal</th>
<th class="tableblock halign-left valign-top">Keyword</th>
<th class="tableblock halign-left valign-top">Protocol</th>
<th class="tableblock halign-left valign-top">IPv6 Extension Header</th>
<th class="tableblock halign-left valign-top">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HOPOPT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6 Hop-by-Hop Option</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC8200]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Internet Control Message</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC792]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IGMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Internet Group Management</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC1112]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GGP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gateway-to-Gateway</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC823]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4 encapsulation</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC2003]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transmission Control</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC9293]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EGP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exterior Gateway Protocol</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC888][David_Mills]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IGP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any private interior gateway (used by Cisco for their IGRP)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[Internet_Assigned_Numbers_Authority]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User Datagram</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC768][Jon_Postel]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">33</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datagram Congestion Control Protocol</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC4340]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">41</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6 encapsulation</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC2473]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">43</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6-Route</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Routing Header for IPv6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[Steve_Deering]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">44</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6-Frag</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fragment Header for IPv6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[Steve_Deering]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encap Security Payload</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC4303]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">51</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AH</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Authentication Header</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC4302]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">58</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6-ICMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMP for IPv6</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC8200]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">59</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6-NoNxt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No Next Header for IPv6</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC8200]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6-Opts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Destination Options for IPv6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC8200]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">108</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPComp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP Payload Compression Protocol</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC2393]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">115</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L2TP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Layer Two Tunneling Protocol</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[RFC3931][Bernard_Aboba]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">132</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCTP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stream Control Transmission Protocol</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[Randall_R_Stewart]</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Header Checksum</em> field is calculated over the IPv4 header only.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is important to understand because it means that the payload of the IPv4 datagram (e.g., TCP or UDP data) is not checked for correctness by the IP protocol.</p>
</li>
<li>
<p>Perhaps surprisingly, the IPv6 header does not have any checksum field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Every IP datagram contains the <em>Source IP Address</em> of the sender of the datagram and the <em>Destination IP Address</em> of where the datagram is destined.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>These are 32-bit values for IPv4 and 128-bit values for IPv6, and they usually identify a single interface on a computer, although multicast and broadcast addresses  violate this rule.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="the-internet-checksum">1.2. The Internet Checksum</h3>
<div class="paragraph">
<p>The Internet checksum is a 16-bit mathematical sum used to determine, with reasonably high probability, whether a received message or portion of a message matches the one sent.</p>
</div>
<div class="paragraph">
<p>Note that the Internet checksum algorithm is not the same as the common <em>cyclic redundancy check</em> (CRC), which offers stronger protection.</p>
</div>
<div class="paragraph">
<p>To compute the IPv4 header checksum for an outgoing datagram,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the value of the datagram&#8217;s <em>Checksum</em> field is first set to 0.</p>
</li>
<li>
<p>Then, the 16-bit one&#8217;s complement sum of the header is calculated (the entire header is considered a sequence of 16-bit words).</p>
</li>
<li>
<p>The 16-bit one&#8217;s complement of this sum is then stored in the <em>Checksum</em> field to make the datagram ready for transmission.</p>
<div class="paragraph">
<p>One&#8217;s complement addition can be implemented by "end-round-carry addition": when a carry bit is produced using conventional (two&#8217;s complement) addition, the carry is added back in as a 1 value.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an IPv4 datagram is received, a checksum is computed across the whole header, including the value of the <em>Checksum</em> field itself. Assuming there are no errors, the computed checksum value is always 0 (a one&#8217;s complement of the value <em>FFFF</em>).</p>
</div>
<div class="paragraph">
<p>Note that for any nontrivial packet or header, the value of the <em>Checksum</em> field in the packet can never be <em>FFFF</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If it were, the sum (prior to the final one&#8217;s complement operation at the sender) would have to have been 0.</p>
</li>
<li>
<p>No sum can ever be 0 using one&#8217;s complement addition unless all the bytes are 0—something that never happens with any legitimate IPv4 header.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the header is found to be bad (the computed checksum is nonzero), the IPv4 implementation discards the received datagram.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No error message is generated.</p>
</li>
<li>
<p>It is up to the higher layers to somehow detect the missing datagram and retransmit if necessary.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/internet-checksum-computed-check.png" alt="Internet checksum" width="55%" height="55%">
</div>
<div class="title">Figure 3. The Internet checksum is the one&#8217;s complement of a one&#8217;s complement 16-bit sum of the data being checksummed (zero padding is used if the number of bytes being summed is odd). If the data being summed includes a <em>Checksum</em> field, the field is first set to 0 prior to the checksum operation and then filled in with the computed checksum. To check whether an incoming block of data that contains a <em>Checksum</em> field (header, payload, etc.) is valid, the same type of checksum is computed over the whole block (including the <em>Checksum</em> field). Because the <em>Checksum</em> field is essentially the inverse of the checksum of the rest of the data, computing the checksum on correctly received data should produce a value of 0.</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">45 10 01 48 00 00 00 00 10 11 70 c4 c0 a8 5b fe c0 a8 5b 82

| 45 10 | Version, IHL, DS, ECN  | 0100 0101 0001 0000

| 01 48 | Total Length           | 0000 0001 0100 1000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0100 0110 0101 1000
<span class="go">| 00 00 | Identification         | 0000 0000 0000 0000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0100 0110 0101 1000
<span class="go">| 00 00 | Flags, Fragment Offset | 0000 0000 0000 0000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0100 0110 0101 1000
<span class="go">| 10 11 | TTL, Protocol          | 0001 0000 0001 0001
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0101 0110 0110 1001
<span class="go">| 70 c4 | Checksum               | 0111 0000 1100 0100
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0101 0110 0110 1001
<span class="go">| c0 a8 | Source Address         | 1100 0000 1010 1000
                                 1 0001 0111 0001 0001
                                 +                   1
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0001 0111 0001 0010 <span class="c"># round-carry</span>
<span class="go">| 5b fe | Source Address         | 0101 1011 1111 1110
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0111 0011 0001 0000
<span class="go">| c0 a8 | Destination Address    | 1100 0000 1010 1000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0011 0011 1011 1001 <span class="c"># round-carry</span>
<span class="go">| 5b 82 | Destination Address    | 0101 1011 1000 0010
</span><span class="gp">                                =&gt;</span><span class="w"> </span>1000 1111 0011 1011
<span class="gp">                                =&gt;</span><span class="w"> </span>0111 0000 1100 0100 <span class="c"># one's complement (i.e. checksum)</span>
<span class="gp">                                =&gt;</span><span class="w"> </span>1111 1111 1111 1111 <span class="c"># computed including the Checksum field</span>
<span class="gp">                                =&gt;</span><span class="w"> </span>0000 0000 0000 0000 <span class="c"># one's complement (correct)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ip-forwarding">2. IP Forwarding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Conceptually, IP forwarding is simple, especially for a host.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the destination is directly connected to the host (e.g., a point-to-point link) or on a shared network (e.g., Ethernet), the IP datagram is sent directly to the destination—a router is not required or used.</p>
</li>
<li>
<p>Otherwise, the host sends the datagram to a single router (called the <em>default router</em>) and lets the router deliver the datagram to its destination.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>What differentiates a host from a router to IP is how IP datagrams are handled: a host never forwards datagrams it does not originate, whereas routers do.</p>
</div>
<div class="paragraph">
<p>In our general scheme, the IP protocol can receive a datagram either</p>
</div>
<div class="ulist">
<ul>
<li>
<p>from another protocol on the same machine (TCP, UDP, etc.)</p>
</li>
<li>
<p>or from a network interface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The IP layer has some information in memory, usually called a <strong><em>routing table</em></strong> or <strong><em>forwarding table</em></strong>, which it searches each time it receives a datagram to send.</p>
</div>
<div class="paragraph">
<p>When a datagram is received from a network interface, IP first checks if the <em>destination IP address</em> is one of</p>
</div>
<div class="ulist">
<ul>
<li>
<p>its own IP addresses (i.e., one of the IP addresses associated with one of its network interfaces)</p>
</li>
<li>
<p>or some other address for which it should receive traffic such as an IP broadcast or multicast address.</p>
<div class="paragraph">
<p>If so, the datagram is delivered to the protocol module specified by the <em>Protocol</em> field in the IPv4 header or <em>Next Header</em> field in the IPv6 header.</p>
</div>
<div class="paragraph">
<p>If the datagram is not destined for one of the IP addresses being used locally by the IP module, then</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(1) if the IP layer was configured to act as a router, the datagram is forwarded; or</p>
</li>
<li>
<p>(2) the datagram is silently discarded.</p>
</li>
<li>
<p>Under some circumstances (e.g., no route is known in case 1), an ICMP message may be sent back to the source indicating an error condition.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="forwarding-table">2.1. Forwarding Table</h3>
<div class="paragraph">
<p>The IP protocol standards do not dictate the precise data required to be in a <em>forwarding table</em>, as this choice is left up to the implementer of the IP protocol.</p>
</div>
<div class="paragraph">
<p>Nevertheless, several key pieces of information are generally required to implement the forwarding table for IP.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Destination</strong>: This contains a 32-bit field (or 128-bit field for IPv6) used for matching the result of a masking operation.</p>
<div class="paragraph">
<p>The destination can be as simple as zero, for a <em>default route</em> covering all destinations, or as long as the full length of an IP address, in the case of a <em>host route</em> that describes only a single destination.</p>
</div>
</li>
<li>
<p><strong>Mask</strong>: This contains a 32-bit field (128-bit field for IPv6) applied as a bitwise <em>AND</em> mask to the destination IP address of a datagram being looked up in the <em>forwarding table</em>.</p>
<div class="paragraph">
<p>The masked result is compared with the set of destinations in the <em>forwarding table entries</em>.</p>
</div>
</li>
<li>
<p><strong>Next-hop</strong>: This contains the 32-bit IPv4 address or 128-bit IPv6 address of the next IP entity (<em>router</em> or <em>host</em>) to which the datagram should be sent.</p>
<div class="paragraph">
<p>The next-hop entity is typically on a network shared with the system performing the forwarding lookup, meaning the two share the same network prefix.</p>
</div>
</li>
<li>
<p><strong>Interface</strong>: This contains an identifier used by the IP layer to reference the network interface that should be used to send the datagram to its next hop.</p>
<div class="paragraph">
<p>For example, it could refer to a host&#8217;s 802.11 wireless interface, a wired Ethernet interface, or a PPP interface associated with a serial port.</p>
</div>
<div class="paragraph">
<p>If the forwarding system is also the sender of the IP datagram, this field is used in selecting which source IP address to use on the outgoing datagram.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>route <span class="nt">-n</span>
<span class="go">Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.91.2    0.0.0.0         UG    0      0        0 ens32
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
192.168.91.0    0.0.0.0         255.255.255.0   U     0      0        0 ens32
192.168.91.0    0.0.0.0         255.255.255.0   U     0      0        0 ens34

</span><span class="gp">$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.2 dev ens32 onlink
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">PS C:\&gt;</span><span class="w"> </span>route print <span class="nt">-4</span>
<span class="go">===========================================================================
Interface List
 10...48 2a e3 94 1e 19 ......Intel(R) Ethernet Connection (10) I219-V
  6...02 00 4c 4f 4f 50 ......Microsoft KM-TEST Loopback Adapter
  5...8c c6 81 fe 82 c5 ......Microsoft Wi-Fi Direct Virtual Adapter
</span><span class="gp">  8...8e c6 81 fe 82 c4 ......Microsoft Wi-Fi Direct Virtual Adapter #</span>2
<span class="go"> 19...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1
  9...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8
 13...8c c6 81 fe 82 c4 ......Intel(R) Wireless-AC 9560 160MHz
  1...........................Software Loopback Interface 1
===========================================================================

IPv4 Route Table
===========================================================================
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0   10.170.109.254    10.170.109.10     35
     10.170.108.0    255.255.254.0         On-link     10.170.109.10    291
    10.170.109.10  255.255.255.255         On-link     10.170.109.10    291
   10.170.109.255  255.255.255.255         On-link     10.170.109.10    291
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
  127.255.255.255  255.255.255.255         On-link         127.0.0.1    331
      169.254.0.0      255.255.0.0         On-link     169.254.24.54    281
    169.254.24.54  255.255.255.255         On-link     169.254.24.54    281
  169.254.255.255  255.255.255.255         On-link     169.254.24.54    281
     192.168.56.0    255.255.255.0         On-link      192.168.56.1    291
     192.168.56.1  255.255.255.255         On-link      192.168.56.1    291
   192.168.56.255  255.255.255.255         On-link      192.168.56.1    291
     192.168.91.0    255.255.255.0         On-link      192.168.91.1    291
     192.168.91.1  255.255.255.255         On-link      192.168.91.1    291
   192.168.91.255  255.255.255.255         On-link      192.168.91.1    291
        224.0.0.0        240.0.0.0         On-link         127.0.0.1    331
        224.0.0.0        240.0.0.0         On-link      192.168.56.1    291
        224.0.0.0        240.0.0.0         On-link      192.168.91.1    291
        224.0.0.0        240.0.0.0         On-link     169.254.24.54    281
        224.0.0.0        240.0.0.0         On-link     10.170.109.10    291
  255.255.255.255  255.255.255.255         On-link         127.0.0.1    331
  255.255.255.255  255.255.255.255         On-link      192.168.56.1    291
  255.255.255.255  255.255.255.255         On-link      192.168.91.1    291
  255.255.255.255  255.255.255.255         On-link     169.254.24.54    281
  255.255.255.255  255.255.255.255         On-link     10.170.109.10    291
===========================================================================
Persistent Routes:
  None</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>IP forwarding is performed on a <strong><em>hop-by-hop</em></strong> basis.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The routers and hosts do not contain the complete forwarding path to any destination.</p>
</li>
<li>
<p>IP forwarding provides the IP address of only the next-hop entity to which the datagram is sent.</p>
</li>
<li>
<p>It is assumed that the next hop is really <em>closer</em> to the destination than the forwarding system is, and that the next-hop router is directly connected to (i.e., shares a common network prefix with) the forwarding system.</p>
</li>
<li>
<p>It is also generally assumed that no <em>loops</em> are constructed between the next hops so that a datagram does not circulate around the network until its <em>TTL</em> or <em>hop limit</em> expires.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ip-forwarding-actions">2.2. IP Forwarding Actions</h3>
<div class="paragraph">
<p>When the IP layer in a host or router needs to send an IP datagram to a next-hop router or host, it first examines the destination IP address (<em>D</em>) in the datagram.</p>
</div>
<div class="paragraph">
<p>Using the value <em>D</em>, the following <strong><em>longest prefix match algorithm</em></strong> is executed on the forwarding table:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Search the table for all entries for which the following property holds: (<em>D ^ m<sub>j</sub></em>) = <em>d<sub>j</sub></em>,</p>
<div class="paragraph">
<p>where <em>m<sub>j</sub></em> is the value of the mask field associated with the forwarding entry <em>e<sub>j</sub></em> having index <em>j</em>,</p>
</div>
<div class="paragraph">
<p>and <em>d<sub>j</sub></em> is the value of the destination field associated with <em>e<sub>j</sub></em>.</p>
</div>
<div class="paragraph">
<p>If the destination IP address <em>D</em> is bitwise <em>ANDed</em> with the mask in each forwarding table entry (<em>m<sub>j</sub></em>),</p>
</div>
<div class="paragraph">
<p>and the result is compared against the destination in the same forwarding table entry (<em>d<sub>j</sub></em>),</p>
</div>
<div class="paragraph">
<p>the entry (<em>e<sub>j</sub></em> here) is a match for the destination IP address.</p>
</div>
<div class="paragraph">
<p>When a match happens, the algorithm notes the entry index (<em>j</em> here) and how many bits in the mask <em>m<sub>j</sub></em> were set to <em>1</em>, and the more bits set to <em>1</em>, the better the match.</p>
</div>
</li>
<li>
<p>The best matching entry <em>e<sub>k</sub></em> (i.e., the one with the largest number of <em>1</em> bits in its mask <em>m<sub>k</sub></em>) is selected, and its next-hop field <em>n<sub>k</sub></em> is used as the next-hop IP address in forwarding the datagram.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If no matches in the forwarding table are found, the datagram is undeliverable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the undeliverable datagram was generated locally (on this host), a <em>host unreachable</em> error is normally returned to the application that generated the datagram.</p>
</li>
<li>
<p>On a router, an <em>ICMP</em> message is normally sent back to the host that sent the datagram.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In some circumstances, more than one entry may match an equal number of <em>1</em> bits.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This can happen, for example, when more than one default route is available (e.g., when attached to more than one ISP, called <em>multihoming</em>).</p>
</li>
<li>
<p>The end-system behavior in such cases is not set by standards and is instead specific to the operating system&#8217;s protocol implementation.</p>
</li>
<li>
<p>A common behavior is for the system to simply choose the first match.</p>
</li>
<li>
<p>More sophisticated systems may attempt to <em>load-balance</em> or <em>split traffic</em> across the multiple routes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="direct-delivery-and-indirect-delivery">2.3. Direct delivery and indirect delivery</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Routers DO NOT change the source and destination IP addresses within the IP packet itself.</p>
</div>
<div class="paragraph">
<p>Routers DO change the source and destination MAC addresses of the Ethernet frame that encapsulates the IP packet.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Where all systems are using the same network prefix, is called <em>direct delivery</em>, and the other case is called <em>indirect delivery</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/direct-delivery-and-indirect-delivery.png" alt="Direct delivery and indirect delivery" width="55%" height="55%">
</div>
<div class="title">Figure 4. Direct delivery and indirect delivery</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Direct delivery does not require the presence of a router—IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination.</p>
</li>
<li>
<p>Indirect delivery involves a router—data is forwarded to the router using the router&#8217;s link-layer address as the destination link-layer address.</p>
</li>
<li>
<p>The router&#8217;s IP address does not appear in the IP datagram (unless the router itself is the source or destination, or when source routing is used).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the following table, the destination IPv4 address <em>D</em> (<em>10.0.0.9</em>) matches both the first and second forwarding table entries.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because it matches the second entry better (<em>25</em> bits instead of none), the <em>gateway</em> or <em>next-hop</em> address is <em>10.0.0.100</em>, the address <em>S</em>.</p>
</li>
<li>
<p>Thus, the gateway portion of the entry contains the address of the sending host&#8217;s own network interface (no router is referenced), indicating that direct delivery is to be used to send the datagram.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 1. The (unicast) IPv4 forwarding table at host <em>S</em> contains only two entries.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Destination</th>
<th class="tableblock halign-left valign-top">Mask</th>
<th class="tableblock halign-left valign-top">Gateway (Next Hop)</th>
<th class="tableblock halign-left valign-top">Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.255.255.128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Host <em>S</em> is configured with IPv4 address and subnet mask <em>10.0.0.100/25</em>.</p>
</li>
<li>
<p>Datagrams destined for addresses in the range <em>10.0.0.1</em> through <em>10.0.0.126</em> use the second forwarding table entry and are sent using <em>direct delivery</em>.</p>
</li>
<li>
<p>All other datagrams use the first entry and are given to router <em>R</em> with IPv4 address <em>10.0.0.1</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The datagram is encapsulated in a lower-layer frame destined for the target host <em>D</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the lower-layer address of the target host is unknown, the <em>ARP</em> protocol (for IPv4) or <em>Neighbor Solicitation</em> (for IPv6) operation may be invoked at this point to determine the correct lower-layer address, <em>D</em>.</p>
</li>
<li>
<p>Once known, the destination address in the datagram is <em>D</em>'s IPv4 address (10.0.0.9), and <em>D</em> is placed in the Destination IP Address field in the lower-layer header.</p>
</li>
<li>
<p>The switch delivers the frame to <em>D</em> based solely on the link-layer address <em>D</em>; it pays no attention to the IP addresses.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>ip n
<span class="go">172.17.0.2 dev docker0 lladdr 02:42:ac:11:00:02 STALE
192.168.91.254 dev ens32 lladdr 00:50:56:fc:89:96 STALE
192.168.91.1 dev ens32 lladdr 00:50:56:c0:00:08 REACHABLE
192.168.91.2 dev ens34 lladdr 00:50:56:e9:f6:27 STALE
192.168.91.2 dev ens32 lladdr 00:50:56:e9:f6:27 STALE
192.168.91.138 dev ens32  FAILED
fe80::50c2:d6ef:87fb:1b7b dev ens34 lladdr 00:50:56:c0:00:08 STALE

</span><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>arp <span class="nt">-n</span>
<span class="go">Address                  HWtype  HWaddress           Flags Mask            Iface
172.17.0.2               ether   02:42:ac:11:00:02   C                     docker0
192.168.91.254           ether   00:50:56:fc:89:96   C                     ens32
192.168.91.1             ether   00:50:56:c0:00:08   C                     ens32
192.168.91.2             ether   00:50:56:e9:f6:27   C                     ens34
192.168.91.2             ether   00:50:56:e9:f6:27   C                     ens32
192.168.91.138                   (incomplete)                              ens32</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 2. The (unicast) IPv4 forwarding table at router <em>R1</em> contains only two entries.</caption>
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 11.1112%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Destination</th>
<th class="tableblock halign-left valign-top">Mask</th>
<th class="tableblock halign-left valign-top">Gateway (Next Hop)</th>
<th class="tableblock halign-left valign-top">Interface</th>
<th class="tableblock halign-left valign-top">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">70.231.159.254</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">70.231.132.85</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NAT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.255.255.128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NAT</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>The forwarding table at <em>R1</em> indicates that address translation should be performed for traffic.</p>
</li>
<li>
<p>The router has a private address on one side (<em>10.0.0.1</em>) and a public address on the other (<em>70.231.132.85</em>).</p>
</li>
<li>
<p>Address translation is used to make datagrams originating on the <em>10.0.0.0/25</em> network appear to the Internet as though they had been sent from <em>70.231.132.85</em>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">node-0:~$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.2 dev ens32 onlink
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138

</span><span class="gp">node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>ip r del default
<span class="go">
</span><span class="gp">node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>ip r add default via 192.168.91.137 dev ens32
<span class="go">
</span><span class="gp">node-0:~$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.137 dev ens32
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">node-1:~$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.2 dev ens32
192.168.56.0/24 dev ens36 proto kernel scope link src 192.168.56.128
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.137
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.131
192.168.91.0/24 dev ens33 proto kernel scope link src 192.168.91.129

</span><span class="gp">node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>sysctl net.ipv4.ip_forward<span class="o">=</span>1
<span class="go">net.ipv4.ip_forward = 1</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">PS C:\&gt;</span><span class="w"> </span>ipconfig
<span class="go">
Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . : xxxxxxxxx
   Link-local IPv6 Address . . . . . : fe80::20b2:4f30:ed18:5956%13
   IPv4 Address. . . . . . . . . . . : 10.170.109.10
   Subnet Mask . . . . . . . . . . . : 255.255.254.0
   Default Gateway . . . . . . . . . : 10.170.109.254</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>traceroute <span class="nt">-I</span> 10.170.109.10
<span class="go">traceroute to 10.170.109.10 (10.170.109.10), 30 hops max, 60 byte packets
 1  node-1 (192.168.91.137)  0.256 ms  0.223 ms  0.252 ms
 2  192.168.91.2 (192.168.91.2)  0.269 ms  0.256 ms  0.235 ms
 3  10.170.109.10 (10.170.109.10)  0.727 ms  0.871 ms  1.175 ms</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mobile-ip">3. Mobile IP</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Mobile IP</strong> is based on the idea that a host has a <em>home</em> network but may visit other networks from time to time.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>While at home, ordinary forwarding is performed.</p>
</li>
<li>
<p>When away from home, the host keeps the IP address it would ordinarily use at home, but some special <em>routing</em> and <em>forwarding</em> tricks are used to make the host appear to the network, and to the other systems with which it communicates, as though it is attached to its home network.</p>
<div class="paragraph">
<p>The scheme depends on a special type of router called a <em>home agent</em> that helps provide routing for mobile nodes.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the complexity in <strong>MIPv6</strong> involves signaling messages and how they are secured. These messages use various forms of the Mobility extension header (Next Header field value <em>135</em>, often just called the <em>mobility header</em>), so Mobile IP is, in effect, a special protocol of its own.</p>
</div>
<div class="sect2">
<h3 id="the-basic-model-for-ip-mobility-bidirectional-tunneling">3.1. The Basic Model for IP Mobility: Bidirectional Tunneling</h3>
<div class="paragraph">
<p>The following figure shows the entities involved in making <em>MIPv6</em> work. Much of the terminology also applies to <em>MIPv4</em> [RFC5944].</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A host that might move is called a <em>mobile node</em> (MN), and the hosts with which it is communicating are called <em>correspondent nodes</em> (CNs).</p>
</li>
<li>
<p>The MN is given an IP address chosen from the network prefix used in its <em>home network</em>. This address is known as its <em>home address</em> (HoA).</p>
<div class="paragraph">
<p>When it travels to a <em>visited network</em>, it is given an additional address, called its <em>care-of-address</em> (CoA).</p>
</div>
</li>
<li>
<p>In the basic model, whenever a CN communicates with an MN, the traffic is routed through the MN&#8217;s <em>home agent</em> (HA).</p>
<div class="paragraph">
<p>HAs are a special type of router deployed in the network infrastructure like other important systems (e.g., routers and Web servers).</p>
</div>
</li>
<li>
<p>The association between an MN&#8217;s HoA and its CoA is called a <em>binding</em> for the MN.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/mobile-ip-model.png" alt="Basic MIPV6 Model" width="55%" height="55%">
</div>
<div class="title">Figure 5. Mobile IP supports the ability of nodes to change their point of network attachment and keep network connections operating. The mobile node’s home agent helps to forward traffic for mobiles it serves and also plays a role in route optimization, which can substantially improve routing performance by allowing mobile and correspondent nodes to communicate directly.</div>
</div>
<div class="paragraph">
<p>The basic model works in cases where an MN&#8217;s CNs do not engage in the MIPv6 protocol. This model is also used for network mobility (called <em>NEMO</em> [RFC3963]), when an entire network is mobile.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the MN (or mobile network router) attaches to a new point in the network, it receives its CoA and sends a <em>binding update</em> message to its HA. The HA responds with a <em>binding acknowledgment</em>.</p>
</li>
<li>
<p>Assuming that all goes well, traffic between the MN and CNs is thereafter routed through the MN&#8217;s HA using a two-way form of IPv6 packet tunneling[RFC2473] called <em>bidirectional tunneling</em>.</p>
<div class="paragraph">
<p>These messages are ordinarily protected using <em>IPsec</em> with the <em>Encapsulating Security Payload</em> (ESP).</p>
</div>
<div class="paragraph">
<p>Doing so ensures that an HA is not fooled into accepting a binding update from a fake MN.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="host-processing-of-ip-datagrams">4. Host Processing of IP Datagrams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although routers do not ordinarily have to consider which IP addresses to place in the <em>Source IP Address</em> and <em>Destination IP Address</em> fields of the packets they forward, hosts must consider both.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Applications such as Web browsers may attempt to make connections to a named host or server that can have multiple addresses.</p>
</li>
<li>
<p>The client system making such connections may also have multiple addresses.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="host-models">4.1. Host Models</h3>
<div class="paragraph">
<p>Although it may appear to be a straightforward decision to determine whether a received unicast datagram matches one of a host&#8217;s IP addresses and should be processed, this decision depends on the <em>host model</em> of the receiving system [RFC1122] and is most relevant for multihomed hosts.</p>
</div>
<div class="paragraph">
<p>There are two host models, the <strong>strong host model</strong> and the <strong>weak host model</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the <em>strong host model</em>, a datagram is accepted for delivery to the local protocol stack only if the IP address contained in the <em>Destination IP Address</em> field matches one of those configured on the interface upon which the datagram arrived.</p>
</li>
<li>
<p>In systems implementing the <em>weak host model</em>, the opposite is true—a datagram carrying a destination address matching any of the local addresses may arrive on any interface and is processed by the receiving protocol stack, irrespective of the network interface upon which it arrived.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Host models also apply to sending behavior. That is, a host using the strong host model sends datagrams from a particular interface only if one of the interface&#8217;s configured addresses matches the <em>Source IP Address</em> field in the datagram being sent.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/host-model.png" alt="Host Model" width="45%" height="45%">
</div>
<div class="title">Figure 6. Hosts may be connected by more than one interface. In such cases, they must decide which addresses to use for the <em>Source IP Address</em> and <em>Destination IP Address</em> fields of the packets they exchange. The addresses used result from a combination of each host&#8217;s forwarding table, application of an address selection algorithm [RFC 3484], and whether hosts are operating using a <em>weak</em> or <em>strong host model</em>.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>In this example, two hosts (A and B) are connected through the global Internet but also through a local network.</p>
</li>
<li>
<p>If host A is set up to conform to the <em>strong host model</em>, packets it receives destined for <em>203.0.113.1</em> from the Internet or destined for <em>192.0.2.1</em> from the local network are dropped.</p>
</li>
<li>
<p>This situation can arise, for example, if host B is configured to obey the <em>weak host model</em>.</p>
<div class="ulist">
<ul>
<li>
<p>It may choose to send packets to <em>192.0.2.1</em> using the local network (e.g., because doing so may be cheaper or faster).</p>
</li>
<li>
<p>This situation seems unfortunate, as A receives what appear to be perfectly legitimate packets, yet drops them merely because it is operating according to the strong host model.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The host model, for both sending and receiving behavior, can be configured in some operating systems.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In Windows (Vista and later), strong host behavior is the default for sending and receiving for IPv4 and IPv6.</p>
</li>
<li>
<p>In Linux, the IP behavior defaults to the weak host model.</p>
</li>
<li>
<p>BSD (including Mac OS X) uses the strong hostmodel.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Windows, the following commands can be used to configure weak host receive and send behavior, respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bat"><span class="kd">C</span>:\&gt; <span class="nb">netsh</span> <span class="kd">interface</span> <span class="kd">ipvX</span> <span class="kd">set</span> <span class="kd">interface</span> <span class="o">&lt;</span><span class="kd">ifname</span><span class="o">&gt;</span> <span class="kd">weakhostreceive</span><span class="o">=</span><span class="kd">Yabled</span>
<span class="kd">C</span>:\&gt; <span class="nb">netsh</span> <span class="kd">interface</span> <span class="kd">ipvX</span> <span class="kd">set</span> <span class="kd">interface</span> <span class="o">&lt;</span><span class="kd">ifname</span><span class="o">&gt;</span> <span class="kd">weakhostsend</span><span class="o">=</span><span class="kd">Yabled</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For these commands, <em>&lt;ifname&gt;</em> is replaced with the appropriate interface name; <em>X</em> is replaced with either 4 or 6, depending on which version of IP is being configured; and <em>Y</em> is replaced with either <em>en</em> or <em>dis</em>, depending on whether weak behavior is to be enabled or disabled, respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">netsh interface ipv4&gt;</span>show interfaces
<span class="go">
Idx     Met         MTU          State                Name
---  ----------  ----------  ------------  ---------------------------
  1          75  4294967295  connected     Loopback Pseudo-Interface 1
 13          35        1500  connected     Wi-Fi
 10           5        1500  disconnected  Ethernet

</span><span class="gp">netsh interface ipv4&gt;</span>show interfaces <span class="nv">interface</span><span class="o">=</span><span class="s2">"Wi-Fi"</span>
<span class="go">
Interface Wi-Fi Parameters
----------------------------------------------
Weak Host Sends                    : disabled
Weak Host Receives                 : disabled</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="tcp_ip_vol_1"></a>[1] Kevin Fall, W. Stevens <em>TCP/IP Illustrated: The Protocols, Volume 1</em>. 2nd edition, Addison-Wesley Professional, 2011</p>
</li>
<li>
<p><a id="AN"></a>[AN] <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" class="bare">https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
