<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>数学归纳法之递归求值 | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="数学归纳法之递归求值" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. 数学归纳法 2. 阶乘 3. 函数和递归 4. 递归求解 5. 尾调用和尾递归 6. 分治法 7. 动态规划 8. 调用栈和调用帧 9. 尾调用优化 10. 参考 1. 数学归纳法 数学归纳法是证明当 n 等于任意一个自然数时某命题成立。证明分为起始步骤（basics）和递推步骤（induction step）两步： 证明当 n = 1 时，命题成立。 证明如果 n = m 时命题成立，那么可以推导出在 n = m + 1 时命题成立。 2. 阶乘 阶乘的定义公式： n! = 1 × 2 × ... × (n-2) × (n - 1) × n 阶乘的递推公式： n! = n × (n-1)! 我们可以用数学归纳法证明阶乘的递推公式如下： 根据阶乘的定义，当 n = 0 或 n = 1 时，0! = 1 或 1! = 1，命题成立。 假设 n = m 时，m! = m × (m - 1)!， 当 n = m + 1 时，则 (m + 1)! = (m + 1) × [(m + 1) - 1]! = (m + 1) × m!，命题成立。 3. 函数和递归 如果我们把 n 的阶乘函数（function）定义为 f(n) = n! ，当 n = 0 或 1时，n! = 1 ，则根据阶乘的递推公式，我们有 f(n) = n × (n - 1)! = n × f(n - 1) 。也就是说，我们要求值 f(n) ，就要求值 f(n - 1) ，再求值 f(n - 2) &#8230;&#8203; f(2) , 最后求值 f(1) ，而这个函数 f 调用自己 f 的情况，我称之为递归（recursion）。 4. 递归求解 递归的用途是用于将一个大的问题，重复分解为相同或相似的子问题，直到子问题小到可以直接求解。 当子问题需要继续分解时，我们称这种情况为递归情况（recursive case）。 当子问题可以直接解决时，递归终止并回升，我称这种情况为基本情况（base case）。 以阶乘函数为例，f(0) = 1 和 f(1) = 1 为基本情况，f(n) = n × f(n - 1)，n &gt; 1 属于递归情况。 // Go 语言，递归求解阶乘 package main import ( &quot;fmt&quot; ) func main() { n := 5 f := factorial(n) fmt.Printf(&quot;%d! = %d\n&quot;, n, f) // Output: // n = 5: 5 * factorial(4) // n = 4: 4 * factorial(3) // n = 3: 3 * factorial(2) // n = 2: 2 * factorial(1) // n = 1: 1 // 5! = 120 } func factorial(n int) int { if n == 0 || n == 1 { // base case fmt.Printf(&quot;n = %d: %d\n&quot;, n, 1) return 1 } fmt.Printf(&quot;n = %d: %d * factorial(%d)\n&quot;, n, n, n-1) return n * factorial(n-1) // recursive case } 5. 尾调用和尾递归 在计算机科学中，尾调用（tail call）是指一个函数的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的函数返回值被当成当前函数的返回结果。如果递归函数（recursion）满足尾调用的定义，则称这种递归为尾递归（tail recursion）。 // Go 语言，尾递归求解阶乘 package main import ( &quot;fmt&quot; ) func main() { n := 5 f := tail_recursive_factorial(n, 1) fmt.Printf(&quot;%d! = %d\n&quot;, n, f) // Output: // n = 5: tail_recursive_factorial(4, 5*1) // n = 4: tail_recursive_factorial(3, 4*5) // n = 3: tail_recursive_factorial(2, 3*20) // n = 2: tail_recursive_factorial(1, 2*60) // n = 1: 120 // 5! = 120 } func tail_recursive_factorial(n, f int) int { if n == 0 || n == 1 { // base case fmt.Printf(&quot;n = %d: %d\n&quot;, n, f) return f } fmt.Printf(&quot;n = %d: tail_recursive_factorial(%d, %d*%d)\n&quot;, n, n-1, n, f) return tail_recursive_factorial(n-1, n*f) // recursive case } 6. 分治法 在计算机科学中，分治法（divide and conquer）是基于多分支递归的一个算法设计模式。分治算法是将问题递归的分解成两个或多个相同或相关类型的子问题，直到这些子问题简单到可以直接求解。最后将子问题的解进行合并得到原始问题的解。分治法是许多高效算法的技术基础，如排序中的归并排序（merge sort）和快速排序（quick sort）等等。 分治法的求解步骤如下： 分解:原问题为若干子问题，这些子问题是原有问题的规模较小的实例 解决:这些子问题，递归地求解各子问题。若子问题的规模足够小，则直接求解 合并:这些子问题的解成原问题的解 快速排序算法： 分解: 选择主元 P(viot), 将待排序序列分割成两个区域（partitions），左边的分区的元素都小于或等于 P，右边的元素大于 P 解决: 对左右两个分区进行递归的快速排序 合并: 由于序列是原址排序，分区的操作即为排序的操作，无需合并 // Go 语言，快速排序 package main import ( &quot;fmt&quot; ) func main() { s := []int{8, 5, 2, 6, 9, 3, 1, 4, 0, 7} fmt.Println(&quot;Before:&quot;, s) quick_sort(s, 0, len(s)) fmt.Println(&quot;After:&quot;, s) // Output: // Before: [8 5 2 6 9 3 1 4 0 7] // low: 0, high: 10, pivot: 7, s: [5 2 6 3 1 4 0 7 9 8] // low: 0, high: 07, pivot: 0, s: [0 2 6 3 1 4 5 7 9 8] // low: 0, high: 07, pivot: 5, s: [0 2 3 1 4 5 6 7 9 8] // low: 0, high: 05, pivot: 4, s: [0 2 3 1 4 5 6 7 9 8] // low: 0, high: 04, pivot: 1, s: [0 1 3 2 4 5 6 7 9 8] // low: 1, high: 04, pivot: 2, s: [0 1 2 3 4 5 6 7 9 8] // low: 2, high: 04, pivot: 3, s: [0 1 2 3 4 5 6 7 9 8] // low: 5, high: 07, pivot: 6, s: [0 1 2 3 4 5 6 7 9 8] // low: 7, high: 10, pivot: 8, s: [0 1 2 3 4 5 6 7 8 9] // low: 8, high: 10, pivot: 9, s: [0 1 2 3 4 5 6 7 8 9] // After: [0 1 2 3 4 5 6 7 8 9] } func quick_sort(s []int, low, high int) { if high-low &gt; 1 { // recursive case mid := partition(s, low, high) quick_sort(s, low, mid) quick_sort(s, mid, high) } // base case } func partition(s []int, low, high int) int { pivot := s[high-1] i := low - 1 for j := low; j &lt; high-1; j++ { if s[j] &lt;= pivot { // compare i++ s[j], s[i] = s[i], s[j] // swap } } s[i+1], s[high-1] = s[high-1], s[i+1] fmt.Printf(&quot;low: %d, high: %02d, pivot: %d, s: %v\n&quot;, low, high, pivot, s) return i + 1 } 7. 动态规划 动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 以求斐波那契数列为例： // a naive algorithm with time O(2^n) and space O(n) func fib(n int) int { // base case if n &lt;= 1 { return n } // recursive case return fib(n-1) + fib(n-2) } // a dynamic programming algorithm with time O(n) and space O(n) func fib(n int) int { if n &lt;= 1 { return n } f := make([]int, n+1) f[0] = 0 f[1] = 1 for i := 2; i &lt;= n; i++ { f[i] = f[i-1] + f[i-2] } return f[n] } 8. 调用栈和调用帧 在计算机科学中，调用栈（call stack）是一种存储函数调用上下文的数据结构，比如局部变量，函数返回控制点等等。 调用栈是由一系列的调用帧（stack frame）的栈结构形式组成。每次发起一个函数调用，都会对新的调用创建新的调用帧。 我们以当 n = 3 的阶乘为例，调用栈（bottom to up）如下所示： n = 1, f = 1 ------------------ n = 2, f = 2 * f(1) ------------------ n = 3, f = 3 * f(2) ------------------ 调用栈的大小通常是有限的，如果持续创建调用帧，则会导致调用栈溢出（stack overflow）。 比如对于递归调用，如果一直没有触发基本情况进行终止调用，进行递归回升，则会导致栈溢出。 // Go 语言，栈溢出 package main func main() { f() // Output: // runtime: goroutine stack exceeds 1000000000-byte limit // fatal error: stack overflow } func f() { f() } 9. 尾调用优化 我们知道尾递归是一种特性的尾调用，下面看下当 n = 3 的阶乘的尾递归调用栈： n = 1, f = 6 ------------------ n = 2, f = f(1, 2 * 3) ------------------ n = 3, f = f(2, 3 * 1) ------------------ 和上述的非尾递归的调用栈比较，我们会发现，尾递归的每次新的调用并不依赖下一个调用帧的返回结果，所以我们可以把这些调用帧减少至一个并重复使用，这种情况就叫做尾递归优化或者尾调用优化（tail call optimaization）。 10. 参考 https://en.wikipedia.org/wiki/Mathematical_induction https://en.wikipedia.org/wiki/Factorial https://en.wikipedia.org/wiki/Recursion_(computer_science) https://www.programmerinterview.com/index.php/recursion/explanation-of-recursion/ https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm https://en.wikipedia.org/wiki/Tail_call https://www.programmerinterview.com/index.php/recursion/tail-recursion/ https://www.programmerinterview.com/index.php/recursion/tail-call-optimization/ https://en.wikipedia.org/wiki/Quicksort" />
<meta property="og:description" content="1. 数学归纳法 2. 阶乘 3. 函数和递归 4. 递归求解 5. 尾调用和尾递归 6. 分治法 7. 动态规划 8. 调用栈和调用帧 9. 尾调用优化 10. 参考 1. 数学归纳法 数学归纳法是证明当 n 等于任意一个自然数时某命题成立。证明分为起始步骤（basics）和递推步骤（induction step）两步： 证明当 n = 1 时，命题成立。 证明如果 n = m 时命题成立，那么可以推导出在 n = m + 1 时命题成立。 2. 阶乘 阶乘的定义公式： n! = 1 × 2 × ... × (n-2) × (n - 1) × n 阶乘的递推公式： n! = n × (n-1)! 我们可以用数学归纳法证明阶乘的递推公式如下： 根据阶乘的定义，当 n = 0 或 n = 1 时，0! = 1 或 1! = 1，命题成立。 假设 n = m 时，m! = m × (m - 1)!， 当 n = m + 1 时，则 (m + 1)! = (m + 1) × [(m + 1) - 1]! = (m + 1) × m!，命题成立。 3. 函数和递归 如果我们把 n 的阶乘函数（function）定义为 f(n) = n! ，当 n = 0 或 1时，n! = 1 ，则根据阶乘的递推公式，我们有 f(n) = n × (n - 1)! = n × f(n - 1) 。也就是说，我们要求值 f(n) ，就要求值 f(n - 1) ，再求值 f(n - 2) &#8230;&#8203; f(2) , 最后求值 f(1) ，而这个函数 f 调用自己 f 的情况，我称之为递归（recursion）。 4. 递归求解 递归的用途是用于将一个大的问题，重复分解为相同或相似的子问题，直到子问题小到可以直接求解。 当子问题需要继续分解时，我们称这种情况为递归情况（recursive case）。 当子问题可以直接解决时，递归终止并回升，我称这种情况为基本情况（base case）。 以阶乘函数为例，f(0) = 1 和 f(1) = 1 为基本情况，f(n) = n × f(n - 1)，n &gt; 1 属于递归情况。 // Go 语言，递归求解阶乘 package main import ( &quot;fmt&quot; ) func main() { n := 5 f := factorial(n) fmt.Printf(&quot;%d! = %d\n&quot;, n, f) // Output: // n = 5: 5 * factorial(4) // n = 4: 4 * factorial(3) // n = 3: 3 * factorial(2) // n = 2: 2 * factorial(1) // n = 1: 1 // 5! = 120 } func factorial(n int) int { if n == 0 || n == 1 { // base case fmt.Printf(&quot;n = %d: %d\n&quot;, n, 1) return 1 } fmt.Printf(&quot;n = %d: %d * factorial(%d)\n&quot;, n, n, n-1) return n * factorial(n-1) // recursive case } 5. 尾调用和尾递归 在计算机科学中，尾调用（tail call）是指一个函数的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的函数返回值被当成当前函数的返回结果。如果递归函数（recursion）满足尾调用的定义，则称这种递归为尾递归（tail recursion）。 // Go 语言，尾递归求解阶乘 package main import ( &quot;fmt&quot; ) func main() { n := 5 f := tail_recursive_factorial(n, 1) fmt.Printf(&quot;%d! = %d\n&quot;, n, f) // Output: // n = 5: tail_recursive_factorial(4, 5*1) // n = 4: tail_recursive_factorial(3, 4*5) // n = 3: tail_recursive_factorial(2, 3*20) // n = 2: tail_recursive_factorial(1, 2*60) // n = 1: 120 // 5! = 120 } func tail_recursive_factorial(n, f int) int { if n == 0 || n == 1 { // base case fmt.Printf(&quot;n = %d: %d\n&quot;, n, f) return f } fmt.Printf(&quot;n = %d: tail_recursive_factorial(%d, %d*%d)\n&quot;, n, n-1, n, f) return tail_recursive_factorial(n-1, n*f) // recursive case } 6. 分治法 在计算机科学中，分治法（divide and conquer）是基于多分支递归的一个算法设计模式。分治算法是将问题递归的分解成两个或多个相同或相关类型的子问题，直到这些子问题简单到可以直接求解。最后将子问题的解进行合并得到原始问题的解。分治法是许多高效算法的技术基础，如排序中的归并排序（merge sort）和快速排序（quick sort）等等。 分治法的求解步骤如下： 分解:原问题为若干子问题，这些子问题是原有问题的规模较小的实例 解决:这些子问题，递归地求解各子问题。若子问题的规模足够小，则直接求解 合并:这些子问题的解成原问题的解 快速排序算法： 分解: 选择主元 P(viot), 将待排序序列分割成两个区域（partitions），左边的分区的元素都小于或等于 P，右边的元素大于 P 解决: 对左右两个分区进行递归的快速排序 合并: 由于序列是原址排序，分区的操作即为排序的操作，无需合并 // Go 语言，快速排序 package main import ( &quot;fmt&quot; ) func main() { s := []int{8, 5, 2, 6, 9, 3, 1, 4, 0, 7} fmt.Println(&quot;Before:&quot;, s) quick_sort(s, 0, len(s)) fmt.Println(&quot;After:&quot;, s) // Output: // Before: [8 5 2 6 9 3 1 4 0 7] // low: 0, high: 10, pivot: 7, s: [5 2 6 3 1 4 0 7 9 8] // low: 0, high: 07, pivot: 0, s: [0 2 6 3 1 4 5 7 9 8] // low: 0, high: 07, pivot: 5, s: [0 2 3 1 4 5 6 7 9 8] // low: 0, high: 05, pivot: 4, s: [0 2 3 1 4 5 6 7 9 8] // low: 0, high: 04, pivot: 1, s: [0 1 3 2 4 5 6 7 9 8] // low: 1, high: 04, pivot: 2, s: [0 1 2 3 4 5 6 7 9 8] // low: 2, high: 04, pivot: 3, s: [0 1 2 3 4 5 6 7 9 8] // low: 5, high: 07, pivot: 6, s: [0 1 2 3 4 5 6 7 9 8] // low: 7, high: 10, pivot: 8, s: [0 1 2 3 4 5 6 7 8 9] // low: 8, high: 10, pivot: 9, s: [0 1 2 3 4 5 6 7 8 9] // After: [0 1 2 3 4 5 6 7 8 9] } func quick_sort(s []int, low, high int) { if high-low &gt; 1 { // recursive case mid := partition(s, low, high) quick_sort(s, low, mid) quick_sort(s, mid, high) } // base case } func partition(s []int, low, high int) int { pivot := s[high-1] i := low - 1 for j := low; j &lt; high-1; j++ { if s[j] &lt;= pivot { // compare i++ s[j], s[i] = s[i], s[j] // swap } } s[i+1], s[high-1] = s[high-1], s[i+1] fmt.Printf(&quot;low: %d, high: %02d, pivot: %d, s: %v\n&quot;, low, high, pivot, s) return i + 1 } 7. 动态规划 动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 以求斐波那契数列为例： // a naive algorithm with time O(2^n) and space O(n) func fib(n int) int { // base case if n &lt;= 1 { return n } // recursive case return fib(n-1) + fib(n-2) } // a dynamic programming algorithm with time O(n) and space O(n) func fib(n int) int { if n &lt;= 1 { return n } f := make([]int, n+1) f[0] = 0 f[1] = 1 for i := 2; i &lt;= n; i++ { f[i] = f[i-1] + f[i-2] } return f[n] } 8. 调用栈和调用帧 在计算机科学中，调用栈（call stack）是一种存储函数调用上下文的数据结构，比如局部变量，函数返回控制点等等。 调用栈是由一系列的调用帧（stack frame）的栈结构形式组成。每次发起一个函数调用，都会对新的调用创建新的调用帧。 我们以当 n = 3 的阶乘为例，调用栈（bottom to up）如下所示： n = 1, f = 1 ------------------ n = 2, f = 2 * f(1) ------------------ n = 3, f = 3 * f(2) ------------------ 调用栈的大小通常是有限的，如果持续创建调用帧，则会导致调用栈溢出（stack overflow）。 比如对于递归调用，如果一直没有触发基本情况进行终止调用，进行递归回升，则会导致栈溢出。 // Go 语言，栈溢出 package main func main() { f() // Output: // runtime: goroutine stack exceeds 1000000000-byte limit // fatal error: stack overflow } func f() { f() } 9. 尾调用优化 我们知道尾递归是一种特性的尾调用，下面看下当 n = 3 的阶乘的尾递归调用栈： n = 1, f = 6 ------------------ n = 2, f = f(1, 2 * 3) ------------------ n = 3, f = f(2, 3 * 1) ------------------ 和上述的非尾递归的调用栈比较，我们会发现，尾递归的每次新的调用并不依赖下一个调用帧的返回结果，所以我们可以把这些调用帧减少至一个并重复使用，这种情况就叫做尾递归优化或者尾调用优化（tail call optimaization）。 10. 参考 https://en.wikipedia.org/wiki/Mathematical_induction https://en.wikipedia.org/wiki/Factorial https://en.wikipedia.org/wiki/Recursion_(computer_science) https://www.programmerinterview.com/index.php/recursion/explanation-of-recursion/ https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm https://en.wikipedia.org/wiki/Tail_call https://www.programmerinterview.com/index.php/recursion/tail-recursion/ https://www.programmerinterview.com/index.php/recursion/tail-call-optimization/ https://en.wikipedia.org/wiki/Quicksort" />
<link rel="canonical" href="https://blog.codefarm.me/2019/03/21/mathematical-induction-and-recusion/" />
<meta property="og:url" content="https://blog.codefarm.me/2019/03/21/mathematical-induction-and-recusion/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-21T15:39:17+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="数学归纳法之递归求值" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-03-21T15:39:17+08:00","datePublished":"2019-03-21T15:39:17+08:00","description":"1. 数学归纳法 2. 阶乘 3. 函数和递归 4. 递归求解 5. 尾调用和尾递归 6. 分治法 7. 动态规划 8. 调用栈和调用帧 9. 尾调用优化 10. 参考 1. 数学归纳法 数学归纳法是证明当 n 等于任意一个自然数时某命题成立。证明分为起始步骤（basics）和递推步骤（induction step）两步： 证明当 n = 1 时，命题成立。 证明如果 n = m 时命题成立，那么可以推导出在 n = m + 1 时命题成立。 2. 阶乘 阶乘的定义公式： n! = 1 × 2 × ... × (n-2) × (n - 1) × n 阶乘的递推公式： n! = n × (n-1)! 我们可以用数学归纳法证明阶乘的递推公式如下： 根据阶乘的定义，当 n = 0 或 n = 1 时，0! = 1 或 1! = 1，命题成立。 假设 n = m 时，m! = m × (m - 1)!， 当 n = m + 1 时，则 (m + 1)! = (m + 1) × [(m + 1) - 1]! = (m + 1) × m!，命题成立。 3. 函数和递归 如果我们把 n 的阶乘函数（function）定义为 f(n) = n! ，当 n = 0 或 1时，n! = 1 ，则根据阶乘的递推公式，我们有 f(n) = n × (n - 1)! = n × f(n - 1) 。也就是说，我们要求值 f(n) ，就要求值 f(n - 1) ，再求值 f(n - 2) &#8230;&#8203; f(2) , 最后求值 f(1) ，而这个函数 f 调用自己 f 的情况，我称之为递归（recursion）。 4. 递归求解 递归的用途是用于将一个大的问题，重复分解为相同或相似的子问题，直到子问题小到可以直接求解。 当子问题需要继续分解时，我们称这种情况为递归情况（recursive case）。 当子问题可以直接解决时，递归终止并回升，我称这种情况为基本情况（base case）。 以阶乘函数为例，f(0) = 1 和 f(1) = 1 为基本情况，f(n) = n × f(n - 1)，n &gt; 1 属于递归情况。 // Go 语言，递归求解阶乘 package main import ( &quot;fmt&quot; ) func main() { n := 5 f := factorial(n) fmt.Printf(&quot;%d! = %d\\n&quot;, n, f) // Output: // n = 5: 5 * factorial(4) // n = 4: 4 * factorial(3) // n = 3: 3 * factorial(2) // n = 2: 2 * factorial(1) // n = 1: 1 // 5! = 120 } func factorial(n int) int { if n == 0 || n == 1 { // base case fmt.Printf(&quot;n = %d: %d\\n&quot;, n, 1) return 1 } fmt.Printf(&quot;n = %d: %d * factorial(%d)\\n&quot;, n, n, n-1) return n * factorial(n-1) // recursive case } 5. 尾调用和尾递归 在计算机科学中，尾调用（tail call）是指一个函数的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的函数返回值被当成当前函数的返回结果。如果递归函数（recursion）满足尾调用的定义，则称这种递归为尾递归（tail recursion）。 // Go 语言，尾递归求解阶乘 package main import ( &quot;fmt&quot; ) func main() { n := 5 f := tail_recursive_factorial(n, 1) fmt.Printf(&quot;%d! = %d\\n&quot;, n, f) // Output: // n = 5: tail_recursive_factorial(4, 5*1) // n = 4: tail_recursive_factorial(3, 4*5) // n = 3: tail_recursive_factorial(2, 3*20) // n = 2: tail_recursive_factorial(1, 2*60) // n = 1: 120 // 5! = 120 } func tail_recursive_factorial(n, f int) int { if n == 0 || n == 1 { // base case fmt.Printf(&quot;n = %d: %d\\n&quot;, n, f) return f } fmt.Printf(&quot;n = %d: tail_recursive_factorial(%d, %d*%d)\\n&quot;, n, n-1, n, f) return tail_recursive_factorial(n-1, n*f) // recursive case } 6. 分治法 在计算机科学中，分治法（divide and conquer）是基于多分支递归的一个算法设计模式。分治算法是将问题递归的分解成两个或多个相同或相关类型的子问题，直到这些子问题简单到可以直接求解。最后将子问题的解进行合并得到原始问题的解。分治法是许多高效算法的技术基础，如排序中的归并排序（merge sort）和快速排序（quick sort）等等。 分治法的求解步骤如下： 分解:原问题为若干子问题，这些子问题是原有问题的规模较小的实例 解决:这些子问题，递归地求解各子问题。若子问题的规模足够小，则直接求解 合并:这些子问题的解成原问题的解 快速排序算法： 分解: 选择主元 P(viot), 将待排序序列分割成两个区域（partitions），左边的分区的元素都小于或等于 P，右边的元素大于 P 解决: 对左右两个分区进行递归的快速排序 合并: 由于序列是原址排序，分区的操作即为排序的操作，无需合并 // Go 语言，快速排序 package main import ( &quot;fmt&quot; ) func main() { s := []int{8, 5, 2, 6, 9, 3, 1, 4, 0, 7} fmt.Println(&quot;Before:&quot;, s) quick_sort(s, 0, len(s)) fmt.Println(&quot;After:&quot;, s) // Output: // Before: [8 5 2 6 9 3 1 4 0 7] // low: 0, high: 10, pivot: 7, s: [5 2 6 3 1 4 0 7 9 8] // low: 0, high: 07, pivot: 0, s: [0 2 6 3 1 4 5 7 9 8] // low: 0, high: 07, pivot: 5, s: [0 2 3 1 4 5 6 7 9 8] // low: 0, high: 05, pivot: 4, s: [0 2 3 1 4 5 6 7 9 8] // low: 0, high: 04, pivot: 1, s: [0 1 3 2 4 5 6 7 9 8] // low: 1, high: 04, pivot: 2, s: [0 1 2 3 4 5 6 7 9 8] // low: 2, high: 04, pivot: 3, s: [0 1 2 3 4 5 6 7 9 8] // low: 5, high: 07, pivot: 6, s: [0 1 2 3 4 5 6 7 9 8] // low: 7, high: 10, pivot: 8, s: [0 1 2 3 4 5 6 7 8 9] // low: 8, high: 10, pivot: 9, s: [0 1 2 3 4 5 6 7 8 9] // After: [0 1 2 3 4 5 6 7 8 9] } func quick_sort(s []int, low, high int) { if high-low &gt; 1 { // recursive case mid := partition(s, low, high) quick_sort(s, low, mid) quick_sort(s, mid, high) } // base case } func partition(s []int, low, high int) int { pivot := s[high-1] i := low - 1 for j := low; j &lt; high-1; j++ { if s[j] &lt;= pivot { // compare i++ s[j], s[i] = s[i], s[j] // swap } } s[i+1], s[high-1] = s[high-1], s[i+1] fmt.Printf(&quot;low: %d, high: %02d, pivot: %d, s: %v\\n&quot;, low, high, pivot, s) return i + 1 } 7. 动态规划 动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 以求斐波那契数列为例： // a naive algorithm with time O(2^n) and space O(n) func fib(n int) int { // base case if n &lt;= 1 { return n } // recursive case return fib(n-1) + fib(n-2) } // a dynamic programming algorithm with time O(n) and space O(n) func fib(n int) int { if n &lt;= 1 { return n } f := make([]int, n+1) f[0] = 0 f[1] = 1 for i := 2; i &lt;= n; i++ { f[i] = f[i-1] + f[i-2] } return f[n] } 8. 调用栈和调用帧 在计算机科学中，调用栈（call stack）是一种存储函数调用上下文的数据结构，比如局部变量，函数返回控制点等等。 调用栈是由一系列的调用帧（stack frame）的栈结构形式组成。每次发起一个函数调用，都会对新的调用创建新的调用帧。 我们以当 n = 3 的阶乘为例，调用栈（bottom to up）如下所示： n = 1, f = 1 ------------------ n = 2, f = 2 * f(1) ------------------ n = 3, f = 3 * f(2) ------------------ 调用栈的大小通常是有限的，如果持续创建调用帧，则会导致调用栈溢出（stack overflow）。 比如对于递归调用，如果一直没有触发基本情况进行终止调用，进行递归回升，则会导致栈溢出。 // Go 语言，栈溢出 package main func main() { f() // Output: // runtime: goroutine stack exceeds 1000000000-byte limit // fatal error: stack overflow } func f() { f() } 9. 尾调用优化 我们知道尾递归是一种特性的尾调用，下面看下当 n = 3 的阶乘的尾递归调用栈： n = 1, f = 6 ------------------ n = 2, f = f(1, 2 * 3) ------------------ n = 3, f = f(2, 3 * 1) ------------------ 和上述的非尾递归的调用栈比较，我们会发现，尾递归的每次新的调用并不依赖下一个调用帧的返回结果，所以我们可以把这些调用帧减少至一个并重复使用，这种情况就叫做尾递归优化或者尾调用优化（tail call optimaization）。 10. 参考 https://en.wikipedia.org/wiki/Mathematical_induction https://en.wikipedia.org/wiki/Factorial https://en.wikipedia.org/wiki/Recursion_(computer_science) https://www.programmerinterview.com/index.php/recursion/explanation-of-recursion/ https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm https://en.wikipedia.org/wiki/Tail_call https://www.programmerinterview.com/index.php/recursion/tail-recursion/ https://www.programmerinterview.com/index.php/recursion/tail-call-optimization/ https://en.wikipedia.org/wiki/Quicksort","headline":"数学归纳法之递归求值","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2019/03/21/mathematical-induction-and-recusion/"},"url":"https://blog.codefarm.me/2019/03/21/mathematical-induction-and-recusion/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">数学归纳法之递归求值</h1><p class="c-post-meta">21 Mar 2019</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#数学归纳法">1. 数学归纳法</a></li>
<li><a href="#阶乘">2. 阶乘</a></li>
<li><a href="#函数和递归">3. 函数和递归</a></li>
<li><a href="#递归求解">4. 递归求解</a></li>
<li><a href="#尾调用和尾递归">5. 尾调用和尾递归</a></li>
<li><a href="#分治法">6. 分治法</a></li>
<li><a href="#动态规划">7. 动态规划</a></li>
<li><a href="#调用栈和调用帧">8. 调用栈和调用帧</a></li>
<li><a href="#尾调用优化">9. 尾调用优化</a></li>
<li><a href="#参考">10. 参考</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="数学归纳法">1. 数学归纳法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数学归纳法是证明当 n 等于任意一个自然数时某命题成立。证明分为起始步骤（basics）和递推步骤（induction step）两步：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>证明当 n = 1 时，命题成立。</p>
</li>
<li>
<p>证明如果 n = m 时命题成立，那么可以推导出在 n = m + 1 时命题成立。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="阶乘">2. 阶乘</h2>
<div class="sectionbody">
<div class="paragraph">
<p>阶乘的定义公式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>n! = 1 × 2 × ... × (n-2) × (n - 1) × n</pre>
</div>
</div>
<div class="paragraph">
<p>阶乘的递推公式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>n! = n × (n-1)!</pre>
</div>
</div>
<div class="paragraph">
<p>我们可以用数学归纳法证明阶乘的递推公式如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>根据阶乘的定义，当 n = 0 或 n = 1 时，0! = 1 或 1! = 1，命题成立。</p>
</li>
<li>
<p>假设 n = m 时，m! = m × (m - 1)!， 当 n = m + 1 时，则 (m + 1)! = (m + 1) × [(m + 1) - 1]! = (m + 1) × m!，命题成立。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="函数和递归">3. 函数和递归</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果我们把 <em>n</em> 的阶乘<strong>函数</strong>（function）定义为 <em>f(n) = n! ，当 n = 0 或 1时，n! = 1</em> ，则根据阶乘的递推公式，我们有 <em>f(n) = n × (n - 1)! = n × f(n - 1)</em> 。也就是说，我们要求值 <em>f(n)</em> ，就要求值 <em>f(n - 1)</em> ，再求值 <em>f(n - 2)</em> &#8230;&#8203; <em>f(2)</em> , 最后求值 <em>f(1)</em> ，而这个函数 <em>f</em> 调用自己 <em>f</em> 的情况，我称之为<strong>递归</strong>（recursion）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="递归求解">4. 递归求解</h2>
<div class="sectionbody">
<div class="paragraph">
<p>递归的用途是用于将一个大的问题，重复<strong>分解</strong>为相同或相似的子问题，直到子问题小到可以直接求解。</p>
</div>
<div class="paragraph">
<p>当子问题需要继续分解时，我们称这种情况为<strong>递归情况</strong>（recursive case）。</p>
</div>
<div class="paragraph">
<p>当子问题可以直接解决时，递归<strong>终止</strong>并回升，我称这种情况为<strong>基本情况</strong>（base case）。</p>
</div>
<div class="paragraph">
<p>以阶乘函数为例，<em>f(0) = 1</em> 和 <em>f(1) = 1</em> 为基本情况，<em>f(n) = n × f(n - 1)，n &gt; 1</em> 属于递归情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Go 语言，递归求解阶乘</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="m">5</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d! = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="c">// Output:</span>
    <span class="c">// n = 5: 5 * factorial(4)</span>
    <span class="c">// n = 4: 4 * factorial(3)</span>
    <span class="c">// n = 3: 3 * factorial(2)</span>
    <span class="c">// n = 2: 2 * factorial(1)</span>
    <span class="c">// n = 1: 1</span>
    <span class="c">// 5! = 120</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span> <span class="c">// base case</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"n = %d: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="m">1</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"n = %d: %d * factorial(%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="c">// recursive case</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="尾调用和尾递归">5. 尾调用和尾递归</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在计算机科学中，<strong>尾调用</strong>（tail call）是指一个函数的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的函数返回值被当成当前函数的返回结果。如果<strong>递归函数</strong>（recursion）满足<strong>尾调用</strong>的定义，则称这种递归为<strong>尾递归</strong>（tail recursion）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Go 语言，尾递归求解阶乘</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="m">5</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="n">tail_recursive_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d! = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="c">// Output:</span>
    <span class="c">// n = 5: tail_recursive_factorial(4, 5*1)</span>
    <span class="c">// n = 4: tail_recursive_factorial(3, 4*5)</span>
    <span class="c">// n = 3: tail_recursive_factorial(2, 3*20)</span>
    <span class="c">// n = 2: tail_recursive_factorial(1, 2*60)</span>
    <span class="c">// n = 1: 120</span>
    <span class="c">// 5! = 120</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">tail_recursive_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span> <span class="c">// base case</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"n = %d: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"n = %d: tail_recursive_factorial(%d, %d*%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tail_recursive_factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="c">// recursive case</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="分治法">6. 分治法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在计算机科学中，<strong>分治法</strong>（divide and conquer）是基于多分支递归的一个算法设计模式。分治算法是将问题递归的分解成两个或多个相同或相关类型的子问题，直到这些子问题简单到可以直接求解。最后将子问题的解进行合并得到原始问题的解。分治法是许多高效算法的技术基础，如排序中的归并排序（merge sort）和快速排序（quick sort）等等。</p>
</div>
<div class="paragraph">
<p>分治法的求解步骤如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>分解</strong>:原问题为若干子问题，这些子问题是原有问题的规模较小的实例</p>
</li>
<li>
<p><strong>解决</strong>:这些子问题，递归地求解各子问题。若子问题的规模足够小，则直接求解</p>
</li>
<li>
<p><strong>合并</strong>:这些子问题的解成原问题的解</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>快速排序算法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>分解</strong>: 选择主元 <strong>P</strong>(viot), 将待排序序列分割成两个区域（partitions），左边的分区的元素都小于或等于 P，右边的元素大于 P</p>
</li>
<li>
<p><strong>解决</strong>: 对左右两个分区进行递归的快速排序</p>
</li>
<li>
<p><strong>合并</strong>: 由于序列是原址排序，分区的操作即为排序的操作，无需合并</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Go 语言，快速排序</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">8</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">7</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Before:"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"After:"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="c">// Output:</span>
    <span class="c">// Before: [8 5 2 6 9 3 1 4 0 7]</span>
    <span class="c">// low: 0, high: 10, pivot: 7, s: [5 2 6 3 1 4 0 7 9 8]</span>
    <span class="c">// low: 0, high: 07, pivot: 0, s: [0 2 6 3 1 4 5 7 9 8]</span>
    <span class="c">// low: 0, high: 07, pivot: 5, s: [0 2 3 1 4 5 6 7 9 8]</span>
    <span class="c">// low: 0, high: 05, pivot: 4, s: [0 2 3 1 4 5 6 7 9 8]</span>
    <span class="c">// low: 0, high: 04, pivot: 1, s: [0 1 3 2 4 5 6 7 9 8]</span>
    <span class="c">// low: 1, high: 04, pivot: 2, s: [0 1 2 3 4 5 6 7 9 8]</span>
    <span class="c">// low: 2, high: 04, pivot: 3, s: [0 1 2 3 4 5 6 7 9 8]</span>
    <span class="c">// low: 5, high: 07, pivot: 6, s: [0 1 2 3 4 5 6 7 9 8]</span>
    <span class="c">// low: 7, high: 10, pivot: 8, s: [0 1 2 3 4 5 6 7 8 9]</span>
    <span class="c">// low: 8, high: 10, pivot: 9, s: [0 1 2 3 4 5 6 7 8 9]</span>
    <span class="c">// After: [0 1 2 3 4 5 6 7 8 9]</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">high</span><span class="o">-</span><span class="n">low</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="p">{</span> <span class="c">// recursive case</span>
        <span class="n">mid</span> <span class="o">:=</span> <span class="n">partition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="n">quick_sort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="n">quick_sort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// base case</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">partition</span><span class="p">(</span><span class="n">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">pivot</span> <span class="o">:=</span> <span class="n">s</span><span class="p">[</span><span class="n">high</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>

    <span class="n">i</span> <span class="o">:=</span> <span class="n">low</span> <span class="o">-</span> <span class="m">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">low</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span> <span class="p">{</span> <span class="c">// compare</span>
            <span class="n">i</span><span class="o">++</span>
            <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c">// swap</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">high</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">high</span><span class="o">-</span><span class="m">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">]</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"low: %d, high: %02d, pivot: %d, s: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="动态规划">7. 动态规划</h2>
<div class="sectionbody">
<div class="paragraph">
<p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
</div>
<div class="paragraph">
<p>动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
</div>
<div class="paragraph">
<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<strong>记忆化</strong>存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈<strong>指数增长</strong>时特别有用。</p>
</div>
<div class="paragraph">
<p>以求斐波那契数列为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// a naive algorithm with time O(2^n) and space O(n)</span>
<span class="k">func</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c">// base case</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="p">}</span>

    <span class="c">// recursive case</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">2</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// a dynamic programming algorithm with time O(n) and space O(n)</span>
<span class="k">func</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="p">}</span>

    <span class="n">f</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
    <span class="n">f</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">f</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="m">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">2</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="调用栈和调用帧">8. 调用栈和调用帧</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在计算机科学中，<strong>调用栈</strong>（call stack）是一种存储函数调用上下文的数据结构，比如局部变量，函数返回控制点等等。</p>
</div>
<div class="paragraph">
<p>调用栈是由一系列的<strong>调用帧</strong>（stack frame）的栈结构形式组成。每次发起一个函数调用，都会对新的调用创建新的调用帧。</p>
</div>
<div class="paragraph">
<p>我们以当 <em>n = 3</em> 的阶乘为例，调用栈（bottom to up）如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>n = 1, f = 1
------------------
n = 2, f = 2 * f(1)
------------------
n = 3, f = 3 * f(2)
------------------</pre>
</div>
</div>
<div class="paragraph">
<p>调用栈的大小通常是有限的，如果持续创建调用帧，则会导致调用<strong>栈溢出</strong>（stack overflow）。</p>
</div>
<div class="paragraph">
<p>比如对于递归调用，如果一直没有触发基本情况进行终止调用，进行递归回升，则会导致栈溢出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Go 语言，栈溢出</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">()</span>
    <span class="c">// Output:</span>
    <span class="c">// runtime: goroutine stack exceeds 1000000000-byte limit</span>
    <span class="c">// fatal error: stack overflow</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">()</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="尾调用优化">9. 尾调用优化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们知道尾递归是一种特性的尾调用，下面看下当 <em>n = 3</em> 的阶乘的尾递归调用栈：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>n = 1, f = 6
------------------
n = 2, f = f(1, 2 * 3)
------------------
n = 3, f = f(2, 3 * 1)
------------------</pre>
</div>
</div>
<div class="paragraph">
<p>和上述的非尾递归的调用栈比较，我们会发现，尾递归的每次新的调用并不依赖下一个调用帧的返回结果，所以我们可以把这些调用帧减少至一个并重复使用，这种情况就叫做<strong>尾递归优化</strong>或者<strong>尾调用优化</strong>（tail call optimaization）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="参考">10. 参考</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Mathematical_induction" class="bare">https://en.wikipedia.org/wiki/Mathematical_induction</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Factorial" class="bare">https://en.wikipedia.org/wiki/Factorial</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Recursion_(computer_science" class="bare">https://en.wikipedia.org/wiki/Recursion_(computer_science</a>)</p>
</li>
<li>
<p><a href="https://www.programmerinterview.com/index.php/recursion/explanation-of-recursion/" class="bare">https://www.programmerinterview.com/index.php/recursion/explanation-of-recursion/</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" class="bare">https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Tail_call" class="bare">https://en.wikipedia.org/wiki/Tail_call</a></p>
</li>
<li>
<p><a href="https://www.programmerinterview.com/index.php/recursion/tail-recursion/" class="bare">https://www.programmerinterview.com/index.php/recursion/tail-recursion/</a></p>
</li>
<li>
<p><a href="https://www.programmerinterview.com/index.php/recursion/tail-call-optimization/" class="bare">https://www.programmerinterview.com/index.php/recursion/tail-call-optimization/</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Quicksort" class="bare">https://en.wikipedia.org/wiki/Quicksort</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
