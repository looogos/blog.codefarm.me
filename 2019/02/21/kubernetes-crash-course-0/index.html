<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>0 - Kubernetes Overview | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="0 - Kubernetes Overview" />
<meta property="og:locale" content="en" />
<meta name="description" content="What is Kubernetes? Kubernetes vs Docker Swarm vs Apache Mesos CLOUD NATIVE COMPUTING FOUNDATION Setup Kubernetes Cluster Set docker.service behind HTTP proxy Set HTTP Proxy for APT/YUM Start minikube behind a HTTP Proxy Learn Kubernetes Basics Kubectl Using kubectl to Create a Deployment Viewing Pods and Nodes Pods overview Node overview Using a Service to Expose Your App Services and Labels Expose Your App Publicly Running Multiple Instances of Your App Scale Your App Performing a Rolling Update Update Your App Quit or not quit ? What is Kubernetes? Kubernetes is a production-grade, open-source platform that orchestrates the placement (scheduling) and execution of application containers within and across computer clusters. Kubernetes provides a container-centric management environment. It orchestrates computing, networking, and storage infrastructure on behalf of user workloads. https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/ Kubernetes vs Docker Swarm vs Apache Mesos https://codefresh.io/kubernetes-tutorial/kubernetes-vs-docker-swarm-vs-apache-mesos/ CLOUD NATIVE COMPUTING FOUNDATION CNCF is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native computing uses an open source software stack to deploy applications as microservices, packaging each part into its own container, and dynamically orchestrating those containers to optimize resource utilization. Cloud native technologies enable software developers to build great products faster. https://www.cncf.io/ Setup Kubernetes Cluster Minikube &amp; Kubeadm AKS &amp; EKS &amp; ACK &amp; TKE https://kubernetes.io/docs/setup/ https://kubernetes.io/docs/setup/minikube/ https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/ https://codefarm.me/2018/12/27/intall-minikube-with-kubeadm-on-debian/ https://codefarm.me/2019/01/28/bootstrapping-kubernetes-clusters-with-kubeadm/ Set docker.service behind HTTP proxy # 1. Edit the docker.service configuration with systemctl $ sudo systemctl edit docker.service # 2. Add the following text in the editor (Please update the PROXY_HOST and PROXY_PORT !!!) # [Service] # Environment=&quot;HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; &quot;NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com&quot; &quot;HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; # 3. Exit the editor. You can also run the following command to print the docker.service.d/override.conf $ cat /etc/systemd/system/docker.service.d/override.conf [Service] Environment=&quot;HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; &quot;NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com&quot; &quot;HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; # 4. Reload systemd manager configuration $ sudo systemctl daemon-reload # 5. Restart the docker.service $ sudo systemctl restart docker.service Set HTTP Proxy for APT/YUM # Set HTTP proxy for APT: $ cat &lt;&lt;EOF &gt; /etc/apt/apt.conf.d/httproxy &gt; Acquire::http::Proxy &quot;http://PROXY_HOST:PORT&quot;; &gt; EOF # Set HTTP proxy for YUM: $ echo &#39;proxy=http://PROXY_HOST:PORT&#39; &gt;&gt; /etc/yum.conf Start minikube behind a HTTP Proxy $ minikube start \ --docker-env HTTP_PROXY=http://PROXY_HOST:PORT/ \ --docker-env HTTPS_PROXY=http://PROXY_HOST:PORT/ \ --docker-env NO_PROXY=index.docker.io,\ registry.hub.docker.com,\ registry-1.docker.io,\ registry.docker-cn.com,\ registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,\ 192.168.99.100\ --registry-mirror https://registry.docker-cn.com https://codefarm.me/2018/08/09/http-proxy-docker-minikube/ Learn Kubernetes Basics Deploy an App Explore Your App Expose Your App Publicly Scale Your App Update Your App https://kubernetes.io/docs/tutorials/kubernetes-basics/ Kubectl Kubectl is a command line interface for running commands against Kubernetes clusters. # kubectl controls the Kubernetes cluster manager. $ kubectl --help # Output shell completion code for the specified shell (bash or zsh). $ kubectl completion --help # Print the supported API resources on the server $ kubectl api-resources --help # List the fields for supported resources $ kubectl explain --help # Modify kubeconfig files using subcommands like &quot;kubectl config set current-context my-context&quot; $ kubectl config --help # Print the logs for a container in a pod or specified resource. $ kubectl logs --help # Execute a command in a container. $ kubectl exec --help Using kubectl to Create a Deployment $ kubectl run nginx --image=nginx:1.15 --port 80 $ kubectl proxy $ curl -iI http://localhost:8001/api/v1/namespaces/default/pods/$(kubectl get po –o jsonpath=&#39;{.items[0].metadata.name}&#39;)/proxy kubectl get - list resources kubectl describe - show detailed information about a resource kubectl logs - print the logs from a container in a pod kubectl exec - execute a command on a container in a pod Viewing Pods and Nodes Pod is a Kubernetes abstraction that represents a group of one or more application containers (such as Docker or rkt), and some shared resources for those containers. Those resources include: Shared storage, as Volumes Networking, as a unique cluster IP address Information about how to run each container, such as the container image version or specific ports to use A Pod models an application-specific “logical host” and can contain different application containers which are relatively tightly coupled. Pods are the atomic unit on the Kubernetes platform. Pods overview Node overview A Pod always runs on a Node. A Node is a worker machine in Kubernetes and may be either a virtual or a physical machine, depending on the cluster. Each Node is managed by the Master. A Node can have multiple pods, and the Kubernetes master automatically handles scheduling the pods across the Nodes in the cluster. Every Kubernetes Node runs at least: Kubelet, a process responsible for communication between the Kubernetes Master and the Node; it manages the Pods and the containers running on a machine. A container runtime (like Docker, rkt) responsible for pulling the container image from a registry, unpacking the container, and running the application. Using a Service to Expose Your App Kubernetes Pods are mortal. A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods. Services can be exposed in different ways by specifying a type in the ServiceSpec: ClusterIP (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster. NodePort - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using :. Superset of ClusterIP. LoadBalancer - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort. ExternalName - Exposes the Service using an arbitrary name (specified by externalName in the spec) by returning a CNAME record with the name. No proxy is used. Services and Labels Labels are key/value pairs that are attached to objects, such as pods. Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of objects. Services match a set of Pods using labels and selectors, a grouping primitive that allows logical operation on objects in Kubernetes. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ Expose Your App Publicly $ kubectl run nginx --image=nginx:1.15 --port=80 kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead. deployment.apps/nginx created $ kubectl get po nginx-6f7d58d4cc-7vnxv --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-6f7d58d4cc-7vnxv 1/1 Running 0 13s pod-template-hash=6f7d58d4cc,run=nginx $ kubectl expose deployment nginx --type=NodePort --port=80 service/nginx exposed $ kubectl get svc nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx NodePort 10.98.138.39 &lt;none&gt; 80:31462/TCP 26s $ kubectl get svc nginx -ojsonpath=&#39;{.spec.ports[0].nodePort}&#39; 31462$ kubectl get no -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME far-seer-01 Ready master 24d v1.13.2 192.168.66.128 &lt;none&gt; Debian GNU/Linux 9 (stretch) 4.9.0-8-amd64 docker://18.6.0 $ curl -iI 192.168.66.128:31462 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Thu, 21 Feb 2019 07:24:48 GMT Content-Type: text/html Content-Length: 612 Last-Modified: Tue, 25 Dec 2018 09:56:47 GMT Connection: keep-alive ETag: &quot;5c21fedf-264&quot; Accept-Ranges: bytes Running Multiple Instances of Your App Scale Your App $ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 20m $ kubectl scale deployment nginx --replicas=4 # scale out deployment.extensions/nginx scaled $ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 20m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 5s nginx-6f7d58d4cc-l7grh 1/1 Running 0 5s nginx-6f7d58d4cc-m8nr2 1/1 Running 0 5s $ kubectl scale deployment nginx --replicas=2 # scale in deployment.extensions/nginx scaled $ kubectl get po -w NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 21m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 62s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 62s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 62s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 64s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 64s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 64s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 64s ^C$ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 21m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 79s $ Performing a Rolling Update Update Your App $ kubectl get deployment NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 2 2 53m $ kubectl get svc nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx NodePort 10.98.138.39 &lt;none&gt; 80:31462/TCP 52m $ curl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.15.8 $ kubectl set image deploy nginx nginx=nginx:1.13 &amp;&amp; kubectl get deploy nginx -w deployment.extensions/nginx image updated NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 1 2 54m nginx 3/2 1 3 54m nginx 2/2 1 2 54m nginx 2/2 2 2 54m ^Ccurl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.13.12 $ kubectl rollout undo deployment nginx deployment.extensions/nginx rolled back $ kubectl get deployments -w NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 2 2 58m ^Ccurl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.15.8 $ kubectl rollout undo deployment nginx deployment.extensions/nginx rolled back $ curl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.13.12 $ kubectl get rs NAME DESIRED CURRENT READY AGE nginx-5df8d97c98 0 0 0 21m nginx-6b46d56475 2 2 2 17m nginx-6f7d58d4cc 0 0 0 63m $ kubectl rollout history deployment nginx deployment.extensions/nginx REVISION CHANGE-CAUSE 2 &lt;none&gt; 3 &lt;none&gt; Quit or not quit ? https://kubernetes.io/" />
<meta property="og:description" content="What is Kubernetes? Kubernetes vs Docker Swarm vs Apache Mesos CLOUD NATIVE COMPUTING FOUNDATION Setup Kubernetes Cluster Set docker.service behind HTTP proxy Set HTTP Proxy for APT/YUM Start minikube behind a HTTP Proxy Learn Kubernetes Basics Kubectl Using kubectl to Create a Deployment Viewing Pods and Nodes Pods overview Node overview Using a Service to Expose Your App Services and Labels Expose Your App Publicly Running Multiple Instances of Your App Scale Your App Performing a Rolling Update Update Your App Quit or not quit ? What is Kubernetes? Kubernetes is a production-grade, open-source platform that orchestrates the placement (scheduling) and execution of application containers within and across computer clusters. Kubernetes provides a container-centric management environment. It orchestrates computing, networking, and storage infrastructure on behalf of user workloads. https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/ Kubernetes vs Docker Swarm vs Apache Mesos https://codefresh.io/kubernetes-tutorial/kubernetes-vs-docker-swarm-vs-apache-mesos/ CLOUD NATIVE COMPUTING FOUNDATION CNCF is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native computing uses an open source software stack to deploy applications as microservices, packaging each part into its own container, and dynamically orchestrating those containers to optimize resource utilization. Cloud native technologies enable software developers to build great products faster. https://www.cncf.io/ Setup Kubernetes Cluster Minikube &amp; Kubeadm AKS &amp; EKS &amp; ACK &amp; TKE https://kubernetes.io/docs/setup/ https://kubernetes.io/docs/setup/minikube/ https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/ https://codefarm.me/2018/12/27/intall-minikube-with-kubeadm-on-debian/ https://codefarm.me/2019/01/28/bootstrapping-kubernetes-clusters-with-kubeadm/ Set docker.service behind HTTP proxy # 1. Edit the docker.service configuration with systemctl $ sudo systemctl edit docker.service # 2. Add the following text in the editor (Please update the PROXY_HOST and PROXY_PORT !!!) # [Service] # Environment=&quot;HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; &quot;NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com&quot; &quot;HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; # 3. Exit the editor. You can also run the following command to print the docker.service.d/override.conf $ cat /etc/systemd/system/docker.service.d/override.conf [Service] Environment=&quot;HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; &quot;NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com&quot; &quot;HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; # 4. Reload systemd manager configuration $ sudo systemctl daemon-reload # 5. Restart the docker.service $ sudo systemctl restart docker.service Set HTTP Proxy for APT/YUM # Set HTTP proxy for APT: $ cat &lt;&lt;EOF &gt; /etc/apt/apt.conf.d/httproxy &gt; Acquire::http::Proxy &quot;http://PROXY_HOST:PORT&quot;; &gt; EOF # Set HTTP proxy for YUM: $ echo &#39;proxy=http://PROXY_HOST:PORT&#39; &gt;&gt; /etc/yum.conf Start minikube behind a HTTP Proxy $ minikube start \ --docker-env HTTP_PROXY=http://PROXY_HOST:PORT/ \ --docker-env HTTPS_PROXY=http://PROXY_HOST:PORT/ \ --docker-env NO_PROXY=index.docker.io,\ registry.hub.docker.com,\ registry-1.docker.io,\ registry.docker-cn.com,\ registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,\ 192.168.99.100\ --registry-mirror https://registry.docker-cn.com https://codefarm.me/2018/08/09/http-proxy-docker-minikube/ Learn Kubernetes Basics Deploy an App Explore Your App Expose Your App Publicly Scale Your App Update Your App https://kubernetes.io/docs/tutorials/kubernetes-basics/ Kubectl Kubectl is a command line interface for running commands against Kubernetes clusters. # kubectl controls the Kubernetes cluster manager. $ kubectl --help # Output shell completion code for the specified shell (bash or zsh). $ kubectl completion --help # Print the supported API resources on the server $ kubectl api-resources --help # List the fields for supported resources $ kubectl explain --help # Modify kubeconfig files using subcommands like &quot;kubectl config set current-context my-context&quot; $ kubectl config --help # Print the logs for a container in a pod or specified resource. $ kubectl logs --help # Execute a command in a container. $ kubectl exec --help Using kubectl to Create a Deployment $ kubectl run nginx --image=nginx:1.15 --port 80 $ kubectl proxy $ curl -iI http://localhost:8001/api/v1/namespaces/default/pods/$(kubectl get po –o jsonpath=&#39;{.items[0].metadata.name}&#39;)/proxy kubectl get - list resources kubectl describe - show detailed information about a resource kubectl logs - print the logs from a container in a pod kubectl exec - execute a command on a container in a pod Viewing Pods and Nodes Pod is a Kubernetes abstraction that represents a group of one or more application containers (such as Docker or rkt), and some shared resources for those containers. Those resources include: Shared storage, as Volumes Networking, as a unique cluster IP address Information about how to run each container, such as the container image version or specific ports to use A Pod models an application-specific “logical host” and can contain different application containers which are relatively tightly coupled. Pods are the atomic unit on the Kubernetes platform. Pods overview Node overview A Pod always runs on a Node. A Node is a worker machine in Kubernetes and may be either a virtual or a physical machine, depending on the cluster. Each Node is managed by the Master. A Node can have multiple pods, and the Kubernetes master automatically handles scheduling the pods across the Nodes in the cluster. Every Kubernetes Node runs at least: Kubelet, a process responsible for communication between the Kubernetes Master and the Node; it manages the Pods and the containers running on a machine. A container runtime (like Docker, rkt) responsible for pulling the container image from a registry, unpacking the container, and running the application. Using a Service to Expose Your App Kubernetes Pods are mortal. A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods. Services can be exposed in different ways by specifying a type in the ServiceSpec: ClusterIP (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster. NodePort - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using :. Superset of ClusterIP. LoadBalancer - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort. ExternalName - Exposes the Service using an arbitrary name (specified by externalName in the spec) by returning a CNAME record with the name. No proxy is used. Services and Labels Labels are key/value pairs that are attached to objects, such as pods. Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of objects. Services match a set of Pods using labels and selectors, a grouping primitive that allows logical operation on objects in Kubernetes. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ Expose Your App Publicly $ kubectl run nginx --image=nginx:1.15 --port=80 kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead. deployment.apps/nginx created $ kubectl get po nginx-6f7d58d4cc-7vnxv --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-6f7d58d4cc-7vnxv 1/1 Running 0 13s pod-template-hash=6f7d58d4cc,run=nginx $ kubectl expose deployment nginx --type=NodePort --port=80 service/nginx exposed $ kubectl get svc nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx NodePort 10.98.138.39 &lt;none&gt; 80:31462/TCP 26s $ kubectl get svc nginx -ojsonpath=&#39;{.spec.ports[0].nodePort}&#39; 31462$ kubectl get no -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME far-seer-01 Ready master 24d v1.13.2 192.168.66.128 &lt;none&gt; Debian GNU/Linux 9 (stretch) 4.9.0-8-amd64 docker://18.6.0 $ curl -iI 192.168.66.128:31462 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Thu, 21 Feb 2019 07:24:48 GMT Content-Type: text/html Content-Length: 612 Last-Modified: Tue, 25 Dec 2018 09:56:47 GMT Connection: keep-alive ETag: &quot;5c21fedf-264&quot; Accept-Ranges: bytes Running Multiple Instances of Your App Scale Your App $ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 20m $ kubectl scale deployment nginx --replicas=4 # scale out deployment.extensions/nginx scaled $ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 20m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 5s nginx-6f7d58d4cc-l7grh 1/1 Running 0 5s nginx-6f7d58d4cc-m8nr2 1/1 Running 0 5s $ kubectl scale deployment nginx --replicas=2 # scale in deployment.extensions/nginx scaled $ kubectl get po -w NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 21m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 62s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 62s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 62s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 64s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 64s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 64s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 64s ^C$ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 21m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 79s $ Performing a Rolling Update Update Your App $ kubectl get deployment NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 2 2 53m $ kubectl get svc nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx NodePort 10.98.138.39 &lt;none&gt; 80:31462/TCP 52m $ curl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.15.8 $ kubectl set image deploy nginx nginx=nginx:1.13 &amp;&amp; kubectl get deploy nginx -w deployment.extensions/nginx image updated NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 1 2 54m nginx 3/2 1 3 54m nginx 2/2 1 2 54m nginx 2/2 2 2 54m ^Ccurl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.13.12 $ kubectl rollout undo deployment nginx deployment.extensions/nginx rolled back $ kubectl get deployments -w NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 2 2 58m ^Ccurl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.15.8 $ kubectl rollout undo deployment nginx deployment.extensions/nginx rolled back $ curl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.13.12 $ kubectl get rs NAME DESIRED CURRENT READY AGE nginx-5df8d97c98 0 0 0 21m nginx-6b46d56475 2 2 2 17m nginx-6f7d58d4cc 0 0 0 63m $ kubectl rollout history deployment nginx deployment.extensions/nginx REVISION CHANGE-CAUSE 2 &lt;none&gt; 3 &lt;none&gt; Quit or not quit ? https://kubernetes.io/" />
<link rel="canonical" href="https://blog.codefarm.me/2019/02/21/kubernetes-crash-course-0/" />
<meta property="og:url" content="https://blog.codefarm.me/2019/02/21/kubernetes-crash-course-0/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-21T17:55:05+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="0 - Kubernetes Overview" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-02-21T17:55:05+08:00","datePublished":"2019-02-21T17:55:05+08:00","description":"What is Kubernetes? Kubernetes vs Docker Swarm vs Apache Mesos CLOUD NATIVE COMPUTING FOUNDATION Setup Kubernetes Cluster Set docker.service behind HTTP proxy Set HTTP Proxy for APT/YUM Start minikube behind a HTTP Proxy Learn Kubernetes Basics Kubectl Using kubectl to Create a Deployment Viewing Pods and Nodes Pods overview Node overview Using a Service to Expose Your App Services and Labels Expose Your App Publicly Running Multiple Instances of Your App Scale Your App Performing a Rolling Update Update Your App Quit or not quit ? What is Kubernetes? Kubernetes is a production-grade, open-source platform that orchestrates the placement (scheduling) and execution of application containers within and across computer clusters. Kubernetes provides a container-centric management environment. It orchestrates computing, networking, and storage infrastructure on behalf of user workloads. https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/ Kubernetes vs Docker Swarm vs Apache Mesos https://codefresh.io/kubernetes-tutorial/kubernetes-vs-docker-swarm-vs-apache-mesos/ CLOUD NATIVE COMPUTING FOUNDATION CNCF is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native computing uses an open source software stack to deploy applications as microservices, packaging each part into its own container, and dynamically orchestrating those containers to optimize resource utilization. Cloud native technologies enable software developers to build great products faster. https://www.cncf.io/ Setup Kubernetes Cluster Minikube &amp; Kubeadm AKS &amp; EKS &amp; ACK &amp; TKE https://kubernetes.io/docs/setup/ https://kubernetes.io/docs/setup/minikube/ https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/ https://codefarm.me/2018/12/27/intall-minikube-with-kubeadm-on-debian/ https://codefarm.me/2019/01/28/bootstrapping-kubernetes-clusters-with-kubeadm/ Set docker.service behind HTTP proxy # 1. Edit the docker.service configuration with systemctl $ sudo systemctl edit docker.service # 2. Add the following text in the editor (Please update the PROXY_HOST and PROXY_PORT !!!) # [Service] # Environment=&quot;HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; &quot;NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com&quot; &quot;HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; # 3. Exit the editor. You can also run the following command to print the docker.service.d/override.conf $ cat /etc/systemd/system/docker.service.d/override.conf [Service] Environment=&quot;HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; &quot;NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com&quot; &quot;HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/&quot; # 4. Reload systemd manager configuration $ sudo systemctl daemon-reload # 5. Restart the docker.service $ sudo systemctl restart docker.service Set HTTP Proxy for APT/YUM # Set HTTP proxy for APT: $ cat &lt;&lt;EOF &gt; /etc/apt/apt.conf.d/httproxy &gt; Acquire::http::Proxy &quot;http://PROXY_HOST:PORT&quot;; &gt; EOF # Set HTTP proxy for YUM: $ echo &#39;proxy=http://PROXY_HOST:PORT&#39; &gt;&gt; /etc/yum.conf Start minikube behind a HTTP Proxy $ minikube start \\ --docker-env HTTP_PROXY=http://PROXY_HOST:PORT/ \\ --docker-env HTTPS_PROXY=http://PROXY_HOST:PORT/ \\ --docker-env NO_PROXY=index.docker.io,\\ registry.hub.docker.com,\\ registry-1.docker.io,\\ registry.docker-cn.com,\\ registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,\\ 192.168.99.100\\ --registry-mirror https://registry.docker-cn.com https://codefarm.me/2018/08/09/http-proxy-docker-minikube/ Learn Kubernetes Basics Deploy an App Explore Your App Expose Your App Publicly Scale Your App Update Your App https://kubernetes.io/docs/tutorials/kubernetes-basics/ Kubectl Kubectl is a command line interface for running commands against Kubernetes clusters. # kubectl controls the Kubernetes cluster manager. $ kubectl --help # Output shell completion code for the specified shell (bash or zsh). $ kubectl completion --help # Print the supported API resources on the server $ kubectl api-resources --help # List the fields for supported resources $ kubectl explain --help # Modify kubeconfig files using subcommands like &quot;kubectl config set current-context my-context&quot; $ kubectl config --help # Print the logs for a container in a pod or specified resource. $ kubectl logs --help # Execute a command in a container. $ kubectl exec --help Using kubectl to Create a Deployment $ kubectl run nginx --image=nginx:1.15 --port 80 $ kubectl proxy $ curl -iI http://localhost:8001/api/v1/namespaces/default/pods/$(kubectl get po –o jsonpath=&#39;{.items[0].metadata.name}&#39;)/proxy kubectl get - list resources kubectl describe - show detailed information about a resource kubectl logs - print the logs from a container in a pod kubectl exec - execute a command on a container in a pod Viewing Pods and Nodes Pod is a Kubernetes abstraction that represents a group of one or more application containers (such as Docker or rkt), and some shared resources for those containers. Those resources include: Shared storage, as Volumes Networking, as a unique cluster IP address Information about how to run each container, such as the container image version or specific ports to use A Pod models an application-specific “logical host” and can contain different application containers which are relatively tightly coupled. Pods are the atomic unit on the Kubernetes platform. Pods overview Node overview A Pod always runs on a Node. A Node is a worker machine in Kubernetes and may be either a virtual or a physical machine, depending on the cluster. Each Node is managed by the Master. A Node can have multiple pods, and the Kubernetes master automatically handles scheduling the pods across the Nodes in the cluster. Every Kubernetes Node runs at least: Kubelet, a process responsible for communication between the Kubernetes Master and the Node; it manages the Pods and the containers running on a machine. A container runtime (like Docker, rkt) responsible for pulling the container image from a registry, unpacking the container, and running the application. Using a Service to Expose Your App Kubernetes Pods are mortal. A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods. Services can be exposed in different ways by specifying a type in the ServiceSpec: ClusterIP (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster. NodePort - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using :. Superset of ClusterIP. LoadBalancer - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort. ExternalName - Exposes the Service using an arbitrary name (specified by externalName in the spec) by returning a CNAME record with the name. No proxy is used. Services and Labels Labels are key/value pairs that are attached to objects, such as pods. Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of objects. Services match a set of Pods using labels and selectors, a grouping primitive that allows logical operation on objects in Kubernetes. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ Expose Your App Publicly $ kubectl run nginx --image=nginx:1.15 --port=80 kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead. deployment.apps/nginx created $ kubectl get po nginx-6f7d58d4cc-7vnxv --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-6f7d58d4cc-7vnxv 1/1 Running 0 13s pod-template-hash=6f7d58d4cc,run=nginx $ kubectl expose deployment nginx --type=NodePort --port=80 service/nginx exposed $ kubectl get svc nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx NodePort 10.98.138.39 &lt;none&gt; 80:31462/TCP 26s $ kubectl get svc nginx -ojsonpath=&#39;{.spec.ports[0].nodePort}&#39; 31462$ kubectl get no -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME far-seer-01 Ready master 24d v1.13.2 192.168.66.128 &lt;none&gt; Debian GNU/Linux 9 (stretch) 4.9.0-8-amd64 docker://18.6.0 $ curl -iI 192.168.66.128:31462 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Thu, 21 Feb 2019 07:24:48 GMT Content-Type: text/html Content-Length: 612 Last-Modified: Tue, 25 Dec 2018 09:56:47 GMT Connection: keep-alive ETag: &quot;5c21fedf-264&quot; Accept-Ranges: bytes Running Multiple Instances of Your App Scale Your App $ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 20m $ kubectl scale deployment nginx --replicas=4 # scale out deployment.extensions/nginx scaled $ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 20m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 5s nginx-6f7d58d4cc-l7grh 1/1 Running 0 5s nginx-6f7d58d4cc-m8nr2 1/1 Running 0 5s $ kubectl scale deployment nginx --replicas=2 # scale in deployment.extensions/nginx scaled $ kubectl get po -w NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 21m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 62s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 62s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 62s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 64s nginx-6f7d58d4cc-m8nr2 0/1 Terminating 0 64s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 64s nginx-6f7d58d4cc-l7grh 0/1 Terminating 0 64s ^C$ kubectl get po NAME READY STATUS RESTARTS AGE nginx-6f7d58d4cc-7vnxv 1/1 Running 0 21m nginx-6f7d58d4cc-ddhgk 1/1 Running 0 79s $ Performing a Rolling Update Update Your App $ kubectl get deployment NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 2 2 53m $ kubectl get svc nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx NodePort 10.98.138.39 &lt;none&gt; 80:31462/TCP 52m $ curl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.15.8 $ kubectl set image deploy nginx nginx=nginx:1.13 &amp;&amp; kubectl get deploy nginx -w deployment.extensions/nginx image updated NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 1 2 54m nginx 3/2 1 3 54m nginx 2/2 1 2 54m nginx 2/2 2 2 54m ^Ccurl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.13.12 $ kubectl rollout undo deployment nginx deployment.extensions/nginx rolled back $ kubectl get deployments -w NAME READY UP-TO-DATE AVAILABLE AGE nginx 2/2 2 2 58m ^Ccurl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.15.8 $ kubectl rollout undo deployment nginx deployment.extensions/nginx rolled back $ curl -iIs 192.168.66.128:31462 | grep Server Server: nginx/1.13.12 $ kubectl get rs NAME DESIRED CURRENT READY AGE nginx-5df8d97c98 0 0 0 21m nginx-6b46d56475 2 2 2 17m nginx-6f7d58d4cc 0 0 0 63m $ kubectl rollout history deployment nginx deployment.extensions/nginx REVISION CHANGE-CAUSE 2 &lt;none&gt; 3 &lt;none&gt; Quit or not quit ? https://kubernetes.io/","headline":"0 - Kubernetes Overview","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2019/02/21/kubernetes-crash-course-0/"},"url":"https://blog.codefarm.me/2019/02/21/kubernetes-crash-course-0/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">0 - Kubernetes Overview</h1><p class="c-post-meta">21 Feb 2019</p>
  </header>

  <div class="c-post-content">
    <ul id="markdown-toc">
  <li><a href="#what-is-kubernetes" id="markdown-toc-what-is-kubernetes">What is Kubernetes?</a></li>
  <li><a href="#kubernetes-vs-docker-swarm-vs-apache-mesos" id="markdown-toc-kubernetes-vs-docker-swarm-vs-apache-mesos">Kubernetes vs Docker Swarm vs Apache Mesos</a></li>
  <li><a href="#cloud-native-computing-foundation" id="markdown-toc-cloud-native-computing-foundation">CLOUD NATIVE <small><small>COMPUTING FOUNDATION</small></small></a></li>
  <li><a href="#setup-kubernetes-cluster" id="markdown-toc-setup-kubernetes-cluster">Setup Kubernetes Cluster</a>    <ul>
      <li><a href="#set-dockerservice-behind-http-proxy" id="markdown-toc-set-dockerservice-behind-http-proxy">Set docker.service behind HTTP proxy</a></li>
      <li><a href="#set-http-proxy-for-aptyum" id="markdown-toc-set-http-proxy-for-aptyum">Set HTTP Proxy for APT/YUM</a></li>
      <li><a href="#start-minikube-behind-a-http-proxy" id="markdown-toc-start-minikube-behind-a-http-proxy">Start minikube behind a HTTP Proxy</a></li>
    </ul>
  </li>
  <li><a href="#learn-kubernetes-basics" id="markdown-toc-learn-kubernetes-basics">Learn Kubernetes Basics</a>    <ul>
      <li><a href="#kubectl" id="markdown-toc-kubectl">Kubectl</a></li>
      <li><a href="#using-kubectl-to-create-a-deployment" id="markdown-toc-using-kubectl-to-create-a-deployment">Using kubectl to Create a Deployment</a></li>
      <li><a href="#viewing-pods-and-nodes" id="markdown-toc-viewing-pods-and-nodes">Viewing Pods and Nodes</a></li>
      <li><a href="#pods-overview" id="markdown-toc-pods-overview">Pods overview</a></li>
      <li><a href="#node-overview" id="markdown-toc-node-overview">Node overview</a></li>
      <li><a href="#using-a-service-to-expose-your-app" id="markdown-toc-using-a-service-to-expose-your-app">Using a Service to Expose Your App</a>        <ul>
          <li><a href="#services-and-labels" id="markdown-toc-services-and-labels">Services and Labels</a></li>
          <li><a href="#expose-your-app-publicly" id="markdown-toc-expose-your-app-publicly">Expose Your App Publicly</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#running-multiple-instances-of-your-app" id="markdown-toc-running-multiple-instances-of-your-app">Running Multiple Instances of Your App</a>    <ul>
      <li><a href="#scale-your-app" id="markdown-toc-scale-your-app">Scale Your App</a></li>
    </ul>
  </li>
  <li><a href="#performing-a-rolling-update" id="markdown-toc-performing-a-rolling-update">Performing a Rolling Update</a>    <ul>
      <li><a href="#update-your-app" id="markdown-toc-update-your-app">Update Your App</a></li>
    </ul>
  </li>
  <li><a href="#quit-or-not-quit-" id="markdown-toc-quit-or-not-quit-">Quit or not quit ?</a></li>
</ul>

<style>
img {
 width: 55%;
}
</style>

<hr />

<h3 id="what-is-kubernetes">What is Kubernetes?</h3>

<ul>
  <li>
    <p>Kubernetes is a production-grade, open-source platform that orchestrates the placement (scheduling) and execution of application containers within and across computer clusters.</p>
  </li>
  <li>
    <p>Kubernetes provides a container-centric management environment. It orchestrates computing, networking, and storage infrastructure on behalf of user workloads.</p>
  </li>
  <li>
    <p><a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></p>
  </li>
</ul>

<h3 id="kubernetes-vs-docker-swarm-vs-apache-mesos">Kubernetes vs Docker Swarm vs Apache Mesos</h3>

<p><img src="/assets/kubernetes/k8s-swarm-mesos.png" alt="Kubernetes vs Docker Swarm vs Apache Mesos" /></p>

<ul>
  <li><a href="https://codefresh.io/kubernetes-tutorial/kubernetes-vs-docker-swarm-vs-apache-mesos/">https://codefresh.io/kubernetes-tutorial/kubernetes-vs-docker-swarm-vs-apache-mesos/</a></li>
</ul>

<h3 id="cloud-native-computing-foundation">CLOUD NATIVE <small><small>COMPUTING FOUNDATION</small></small></h3>

<p><img src="/assets/kubernetes/cncf.png" alt="CLOUD NATIVE COMPUTING FOUNDATION" /></p>

<ul>
  <li>CNCF is an open source software foundation dedicated to making cloud native computing universal and sustainable.</li>
  <li>Cloud native computing uses an open source software stack to deploy applications as microservices, packaging each part into its own container, and dynamically orchestrating those containers to optimize resource utilization.</li>
  <li>Cloud native technologies enable software developers to build great products faster.</li>
  <li>https://www.cncf.io/</li>
</ul>

<h3 id="setup-kubernetes-cluster">Setup Kubernetes Cluster</h3>

<p><img src="/assets/kubernetes/gfw.png" alt="GFW" /></p>

<ul>
  <li>Minikube &amp; Kubeadm</li>
  <li>
    <p>AKS &amp; EKS &amp; ACK &amp; TKE</p>
  </li>
  <li>
    <p><a href="https://kubernetes.io/docs/setup/">https://kubernetes.io/docs/setup/</a></p>
  </li>
  <li>
    <p><a href="https://kubernetes.io/docs/setup/minikube/">https://kubernetes.io/docs/setup/minikube/</a></p>
  </li>
  <li>
    <p><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/">https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/</a></p>
  </li>
  <li>
    <p><a href="https://codefarm.me/2018/12/27/intall-minikube-with-kubeadm-on-debian/">https://codefarm.me/2018/12/27/intall-minikube-with-kubeadm-on-debian/</a></p>
  </li>
  <li><a href="https://codefarm.me/2019/01/28/bootstrapping-kubernetes-clusters-with-kubeadm/">https://codefarm.me/2019/01/28/bootstrapping-kubernetes-clusters-with-kubeadm/</a></li>
</ul>

<h4 id="set-dockerservice-behind-http-proxy">Set docker.service behind HTTP proxy</h4>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. Edit the docker.service configuration with systemctl</span>
<span class="nv">$ </span><span class="nb">sudo </span>systemctl edit docker.service
<span class="c"># 2. Add the following text in the editor (Please update the PROXY_HOST and PROXY_PORT !!!)</span>
<span class="c">#   [Service]</span>
<span class="c">#   Environment="HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/" "NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com" "HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/"</span>
<span class="c"># 3. Exit the editor. You can also run the following command to print the docker.service.d/override.conf</span>
<span class="nv">$ </span><span class="nb">cat</span> /etc/systemd/system/docker.service.d/override.conf 
<span class="o">[</span>Service]
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"HTTP_PROXY=http://PROXY_HOST:PROXY_PORT/"</span> <span class="s2">"NO_PROXY=registry.docker-cn.com,registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,repository.gridsum.com,index.docker.io,registry.hub.docker.com,registry-1.docker.io,auth.docker.io,production.cloudflare.docker.com"</span> <span class="s2">"HTTPS_PROXY=http://PROXY_HOST:PROXY_PORT/"</span>
<span class="c"># 4. Reload systemd manager configuration</span>
<span class="nv">$ </span><span class="nb">sudo </span>systemctl daemon-reload
<span class="c"># 5. Restart the docker.service</span>
<span class="nv">$ </span><span class="nb">sudo </span>systemctl restart docker.service
</code></pre></div></div>

<h4 id="set-http-proxy-for-aptyum">Set HTTP Proxy for APT/YUM</h4>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Set HTTP proxy for APT:</span>
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; /etc/apt/apt.conf.d/httproxy 
&gt; Acquire::http::Proxy "http://PROXY_HOST:PORT";
&gt; EOF

# Set HTTP proxy for YUM:
</span><span class="nv">$ </span><span class="sh">echo 'proxy=http://PROXY_HOST:PORT' &gt;&gt; /etc/yum.conf
</span></code></pre></div></div>

<h4 id="start-minikube-behind-a-http-proxy">Start minikube behind a HTTP Proxy</h4>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>minikube start <span class="se">\</span>
     <span class="nt">--docker-env</span> <span class="nv">HTTP_PROXY</span><span class="o">=</span>http://PROXY_HOST:PORT/ <span class="se">\</span>
     <span class="nt">--docker-env</span> <span class="nv">HTTPS_PROXY</span><span class="o">=</span>http://PROXY_HOST:PORT/ <span class="se">\</span>
     <span class="nt">--docker-env</span> <span class="nv">NO_PROXY</span><span class="o">=</span>index.docker.io,<span class="se">\</span>
 registry.hub.docker.com,<span class="se">\</span>
 registry-1.docker.io,<span class="se">\</span>
 registry.docker-cn.com,<span class="se">\</span>
 registry-mirror-cache-cn.oss-cn-shanghai.aliyuncs.com,<span class="se">\</span>
 192.168.99.100<span class="se">\</span>
     <span class="nt">--registry-mirror</span> https://registry.docker-cn.com
</code></pre></div></div>

<ul>
  <li><a href="https://codefarm.me/2018/08/09/http-proxy-docker-minikube/">https://codefarm.me/2018/08/09/http-proxy-docker-minikube/</a></li>
</ul>

<h3 id="learn-kubernetes-basics">Learn Kubernetes Basics</h3>

<ul>
  <li>Deploy an App</li>
  <li>Explore Your App</li>
  <li>Expose Your App Publicly</li>
  <li>Scale Your App</li>
  <li>
    <p>Update Your App</p>
  </li>
  <li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></li>
</ul>

<h4 id="kubectl">Kubectl</h4>

<p>Kubectl is a command line interface for running commands against Kubernetes clusters.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># kubectl controls the Kubernetes cluster manager.</span>
<span class="nv">$ </span>kubectl <span class="nt">--help</span>
<span class="c"># Output shell completion code for the specified shell (bash or zsh).</span>
<span class="nv">$ </span>kubectl completion <span class="nt">--help</span>
<span class="c"># Print the supported API resources on the server</span>
<span class="nv">$ </span>kubectl api-resources <span class="nt">--help</span>
<span class="c"># List the fields for supported resources</span>
<span class="nv">$ </span>kubectl explain <span class="nt">--help</span>
<span class="c"># Modify kubeconfig files using subcommands like "kubectl config set current-context my-context"</span>
<span class="nv">$ </span>kubectl config <span class="nt">--help</span>
<span class="c"># Print the logs for a container in a pod or specified resource.</span>
<span class="nv">$ </span>kubectl logs <span class="nt">--help</span>
<span class="c"># Execute a command in a container.</span>
<span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">--help</span>
</code></pre></div></div>

<h4 id="using-kubectl-to-create-a-deployment">Using kubectl to Create a Deployment</h4>

<p><img src="https://d33wubrfki0l68.cloudfront.net/152c845f25df8e69dd24dd7b0836a289747e258a/4a1d2/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg" alt="Kubernetes Cluster" /></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl run nginx <span class="nt">--image</span><span class="o">=</span>nginx:1.15 <span class="nt">--port</span> 80

<span class="nv">$ </span>kubectl proxy

<span class="nv">$ </span>curl <span class="nt">-iI</span> http://localhost:8001/api/v1/namespaces/default/pods/<span class="si">$(</span>kubectl get po –o <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.items[0].metadata.name}'</span><span class="si">)</span>/proxy
</code></pre></div></div>

<ul>
  <li><strong>kubectl get</strong> - list resources</li>
  <li><strong>kubectl describe</strong> - show detailed information about a resource</li>
  <li><strong>kubectl logs</strong> - print the logs from a container in a pod</li>
  <li><strong>kubectl exec</strong> - execute a command on a container in a pod</li>
</ul>

<h4 id="viewing-pods-and-nodes">Viewing Pods and Nodes</h4>

<p><img src="https://d33wubrfki0l68.cloudfront.net/5cb72d407cbe2755e581b6de757e0d81760d5b86/a9df9/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg" alt="Node overview" /></p>

<ul>
  <li>Pod is a Kubernetes abstraction that represents a group of one or more application containers (such as Docker or rkt), and some shared resources for those containers. Those resources include:</li>
  <li>Shared storage, as Volumes</li>
  <li>Networking, as a unique cluster IP address</li>
  <li>
    <p>Information about how to run each container, such as the container image version or specific ports to use</p>
  </li>
  <li>
    <p>A Pod models an application-specific “logical host” and can contain different application containers which are relatively tightly coupled.</p>
  </li>
  <li>Pods are the atomic unit on the Kubernetes platform.</li>
</ul>

<h4 id="pods-overview">Pods overview</h4>

<p><img src="https://d33wubrfki0l68.cloudfront.net/fe03f68d8ede9815184852ca2a4fd30325e5d15a/98064/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg" alt="Pods overview" /></p>

<h4 id="node-overview">Node overview</h4>

<p><img src="https://d33wubrfki0l68.cloudfront.net/5cb72d407cbe2755e581b6de757e0d81760d5b86/a9df9/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg" alt="Node overview" /></p>

<ul>
  <li>A Pod always runs on a Node.</li>
  <li>A Node is a worker machine in Kubernetes and may be either a virtual or a physical machine, depending on the cluster.</li>
  <li>Each Node is managed by the Master.</li>
  <li>
    <p>A Node can have multiple pods, and the Kubernetes master automatically handles scheduling the pods across the Nodes in the cluster.</p>
  </li>
  <li>Every Kubernetes Node runs at least:
    <ul>
      <li><strong>Kubelet</strong>, a process responsible for communication between the Kubernetes Master and the Node; it manages the Pods and the containers running on a machine.</li>
      <li>A <strong>container runtime</strong> (like Docker, rkt) responsible for pulling the container image from a registry, unpacking the container, and running the application.</li>
    </ul>
  </li>
</ul>

<h4 id="using-a-service-to-expose-your-app">Using a Service to Expose Your App</h4>

<p><img src="https://d33wubrfki0l68.cloudfront.net/cc38b0f3c0fd94e66495e3a4198f2096cdecd3d5/ace10/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg" alt="Services and Labels" /></p>

<ul>
  <li>Kubernetes Pods are mortal.</li>
  <li>A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods.</li>
  <li>Services can be exposed in different ways by specifying a type in the ServiceSpec:
    <ul>
      <li><strong>ClusterIP</strong> (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster.</li>
      <li><strong>NodePort</strong> - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using <NodeIP>:<NodePort>. Superset of ClusterIP.</NodePort></NodeIP></li>
      <li><strong>LoadBalancer</strong> - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort.</li>
      <li><strong>ExternalName</strong> - Exposes the Service using an arbitrary name (specified by externalName in the spec) by returning a CNAME record with the name. No proxy is used.</li>
    </ul>
  </li>
</ul>

<h5 id="services-and-labels">Services and Labels</h5>

<p><img src="https://d33wubrfki0l68.cloudfront.net/b964c59cdc1979dd4e1904c25f43745564ef6bee/f3351/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg" alt="Services and Labels" /></p>

<ul>
  <li><strong>Labels</strong> are key/value pairs that are attached to objects, such as pods.</li>
  <li>Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system.</li>
  <li>Labels can be used to organize and to select subsets of objects.</li>
  <li>Services match a set of Pods using labels and selectors, a grouping primitive that allows logical operation on objects in Kubernetes.</li>
  <li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/</a></li>
</ul>

<h5 id="expose-your-app-publicly">Expose Your App Publicly</h5>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl run nginx <span class="nt">--image</span><span class="o">=</span>nginx:1.15 <span class="nt">--port</span><span class="o">=</span>80
kubectl run <span class="nt">--generator</span><span class="o">=</span>deployment/apps.v1 is DEPRECATED and will be removed <span class="k">in </span>a future version. Use kubectl run <span class="nt">--generator</span><span class="o">=</span>run-pod/v1 or kubectl create instead.
deployment.apps/nginx created
<span class="nv">$ </span>kubectl get po nginx-6f7d58d4cc-7vnxv <span class="nt">--show-labels</span> 
NAME                     READY   STATUS    RESTARTS   AGE   LABELS
nginx-6f7d58d4cc-7vnxv   1/1     Running   0          13s   pod-template-hash<span class="o">=</span>6f7d58d4cc,run<span class="o">=</span>nginx
<span class="nv">$ </span>kubectl expose deployment nginx <span class="nt">--type</span><span class="o">=</span>NodePort <span class="nt">--port</span><span class="o">=</span>80 
service/nginx exposed
<span class="nv">$ </span>kubectl get svc nginx 
NAME    TYPE       CLUSTER-IP     EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>        AGE
nginx   NodePort   10.98.138.39   &lt;none&gt;        80:31462/TCP   26s
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get svc nginx <span class="nt">-ojsonpath</span><span class="o">=</span><span class="s1">'{.spec.ports[0].nodePort}'</span>
31462<span class="nv">$ </span>kubectl get no <span class="nt">-o</span> wide
NAME          STATUS   ROLES    AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE                       KERNEL-VERSION   CONTAINER-RUNTIME
far-seer-01   Ready    master   24d   v1.13.2   192.168.66.128   &lt;none&gt;        Debian GNU/Linux 9 <span class="o">(</span>stretch<span class="o">)</span>   4.9.0-8-amd64    docker://18.6.0
<span class="nv">$ </span>curl <span class="nt">-iI</span> 192.168.66.128:31462
HTTP/1.1 200 OK
Server: nginx/1.15.8
Date: Thu, 21 Feb 2019 07:24:48 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 25 Dec 2018 09:56:47 GMT
Connection: keep-alive
ETag: <span class="s2">"5c21fedf-264"</span>
Accept-Ranges: bytes

</code></pre></div></div>

<h3 id="running-multiple-instances-of-your-app">Running Multiple Instances of Your App</h3>

<p><img src="https://d33wubrfki0l68.cloudfront.net/043eb67914e9474e30a303553d5a4c6c7301f378/0d8f6/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg" alt="Current State" /></p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/30f75140a581110443397192d70a4cdb37df7bfc/b5f56/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg" alt="New State" /></p>

<h4 id="scale-your-app">Scale Your App</h4>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get po
NAME                     READY   STATUS    RESTARTS   AGE
nginx-6f7d58d4cc-7vnxv   1/1     Running   0          20m
<span class="nv">$ </span>kubectl scale deployment nginx <span class="nt">--replicas</span><span class="o">=</span>4    <span class="c"># scale out</span>
deployment.extensions/nginx scaled
<span class="nv">$ </span>kubectl get po
NAME                     READY   STATUS    RESTARTS   AGE
nginx-6f7d58d4cc-7vnxv   1/1     Running   0          20m
nginx-6f7d58d4cc-ddhgk   1/1     Running   0          5s
nginx-6f7d58d4cc-l7grh   1/1     Running   0          5s
nginx-6f7d58d4cc-m8nr2   1/1     Running   0          5s
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nv">$ </span>kubectl scale deployment nginx <span class="nt">--replicas</span><span class="o">=</span>2    <span class="c"># scale in</span>
deployment.extensions/nginx scaled
<span class="nv">$ </span>kubectl get po <span class="nt">-w</span>
NAME                     READY   STATUS        RESTARTS   AGE
nginx-6f7d58d4cc-7vnxv   1/1     Running       0          21m
nginx-6f7d58d4cc-ddhgk   1/1     Running       0          62s
nginx-6f7d58d4cc-l7grh   0/1     Terminating   0          62s
nginx-6f7d58d4cc-m8nr2   0/1     Terminating   0          62s
nginx-6f7d58d4cc-m8nr2   0/1   Terminating   0     64s
nginx-6f7d58d4cc-m8nr2   0/1   Terminating   0     64s
nginx-6f7d58d4cc-l7grh   0/1   Terminating   0     64s
nginx-6f7d58d4cc-l7grh   0/1   Terminating   0     64s
^C<span class="nv">$ </span>kubectl get po
NAME                     READY   STATUS    RESTARTS   AGE
nginx-6f7d58d4cc-7vnxv   1/1     Running   0          21m
nginx-6f7d58d4cc-ddhgk   1/1     Running   0          79s
<span class="nv">$ </span>
</code></pre></div></div>

<h3 id="performing-a-rolling-update">Performing a Rolling Update</h3>

<p><img src="https://d33wubrfki0l68.cloudfront.net/30f75140a581110443397192d70a4cdb37df7bfc/fa906/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg" alt="Current State" /></p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/678bcc3281bfcc588e87c73ffdc73c7a8380aca9/703a2/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg" alt="Updating State" /></p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/6d8bc1ebb4dc67051242bc828d3ae849dbeedb93/fbfa8/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg" alt="New State" /></p>

<h4 id="update-your-app">Update Your App</h4>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get deployment
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   2/2     2            2           53m
<span class="nv">$ </span>kubectl get svc nginx 
NAME    TYPE       CLUSTER-IP     EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>        AGE
nginx   NodePort   10.98.138.39   &lt;none&gt;        80:31462/TCP   52m
<span class="nv">$ </span>curl <span class="nt">-iIs</span> 192.168.66.128:31462 | <span class="nb">grep </span>Server
Server: nginx/1.15.8
<span class="nv">$ </span>kubectl <span class="nb">set </span>image deploy nginx <span class="nv">nginx</span><span class="o">=</span>nginx:1.13 <span class="o">&amp;&amp;</span> kubectl get deploy nginx <span class="nt">-w</span>
deployment.extensions/nginx image updated
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   2/2     1            2           54m
nginx   3/2   1     3     54m
nginx   2/2   1     2     54m
nginx   2/2   2     2     54m
^Ccurl <span class="nt">-iIs</span> 192.168.66.128:31462 | <span class="nb">grep </span>Server
Server: nginx/1.13.12
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl rollout undo deployment nginx 
deployment.extensions/nginx rolled back
<span class="nv">$ </span>kubectl get deployments <span class="nt">-w</span>
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   2/2     2            2           58m
^Ccurl <span class="nt">-iIs</span> 192.168.66.128:31462 | <span class="nb">grep </span>Server
Server: nginx/1.15.8
<span class="nv">$ </span>kubectl rollout undo deployment nginx 
deployment.extensions/nginx rolled back
<span class="nv">$ </span>curl <span class="nt">-iIs</span> 192.168.66.128:31462 | <span class="nb">grep </span>Server
Server: nginx/1.13.12
<span class="nv">$ </span>kubectl get rs
NAME               DESIRED   CURRENT   READY   AGE
nginx-5df8d97c98   0         0         0       21m
nginx-6b46d56475   2         2         2       17m
nginx-6f7d58d4cc   0         0         0       63m
<span class="nv">$ </span>kubectl rollout <span class="nb">history </span>deployment nginx 
deployment.extensions/nginx 
REVISION  CHANGE-CAUSE
2         &lt;none&gt;
3         &lt;none&gt;
</code></pre></div></div>

<h3 id="quit-or-not-quit-">Quit or not quit ?</h3>

<p><a href="https://kubernetes.io/">https://kubernetes.io/</a></p>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
