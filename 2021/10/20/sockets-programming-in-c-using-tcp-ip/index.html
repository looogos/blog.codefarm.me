<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Sockets Programming in C using TCP/IP | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Sockets Programming in C using TCP/IP" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. Berkley Sockets 1.1. Sockets 2. Socket Programming 2.1. Client-Server communication 2.2. Sockets - Procedures 2.3. Client - Server Communication - Unix 2.4. Example - Echo 3. References 1. Berkley Sockets Universally known as Sockets It is an abstraction through which an application may send and receive data Provide generic accessto interprocess communication services e.g. IPX/SPX, Appletalk, TCP/IP Standard API for networking 1.1. Sockets Uniquely identified by an internet address an end-to-end protocol (e.g. TCP or UDP) a port number Two types of (TCP/IP) sockets Stream sockets (e.g. uses TCP) provide reliable byte-stream service Datagram sockets (e.g. uses UDP) provide best-effort datagram service messages up to 65.500 bytes Socket extend the convectional UNIX I/O facilities file descriptors for network communication extended the read and write system calls 2. Socket Programming 2.1. Client-Server communication Server passively waits for and responds to clients passive socket Client initiates the communication must know the address and the port of the server active socket 2.2. Sockets - Procedures Table 1. Sockets - Procedures Primitive Meaning Socket Create a new commnunication endpoint Bind Attach a local address to a socket Listen Announce willingness to accept connections Accept Block caller until a connection request arrives Connect Actively attempt to establish a connection Send Send some date over the connection Receive Receive some date over the connection Shutdown Shut down part of a full-duplex connection Close Release the connection 2.3. Client - Server Communication - Unix SOCKET(2) Linux Programmer&#39;s Manual SOCKET(2) NAME socket - create an endpoint for communication SYNOPSIS #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); DESCRIPTION socket() creates an endpoint for communication and returns a file de‐ scriptor that refers to that endpoint. The file descriptor returned by a successful call will be the lowest-numbered file descriptor not cur‐ rently open for the process. Table 2. Client - Server Communication - Unix Stream (e.g. TCP) Datagram (e.g. UDP) Server Client Server Client socket() socket() socket() socket() bind() &lt;bind()&gt; bind() bind() listen() accept() syn point connect() recv() send() recvfrom() sendto() send() recv() sendto() recvfrom() close() close() close() close() 2.3.1. Socket creation in C: socket() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); int sockid = socket(family, type, protocol); sockid: socket descriptor, an integer (like a file-handle) family: integer, communication domain, e.g., PF_INET, IPv4 protocols, Internet addresses (typically used) PF_UNIX, Local communication, File addresses type: communication type SOCK_STREAM - reliable, 2-way, connection-based service SOCK_DGRAM - unreliable, connectionless, messages of maximum length protocol: specifies protocol IPPROTO_TCP IPPROTO_UDP usually set to 0 (i.e., use default protocol) upon failure returns -1 Note: socket call does not specify where data will be coming from, nor where it will be going to – it just creates the interface! 2.3.2. Socket close in C: close() #include &lt;unistd.h&gt; int close(int fd); When finished using a socket, the socket should be closed status= close(sockid); sockid: the file descriptor (socket being closed) status: 0 if successful, -1 if error Closing a socket closes a connection (for stream socket) frees up the port used by the socket 2.3.3. Assign address to socket: bind() #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); associates and reserves a port for use by the socket int status = bind(sockid, &amp;addrport, size); sockid: integer, socket descriptor addrport: struct sockaddr, the (IP) address and port of the machine for TCP/IP server, internet address is usually set to INADDR_ANY, i.e., chooses any incoming interface size: the size (in bytes) of the addrport structure status: upon failure -1 is returned 2.3.3.1. Specifying Addresses Socket API defines a generic data type for addresses: struct sockaddr { unsigned short sa_family; /* Address family (e.g. AF_INET) */ char sa_data[14]; /* Family-specific address information */ } Particular form of the sockaddr used for TCP/IP addresses: struct in_addr { unsigned long s_addr; /* Internet address (32 bits) */ } struct sockaddr_in { unsigned short sin_family; /* Internet protocol (AF_INET) */ unsigned short sin_port; /* Address port (16 bits) */ struct in_addr sin_addr; /* Internet address (32 bits) */ char sin_zero[8]; /* Not used */ } Important: sockaddr_in can be casted to a sockaddr 2.3.3.2. bind() - Example with TCP int sockid; struct sockaddr_in addrport; sockid = socket(PF_INET, SOCK_STREAM, 0); addrport.sin_family = AF_INET; addrport.sin_port = htons(5100); addrport.sin_addr.s_addr = htonl(INADDR_ANY); if(bind(sockid, (struct sockaddr *) &amp;addrport, sizeof(addrport))!= -1) { // … } 2.3.3.3. Skipping the bind() bind can be skipped for both types of sockets Datagram socket: if only sending, no need to bind. The OS finds a port each timethe socket sends a packet if receiving, need to bind Stream socket: destination determined during connection setup don&#8217;t need to know port sending from (during connection setup, receiving end is informed of port) 2.3.4. Assign address to socket: listen() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int listen(int sockfd, int backlog); Instructs TCP protocol implementation to listen for connections int status = listen(sockid, queueLimit); sockid: integer, socket descriptor queueLimit: integer, # of active participants that can &quot;wait&quot; for a connection status: 0 if listening, -1 if error listen() is non-blocking: returns immediately The listening socket (sockid) is never used for sending and receiving is used by the server only as a way to get new sockets 2.3.5. Establish Connection: connect() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); The client establishes a connection with the server by calling connect() int status = connect(sockid, &amp;foreignAddr, addrlen); sockid: integer, socket to be used in connection foreignAddr: struct sockaddr: address of the passive participant addrlen: integer, sizeof(foreignAddr) status: 0 if successful connect, -1 otherwise connect() is blocking 2.3.6. Incoming Connection: accept() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); The server gets a socket for an incoming client connection by calling accept() int s = accept(sockid, &amp;clientAddr, &amp;addrLen); s: integer, the new socket (used for data-transfer) sockid: integer, the orig. socket (being listened on) clientAddr: struct sockaddr, address of the active participant filled in upon return addrLen: sizeof(clientAddr): value/result parameter must be set appropriately before call adjusted upon return accept() is blocking: waits for connection before returning dequeues the next connection on the queue for socket (sockid) 2.3.7. Exchanging data with stream socket int count = send(sockid, msg, msgLen, flags); msg: const void[], message to be transmitted msgLen: integer, length of message (in bytes) to transmit flags: integer, special options, usually just 0 count: # bytes transmitted (-1 if error) int count = recv(sockid, recvBuf, bufLen, flags); recvBuf: void[], stores received bytes bufLen: # bytes received flags: integer, special options, usually just 0 count: # bytes received (-1 if error) Calls are blocking returns only after data is sent / received 2.3.8. Exchanging data with datagram socket int count = sendto(sockid, msg, msgLen, flags, &amp;foreignAddr, addrlen); msg, msgLen, flags, count: same with send() foreignAddr: struct sockaddr, address of the destination addrLen: sizeof(foreignAddr) int count = recvfrom(sockid, recvBuf, bufLen, flags, &amp;clientAddr, addrlen); recvBuf, bufLen, flags, count: same with recv() clientAddr: struct sockaddr, address of the client addrLen: sizeof(clientAddr) Calls are blocking returns only after data is sent / received 2.4. Example - Echo A client communicates with an &quot;echo&quot; server The server simply echoes whatever it receives back to the client /* die_with_error.h */ void die_with_error(char*); /* die_with_error.c */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; void die_with_error(char* error) { int errsv = errno; fprintf(stderr, &quot;%s: %s&quot;, strerror(errsv), error); exit(EXIT_FAILURE); } 2.4.1. Echo using stream socket /* tcp_server.c */ #include &lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;unistd.h&gt; #include &quot;die_with_error.h&quot; #define MAXPENDING 1024 #define RCVBUFSIZE 4096 int main(void) { /* Create a TCP socket */ /* Create socket for incoming connections */ int serv_sock; if ((serv_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) { die_with_error(&quot;socket() failed&quot;); } /* Assign a port to socket */ int serv_port = 5100; struct sockaddr_in serv_addr; serv_addr.sin_family = AF_INET; /* Internet address family */ serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); /* Any incoming interface */ serv_addr.sin_port = htons(serv_port); /* Local port */ if (bind(serv_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) { die_with_error(&quot;bind() failed&quot;); } /* Set socket to listen */ /* Mark the socket so it will listen for incoming connections */ if (listen(serv_sock, MAXPENDING) &lt; 0) { die_with_error(&quot;listen() failed&quot;); } /* Repeatedly: */ /* Run forever */ for (;;) { /* Accept new connectionb */ /* Server is now blocked waiting for connection from a client */ int client_sock; struct sockaddr client_addr; int addr_len; addr_len = sizeof(client_addr); if ((client_sock = accept(serv_sock, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; 0) { die_with_error(&quot;accept() failed&quot;); } struct sockaddr_in *c_addr = (struct sockaddr_in *)&amp;client_addr; char c_ip_addr[INET6_ADDRSTRLEN]; inet_ntop(c_addr -&gt; sin_family, &amp;(c_addr -&gt; sin_addr), c_ip_addr, addr_len); int c_port = ntohs(c_addr -&gt; sin_port); printf(&quot;%s:%d =&gt;\n&quot;, c_ip_addr, c_port); /* Receive mesage from client */ int recv_msg_size; char echo_buf[RCVBUFSIZE]; if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;first recv() failed&quot;); } /* Send received string and receive again until end of transmission */ while (recv_msg_size &gt; 0) { /* zero indicates end of transmission */ if (send(client_sock, echo_buf, recv_msg_size, 0) != recv_msg_size) { die_with_error(&quot;repeat send() failed&quot;); } printf(echo_buf); memset(echo_buf, &#39;\0&#39;, RCVBUFSIZE); if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;recv() failed&quot;); } } /* Close the connection */ close(client_sock); printf(&quot;%s:%d &lt;=\n&quot;, c_ip_addr, c_port); } } /* tcp_client.c */ #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &quot;die_with_error.h&quot; #define RCVBUFSIZE 4096 int main(void) { /* Create a TCP socket */ /* Create a reliable, stream socket using TCP */ int client_sock; if ((client_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) { die_with_error(&quot;socket() failed&quot;); } /* Establish connection */ char *serv_ip = &quot;127.0.0.1&quot;; int serv_port = 5100; struct sockaddr_in serv_addr; serv_addr.sin_family = AF_INET; /* Internet address family */ serv_addr.sin_addr.s_addr = inet_addr(serv_ip); /* Server IP address*/ serv_addr.sin_port = htons(serv_port); /* Server port */ if (connect(client_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) { die_with_error(&quot;connect() failed&quot;); } /* Communicate */ int read_len; char *read_buf = (char*)malloc(RCVBUFSIZE * sizeof(char)); int recv_msg_size; char echo_buf[RCVBUFSIZE]; for(;;) { read_buf = fgets(read_buf, sizeof(read_buf), stdin); if(read_buf == NULL) { exit(EXIT_SUCCESS); } read_len = strlen(read_buf); /* Determine input length *//* Send the string to the server */ if (send(client_sock, read_buf, read_len, 0) != read_len) { die_with_error(&quot;send() sent a different number of bytes than expected&quot;); } /* Receive mesage from server */ if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;recv() failed&quot;); } fputs(echo_buf, stdout); memset(read_buf, &#39;\0&#39;, RCVBUFSIZE); memset(echo_buf, &#39;\0&#39;, RCVBUFSIZE); } /* Close the connection */ close(client_sock); } $ gcc die_with_error.h die_with_error.c tcp_server.c -o tcp_server $ ./tcp_server 127.0.0.1:45934 =&gt; Hello world! 127.0.0.1:45934 &lt;= ^C $ gcc die_with_error.h die_with_error.c tcp_client.c -o tcp_client $ echo &#39;Hello world!&#39; | ./tcp_client Hello world! 3. References https://www.csd.uoc.gr/~hy556/material.html" />
<meta property="og:description" content="1. Berkley Sockets 1.1. Sockets 2. Socket Programming 2.1. Client-Server communication 2.2. Sockets - Procedures 2.3. Client - Server Communication - Unix 2.4. Example - Echo 3. References 1. Berkley Sockets Universally known as Sockets It is an abstraction through which an application may send and receive data Provide generic accessto interprocess communication services e.g. IPX/SPX, Appletalk, TCP/IP Standard API for networking 1.1. Sockets Uniquely identified by an internet address an end-to-end protocol (e.g. TCP or UDP) a port number Two types of (TCP/IP) sockets Stream sockets (e.g. uses TCP) provide reliable byte-stream service Datagram sockets (e.g. uses UDP) provide best-effort datagram service messages up to 65.500 bytes Socket extend the convectional UNIX I/O facilities file descriptors for network communication extended the read and write system calls 2. Socket Programming 2.1. Client-Server communication Server passively waits for and responds to clients passive socket Client initiates the communication must know the address and the port of the server active socket 2.2. Sockets - Procedures Table 1. Sockets - Procedures Primitive Meaning Socket Create a new commnunication endpoint Bind Attach a local address to a socket Listen Announce willingness to accept connections Accept Block caller until a connection request arrives Connect Actively attempt to establish a connection Send Send some date over the connection Receive Receive some date over the connection Shutdown Shut down part of a full-duplex connection Close Release the connection 2.3. Client - Server Communication - Unix SOCKET(2) Linux Programmer&#39;s Manual SOCKET(2) NAME socket - create an endpoint for communication SYNOPSIS #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); DESCRIPTION socket() creates an endpoint for communication and returns a file de‐ scriptor that refers to that endpoint. The file descriptor returned by a successful call will be the lowest-numbered file descriptor not cur‐ rently open for the process. Table 2. Client - Server Communication - Unix Stream (e.g. TCP) Datagram (e.g. UDP) Server Client Server Client socket() socket() socket() socket() bind() &lt;bind()&gt; bind() bind() listen() accept() syn point connect() recv() send() recvfrom() sendto() send() recv() sendto() recvfrom() close() close() close() close() 2.3.1. Socket creation in C: socket() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); int sockid = socket(family, type, protocol); sockid: socket descriptor, an integer (like a file-handle) family: integer, communication domain, e.g., PF_INET, IPv4 protocols, Internet addresses (typically used) PF_UNIX, Local communication, File addresses type: communication type SOCK_STREAM - reliable, 2-way, connection-based service SOCK_DGRAM - unreliable, connectionless, messages of maximum length protocol: specifies protocol IPPROTO_TCP IPPROTO_UDP usually set to 0 (i.e., use default protocol) upon failure returns -1 Note: socket call does not specify where data will be coming from, nor where it will be going to – it just creates the interface! 2.3.2. Socket close in C: close() #include &lt;unistd.h&gt; int close(int fd); When finished using a socket, the socket should be closed status= close(sockid); sockid: the file descriptor (socket being closed) status: 0 if successful, -1 if error Closing a socket closes a connection (for stream socket) frees up the port used by the socket 2.3.3. Assign address to socket: bind() #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); associates and reserves a port for use by the socket int status = bind(sockid, &amp;addrport, size); sockid: integer, socket descriptor addrport: struct sockaddr, the (IP) address and port of the machine for TCP/IP server, internet address is usually set to INADDR_ANY, i.e., chooses any incoming interface size: the size (in bytes) of the addrport structure status: upon failure -1 is returned 2.3.3.1. Specifying Addresses Socket API defines a generic data type for addresses: struct sockaddr { unsigned short sa_family; /* Address family (e.g. AF_INET) */ char sa_data[14]; /* Family-specific address information */ } Particular form of the sockaddr used for TCP/IP addresses: struct in_addr { unsigned long s_addr; /* Internet address (32 bits) */ } struct sockaddr_in { unsigned short sin_family; /* Internet protocol (AF_INET) */ unsigned short sin_port; /* Address port (16 bits) */ struct in_addr sin_addr; /* Internet address (32 bits) */ char sin_zero[8]; /* Not used */ } Important: sockaddr_in can be casted to a sockaddr 2.3.3.2. bind() - Example with TCP int sockid; struct sockaddr_in addrport; sockid = socket(PF_INET, SOCK_STREAM, 0); addrport.sin_family = AF_INET; addrport.sin_port = htons(5100); addrport.sin_addr.s_addr = htonl(INADDR_ANY); if(bind(sockid, (struct sockaddr *) &amp;addrport, sizeof(addrport))!= -1) { // … } 2.3.3.3. Skipping the bind() bind can be skipped for both types of sockets Datagram socket: if only sending, no need to bind. The OS finds a port each timethe socket sends a packet if receiving, need to bind Stream socket: destination determined during connection setup don&#8217;t need to know port sending from (during connection setup, receiving end is informed of port) 2.3.4. Assign address to socket: listen() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int listen(int sockfd, int backlog); Instructs TCP protocol implementation to listen for connections int status = listen(sockid, queueLimit); sockid: integer, socket descriptor queueLimit: integer, # of active participants that can &quot;wait&quot; for a connection status: 0 if listening, -1 if error listen() is non-blocking: returns immediately The listening socket (sockid) is never used for sending and receiving is used by the server only as a way to get new sockets 2.3.5. Establish Connection: connect() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); The client establishes a connection with the server by calling connect() int status = connect(sockid, &amp;foreignAddr, addrlen); sockid: integer, socket to be used in connection foreignAddr: struct sockaddr: address of the passive participant addrlen: integer, sizeof(foreignAddr) status: 0 if successful connect, -1 otherwise connect() is blocking 2.3.6. Incoming Connection: accept() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); The server gets a socket for an incoming client connection by calling accept() int s = accept(sockid, &amp;clientAddr, &amp;addrLen); s: integer, the new socket (used for data-transfer) sockid: integer, the orig. socket (being listened on) clientAddr: struct sockaddr, address of the active participant filled in upon return addrLen: sizeof(clientAddr): value/result parameter must be set appropriately before call adjusted upon return accept() is blocking: waits for connection before returning dequeues the next connection on the queue for socket (sockid) 2.3.7. Exchanging data with stream socket int count = send(sockid, msg, msgLen, flags); msg: const void[], message to be transmitted msgLen: integer, length of message (in bytes) to transmit flags: integer, special options, usually just 0 count: # bytes transmitted (-1 if error) int count = recv(sockid, recvBuf, bufLen, flags); recvBuf: void[], stores received bytes bufLen: # bytes received flags: integer, special options, usually just 0 count: # bytes received (-1 if error) Calls are blocking returns only after data is sent / received 2.3.8. Exchanging data with datagram socket int count = sendto(sockid, msg, msgLen, flags, &amp;foreignAddr, addrlen); msg, msgLen, flags, count: same with send() foreignAddr: struct sockaddr, address of the destination addrLen: sizeof(foreignAddr) int count = recvfrom(sockid, recvBuf, bufLen, flags, &amp;clientAddr, addrlen); recvBuf, bufLen, flags, count: same with recv() clientAddr: struct sockaddr, address of the client addrLen: sizeof(clientAddr) Calls are blocking returns only after data is sent / received 2.4. Example - Echo A client communicates with an &quot;echo&quot; server The server simply echoes whatever it receives back to the client /* die_with_error.h */ void die_with_error(char*); /* die_with_error.c */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; void die_with_error(char* error) { int errsv = errno; fprintf(stderr, &quot;%s: %s&quot;, strerror(errsv), error); exit(EXIT_FAILURE); } 2.4.1. Echo using stream socket /* tcp_server.c */ #include &lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;unistd.h&gt; #include &quot;die_with_error.h&quot; #define MAXPENDING 1024 #define RCVBUFSIZE 4096 int main(void) { /* Create a TCP socket */ /* Create socket for incoming connections */ int serv_sock; if ((serv_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) { die_with_error(&quot;socket() failed&quot;); } /* Assign a port to socket */ int serv_port = 5100; struct sockaddr_in serv_addr; serv_addr.sin_family = AF_INET; /* Internet address family */ serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); /* Any incoming interface */ serv_addr.sin_port = htons(serv_port); /* Local port */ if (bind(serv_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) { die_with_error(&quot;bind() failed&quot;); } /* Set socket to listen */ /* Mark the socket so it will listen for incoming connections */ if (listen(serv_sock, MAXPENDING) &lt; 0) { die_with_error(&quot;listen() failed&quot;); } /* Repeatedly: */ /* Run forever */ for (;;) { /* Accept new connectionb */ /* Server is now blocked waiting for connection from a client */ int client_sock; struct sockaddr client_addr; int addr_len; addr_len = sizeof(client_addr); if ((client_sock = accept(serv_sock, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; 0) { die_with_error(&quot;accept() failed&quot;); } struct sockaddr_in *c_addr = (struct sockaddr_in *)&amp;client_addr; char c_ip_addr[INET6_ADDRSTRLEN]; inet_ntop(c_addr -&gt; sin_family, &amp;(c_addr -&gt; sin_addr), c_ip_addr, addr_len); int c_port = ntohs(c_addr -&gt; sin_port); printf(&quot;%s:%d =&gt;\n&quot;, c_ip_addr, c_port); /* Receive mesage from client */ int recv_msg_size; char echo_buf[RCVBUFSIZE]; if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;first recv() failed&quot;); } /* Send received string and receive again until end of transmission */ while (recv_msg_size &gt; 0) { /* zero indicates end of transmission */ if (send(client_sock, echo_buf, recv_msg_size, 0) != recv_msg_size) { die_with_error(&quot;repeat send() failed&quot;); } printf(echo_buf); memset(echo_buf, &#39;\0&#39;, RCVBUFSIZE); if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;recv() failed&quot;); } } /* Close the connection */ close(client_sock); printf(&quot;%s:%d &lt;=\n&quot;, c_ip_addr, c_port); } } /* tcp_client.c */ #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &quot;die_with_error.h&quot; #define RCVBUFSIZE 4096 int main(void) { /* Create a TCP socket */ /* Create a reliable, stream socket using TCP */ int client_sock; if ((client_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) { die_with_error(&quot;socket() failed&quot;); } /* Establish connection */ char *serv_ip = &quot;127.0.0.1&quot;; int serv_port = 5100; struct sockaddr_in serv_addr; serv_addr.sin_family = AF_INET; /* Internet address family */ serv_addr.sin_addr.s_addr = inet_addr(serv_ip); /* Server IP address*/ serv_addr.sin_port = htons(serv_port); /* Server port */ if (connect(client_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) { die_with_error(&quot;connect() failed&quot;); } /* Communicate */ int read_len; char *read_buf = (char*)malloc(RCVBUFSIZE * sizeof(char)); int recv_msg_size; char echo_buf[RCVBUFSIZE]; for(;;) { read_buf = fgets(read_buf, sizeof(read_buf), stdin); if(read_buf == NULL) { exit(EXIT_SUCCESS); } read_len = strlen(read_buf); /* Determine input length *//* Send the string to the server */ if (send(client_sock, read_buf, read_len, 0) != read_len) { die_with_error(&quot;send() sent a different number of bytes than expected&quot;); } /* Receive mesage from server */ if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;recv() failed&quot;); } fputs(echo_buf, stdout); memset(read_buf, &#39;\0&#39;, RCVBUFSIZE); memset(echo_buf, &#39;\0&#39;, RCVBUFSIZE); } /* Close the connection */ close(client_sock); } $ gcc die_with_error.h die_with_error.c tcp_server.c -o tcp_server $ ./tcp_server 127.0.0.1:45934 =&gt; Hello world! 127.0.0.1:45934 &lt;= ^C $ gcc die_with_error.h die_with_error.c tcp_client.c -o tcp_client $ echo &#39;Hello world!&#39; | ./tcp_client Hello world! 3. References https://www.csd.uoc.gr/~hy556/material.html" />
<link rel="canonical" href="https://blog.codefarm.me/2021/10/20/sockets-programming-in-c-using-tcp-ip/" />
<meta property="og:url" content="https://blog.codefarm.me/2021/10/20/sockets-programming-in-c-using-tcp-ip/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-20T13:13:54+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Sockets Programming in C using TCP/IP" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-20T13:13:54+08:00","datePublished":"2021-10-20T13:13:54+08:00","description":"1. Berkley Sockets 1.1. Sockets 2. Socket Programming 2.1. Client-Server communication 2.2. Sockets - Procedures 2.3. Client - Server Communication - Unix 2.4. Example - Echo 3. References 1. Berkley Sockets Universally known as Sockets It is an abstraction through which an application may send and receive data Provide generic accessto interprocess communication services e.g. IPX/SPX, Appletalk, TCP/IP Standard API for networking 1.1. Sockets Uniquely identified by an internet address an end-to-end protocol (e.g. TCP or UDP) a port number Two types of (TCP/IP) sockets Stream sockets (e.g. uses TCP) provide reliable byte-stream service Datagram sockets (e.g. uses UDP) provide best-effort datagram service messages up to 65.500 bytes Socket extend the convectional UNIX I/O facilities file descriptors for network communication extended the read and write system calls 2. Socket Programming 2.1. Client-Server communication Server passively waits for and responds to clients passive socket Client initiates the communication must know the address and the port of the server active socket 2.2. Sockets - Procedures Table 1. Sockets - Procedures Primitive Meaning Socket Create a new commnunication endpoint Bind Attach a local address to a socket Listen Announce willingness to accept connections Accept Block caller until a connection request arrives Connect Actively attempt to establish a connection Send Send some date over the connection Receive Receive some date over the connection Shutdown Shut down part of a full-duplex connection Close Release the connection 2.3. Client - Server Communication - Unix SOCKET(2) Linux Programmer&#39;s Manual SOCKET(2) NAME socket - create an endpoint for communication SYNOPSIS #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); DESCRIPTION socket() creates an endpoint for communication and returns a file de‐ scriptor that refers to that endpoint. The file descriptor returned by a successful call will be the lowest-numbered file descriptor not cur‐ rently open for the process. Table 2. Client - Server Communication - Unix Stream (e.g. TCP) Datagram (e.g. UDP) Server Client Server Client socket() socket() socket() socket() bind() &lt;bind()&gt; bind() bind() listen() accept() syn point connect() recv() send() recvfrom() sendto() send() recv() sendto() recvfrom() close() close() close() close() 2.3.1. Socket creation in C: socket() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); int sockid = socket(family, type, protocol); sockid: socket descriptor, an integer (like a file-handle) family: integer, communication domain, e.g., PF_INET, IPv4 protocols, Internet addresses (typically used) PF_UNIX, Local communication, File addresses type: communication type SOCK_STREAM - reliable, 2-way, connection-based service SOCK_DGRAM - unreliable, connectionless, messages of maximum length protocol: specifies protocol IPPROTO_TCP IPPROTO_UDP usually set to 0 (i.e., use default protocol) upon failure returns -1 Note: socket call does not specify where data will be coming from, nor where it will be going to – it just creates the interface! 2.3.2. Socket close in C: close() #include &lt;unistd.h&gt; int close(int fd); When finished using a socket, the socket should be closed status= close(sockid); sockid: the file descriptor (socket being closed) status: 0 if successful, -1 if error Closing a socket closes a connection (for stream socket) frees up the port used by the socket 2.3.3. Assign address to socket: bind() #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); associates and reserves a port for use by the socket int status = bind(sockid, &amp;addrport, size); sockid: integer, socket descriptor addrport: struct sockaddr, the (IP) address and port of the machine for TCP/IP server, internet address is usually set to INADDR_ANY, i.e., chooses any incoming interface size: the size (in bytes) of the addrport structure status: upon failure -1 is returned 2.3.3.1. Specifying Addresses Socket API defines a generic data type for addresses: struct sockaddr { unsigned short sa_family; /* Address family (e.g. AF_INET) */ char sa_data[14]; /* Family-specific address information */ } Particular form of the sockaddr used for TCP/IP addresses: struct in_addr { unsigned long s_addr; /* Internet address (32 bits) */ } struct sockaddr_in { unsigned short sin_family; /* Internet protocol (AF_INET) */ unsigned short sin_port; /* Address port (16 bits) */ struct in_addr sin_addr; /* Internet address (32 bits) */ char sin_zero[8]; /* Not used */ } Important: sockaddr_in can be casted to a sockaddr 2.3.3.2. bind() - Example with TCP int sockid; struct sockaddr_in addrport; sockid = socket(PF_INET, SOCK_STREAM, 0); addrport.sin_family = AF_INET; addrport.sin_port = htons(5100); addrport.sin_addr.s_addr = htonl(INADDR_ANY); if(bind(sockid, (struct sockaddr *) &amp;addrport, sizeof(addrport))!= -1) { // … } 2.3.3.3. Skipping the bind() bind can be skipped for both types of sockets Datagram socket: if only sending, no need to bind. The OS finds a port each timethe socket sends a packet if receiving, need to bind Stream socket: destination determined during connection setup don&#8217;t need to know port sending from (during connection setup, receiving end is informed of port) 2.3.4. Assign address to socket: listen() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int listen(int sockfd, int backlog); Instructs TCP protocol implementation to listen for connections int status = listen(sockid, queueLimit); sockid: integer, socket descriptor queueLimit: integer, # of active participants that can &quot;wait&quot; for a connection status: 0 if listening, -1 if error listen() is non-blocking: returns immediately The listening socket (sockid) is never used for sending and receiving is used by the server only as a way to get new sockets 2.3.5. Establish Connection: connect() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); The client establishes a connection with the server by calling connect() int status = connect(sockid, &amp;foreignAddr, addrlen); sockid: integer, socket to be used in connection foreignAddr: struct sockaddr: address of the passive participant addrlen: integer, sizeof(foreignAddr) status: 0 if successful connect, -1 otherwise connect() is blocking 2.3.6. Incoming Connection: accept() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); The server gets a socket for an incoming client connection by calling accept() int s = accept(sockid, &amp;clientAddr, &amp;addrLen); s: integer, the new socket (used for data-transfer) sockid: integer, the orig. socket (being listened on) clientAddr: struct sockaddr, address of the active participant filled in upon return addrLen: sizeof(clientAddr): value/result parameter must be set appropriately before call adjusted upon return accept() is blocking: waits for connection before returning dequeues the next connection on the queue for socket (sockid) 2.3.7. Exchanging data with stream socket int count = send(sockid, msg, msgLen, flags); msg: const void[], message to be transmitted msgLen: integer, length of message (in bytes) to transmit flags: integer, special options, usually just 0 count: # bytes transmitted (-1 if error) int count = recv(sockid, recvBuf, bufLen, flags); recvBuf: void[], stores received bytes bufLen: # bytes received flags: integer, special options, usually just 0 count: # bytes received (-1 if error) Calls are blocking returns only after data is sent / received 2.3.8. Exchanging data with datagram socket int count = sendto(sockid, msg, msgLen, flags, &amp;foreignAddr, addrlen); msg, msgLen, flags, count: same with send() foreignAddr: struct sockaddr, address of the destination addrLen: sizeof(foreignAddr) int count = recvfrom(sockid, recvBuf, bufLen, flags, &amp;clientAddr, addrlen); recvBuf, bufLen, flags, count: same with recv() clientAddr: struct sockaddr, address of the client addrLen: sizeof(clientAddr) Calls are blocking returns only after data is sent / received 2.4. Example - Echo A client communicates with an &quot;echo&quot; server The server simply echoes whatever it receives back to the client /* die_with_error.h */ void die_with_error(char*); /* die_with_error.c */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; void die_with_error(char* error) { int errsv = errno; fprintf(stderr, &quot;%s: %s&quot;, strerror(errsv), error); exit(EXIT_FAILURE); } 2.4.1. Echo using stream socket /* tcp_server.c */ #include &lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;unistd.h&gt; #include &quot;die_with_error.h&quot; #define MAXPENDING 1024 #define RCVBUFSIZE 4096 int main(void) { /* Create a TCP socket */ /* Create socket for incoming connections */ int serv_sock; if ((serv_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) { die_with_error(&quot;socket() failed&quot;); } /* Assign a port to socket */ int serv_port = 5100; struct sockaddr_in serv_addr; serv_addr.sin_family = AF_INET; /* Internet address family */ serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); /* Any incoming interface */ serv_addr.sin_port = htons(serv_port); /* Local port */ if (bind(serv_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) { die_with_error(&quot;bind() failed&quot;); } /* Set socket to listen */ /* Mark the socket so it will listen for incoming connections */ if (listen(serv_sock, MAXPENDING) &lt; 0) { die_with_error(&quot;listen() failed&quot;); } /* Repeatedly: */ /* Run forever */ for (;;) { /* Accept new connectionb */ /* Server is now blocked waiting for connection from a client */ int client_sock; struct sockaddr client_addr; int addr_len; addr_len = sizeof(client_addr); if ((client_sock = accept(serv_sock, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; 0) { die_with_error(&quot;accept() failed&quot;); } struct sockaddr_in *c_addr = (struct sockaddr_in *)&amp;client_addr; char c_ip_addr[INET6_ADDRSTRLEN]; inet_ntop(c_addr -&gt; sin_family, &amp;(c_addr -&gt; sin_addr), c_ip_addr, addr_len); int c_port = ntohs(c_addr -&gt; sin_port); printf(&quot;%s:%d =&gt;\\n&quot;, c_ip_addr, c_port); /* Receive mesage from client */ int recv_msg_size; char echo_buf[RCVBUFSIZE]; if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;first recv() failed&quot;); } /* Send received string and receive again until end of transmission */ while (recv_msg_size &gt; 0) { /* zero indicates end of transmission */ if (send(client_sock, echo_buf, recv_msg_size, 0) != recv_msg_size) { die_with_error(&quot;repeat send() failed&quot;); } printf(echo_buf); memset(echo_buf, &#39;\\0&#39;, RCVBUFSIZE); if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;recv() failed&quot;); } } /* Close the connection */ close(client_sock); printf(&quot;%s:%d &lt;=\\n&quot;, c_ip_addr, c_port); } } /* tcp_client.c */ #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &quot;die_with_error.h&quot; #define RCVBUFSIZE 4096 int main(void) { /* Create a TCP socket */ /* Create a reliable, stream socket using TCP */ int client_sock; if ((client_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) { die_with_error(&quot;socket() failed&quot;); } /* Establish connection */ char *serv_ip = &quot;127.0.0.1&quot;; int serv_port = 5100; struct sockaddr_in serv_addr; serv_addr.sin_family = AF_INET; /* Internet address family */ serv_addr.sin_addr.s_addr = inet_addr(serv_ip); /* Server IP address*/ serv_addr.sin_port = htons(serv_port); /* Server port */ if (connect(client_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) { die_with_error(&quot;connect() failed&quot;); } /* Communicate */ int read_len; char *read_buf = (char*)malloc(RCVBUFSIZE * sizeof(char)); int recv_msg_size; char echo_buf[RCVBUFSIZE]; for(;;) { read_buf = fgets(read_buf, sizeof(read_buf), stdin); if(read_buf == NULL) { exit(EXIT_SUCCESS); } read_len = strlen(read_buf); /* Determine input length *//* Send the string to the server */ if (send(client_sock, read_buf, read_len, 0) != read_len) { die_with_error(&quot;send() sent a different number of bytes than expected&quot;); } /* Receive mesage from server */ if ((recv_msg_size = recv(client_sock, echo_buf, RCVBUFSIZE, 0)) &lt; 0) { die_with_error(&quot;recv() failed&quot;); } fputs(echo_buf, stdout); memset(read_buf, &#39;\\0&#39;, RCVBUFSIZE); memset(echo_buf, &#39;\\0&#39;, RCVBUFSIZE); } /* Close the connection */ close(client_sock); } $ gcc die_with_error.h die_with_error.c tcp_server.c -o tcp_server $ ./tcp_server 127.0.0.1:45934 =&gt; Hello world! 127.0.0.1:45934 &lt;= ^C $ gcc die_with_error.h die_with_error.c tcp_client.c -o tcp_client $ echo &#39;Hello world!&#39; | ./tcp_client Hello world! 3. References https://www.csd.uoc.gr/~hy556/material.html","headline":"Sockets Programming in C using TCP/IP","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2021/10/20/sockets-programming-in-c-using-tcp-ip/"},"url":"https://blog.codefarm.me/2021/10/20/sockets-programming-in-c-using-tcp-ip/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Sockets Programming in C using TCP/IP</h1><p class="c-post-meta">20 Oct 2021</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#berkley-sockets">1. Berkley Sockets</a>
<ul class="sectlevel2">
<li><a href="#sockets">1.1. Sockets</a></li>
</ul>
</li>
<li><a href="#socket-programming">2. Socket Programming</a>
<ul class="sectlevel2">
<li><a href="#client-server-communication">2.1. Client-Server communication</a></li>
<li><a href="#sockets-procedures">2.2. Sockets - Procedures</a></li>
<li><a href="#client-server-communication-unix">2.3. Client - Server Communication - Unix</a></li>
<li><a href="#example-echo">2.4. Example - Echo</a></li>
</ul>
</li>
<li><a href="#references">3. References</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="berkley-sockets">1. Berkley Sockets</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Universally known as <strong>Sockets</strong></p>
</li>
<li>
<p>It is an abstraction through which an application may send and receive data</p>
</li>
<li>
<p>Provide generic accessto <em>interprocess communication</em> services</p>
<div class="ulist">
<ul>
<li>
<p>e.g. IPX/SPX, Appletalk, TCP/IP</p>
</li>
</ul>
</div>
</li>
<li>
<p>Standard API for networking</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="sockets">1.1. Sockets</h3>
<div class="ulist">
<ul>
<li>
<p>Uniquely identified by</p>
<div class="ulist">
<ul>
<li>
<p>an <code>internet address</code></p>
</li>
<li>
<p>an end-to-end <code>protocol</code> (e.g. TCP or UDP)</p>
</li>
<li>
<p>a <code>port number</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Two types of (TCP/IP) sockets</p>
<div class="ulist">
<ul>
<li>
<p><strong>Stream</strong> sockets (e.g. uses TCP)</p>
<div class="ulist">
<ul>
<li>
<p>provide reliable byte-stream service</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Datagram</strong> sockets (e.g. uses UDP)</p>
<div class="ulist">
<ul>
<li>
<p>provide best-effort datagram service</p>
</li>
<li>
<p>messages up to 65.500 bytes</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Socket extend the convectional UNIX I/O facilities</p>
<div class="ulist">
<ul>
<li>
<p>file descriptors for network communication</p>
</li>
<li>
<p>extended the read and write system calls</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="socket-programming">2. Socket Programming</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="client-server-communication">2.1. Client-Server communication</h3>
<div class="ulist">
<ul>
<li>
<p>Server</p>
<div class="ulist">
<ul>
<li>
<p>passively waits for and responds to clients</p>
</li>
<li>
<p><strong>passive</strong> socket</p>
</li>
</ul>
</div>
</li>
<li>
<p>Client</p>
<div class="ulist">
<ul>
<li>
<p>initiates the communication</p>
</li>
<li>
<p>must know the address and the port of the server</p>
</li>
<li>
<p><strong>active</strong> socket</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="sockets-procedures">2.2. Sockets - Procedures</h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Sockets - Procedures</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Primitive</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Socket</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create a new commnunication endpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bind</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attach a local address to a socket</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Listen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Announce willingness to accept connections</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Accept</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Block caller until a connection request arrives</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Actively attempt to establish a connection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send some date over the connection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Receive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Receive some date over the connection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shutdown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shut down part of a full-duplex connection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Close</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Release the connection</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="client-server-communication-unix">2.3. Client - Server Communication - Unix</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="man">SOCKET(2)                  Linux Programmer's Manual                 SOCKET(2)

NAME
       socket - create an endpoint for communication

SYNOPSIS
       #include &lt;sys/types.h&gt;          /* See NOTES */
       #include &lt;sys/socket.h&gt;

       int socket(int domain, int type, int protocol);

DESCRIPTION
       socket()  creates  an endpoint for communication and returns a file de‐
       scriptor that refers to that endpoint.  The file descriptor returned by
       a  successful call will be the lowest-numbered file descriptor not cur‐
       rently open for the process.</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Client - Server Communication - Unix</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top" colspan="3">Stream (e.g. TCP)</th>
<th class="tableblock halign-left valign-top" colspan="3">Datagram (e.g. UDP)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Server</strong></p></td>
<td class="tableblock halign-left valign-top" rowspan="4"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Client</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Server</strong></p></td>
<td class="tableblock halign-left valign-top" rowspan="5"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Client</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">socket()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">socket()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">socket()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">socket()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bind()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;bind()&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bind()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bind()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">listen()</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">accept()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>syn point</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">connect()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">recv()</p></td>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">send()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">recvfrom()</p></td>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sendto()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">send()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">recv()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sendto()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">recvfrom()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">close()</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">close()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">close()</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">close()</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="socket-creation-in-c-socket">2.3.1. Socket creation in C: <code>socket()</code></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int sockid = socket(family, type, protocol);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>sockid</code>: socket descriptor, an integer (like a file-handle)</p>
</li>
<li>
<p><code>family</code>: integer, communication domain, e.g.,</p>
<div class="ulist">
<ul>
<li>
<p>PF_INET, IPv4 protocols, Internet addresses (typically used)</p>
</li>
<li>
<p>PF_UNIX, Local communication, File addresses</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>type</code>: communication type</p>
<div class="ulist">
<ul>
<li>
<p>SOCK_STREAM - reliable, 2-way, connection-based service</p>
</li>
<li>
<p>SOCK_DGRAM - unreliable, connectionless, messages of maximum length</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>protocol</code>: specifies protocol</p>
<div class="ulist">
<ul>
<li>
<p>IPPROTO_TCP IPPROTO_UDP</p>
</li>
<li>
<p>usually set to 0 (i.e., use default protocol)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>upon failure returns -1</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Note:</strong> socket call does not specify where data will be coming from, nor where it will be going to – it just creates the interface!
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="socket-close-in-c-close">2.3.2. Socket close in C: <code>close()</code></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>When finished using a socket, the socket should be closed</p>
<div class="ulist">
<ul>
<li>
<p><code>status= close(sockid);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>sockid</code>: the file descriptor (socket being closed)</p>
</li>
<li>
<p><code>status</code>: 0 if successful, -1 if error</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Closing a socket</p>
<div class="ulist">
<ul>
<li>
<p>closes a connection (for stream socket)</p>
</li>
<li>
<p>frees up the port used by the socket</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="assign-address-to-socket-bind">2.3.3. Assign address to socket: <code>bind()</code></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="c1">          /* See NOTES */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
         <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>associates and reserves a port for use by the socket</p>
</li>
<li>
<p><code>int status = bind(sockid, &amp;addrport, size);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>sockid</code>: integer, socket descriptor</p>
</li>
<li>
<p><code>addrport</code>: struct sockaddr, the (IP) address and port of the machine</p>
<div class="ulist">
<ul>
<li>
<p>for TCP/IP server, internet address is usually set to INADDR_ANY, i.e., chooses any incoming interface</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>size</code>: the size (in bytes) of the addrport structure</p>
</li>
<li>
<p><code>status</code>: upon failure -1 is returned</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="specifying-addresses">2.3.3.1. Specifying Addresses</h5>
<div class="ulist">
<ul>
<li>
<p>Socket API defines a generic data type for addresses:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sa_family</span><span class="p">;</span> <span class="cm">/* Address family (e.g. AF_INET) */</span>
    <span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>         <span class="cm">/* Family-specific address information */</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Particular form of the <code>sockaddr</code> used for TCP/IP addresses:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_addr</span><span class="p">;</span>      <span class="cm">/* Internet address (32 bits) */</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sin_family</span><span class="p">;</span> <span class="cm">/* Internet protocol (AF_INET) */</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sin_port</span><span class="p">;</span>   <span class="cm">/* Address port (16 bits) */</span>
    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span>   <span class="cm">/* Internet address (32 bits) */</span>
    <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>          <span class="cm">/* Not used */</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong>Important:</strong> <code>sockaddr_in</code> can be casted to a <code>sockaddr</code>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="bind-example-with-tcp">2.3.3.2. <code>bind()</code> - Example with TCP</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">sockid</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addrport</span><span class="p">;</span>
<span class="n">sockid</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">addrport</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">addrport</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">5100</span><span class="p">);</span>
<span class="n">addrport</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sockid</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addrport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrport</span><span class="p">))</span><span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// …</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="skipping-the-bind">2.3.3.3. Skipping the <code>bind()</code></h5>
<div class="ulist">
<ul>
<li>
<p>bind can be skipped for both types of sockets</p>
<div class="ulist">
<ul>
<li>
<p>Datagram socket:</p>
<div class="ulist">
<ul>
<li>
<p>if only sending, no need to bind. The OS finds a port each timethe socket sends a packet</p>
</li>
<li>
<p>if receiving, need to bind</p>
</li>
</ul>
</div>
</li>
<li>
<p>Stream socket:</p>
<div class="ulist">
<ul>
<li>
<p>destination determined during connection setup</p>
</li>
<li>
<p>don&#8217;t need to know port sending from (during connection setup, receiving end is informed of port)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="assign-address-to-socket-listen">2.3.4. Assign address to socket: <code>listen()</code></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Instructs TCP protocol implementation to listen for connections</p>
</li>
<li>
<p><code>int status = listen(sockid, queueLimit);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>sockid</code>: integer, socket descriptor</p>
</li>
<li>
<p><code>queueLimit</code>: integer, # of active participants that can "wait" for a connection</p>
</li>
<li>
<p><code>status</code>: 0 if listening, -1 if error</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>listen()</code> is <strong>non-blocking</strong>: returns immediately</p>
</li>
<li>
<p>The listening socket (<code>sockid</code>)</p>
<div class="ulist">
<ul>
<li>
<p>is never used for sending and receiving</p>
</li>
<li>
<p>is used by the server only as a way to get new sockets</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="establish-connection-connect">2.3.5. Establish Connection: <code>connect()</code></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
            <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The client establishes a connection with the server by calling <code>connect()</code></p>
</li>
<li>
<p><code>int status = connect(sockid, &amp;foreignAddr, addrlen);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>sockid</code>: integer, socket to be used in connection</p>
</li>
<li>
<p><code>foreignAddr</code>: struct sockaddr: address of the passive participant</p>
</li>
<li>
<p><code>addrlen</code>: integer, sizeof(foreignAddr)</p>
</li>
<li>
<p><code>status</code>: 0 if successful connect, -1 otherwise</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>connect()</code> is <strong>blocking</strong></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="incoming-connection-accept">2.3.6. Incoming Connection: <code>accept()</code></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The server gets a socket for an incoming client connection by calling <code>accept()</code></p>
</li>
<li>
<p><code>int s = accept(sockid, &amp;clientAddr, &amp;addrLen);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>s</code>: integer, the new socket (used for <em>data-transfer</em>)</p>
</li>
<li>
<p><code>sockid</code>: integer, the orig. socket (being listened on)</p>
</li>
<li>
<p><code>clientAddr</code>: struct sockaddr, address of the active participant</p>
<div class="ulist">
<ul>
<li>
<p>filled in upon return</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>addrLen</code>: sizeof(clientAddr): value/result parameter</p>
<div class="ulist">
<ul>
<li>
<p>must be set appropriately before call</p>
</li>
<li>
<p>adjusted upon return</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>accept()</code></p>
<div class="ulist">
<ul>
<li>
<p>is <strong>blocking</strong>: waits for connection before returning</p>
</li>
<li>
<p>dequeues the next connection on the queue for socket (<code>sockid</code>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="exchanging-data-with-stream-socket">2.3.7. Exchanging data with stream socket</h4>
<div class="ulist">
<ul>
<li>
<p><code>int count = send(sockid, msg, msgLen, flags);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>msg</code>: const void[], message to be transmitted</p>
</li>
<li>
<p><code>msgLen</code>: integer, length of message (in bytes) to transmit</p>
</li>
<li>
<p><code>flags</code>: integer, special options, usually just 0</p>
</li>
<li>
<p><code>count</code>: # bytes transmitted (-1 if error)</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>int count = recv(sockid, recvBuf, bufLen, flags);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>recvBuf</code>: void[], stores received bytes</p>
</li>
<li>
<p><code>bufLen</code>: # bytes received</p>
</li>
<li>
<p><code>flags</code>: integer, special options, usually just 0</p>
</li>
<li>
<p><code>count</code>: # bytes received (-1 if error)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Calls are <strong>blocking</strong></p>
<div class="ulist">
<ul>
<li>
<p>returns only after data is sent / received</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="exchanging-data-with-datagram-socket">2.3.8. Exchanging data with datagram socket</h4>
<div class="ulist">
<ul>
<li>
<p><code>int count = sendto(sockid, msg, msgLen, flags, &amp;foreignAddr, addrlen);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>msg</code>, <code>msgLen</code>, <code>flags</code>, <code>count</code>: same with <code>send()</code></p>
</li>
<li>
<p><code>foreignAddr</code>: struct sockaddr, address of the destination</p>
</li>
<li>
<p><code>addrLen</code>: sizeof(foreignAddr)</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>int count = recvfrom(sockid, recvBuf, bufLen, flags, &amp;clientAddr, addrlen);</code></p>
<div class="ulist">
<ul>
<li>
<p><code>recvBuf</code>, <code>bufLen</code>, <code>flags</code>, <code>count</code>: same with <code>recv()</code></p>
</li>
<li>
<p><code>clientAddr</code>: struct sockaddr, address of the client</p>
</li>
<li>
<p><code>addrLen</code>: sizeof(clientAddr)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Calls are <strong>blocking</strong></p>
<div class="ulist">
<ul>
<li>
<p>returns only after data is sent / received</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="example-echo">2.4. Example - Echo</h3>
<div class="ulist">
<ul>
<li>
<p>A client communicates with an "echo" server</p>
</li>
<li>
<p>The server simply echoes whatever it receives back to the client</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* die_with_error.h */</span>

<span class="kt">void</span> <span class="nf">die_with_error</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* die_with_error.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">die_with_error</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">errsv</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errsv</span><span class="p">),</span> <span class="n">error</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="echo-using-stream-socket">2.4.1. Echo using stream socket</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* tcp_server.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"die_with_error.h"</span><span class="cp">
</span>
<span class="cp">#define MAXPENDING 1024
#define RCVBUFSIZE 4096
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Create a TCP socket */</span>
    <span class="cm">/* Create socket for incoming connections */</span>
    <span class="kt">int</span> <span class="n">serv_sock</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">serv_sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">die_with_error</span><span class="p">(</span><span class="s">"socket() failed"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Assign a port to socket */</span>
    <span class="kt">int</span> <span class="n">serv_port</span> <span class="o">=</span> <span class="mi">5100</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">;</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>                 <span class="cm">/* Internet address family */</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>  <span class="cm">/* Any incoming interface */</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">serv_port</span><span class="p">);</span>           <span class="cm">/* Local port */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">die_with_error</span><span class="p">(</span><span class="s">"bind() failed"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Set socket to listen */</span>
    <span class="cm">/* Mark the socket so it will listen for incoming connections */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="n">MAXPENDING</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">die_with_error</span><span class="p">(</span><span class="s">"listen() failed"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Repeatedly: */</span>
    <span class="cm">/* Run forever */</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* Accept new connectionb */</span>
        <span class="cm">/* Server is now blocked waiting for connection from a client */</span>
        <span class="kt">int</span> <span class="n">client_sock</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">client_addr</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">addr_len</span><span class="p">;</span>
        <span class="n">addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_addr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">client_sock</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_len</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">die_with_error</span><span class="p">(</span><span class="s">"accept() failed"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">c_addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_addr</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">c_ip_addr</span><span class="p">[</span><span class="n">INET6_ADDRSTRLEN</span><span class="p">];</span>
        <span class="n">inet_ntop</span><span class="p">(</span><span class="n">c_addr</span> <span class="o">-&gt;</span> <span class="n">sin_family</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">c_addr</span> <span class="o">-&gt;</span> <span class="n">sin_addr</span><span class="p">),</span> <span class="n">c_ip_addr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">c_port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">c_addr</span> <span class="o">-&gt;</span> <span class="n">sin_port</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s:%d =&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c_ip_addr</span><span class="p">,</span> <span class="n">c_port</span><span class="p">);</span>

        <span class="cm">/* Receive mesage from client */</span>
        <span class="kt">int</span> <span class="n">recv_msg_size</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">echo_buf</span><span class="p">[</span><span class="n">RCVBUFSIZE</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">recv_msg_size</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">echo_buf</span><span class="p">,</span> <span class="n">RCVBUFSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">die_with_error</span><span class="p">(</span><span class="s">"first recv() failed"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Send received string and receive again until end of transmission */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">recv_msg_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* zero indicates end of transmission */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">send</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">echo_buf</span><span class="p">,</span> <span class="n">recv_msg_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">recv_msg_size</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">die_with_error</span><span class="p">(</span><span class="s">"repeat send() failed"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">printf</span><span class="p">(</span><span class="n">echo_buf</span><span class="p">);</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">echo_buf</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="n">RCVBUFSIZE</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">recv_msg_size</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">echo_buf</span><span class="p">,</span> <span class="n">RCVBUFSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">die_with_error</span><span class="p">(</span><span class="s">"recv() failed"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Close the connection */</span>
        <span class="n">close</span><span class="p">(</span><span class="n">client_sock</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s:%d &lt;=</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c_ip_addr</span><span class="p">,</span> <span class="n">c_port</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* tcp_client.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"die_with_error.h"</span><span class="cp">
</span>
<span class="cp">#define RCVBUFSIZE 4096
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Create a TCP socket */</span>
    <span class="cm">/* Create a reliable, stream socket using TCP */</span>
    <span class="kt">int</span> <span class="n">client_sock</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">client_sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">die_with_error</span><span class="p">(</span><span class="s">"socket() failed"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Establish connection */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">serv_ip</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">serv_port</span> <span class="o">=</span> <span class="mi">5100</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">;</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>                     <span class="cm">/* Internet address family */</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">serv_ip</span><span class="p">);</span>     <span class="cm">/* Server IP address*/</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">serv_port</span><span class="p">);</span>              <span class="cm">/* Server port */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">die_with_error</span><span class="p">(</span><span class="s">"connect() failed"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Communicate */</span>
    <span class="kt">int</span> <span class="n">read_len</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">read_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">RCVBUFSIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">recv_msg_size</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">echo_buf</span><span class="p">[</span><span class="n">RCVBUFSIZE</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">read_buf</span> <span class="o">=</span> <span class="n">fgets</span><span class="p">(</span><span class="n">read_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_buf</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">read_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">read_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">read_buf</span><span class="p">);</span> <span class="cm">/* Determine input length *//* Send the string to the server */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">send</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">read_buf</span><span class="p">,</span> <span class="n">read_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">read_len</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">die_with_error</span><span class="p">(</span><span class="s">"send() sent a different number of bytes than expected"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Receive mesage from server */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">recv_msg_size</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">echo_buf</span><span class="p">,</span> <span class="n">RCVBUFSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">die_with_error</span><span class="p">(</span><span class="s">"recv() failed"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">fputs</span><span class="p">(</span><span class="n">echo_buf</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">read_buf</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="n">RCVBUFSIZE</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">echo_buf</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="n">RCVBUFSIZE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Close the connection */</span>
    <span class="n">close</span><span class="p">(</span><span class="n">client_sock</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>gcc die_with_error.h die_with_error.c tcp_server.c <span class="nt">-o</span> tcp_server
<span class="gp">$</span><span class="w"> </span>./tcp_server
<span class="gp">127.0.0.1:45934 =&gt;</span><span class="w">
</span><span class="go">Hello world!
127.0.0.1:45934 &lt;=
^C</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>gcc die_with_error.h die_with_error.c tcp_client.c <span class="nt">-o</span> tcp_client
<span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'Hello world!'</span> | ./tcp_client
<span class="go">Hello world!</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">3. References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://www.csd.uoc.gr/~hy556/material.html" class="bare">https://www.csd.uoc.gr/~hy556/material.html</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
