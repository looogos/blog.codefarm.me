<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Python &amp; WSGI Applications | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Python &amp; WSGI Applications" />
<meta property="og:locale" content="en" />
<meta name="description" content="Installing uWSGI with Python support When you start learning uWSGI, try to build from offical sources: using distribution-supplied packages may brings you plenty of headaches. When things are clear, you can use modular builds (like the ones available in your distribution). uWSGI is a (big) C application, so you need a C compiler (like gcc or clang) and the Python development headers. On a Debian-based distro an apt-get install build-essential python-dev will be enough. You have various ways to install uWSGI for Python: via pip pip install uwsgi using the network installer curl http://uwsgi.it/install | bash -s default /tmp/uwsgi (this will install the uWSGI binary into /tmp/uwsgi, feel free to change it). via downloading a source tarball and “making” it wget http://projects.unbit.it/downloads/uwsgi-latest.tar.gz tar zxvf uwsgi-latest.tar.gz cd &lt;dir&gt; make (after the build you will have a uwsgi binary in the current directory). One thing you may want to take into account with distro-supplied packages, is that very probably your distribution has built uWSGI in modular way (every feature is a different plugin that must be loaded). To complete it, you have to prepend --plugin python,http to the first series of examples, and --plugin python when the HTTP router is removed. The first WSGI application Let’s start with a simple “Hello World” example: def application(env, start_response): start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)]) return [b&quot;Hello World&quot;] (save it as foobar.py) As you can see, it composed of a single Python function. It is called “application” as this is default function that the uWSGI Python loader will search for (but you can obviously customize it). Deploy it on HTTP port 9090 Now start uWSGI to run an HTTP server/router passing requests to your WSGI application: uwsgi --http :9090 --wsgi-file foobar.py That’s all. Do not use --http when you have a frontend webserver or you are doning some form of benchmark, use --http-socket. Add concurrency and monitoring The first tuning you would like to make is adding concurrency (by deafult uWSGI starts with a single process and a single thread). You can add more processes with the --processes option or more threads with the --threads option (or you can have both). uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2 This will spawn 4 processes (each with 2 threads), a master process (will respawn your processes when they die) and the HTTP router. One important task is monitoring. Understanding what is goning on is vital in production deployment. The status subsystem allows you to export uWSGI’s internal statistics as JSON: uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 Make some request to your app and then telnet to the port 9191, you’ll get lots of fun information. You may want to use “uwsgitop” (just pip install it), which is a top-like tool for monitoring instances. Putting behind a full webserver Even though uWSGI HTTP router is solid and high-perfomance, you may want to put your applicaiton behind a fully-capable webserver. uWSGI natively speaks HTTP, FastCGI, SCGI and its specific protocol named “uwsgi” (yes, wrong naming choice). The best performing protocol is obviously uwsgi, alread supported by nginx and Cherokee (while various Apache modules are available). A common nginx config is the following: location / { include uwsgi_params; uwsgi_pass 127.0.0.1:3031; } This means “pass every request to the server bound to port 3031 speaking the uwsgi protocol”. Now we can spawn uWSGI to natively speak the uwsgi protocol: uwsgi --socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 If you’ll run ps aux, you will see one process less. The HTTP router has been removed as our “workers” (the processes assigned to uWSGI) natively speak the uwsgi protocol. If your proxy/webserver/router speaks HTTP, you have to tell uWSGI to natively speak the http protocol (this is different from -–http that will spawn a proxy by itself): uwsgi --http-socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 Automatically starting uWSGI on boot If you are thinking about firing up vi and writing an init.d script for spawning uWSGI, just sit (and calm) down and make sure your system doesn’t offer a better (more modern) approach first. Each distribution has chose a startup system (Upstart, Systemd…) and there are tons of process manangers available (supervisord, god, monit, circus…). uWSGI will integrate very well with all of them (we hope), but if you plan to deploy a big number of apps check the uWSGI Emperor - it it more or less the dream of every devops engineer. Deploying Django Django is very probably the most used Python web framework around. Deploying it is pretty easy. We suppose the Django project is in /home/foobar/myproject: uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --wsgi-file myproject/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 (with --chdir we move to a specific directory). In Django this is required to correctly load modules. Argh! What the hell is this?! Yes, you’re right, you’re right…dealing with such long command lines is unpractical, foolish and error-prone. Never fear! uWSGI supports various configuration styles. Here we will use .ini files. [uwsgi] socket = 127.0.0.1:3031 chdir = /home/foobar/myproject/ wsgi-file = myproject/wsgi.py processes = 4 threads = 2 stats = 127.0.0.1:9191 A lot better! Just run it: uwsgi yourfile.ini If the file /home/foobar/myproject/myproject/wsgi.py (or whatever you have called your project) does not exist, you are very probably using an old (&lt;1.4) version of Django. In such a case you need a little bit more configuration: uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --pythonpath .. --env DJANGO_SETTINGS_MODULE=myproject.settings --module &quot;django.core.handlers.wsgi:WSGIHandler()&quot; --processes 4 --threads 2 --stats 127.0.0.1:9191 Or, using the .ini file: [uwsgi] socket = 127.0.0.1:3031 chdir = /home/foobar/myproject/ pythonpath = .. env = DJANGO_SETTINGS_MODULE=myproject.settings module = django.core.handlers.wsgi:WSGIHandler() processes = 4 threads = 2 stats = 127.0.0.1:9191 Older (&lt;1.4) Django releases need to set env, module and the pythonpath (... allow us to reach the myproject.settings module). A note on Python threads If you start uWSGI without threads, the Python GIL will not be eanbled, so threads generated by your application will never run. You may not like that choice, but remember that uWSGI is a language-independent server, so most of its choices are for maintaining it “agnostic”. But do not worry, there are basically no choices made by the uWSGI developers that cannot be changed with an option. If you want to maintain Python threads support without starting multiple threads for your application, just add the --enable-threads option (or `enable-threads = true in init style). Virtualenvs uWSGI can be configured to search for Python modules in a specific virtuaenv. Just add virtualenv = &lt;path&gt; to your options. Python Auto-reloading (DEVELOPMENT ONLY!) In production you can monitor file/directory changes for triggering reloads (touch-reload, fs-reload…). During development having a monitor for all of the loaded/used python modules can be handy. But please use it only during development. This check is done by a thread that scans the modules list with the specified frequency: [uwsgi] ... py-autoreload = 2 will check for ptyhon modules changes every 2 seconds and eventually restart the instance. And again: Use this only in development. Security and availability Always avoid running your uWSGI instances as root. You can drop privileges using uid and gid options: [uwsgi] https = :9090,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 If you need to bind to privileged ports (like 443 for HTTPS), use shared sockets. They are created before dropping privileges and can be referenced with the =N syntax, where N is the socket number (starting from 0): [uwsgi] shared-socket = :443 https = =0,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 A common problem with webapp deployment is “stuck request”. All of your threads/workers are stuck (blocked on request) and your app cannot accept more requests. To avoid that problem you can set a karakiri timer. It is a monitor (managed by the master process) that destroy processes stuck for more than the specified number of seconds (choose karakiri value carefully). For example, you may want to destroy workers blocked for more than 30 seconds: [uwsgi] shared-socket = :443 https = =0,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 harakiri = 30 In addition to this, since uWSGI 1.9, the stats server exports the whole set of request variables, so you can see (in realtime) what your instance is doing (for each worker, thread or async core). Managing the uWSGI server INI files .INI files are a standard de-facto cofiguration format used by many applications. It consists of [section]s and key=value pairs. An example uWSGI INI configuration: [uwsgi] socket = /tmp/uwsgi.sock socket = 127.0.0.1:3031 master = true workers = 3 By default, uWSGI uses the [uwsgi] section, but you can specify another section name while loading the INI file with the syntax filename:section, that is: uwsgi --ini myconf.ini:app1 Alternatively, you can load another section from the same file by ommitting the filename and specifying just the section name. Note that technically, this loads the named section from the last.ini file loaded instead of the current one, so be careful when including other files. [uwsgi] # This will load the app1 section below ini = :app1 # This will load the defaults.ini file ini = defaults.ini # This will load the app2 section from the defaults.ini file! ini = :app2 [app1] plugin = rack [app2] plugin = php Whitespace is insignificant within lines. Lines starting with a semicolon (;) or a hash/octothorpe (#) are ignored as comments. Boolean values may be set without the value part. Simply master is thus equivalent to master=true. This may not be compatible with other INI parsers such as paste.deploy. For convenience, uWSGI recognizes bare .ini arguments specially, so the invocation uwsgi myconf.ini is equal to uwsgi --ini myconf.ini. Reloading the server When running with the master process mode, the uWSGI server can be gracefully restarted without closing the main sockets. This funcitonality allows you patch/upgrade the uWSGI server without closing the connection with the web server and losing a single request. When you send the SIGHUP to the master process it will try to gracefully stop all the workers, waiting for the completion of any currently running requests. Then it closes all the eventually opened file descriptors not related to uWSGI. Lastly, it binary patches (using execve()) the uWSGI process image with a new one, inheriting all of the previous file descriptors. The server will known that it is a reloaded instance and will skip all the sockets initialization, reusing the previous ones. Sending the SIGTERM signal will obtain the same result reload-wise but will not wait for the completion of running requests. There are several ways to make uWSGI gracefully restart. There are several ways to make uWSGI gracefully restart. # using kill to send the signal kill -HUP `cat /tmp/project-master.pid` # or the convenience option --reload uwsgi --reload /tmp/project-master.pid # or if uwsgi was started with touch-reload=/tmp/somefile touch /tmp/somefile Or from your application, in Python: uwsgi.reload() Or in Ruby, UWSGI.reload Stoping the server If you have the uWSGI process running in the foreground for some reason, you can just hit CTRL+C to kill it off. When dealing with background processes, you’ll need to use the master pidfile again. The SIGINT singal will kill uWSGI. kill -INT `cat /tmp/project-master.pid` # or for convenience... uwsgi --stop /tmp/project-master.pid References Quickstart for Python/WSGI applications — uWSGI 2.0 documentation Managing the uWSGI server — uWSGI 2.0 documentation Configuring uWSGI — uWSGI 2.0 documentatio uWSGI Options — uWSGI 2.0 documentatio" />
<meta property="og:description" content="Installing uWSGI with Python support When you start learning uWSGI, try to build from offical sources: using distribution-supplied packages may brings you plenty of headaches. When things are clear, you can use modular builds (like the ones available in your distribution). uWSGI is a (big) C application, so you need a C compiler (like gcc or clang) and the Python development headers. On a Debian-based distro an apt-get install build-essential python-dev will be enough. You have various ways to install uWSGI for Python: via pip pip install uwsgi using the network installer curl http://uwsgi.it/install | bash -s default /tmp/uwsgi (this will install the uWSGI binary into /tmp/uwsgi, feel free to change it). via downloading a source tarball and “making” it wget http://projects.unbit.it/downloads/uwsgi-latest.tar.gz tar zxvf uwsgi-latest.tar.gz cd &lt;dir&gt; make (after the build you will have a uwsgi binary in the current directory). One thing you may want to take into account with distro-supplied packages, is that very probably your distribution has built uWSGI in modular way (every feature is a different plugin that must be loaded). To complete it, you have to prepend --plugin python,http to the first series of examples, and --plugin python when the HTTP router is removed. The first WSGI application Let’s start with a simple “Hello World” example: def application(env, start_response): start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)]) return [b&quot;Hello World&quot;] (save it as foobar.py) As you can see, it composed of a single Python function. It is called “application” as this is default function that the uWSGI Python loader will search for (but you can obviously customize it). Deploy it on HTTP port 9090 Now start uWSGI to run an HTTP server/router passing requests to your WSGI application: uwsgi --http :9090 --wsgi-file foobar.py That’s all. Do not use --http when you have a frontend webserver or you are doning some form of benchmark, use --http-socket. Add concurrency and monitoring The first tuning you would like to make is adding concurrency (by deafult uWSGI starts with a single process and a single thread). You can add more processes with the --processes option or more threads with the --threads option (or you can have both). uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2 This will spawn 4 processes (each with 2 threads), a master process (will respawn your processes when they die) and the HTTP router. One important task is monitoring. Understanding what is goning on is vital in production deployment. The status subsystem allows you to export uWSGI’s internal statistics as JSON: uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 Make some request to your app and then telnet to the port 9191, you’ll get lots of fun information. You may want to use “uwsgitop” (just pip install it), which is a top-like tool for monitoring instances. Putting behind a full webserver Even though uWSGI HTTP router is solid and high-perfomance, you may want to put your applicaiton behind a fully-capable webserver. uWSGI natively speaks HTTP, FastCGI, SCGI and its specific protocol named “uwsgi” (yes, wrong naming choice). The best performing protocol is obviously uwsgi, alread supported by nginx and Cherokee (while various Apache modules are available). A common nginx config is the following: location / { include uwsgi_params; uwsgi_pass 127.0.0.1:3031; } This means “pass every request to the server bound to port 3031 speaking the uwsgi protocol”. Now we can spawn uWSGI to natively speak the uwsgi protocol: uwsgi --socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 If you’ll run ps aux, you will see one process less. The HTTP router has been removed as our “workers” (the processes assigned to uWSGI) natively speak the uwsgi protocol. If your proxy/webserver/router speaks HTTP, you have to tell uWSGI to natively speak the http protocol (this is different from -–http that will spawn a proxy by itself): uwsgi --http-socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 Automatically starting uWSGI on boot If you are thinking about firing up vi and writing an init.d script for spawning uWSGI, just sit (and calm) down and make sure your system doesn’t offer a better (more modern) approach first. Each distribution has chose a startup system (Upstart, Systemd…) and there are tons of process manangers available (supervisord, god, monit, circus…). uWSGI will integrate very well with all of them (we hope), but if you plan to deploy a big number of apps check the uWSGI Emperor - it it more or less the dream of every devops engineer. Deploying Django Django is very probably the most used Python web framework around. Deploying it is pretty easy. We suppose the Django project is in /home/foobar/myproject: uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --wsgi-file myproject/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 (with --chdir we move to a specific directory). In Django this is required to correctly load modules. Argh! What the hell is this?! Yes, you’re right, you’re right…dealing with such long command lines is unpractical, foolish and error-prone. Never fear! uWSGI supports various configuration styles. Here we will use .ini files. [uwsgi] socket = 127.0.0.1:3031 chdir = /home/foobar/myproject/ wsgi-file = myproject/wsgi.py processes = 4 threads = 2 stats = 127.0.0.1:9191 A lot better! Just run it: uwsgi yourfile.ini If the file /home/foobar/myproject/myproject/wsgi.py (or whatever you have called your project) does not exist, you are very probably using an old (&lt;1.4) version of Django. In such a case you need a little bit more configuration: uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --pythonpath .. --env DJANGO_SETTINGS_MODULE=myproject.settings --module &quot;django.core.handlers.wsgi:WSGIHandler()&quot; --processes 4 --threads 2 --stats 127.0.0.1:9191 Or, using the .ini file: [uwsgi] socket = 127.0.0.1:3031 chdir = /home/foobar/myproject/ pythonpath = .. env = DJANGO_SETTINGS_MODULE=myproject.settings module = django.core.handlers.wsgi:WSGIHandler() processes = 4 threads = 2 stats = 127.0.0.1:9191 Older (&lt;1.4) Django releases need to set env, module and the pythonpath (... allow us to reach the myproject.settings module). A note on Python threads If you start uWSGI without threads, the Python GIL will not be eanbled, so threads generated by your application will never run. You may not like that choice, but remember that uWSGI is a language-independent server, so most of its choices are for maintaining it “agnostic”. But do not worry, there are basically no choices made by the uWSGI developers that cannot be changed with an option. If you want to maintain Python threads support without starting multiple threads for your application, just add the --enable-threads option (or `enable-threads = true in init style). Virtualenvs uWSGI can be configured to search for Python modules in a specific virtuaenv. Just add virtualenv = &lt;path&gt; to your options. Python Auto-reloading (DEVELOPMENT ONLY!) In production you can monitor file/directory changes for triggering reloads (touch-reload, fs-reload…). During development having a monitor for all of the loaded/used python modules can be handy. But please use it only during development. This check is done by a thread that scans the modules list with the specified frequency: [uwsgi] ... py-autoreload = 2 will check for ptyhon modules changes every 2 seconds and eventually restart the instance. And again: Use this only in development. Security and availability Always avoid running your uWSGI instances as root. You can drop privileges using uid and gid options: [uwsgi] https = :9090,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 If you need to bind to privileged ports (like 443 for HTTPS), use shared sockets. They are created before dropping privileges and can be referenced with the =N syntax, where N is the socket number (starting from 0): [uwsgi] shared-socket = :443 https = =0,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 A common problem with webapp deployment is “stuck request”. All of your threads/workers are stuck (blocked on request) and your app cannot accept more requests. To avoid that problem you can set a karakiri timer. It is a monitor (managed by the master process) that destroy processes stuck for more than the specified number of seconds (choose karakiri value carefully). For example, you may want to destroy workers blocked for more than 30 seconds: [uwsgi] shared-socket = :443 https = =0,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 harakiri = 30 In addition to this, since uWSGI 1.9, the stats server exports the whole set of request variables, so you can see (in realtime) what your instance is doing (for each worker, thread or async core). Managing the uWSGI server INI files .INI files are a standard de-facto cofiguration format used by many applications. It consists of [section]s and key=value pairs. An example uWSGI INI configuration: [uwsgi] socket = /tmp/uwsgi.sock socket = 127.0.0.1:3031 master = true workers = 3 By default, uWSGI uses the [uwsgi] section, but you can specify another section name while loading the INI file with the syntax filename:section, that is: uwsgi --ini myconf.ini:app1 Alternatively, you can load another section from the same file by ommitting the filename and specifying just the section name. Note that technically, this loads the named section from the last.ini file loaded instead of the current one, so be careful when including other files. [uwsgi] # This will load the app1 section below ini = :app1 # This will load the defaults.ini file ini = defaults.ini # This will load the app2 section from the defaults.ini file! ini = :app2 [app1] plugin = rack [app2] plugin = php Whitespace is insignificant within lines. Lines starting with a semicolon (;) or a hash/octothorpe (#) are ignored as comments. Boolean values may be set without the value part. Simply master is thus equivalent to master=true. This may not be compatible with other INI parsers such as paste.deploy. For convenience, uWSGI recognizes bare .ini arguments specially, so the invocation uwsgi myconf.ini is equal to uwsgi --ini myconf.ini. Reloading the server When running with the master process mode, the uWSGI server can be gracefully restarted without closing the main sockets. This funcitonality allows you patch/upgrade the uWSGI server without closing the connection with the web server and losing a single request. When you send the SIGHUP to the master process it will try to gracefully stop all the workers, waiting for the completion of any currently running requests. Then it closes all the eventually opened file descriptors not related to uWSGI. Lastly, it binary patches (using execve()) the uWSGI process image with a new one, inheriting all of the previous file descriptors. The server will known that it is a reloaded instance and will skip all the sockets initialization, reusing the previous ones. Sending the SIGTERM signal will obtain the same result reload-wise but will not wait for the completion of running requests. There are several ways to make uWSGI gracefully restart. There are several ways to make uWSGI gracefully restart. # using kill to send the signal kill -HUP `cat /tmp/project-master.pid` # or the convenience option --reload uwsgi --reload /tmp/project-master.pid # or if uwsgi was started with touch-reload=/tmp/somefile touch /tmp/somefile Or from your application, in Python: uwsgi.reload() Or in Ruby, UWSGI.reload Stoping the server If you have the uWSGI process running in the foreground for some reason, you can just hit CTRL+C to kill it off. When dealing with background processes, you’ll need to use the master pidfile again. The SIGINT singal will kill uWSGI. kill -INT `cat /tmp/project-master.pid` # or for convenience... uwsgi --stop /tmp/project-master.pid References Quickstart for Python/WSGI applications — uWSGI 2.0 documentation Managing the uWSGI server — uWSGI 2.0 documentation Configuring uWSGI — uWSGI 2.0 documentatio uWSGI Options — uWSGI 2.0 documentatio" />
<link rel="canonical" href="https://blog.codefarm.me/2016/05/13/python-and-wsgi-applications/" />
<meta property="og:url" content="https://blog.codefarm.me/2016/05/13/python-and-wsgi-applications/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-13T14:51:33+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python &amp; WSGI Applications" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-05-13T14:51:33+08:00","datePublished":"2016-05-13T14:51:33+08:00","description":"Installing uWSGI with Python support When you start learning uWSGI, try to build from offical sources: using distribution-supplied packages may brings you plenty of headaches. When things are clear, you can use modular builds (like the ones available in your distribution). uWSGI is a (big) C application, so you need a C compiler (like gcc or clang) and the Python development headers. On a Debian-based distro an apt-get install build-essential python-dev will be enough. You have various ways to install uWSGI for Python: via pip pip install uwsgi using the network installer curl http://uwsgi.it/install | bash -s default /tmp/uwsgi (this will install the uWSGI binary into /tmp/uwsgi, feel free to change it). via downloading a source tarball and “making” it wget http://projects.unbit.it/downloads/uwsgi-latest.tar.gz tar zxvf uwsgi-latest.tar.gz cd &lt;dir&gt; make (after the build you will have a uwsgi binary in the current directory). One thing you may want to take into account with distro-supplied packages, is that very probably your distribution has built uWSGI in modular way (every feature is a different plugin that must be loaded). To complete it, you have to prepend --plugin python,http to the first series of examples, and --plugin python when the HTTP router is removed. The first WSGI application Let’s start with a simple “Hello World” example: def application(env, start_response): start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)]) return [b&quot;Hello World&quot;] (save it as foobar.py) As you can see, it composed of a single Python function. It is called “application” as this is default function that the uWSGI Python loader will search for (but you can obviously customize it). Deploy it on HTTP port 9090 Now start uWSGI to run an HTTP server/router passing requests to your WSGI application: uwsgi --http :9090 --wsgi-file foobar.py That’s all. Do not use --http when you have a frontend webserver or you are doning some form of benchmark, use --http-socket. Add concurrency and monitoring The first tuning you would like to make is adding concurrency (by deafult uWSGI starts with a single process and a single thread). You can add more processes with the --processes option or more threads with the --threads option (or you can have both). uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2 This will spawn 4 processes (each with 2 threads), a master process (will respawn your processes when they die) and the HTTP router. One important task is monitoring. Understanding what is goning on is vital in production deployment. The status subsystem allows you to export uWSGI’s internal statistics as JSON: uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 Make some request to your app and then telnet to the port 9191, you’ll get lots of fun information. You may want to use “uwsgitop” (just pip install it), which is a top-like tool for monitoring instances. Putting behind a full webserver Even though uWSGI HTTP router is solid and high-perfomance, you may want to put your applicaiton behind a fully-capable webserver. uWSGI natively speaks HTTP, FastCGI, SCGI and its specific protocol named “uwsgi” (yes, wrong naming choice). The best performing protocol is obviously uwsgi, alread supported by nginx and Cherokee (while various Apache modules are available). A common nginx config is the following: location / { include uwsgi_params; uwsgi_pass 127.0.0.1:3031; } This means “pass every request to the server bound to port 3031 speaking the uwsgi protocol”. Now we can spawn uWSGI to natively speak the uwsgi protocol: uwsgi --socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 If you’ll run ps aux, you will see one process less. The HTTP router has been removed as our “workers” (the processes assigned to uWSGI) natively speak the uwsgi protocol. If your proxy/webserver/router speaks HTTP, you have to tell uWSGI to natively speak the http protocol (this is different from -–http that will spawn a proxy by itself): uwsgi --http-socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 Automatically starting uWSGI on boot If you are thinking about firing up vi and writing an init.d script for spawning uWSGI, just sit (and calm) down and make sure your system doesn’t offer a better (more modern) approach first. Each distribution has chose a startup system (Upstart, Systemd…) and there are tons of process manangers available (supervisord, god, monit, circus…). uWSGI will integrate very well with all of them (we hope), but if you plan to deploy a big number of apps check the uWSGI Emperor - it it more or less the dream of every devops engineer. Deploying Django Django is very probably the most used Python web framework around. Deploying it is pretty easy. We suppose the Django project is in /home/foobar/myproject: uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --wsgi-file myproject/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 (with --chdir we move to a specific directory). In Django this is required to correctly load modules. Argh! What the hell is this?! Yes, you’re right, you’re right…dealing with such long command lines is unpractical, foolish and error-prone. Never fear! uWSGI supports various configuration styles. Here we will use .ini files. [uwsgi] socket = 127.0.0.1:3031 chdir = /home/foobar/myproject/ wsgi-file = myproject/wsgi.py processes = 4 threads = 2 stats = 127.0.0.1:9191 A lot better! Just run it: uwsgi yourfile.ini If the file /home/foobar/myproject/myproject/wsgi.py (or whatever you have called your project) does not exist, you are very probably using an old (&lt;1.4) version of Django. In such a case you need a little bit more configuration: uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --pythonpath .. --env DJANGO_SETTINGS_MODULE=myproject.settings --module &quot;django.core.handlers.wsgi:WSGIHandler()&quot; --processes 4 --threads 2 --stats 127.0.0.1:9191 Or, using the .ini file: [uwsgi] socket = 127.0.0.1:3031 chdir = /home/foobar/myproject/ pythonpath = .. env = DJANGO_SETTINGS_MODULE=myproject.settings module = django.core.handlers.wsgi:WSGIHandler() processes = 4 threads = 2 stats = 127.0.0.1:9191 Older (&lt;1.4) Django releases need to set env, module and the pythonpath (... allow us to reach the myproject.settings module). A note on Python threads If you start uWSGI without threads, the Python GIL will not be eanbled, so threads generated by your application will never run. You may not like that choice, but remember that uWSGI is a language-independent server, so most of its choices are for maintaining it “agnostic”. But do not worry, there are basically no choices made by the uWSGI developers that cannot be changed with an option. If you want to maintain Python threads support without starting multiple threads for your application, just add the --enable-threads option (or `enable-threads = true in init style). Virtualenvs uWSGI can be configured to search for Python modules in a specific virtuaenv. Just add virtualenv = &lt;path&gt; to your options. Python Auto-reloading (DEVELOPMENT ONLY!) In production you can monitor file/directory changes for triggering reloads (touch-reload, fs-reload…). During development having a monitor for all of the loaded/used python modules can be handy. But please use it only during development. This check is done by a thread that scans the modules list with the specified frequency: [uwsgi] ... py-autoreload = 2 will check for ptyhon modules changes every 2 seconds and eventually restart the instance. And again: Use this only in development. Security and availability Always avoid running your uWSGI instances as root. You can drop privileges using uid and gid options: [uwsgi] https = :9090,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 If you need to bind to privileged ports (like 443 for HTTPS), use shared sockets. They are created before dropping privileges and can be referenced with the =N syntax, where N is the socket number (starting from 0): [uwsgi] shared-socket = :443 https = =0,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 A common problem with webapp deployment is “stuck request”. All of your threads/workers are stuck (blocked on request) and your app cannot accept more requests. To avoid that problem you can set a karakiri timer. It is a monitor (managed by the master process) that destroy processes stuck for more than the specified number of seconds (choose karakiri value carefully). For example, you may want to destroy workers blocked for more than 30 seconds: [uwsgi] shared-socket = :443 https = =0,foobar.crt,foobar.key uid = foo gid = bar chdir = path_to_web2py module = wsgihandler master = true processes = 8 harakiri = 30 In addition to this, since uWSGI 1.9, the stats server exports the whole set of request variables, so you can see (in realtime) what your instance is doing (for each worker, thread or async core). Managing the uWSGI server INI files .INI files are a standard de-facto cofiguration format used by many applications. It consists of [section]s and key=value pairs. An example uWSGI INI configuration: [uwsgi] socket = /tmp/uwsgi.sock socket = 127.0.0.1:3031 master = true workers = 3 By default, uWSGI uses the [uwsgi] section, but you can specify another section name while loading the INI file with the syntax filename:section, that is: uwsgi --ini myconf.ini:app1 Alternatively, you can load another section from the same file by ommitting the filename and specifying just the section name. Note that technically, this loads the named section from the last.ini file loaded instead of the current one, so be careful when including other files. [uwsgi] # This will load the app1 section below ini = :app1 # This will load the defaults.ini file ini = defaults.ini # This will load the app2 section from the defaults.ini file! ini = :app2 [app1] plugin = rack [app2] plugin = php Whitespace is insignificant within lines. Lines starting with a semicolon (;) or a hash/octothorpe (#) are ignored as comments. Boolean values may be set without the value part. Simply master is thus equivalent to master=true. This may not be compatible with other INI parsers such as paste.deploy. For convenience, uWSGI recognizes bare .ini arguments specially, so the invocation uwsgi myconf.ini is equal to uwsgi --ini myconf.ini. Reloading the server When running with the master process mode, the uWSGI server can be gracefully restarted without closing the main sockets. This funcitonality allows you patch/upgrade the uWSGI server without closing the connection with the web server and losing a single request. When you send the SIGHUP to the master process it will try to gracefully stop all the workers, waiting for the completion of any currently running requests. Then it closes all the eventually opened file descriptors not related to uWSGI. Lastly, it binary patches (using execve()) the uWSGI process image with a new one, inheriting all of the previous file descriptors. The server will known that it is a reloaded instance and will skip all the sockets initialization, reusing the previous ones. Sending the SIGTERM signal will obtain the same result reload-wise but will not wait for the completion of running requests. There are several ways to make uWSGI gracefully restart. There are several ways to make uWSGI gracefully restart. # using kill to send the signal kill -HUP `cat /tmp/project-master.pid` # or the convenience option --reload uwsgi --reload /tmp/project-master.pid # or if uwsgi was started with touch-reload=/tmp/somefile touch /tmp/somefile Or from your application, in Python: uwsgi.reload() Or in Ruby, UWSGI.reload Stoping the server If you have the uWSGI process running in the foreground for some reason, you can just hit CTRL+C to kill it off. When dealing with background processes, you’ll need to use the master pidfile again. The SIGINT singal will kill uWSGI. kill -INT `cat /tmp/project-master.pid` # or for convenience... uwsgi --stop /tmp/project-master.pid References Quickstart for Python/WSGI applications — uWSGI 2.0 documentation Managing the uWSGI server — uWSGI 2.0 documentation Configuring uWSGI — uWSGI 2.0 documentatio uWSGI Options — uWSGI 2.0 documentatio","headline":"Python &amp; WSGI Applications","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2016/05/13/python-and-wsgi-applications/"},"url":"https://blog.codefarm.me/2016/05/13/python-and-wsgi-applications/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Python &amp; WSGI Applications</h1><p class="c-post-meta">13 May 2016</p>
  </header>

  <div class="c-post-content">
    <h2 id="installing-uwsgi-with-python-support">Installing uWSGI with Python support</h2>

<p><em>When you start learning uWSGI, try to build from offical sources: using distribution-supplied packages may brings you plenty of headaches. When things are clear, you can use modular builds (like the ones available in your distribution).</em></p>

<p>uWSGI is a (big) C application, so you need a C compiler (like gcc or clang) and the Python development headers.</p>

<p>On a Debian-based distro an</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install build-essential python-dev
</code></pre></div></div>

<p>will be enough.</p>

<p>You have various ways to install uWSGI for Python:</p>

<ul>
  <li>
    <p>via pip</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  pip install uwsgi
</code></pre></div>    </div>
  </li>
  <li>
    <p>using the network installer</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  curl http://uwsgi.it/install | bash -s default /tmp/uwsgi
</code></pre></div>    </div>

    <p>(this will install the uWSGI binary into <code class="language-plaintext highlighter-rouge">/tmp/uwsgi</code>, feel free to change it).</p>
  </li>
  <li>
    <p>via downloading a source tarball and “making” it</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  wget http://projects.unbit.it/downloads/uwsgi-latest.tar.gz
  tar zxvf uwsgi-latest.tar.gz
  cd &lt;dir&gt;
  make
</code></pre></div>    </div>

    <p>(after the build you will have a uwsgi binary in the current directory).</p>
  </li>
</ul>

<p>One thing you may want to take into account with distro-supplied packages, is that very probably your distribution has built uWSGI in modular way (every feature is a different plugin that must be loaded). To complete it, you have to prepend <code class="language-plaintext highlighter-rouge">--plugin python,http</code> to the first series of examples, and <code class="language-plaintext highlighter-rouge">--plugin python</code> when the HTTP router is removed.</p>

<h2 id="the-first-wsgi-application">The first WSGI application</h2>

<p>Let’s start with a simple “Hello World” example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def application(env, start_response):
    start_response('200 OK', [('Content-Type','text/html')])
    return [b"Hello World"]
</code></pre></div></div>

<p>(save it as <code class="language-plaintext highlighter-rouge">foobar.py</code>)</p>

<p>As you can see, it composed of a single Python function. It is called “application” as this is default function that the uWSGI Python loader will search for (but you can obviously customize it).</p>

<h3 id="deploy-it-on-http-port-9090">Deploy it on HTTP port 9090</h3>

<p>Now start uWSGI to run an HTTP server/router passing requests to your WSGI application:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --http :9090 --wsgi-file foobar.py
</code></pre></div></div>

<p>That’s all.</p>

<p><em>Do not use <code class="language-plaintext highlighter-rouge">--http</code> when you have a frontend webserver or you are doning some form of benchmark, use <code class="language-plaintext highlighter-rouge">--http-socket</code>.</em></p>

<h3 id="add-concurrency-and-monitoring">Add concurrency and monitoring</h3>

<p>The first tuning you would like to make is adding concurrency (by deafult uWSGI starts with a single process and a single thread).</p>

<p>You can add more processes with the <code class="language-plaintext highlighter-rouge">--processes</code> option or more threads with the <code class="language-plaintext highlighter-rouge">--threads</code> option (or you can have both).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2
</code></pre></div></div>

<p>This will spawn 4 processes (each with 2 threads), a master process (will respawn your processes when they die) and the HTTP router.</p>

<p>One important task is monitoring. Understanding what is goning on is vital in production deployment.</p>

<p>The status subsystem allows you to export uWSGI’s internal statistics as JSON:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --http :9090 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191
</code></pre></div></div>

<p>Make some request to your app and then telnet to the port 9191, you’ll get lots of fun information.</p>

<p>You may want to use “uwsgitop” (just <code class="language-plaintext highlighter-rouge">pip install</code> it), which is a top-like tool for monitoring instances.</p>

<h3 id="putting-behind-a-full-webserver">Putting behind a full webserver</h3>

<p>Even though uWSGI HTTP router is solid and high-perfomance, you may want to put your applicaiton behind a fully-capable webserver.</p>

<p>uWSGI natively speaks HTTP, FastCGI, SCGI and its specific protocol named “uwsgi” (yes, wrong naming choice). The best performing protocol is obviously uwsgi, alread supported by nginx and Cherokee (while various Apache modules are available).</p>

<p>A common nginx config is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>location / {
    include uwsgi_params;
    uwsgi_pass 127.0.0.1:3031;
}
</code></pre></div></div>

<p>This means “pass every request to the server bound to port 3031 speaking the uwsgi protocol”.</p>

<p>Now we can spawn uWSGI to natively speak the uwsgi protocol:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191
</code></pre></div></div>

<p>If you’ll run <code class="language-plaintext highlighter-rouge">ps aux</code>, you will see one process less. The HTTP router has been removed as our “workers” (the processes assigned to uWSGI) natively speak the uwsgi protocol.</p>

<p>If your proxy/webserver/router speaks HTTP, you have to tell uWSGI to natively speak the http protocol (this is different from <code class="language-plaintext highlighter-rouge">-–http</code> that will spawn a proxy by itself):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --http-socket 127.0.0.1:3031 --wsgi-file foobar.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191
</code></pre></div></div>

<h3 id="automatically-starting-uwsgi-on-boot">Automatically starting uWSGI on boot</h3>

<p>If you are thinking about firing up vi and writing an init.d script for spawning uWSGI, just sit (and calm) down and make sure your system doesn’t offer a better (more modern) approach first.</p>

<p>Each distribution has chose a startup system (<a href="http://uwsgi.readthedocs.io/en/latest/Upstart.html">Upstart</a>, <a href="http://uwsgi.readthedocs.io/en/latest/Systemd.html">Systemd</a>…) and there are tons of process manangers available (supervisord, god, monit, circus…).</p>

<p>uWSGI will integrate very well with all of them (we hope), but if you plan to deploy a big number of apps check the uWSGI <a href="http://uwsgi.readthedocs.io/en/latest/Emperor.html">Emperor</a> - it it more or less the dream of every devops engineer.</p>

<h3 id="deploying-django">Deploying Django</h3>

<p>Django is very probably the most used Python web framework around. Deploying it is pretty easy.</p>

<p>We suppose the Django project is in <code class="language-plaintext highlighter-rouge">/home/foobar/myproject</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --wsgi-file myproject/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191
</code></pre></div></div>

<p>(with <code class="language-plaintext highlighter-rouge">--chdir</code> we move to a specific directory). In Django this is required to correctly load modules.</p>

<p>Argh! What the hell is this?! Yes, you’re right, you’re right…dealing with such long command lines is unpractical, foolish and error-prone. Never fear! uWSGI supports various configuration styles. Here we will use .ini files.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
socket = 127.0.0.1:3031
chdir = /home/foobar/myproject/
wsgi-file = myproject/wsgi.py
processes = 4
threads = 2
stats = 127.0.0.1:9191 
</code></pre></div></div>

<p>A lot better!</p>

<p>Just run it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi yourfile.ini
</code></pre></div></div>

<p>If the file <code class="language-plaintext highlighter-rouge">/home/foobar/myproject/myproject/wsgi.py</code> (or whatever you have called your project) does not exist, you are very probably using an old (&lt;1.4) version of Django. In such a case you need a little bit more configuration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --pythonpath .. --env DJANGO_SETTINGS_MODULE=myproject.settings --module "django.core.handlers.wsgi:WSGIHandler()" --processes 4 --threads 2 --stats 127.0.0.1:9191
</code></pre></div></div>

<p>Or, using the .ini file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
socket = 127.0.0.1:3031
chdir = /home/foobar/myproject/
pythonpath = ..
env = DJANGO_SETTINGS_MODULE=myproject.settings
module = django.core.handlers.wsgi:WSGIHandler()
processes = 4
threads = 2
stats = 127.0.0.1:9191
</code></pre></div></div>

<p>Older (&lt;1.4) Django releases need to set <code class="language-plaintext highlighter-rouge">env</code>, <code class="language-plaintext highlighter-rouge">module</code> and the <code class="language-plaintext highlighter-rouge">pythonpath</code> (<code class="language-plaintext highlighter-rouge">...</code> allow us to reach the <code class="language-plaintext highlighter-rouge">myproject.settings</code> module).</p>

<h3 id="a-note-on-python-threads">A note on Python threads</h3>

<p>If you start uWSGI without threads, the Python GIL will not be eanbled, so threads generated by your application will never run. You may not like that choice, but remember that uWSGI is a language-independent server, so most of its choices are for maintaining it “agnostic”.</p>

<p>But do not worry, there are basically no choices made by the uWSGI developers that cannot be changed with an option.</p>

<p>If you want to maintain Python threads support without starting multiple threads for your application, just add the <code class="language-plaintext highlighter-rouge">--enable-threads</code> option (or `enable-threads = true in init style).</p>

<h3 id="virtualenvs">Virtualenvs</h3>

<p>uWSGI can be configured to search for Python modules in a specific virtuaenv.</p>

<p>Just add <code class="language-plaintext highlighter-rouge">virtualenv = &lt;path&gt;</code> to your options.</p>

<h3 id="python-auto-reloading-development-only">Python Auto-reloading (DEVELOPMENT ONLY!)</h3>

<p>In production you can monitor file/directory changes for triggering reloads (touch-reload, fs-reload…).</p>

<p>During development having a monitor for all of the loaded/used python modules can be handy. But please use it only during development.</p>

<p>This check is done by a thread that scans the modules list with the specified frequency:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
...
py-autoreload = 2
</code></pre></div></div>

<p>will check for ptyhon modules changes every 2 seconds and eventually restart the instance.</p>

<p>And again:</p>

<p><em>Use this only in development.</em></p>

<h3 id="security-and-availability">Security and availability</h3>

<p><strong>Always</strong> avoid running your uWSGI instances as root. You can drop privileges using <code class="language-plaintext highlighter-rouge">uid</code> and <code class="language-plaintext highlighter-rouge">gid</code> options:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
https = :9090,foobar.crt,foobar.key
uid = foo
gid = bar
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8
</code></pre></div></div>

<p>If you need to bind to privileged ports (like 443 for HTTPS), use shared sockets. They are created before dropping privileges and can be referenced with the <code class="language-plaintext highlighter-rouge">=N</code> syntax, where <code class="language-plaintext highlighter-rouge">N</code> is the socket number (starting from 0):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
shared-socket = :443
https = =0,foobar.crt,foobar.key
uid = foo
gid = bar
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8
</code></pre></div></div>

<p>A common problem with webapp deployment is “stuck request”. All of your threads/workers are stuck (blocked on request) and your app cannot accept more requests. To avoid that problem you can set a <code class="language-plaintext highlighter-rouge">karakiri</code> timer. It is a monitor (managed by the master process) that destroy processes stuck for more than the specified number of seconds (choose <code class="language-plaintext highlighter-rouge">karakiri</code> value carefully). For example, you may want to destroy workers blocked for more than 30 seconds:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
shared-socket = :443
https = =0,foobar.crt,foobar.key
uid = foo
gid = bar
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8
harakiri = 30
</code></pre></div></div>

<p>In addition to this, since uWSGI 1.9, the stats server exports the whole set of request variables, so you can see (in realtime) what your instance is doing (for each worker, thread or async core).</p>

<h2 id="managing-the-uwsgi-server">Managing the uWSGI server</h2>

<h3 id="ini-files">INI files</h3>

<p>.INI files are a standard de-facto cofiguration format used by many applications. It consists of <code class="language-plaintext highlighter-rouge">[section]</code>s and <code class="language-plaintext highlighter-rouge">key=value</code> pairs.</p>

<p>An example uWSGI INI configuration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
socket = /tmp/uwsgi.sock
socket = 127.0.0.1:3031
master = true
workers = 3
</code></pre></div></div>

<p>By default, uWSGI uses the <code class="language-plaintext highlighter-rouge">[uwsgi]</code> section, but you can specify another section name while loading the INI file with the syntax <code class="language-plaintext highlighter-rouge">filename:section</code>, that is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi --ini myconf.ini:app1
</code></pre></div></div>

<p>Alternatively, you can load another section from the same file by ommitting the filename and specifying just the section name. Note that technically, this loads the named section from the last.ini file loaded instead of the current one, so be careful when including other files.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
# This will load the app1 section below
ini = :app1
# This will load the defaults.ini file
ini = defaults.ini
# This will load the app2 section from the defaults.ini file!
ini = :app2

[app1]
plugin = rack

[app2]
plugin = php
</code></pre></div></div>

<ul>
  <li>Whitespace is insignificant within lines.</li>
  <li>Lines starting with a semicolon (<code class="language-plaintext highlighter-rouge">;</code>) or a hash/octothorpe (<code class="language-plaintext highlighter-rouge">#</code>) are ignored as comments.</li>
  <li>Boolean values may be set without the value part. Simply <code class="language-plaintext highlighter-rouge">master</code> is thus equivalent to <code class="language-plaintext highlighter-rouge">master=true</code>. This may not be compatible with other INI parsers such as <code class="language-plaintext highlighter-rouge">paste.deploy</code>.</li>
  <li>For convenience, uWSGI recognizes bare <code class="language-plaintext highlighter-rouge">.ini</code> arguments specially, so the invocation <code class="language-plaintext highlighter-rouge">uwsgi myconf.ini</code> is equal to <code class="language-plaintext highlighter-rouge">uwsgi --ini myconf.ini</code>.</li>
</ul>

<h3 id="reloading-the-server">Reloading the server</h3>

<p>When running with the <code class="language-plaintext highlighter-rouge">master</code> process mode, the uWSGI server can be gracefully restarted without closing the main sockets.</p>

<p>This funcitonality allows you patch/upgrade the uWSGI server without closing the connection with the web server and losing a single request.</p>

<p>When you send the <em>SIGHUP</em> to the master process it will try to gracefully stop all the workers, waiting for the completion of any currently running requests.</p>

<p>Then it closes all the eventually opened file descriptors not related to uWSGI.</p>

<p>Lastly, it binary patches (using <code class="language-plaintext highlighter-rouge">execve()</code>) the uWSGI process image with a new one, inheriting all of the previous file descriptors.</p>

<p>The server will known that it is a reloaded instance and will skip all the sockets initialization, reusing the previous ones.</p>

<p><em>Sending the SIGTERM signal will obtain the same result reload-wise but will not wait for the completion of running requests.</em></p>

<p>There are several ways to make uWSGI gracefully restart.</p>

<p>There are several ways to make uWSGI gracefully restart.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># using kill to send the signal
kill -HUP `cat /tmp/project-master.pid`
# or the convenience option --reload
uwsgi --reload /tmp/project-master.pid
# or if uwsgi was started with touch-reload=/tmp/somefile
touch /tmp/somefile
</code></pre></div></div>

<p>Or from your application, in Python:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uwsgi.reload()
</code></pre></div></div>

<p>Or in Ruby,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UWSGI.reload
</code></pre></div></div>

<h3 id="stoping-the-server">Stoping the server</h3>

<p>If you have the uWSGI process running in the foreground for some reason, you can just hit CTRL+C to kill it off.</p>

<p>When dealing with background processes, you’ll need to use the master pidfile again. The SIGINT singal will kill uWSGI.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kill -INT `cat /tmp/project-master.pid`
# or for convenience...
uwsgi --stop /tmp/project-master.pid
</code></pre></div></div>

<hr />

<h3 id="references">References</h3>

<ul>
  <li>
    <p><a href="http://uwsgi.readthedocs.io/en/latest/WSGIquickstart.html">Quickstart for Python/WSGI applications — uWSGI 2.0 documentation</a></p>
  </li>
  <li>
    <p><a href="http://uwsgi.readthedocs.io/en/latest/Management.html">Managing the uWSGI server — uWSGI 2.0 documentation</a></p>
  </li>
  <li>
    <p><a href="http://uwsgi.readthedocs.io/en/latest/Configuration.html">Configuring uWSGI — uWSGI 2.0 documentatio</a></p>
  </li>
  <li>
    <p><a href="http://uwsgi.readthedocs.io/en/latest/Options.html">uWSGI Options — uWSGI 2.0 documentatio</a></p>
  </li>
</ul>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
