<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Database index and data structure | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Database index and data structure" />
<meta property="og:locale" content="en" />
<meta name="description" content="Hash table A hash table (hash map) is a data structure used a hash function to compute an index into an array of buckets or slots. A small phone book as a hash table Binary tree A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A labeled binary tree of size 9 and height 3, with a root node whose value is 2. The above tree is unbalanced and not sorted. Binary search tree The binary search trees (BST), sometimes called ordered or sorted binary trees, are a particular type of binary tree. Binary search tree keep their keys in sorted order, so that lookup and other operation can use the principle of binary search. On average, binary search trees with n nodes have O(log n) height. However, in the worst case, binary search trees can have O(n) height, when the unbalanced tree resembles a linked list (degenerate tree). A binary search tree of size 9 and depth 3, with 8 at the root. The leaves are not drawn. Self-balancing binary search tree The self-balancing (or height-balanced) binary search tree is any node-based binary search tree that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions. The red–black tree, which is a type of self-balancing binary search tree, was called symmetric binary B-tree. An example of an unbalanced tree; following the path from the root to a node takes an average of 3.27 node accesses The same tree after being height-balanced; the average path effort decreased to 3.00 node accesses Tree rotations are very common internal operations on self-balancing binary trees to keep perfect or near-to-perfect balance. B-tree The B-tree is a generalization of a binary search tree in that a node can have more than two children. Unlike self-balancing binary search trees, the B-tree is optimaized for systems that read and write large blocks of data. B-trees are a good example of a data structure for external memory. It is commonly used in databases and filesystems. A B-tree (Bayer &amp; McCreight 1972) of order 5 (Knuth 1998). A B Tree insertion example with each iteration. The nodes of this B tree have at most 3 children (Knuth order 3). B+ tree A B+ tree can be viewed as a B-tree in which each node contains only keys (not key-values pairs), and to which an additional level is added at the bottom with linked leaves. The primary value of a B+ tree is in storing data for efficient retrieval in a block-oriented storage context — in particular, filesystems. This is primarily because unlike binary search trees, B+ trees have very high fanout (number of pointers to child nodes in a node, typically on the order of 100 or more), which reduces the number of I/O operations required to find an element in the tree. A simple B+ tree example linking the keys 1–7 to data values d1-d7. The linked list (red) allows rapid in-order traversal. This particular tree’s branching factor is b=4. Database index The best way to improve the performance of SELECT operations is to create indexes on one or more of the columns that are tested in the query. An index is a copy of select columns of data from a table. Some databases extend the power of indexing by letting developer create indices on fuctions or expressions. For example, an index could be created on upper(last_name), which would only store the upper case versions of the last_name field in the index. Indexes also add to the cost of inserts, updates, and deletes because each index must be updated. Non-clustered The data is present in arbitrary order, but the logical ordering is specified by the index. The data row may be spread throughout the table regardless of the value of the indexed column or expression. In a non-clustered index, The physical order of the rows is not the same as the index order. The indexed columns are typically non-primary key columns used in JOIN, WHERE, and ORDER BY clauses. There can be more than one non-clustered index on a database table. Clustered Clustering alters the data block into certain distinct order to match the index, resulting in the row data being stored in order. Clustered indices can greatly increase overall speed of retrieval, but usually only where the data is accessed sequentially in the same or reverse order of the clustered index, or when a range of items is selected. Only one clustered index can be created on a given database table. Multiple-Column Indexes The order that the index definition defines the columns in is important. Databases can use multiple-columns indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. Comparison of B-Tree and Hash Indexes B-Tree Index A B-tree index can be used for column comparisons in expressions that use the =,&gt;,&gt;=,&lt;,&lt;=, or BETWEEN operators. The index also can be used for LIKE comparisons if the argument to LIKE is a constant string that does not start with a wildcard character. The following SELECT statements use indexs: SELECT * FROM tbl_name WHERE key_col LIKE &#39;Patrick%&#39;; SELECT * FROM tbl_name WHERE key_col LIKE &#39;Pat%_ck%&#39;; The following SELECT statements do not use indexes: SELECT * FROM tbl_name WHERE key_col LIKE &#39;%Patrick%&#39;; SELECT * FROM tbl_name WHERE key_col LIKE other_col; A search using col_name IS NULL employs indexes if col_name is indexed. Any index that does not span all AND levels in the WHERE clause is not used to optimize the query. In other words, to be able to use an index, a prefix of the index must be used in every AND group. The following WHERE clauses use indexes: ... WHERE index_part1=1 AND index_part2=2 AND other_column=3 /* index = 1 OR index = 2 */ ... WHERE index=1 OR A=10 AND index=2 /* optimized like &quot;index_part1=&#39;hello&#39;&quot; */ ... WHERE index_part1=&#39;hello&#39; AND index_part3=5 /* Can use index on index1 but not on index2 or index3 */ ... WHERE index1=1 AND index2=2 OR index1=3 AND index3=3; These WHERE clauses do *not* use indexes: /* index_part1 is not used */ ... WHERE index_part2=1 AND index_part3=2 /* Index is not used in both parts of the WHERE clause */ ... WHERE index=1 OR A=10 /* No index spans all rows */ ... WHERE index_part1=1 OR index_part2=10 Hash Index They are used only for equality comparisons that use the = or &lt;=&gt; operators (but are very fast). They are not used for comparison operators such as &lt; that find a range of values. Systems that rely on this type of single-value lookup are known as “key-value stores”. The optimizer cannot use a hash index to speed up ORDER BY operations. (This type of index cannot be used to search for the next entry in order.) Only whole keys can be used to search for a row. (With a B-tree index, any leftmost prefix of the key can be used to find rows.) References Database index What data structure does mysql use to store data? MySQL 5.5 Reference Manual / Optimization / Optimization and Indexes Clustered Index Structures Hash table Wiki: Binary tree CMU: Binary Trees Binary search tree Self-balancing binary search tree B-tree B+ tree Computer Algorithms: Balancing a Binary Search Tree Binary search algorithm Divide and conquer algorithms" />
<meta property="og:description" content="Hash table A hash table (hash map) is a data structure used a hash function to compute an index into an array of buckets or slots. A small phone book as a hash table Binary tree A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A labeled binary tree of size 9 and height 3, with a root node whose value is 2. The above tree is unbalanced and not sorted. Binary search tree The binary search trees (BST), sometimes called ordered or sorted binary trees, are a particular type of binary tree. Binary search tree keep their keys in sorted order, so that lookup and other operation can use the principle of binary search. On average, binary search trees with n nodes have O(log n) height. However, in the worst case, binary search trees can have O(n) height, when the unbalanced tree resembles a linked list (degenerate tree). A binary search tree of size 9 and depth 3, with 8 at the root. The leaves are not drawn. Self-balancing binary search tree The self-balancing (or height-balanced) binary search tree is any node-based binary search tree that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions. The red–black tree, which is a type of self-balancing binary search tree, was called symmetric binary B-tree. An example of an unbalanced tree; following the path from the root to a node takes an average of 3.27 node accesses The same tree after being height-balanced; the average path effort decreased to 3.00 node accesses Tree rotations are very common internal operations on self-balancing binary trees to keep perfect or near-to-perfect balance. B-tree The B-tree is a generalization of a binary search tree in that a node can have more than two children. Unlike self-balancing binary search trees, the B-tree is optimaized for systems that read and write large blocks of data. B-trees are a good example of a data structure for external memory. It is commonly used in databases and filesystems. A B-tree (Bayer &amp; McCreight 1972) of order 5 (Knuth 1998). A B Tree insertion example with each iteration. The nodes of this B tree have at most 3 children (Knuth order 3). B+ tree A B+ tree can be viewed as a B-tree in which each node contains only keys (not key-values pairs), and to which an additional level is added at the bottom with linked leaves. The primary value of a B+ tree is in storing data for efficient retrieval in a block-oriented storage context — in particular, filesystems. This is primarily because unlike binary search trees, B+ trees have very high fanout (number of pointers to child nodes in a node, typically on the order of 100 or more), which reduces the number of I/O operations required to find an element in the tree. A simple B+ tree example linking the keys 1–7 to data values d1-d7. The linked list (red) allows rapid in-order traversal. This particular tree’s branching factor is b=4. Database index The best way to improve the performance of SELECT operations is to create indexes on one or more of the columns that are tested in the query. An index is a copy of select columns of data from a table. Some databases extend the power of indexing by letting developer create indices on fuctions or expressions. For example, an index could be created on upper(last_name), which would only store the upper case versions of the last_name field in the index. Indexes also add to the cost of inserts, updates, and deletes because each index must be updated. Non-clustered The data is present in arbitrary order, but the logical ordering is specified by the index. The data row may be spread throughout the table regardless of the value of the indexed column or expression. In a non-clustered index, The physical order of the rows is not the same as the index order. The indexed columns are typically non-primary key columns used in JOIN, WHERE, and ORDER BY clauses. There can be more than one non-clustered index on a database table. Clustered Clustering alters the data block into certain distinct order to match the index, resulting in the row data being stored in order. Clustered indices can greatly increase overall speed of retrieval, but usually only where the data is accessed sequentially in the same or reverse order of the clustered index, or when a range of items is selected. Only one clustered index can be created on a given database table. Multiple-Column Indexes The order that the index definition defines the columns in is important. Databases can use multiple-columns indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. Comparison of B-Tree and Hash Indexes B-Tree Index A B-tree index can be used for column comparisons in expressions that use the =,&gt;,&gt;=,&lt;,&lt;=, or BETWEEN operators. The index also can be used for LIKE comparisons if the argument to LIKE is a constant string that does not start with a wildcard character. The following SELECT statements use indexs: SELECT * FROM tbl_name WHERE key_col LIKE &#39;Patrick%&#39;; SELECT * FROM tbl_name WHERE key_col LIKE &#39;Pat%_ck%&#39;; The following SELECT statements do not use indexes: SELECT * FROM tbl_name WHERE key_col LIKE &#39;%Patrick%&#39;; SELECT * FROM tbl_name WHERE key_col LIKE other_col; A search using col_name IS NULL employs indexes if col_name is indexed. Any index that does not span all AND levels in the WHERE clause is not used to optimize the query. In other words, to be able to use an index, a prefix of the index must be used in every AND group. The following WHERE clauses use indexes: ... WHERE index_part1=1 AND index_part2=2 AND other_column=3 /* index = 1 OR index = 2 */ ... WHERE index=1 OR A=10 AND index=2 /* optimized like &quot;index_part1=&#39;hello&#39;&quot; */ ... WHERE index_part1=&#39;hello&#39; AND index_part3=5 /* Can use index on index1 but not on index2 or index3 */ ... WHERE index1=1 AND index2=2 OR index1=3 AND index3=3; These WHERE clauses do *not* use indexes: /* index_part1 is not used */ ... WHERE index_part2=1 AND index_part3=2 /* Index is not used in both parts of the WHERE clause */ ... WHERE index=1 OR A=10 /* No index spans all rows */ ... WHERE index_part1=1 OR index_part2=10 Hash Index They are used only for equality comparisons that use the = or &lt;=&gt; operators (but are very fast). They are not used for comparison operators such as &lt; that find a range of values. Systems that rely on this type of single-value lookup are known as “key-value stores”. The optimizer cannot use a hash index to speed up ORDER BY operations. (This type of index cannot be used to search for the next entry in order.) Only whole keys can be used to search for a row. (With a B-tree index, any leftmost prefix of the key can be used to find rows.) References Database index What data structure does mysql use to store data? MySQL 5.5 Reference Manual / Optimization / Optimization and Indexes Clustered Index Structures Hash table Wiki: Binary tree CMU: Binary Trees Binary search tree Self-balancing binary search tree B-tree B+ tree Computer Algorithms: Balancing a Binary Search Tree Binary search algorithm Divide and conquer algorithms" />
<link rel="canonical" href="https://blog.codefarm.me/2016/04/02/database-index-and-data-structure/" />
<meta property="og:url" content="https://blog.codefarm.me/2016/04/02/database-index-and-data-structure/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-04-02T23:52:59+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Database index and data structure" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-04-02T23:52:59+08:00","datePublished":"2016-04-02T23:52:59+08:00","description":"Hash table A hash table (hash map) is a data structure used a hash function to compute an index into an array of buckets or slots. A small phone book as a hash table Binary tree A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A labeled binary tree of size 9 and height 3, with a root node whose value is 2. The above tree is unbalanced and not sorted. Binary search tree The binary search trees (BST), sometimes called ordered or sorted binary trees, are a particular type of binary tree. Binary search tree keep their keys in sorted order, so that lookup and other operation can use the principle of binary search. On average, binary search trees with n nodes have O(log n) height. However, in the worst case, binary search trees can have O(n) height, when the unbalanced tree resembles a linked list (degenerate tree). A binary search tree of size 9 and depth 3, with 8 at the root. The leaves are not drawn. Self-balancing binary search tree The self-balancing (or height-balanced) binary search tree is any node-based binary search tree that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions. The red–black tree, which is a type of self-balancing binary search tree, was called symmetric binary B-tree. An example of an unbalanced tree; following the path from the root to a node takes an average of 3.27 node accesses The same tree after being height-balanced; the average path effort decreased to 3.00 node accesses Tree rotations are very common internal operations on self-balancing binary trees to keep perfect or near-to-perfect balance. B-tree The B-tree is a generalization of a binary search tree in that a node can have more than two children. Unlike self-balancing binary search trees, the B-tree is optimaized for systems that read and write large blocks of data. B-trees are a good example of a data structure for external memory. It is commonly used in databases and filesystems. A B-tree (Bayer &amp; McCreight 1972) of order 5 (Knuth 1998). A B Tree insertion example with each iteration. The nodes of this B tree have at most 3 children (Knuth order 3). B+ tree A B+ tree can be viewed as a B-tree in which each node contains only keys (not key-values pairs), and to which an additional level is added at the bottom with linked leaves. The primary value of a B+ tree is in storing data for efficient retrieval in a block-oriented storage context — in particular, filesystems. This is primarily because unlike binary search trees, B+ trees have very high fanout (number of pointers to child nodes in a node, typically on the order of 100 or more), which reduces the number of I/O operations required to find an element in the tree. A simple B+ tree example linking the keys 1–7 to data values d1-d7. The linked list (red) allows rapid in-order traversal. This particular tree’s branching factor is b=4. Database index The best way to improve the performance of SELECT operations is to create indexes on one or more of the columns that are tested in the query. An index is a copy of select columns of data from a table. Some databases extend the power of indexing by letting developer create indices on fuctions or expressions. For example, an index could be created on upper(last_name), which would only store the upper case versions of the last_name field in the index. Indexes also add to the cost of inserts, updates, and deletes because each index must be updated. Non-clustered The data is present in arbitrary order, but the logical ordering is specified by the index. The data row may be spread throughout the table regardless of the value of the indexed column or expression. In a non-clustered index, The physical order of the rows is not the same as the index order. The indexed columns are typically non-primary key columns used in JOIN, WHERE, and ORDER BY clauses. There can be more than one non-clustered index on a database table. Clustered Clustering alters the data block into certain distinct order to match the index, resulting in the row data being stored in order. Clustered indices can greatly increase overall speed of retrieval, but usually only where the data is accessed sequentially in the same or reverse order of the clustered index, or when a range of items is selected. Only one clustered index can be created on a given database table. Multiple-Column Indexes The order that the index definition defines the columns in is important. Databases can use multiple-columns indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. Comparison of B-Tree and Hash Indexes B-Tree Index A B-tree index can be used for column comparisons in expressions that use the =,&gt;,&gt;=,&lt;,&lt;=, or BETWEEN operators. The index also can be used for LIKE comparisons if the argument to LIKE is a constant string that does not start with a wildcard character. The following SELECT statements use indexs: SELECT * FROM tbl_name WHERE key_col LIKE &#39;Patrick%&#39;; SELECT * FROM tbl_name WHERE key_col LIKE &#39;Pat%_ck%&#39;; The following SELECT statements do not use indexes: SELECT * FROM tbl_name WHERE key_col LIKE &#39;%Patrick%&#39;; SELECT * FROM tbl_name WHERE key_col LIKE other_col; A search using col_name IS NULL employs indexes if col_name is indexed. Any index that does not span all AND levels in the WHERE clause is not used to optimize the query. In other words, to be able to use an index, a prefix of the index must be used in every AND group. The following WHERE clauses use indexes: ... WHERE index_part1=1 AND index_part2=2 AND other_column=3 /* index = 1 OR index = 2 */ ... WHERE index=1 OR A=10 AND index=2 /* optimized like &quot;index_part1=&#39;hello&#39;&quot; */ ... WHERE index_part1=&#39;hello&#39; AND index_part3=5 /* Can use index on index1 but not on index2 or index3 */ ... WHERE index1=1 AND index2=2 OR index1=3 AND index3=3; These WHERE clauses do *not* use indexes: /* index_part1 is not used */ ... WHERE index_part2=1 AND index_part3=2 /* Index is not used in both parts of the WHERE clause */ ... WHERE index=1 OR A=10 /* No index spans all rows */ ... WHERE index_part1=1 OR index_part2=10 Hash Index They are used only for equality comparisons that use the = or &lt;=&gt; operators (but are very fast). They are not used for comparison operators such as &lt; that find a range of values. Systems that rely on this type of single-value lookup are known as “key-value stores”. The optimizer cannot use a hash index to speed up ORDER BY operations. (This type of index cannot be used to search for the next entry in order.) Only whole keys can be used to search for a row. (With a B-tree index, any leftmost prefix of the key can be used to find rows.) References Database index What data structure does mysql use to store data? MySQL 5.5 Reference Manual / Optimization / Optimization and Indexes Clustered Index Structures Hash table Wiki: Binary tree CMU: Binary Trees Binary search tree Self-balancing binary search tree B-tree B+ tree Computer Algorithms: Balancing a Binary Search Tree Binary search algorithm Divide and conquer algorithms","headline":"Database index and data structure","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2016/04/02/database-index-and-data-structure/"},"url":"https://blog.codefarm.me/2016/04/02/database-index-and-data-structure/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Database index and data structure</h1><p class="c-post-meta">02 Apr 2016</p>
  </header>

  <div class="c-post-content">
    <h3 id="hash-table">Hash table</h3>

<p>A <strong>hash table (hash map)</strong> is a data structure used a <em>hash function</em> to compute an <em>index</em> into an array of <em>buckets</em> or <em>slots</em>.</p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg/315px-Hash_table_3_1_1_0_1_0_0_SP.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg/473px-Hash_table_3_1_1_0_1_0_0_SP.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg/630px-Hash_table_3_1_1_0_1_0_0_SP.svg.png 2x" data-file-width="315" data-file-height="230" height="230" width="315" /></p>

<p><em>A small phone book as a hash table</em></p>

<h3 id="binary-tree">Binary tree</h3>

<p>A <strong>binary tree</strong> is a <em>tree data structure</em> in which each node has at most two children, which are referred to as the <em>left child</em> and the <em>right child</em>.</p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/192px-Binary_tree.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/288px-Binary_tree.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/384px-Binary_tree.svg.png 2x" data-file-width="300" data-file-height="250" height="160" width="192" /></p>

<p><em>A labeled binary tree of size 9 and height 3, with a root node whose value is 2. The above tree is unbalanced and not sorted.</em></p>

<h3 id="binary-search-tree">Binary search tree</h3>

<p>The <strong>binary search trees (BST)</strong>, sometimes called <strong>ordered</strong> or <strong>sorted binary trees</strong>, are a particular type of <em>binary tree</em>.</p>

<p>Binary search tree keep their keys in sorted order, so that lookup and other operation can use the principle of <em>binary search</em>.</p>

<p>On average, binary search trees with <em>n</em> nodes have <em>O(log n)</em> height. However, in the worst case, binary search trees can have <em>O(n)</em> height, when the unbalanced tree resembles a <em>linked list</em> (degenerate tree).</p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/200px-Binary_search_tree.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/400px-Binary_search_tree.svg.png 2x" data-file-width="300" data-file-height="250" height="167" width="200" /></p>

<p><em>A binary search tree of size 9 and depth 3, with 8 at the root. The leaves are not drawn.</em></p>

<h3 id="self-balancing-binary-search-tree">Self-balancing binary search tree</h3>

<p>The <strong>self-balancing</strong> (or <strong>height-balanced</strong>) <strong>binary search tree</strong> is any node-based <em>binary search tree</em> that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions.</p>

<p>The <em>red–black tree</em>, which is a type of self-balancing binary search tree, was called symmetric binary <em>B-tree</em>.</p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Unbalanced_binary_tree.svg/251px-Unbalanced_binary_tree.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Unbalanced_binary_tree.svg/377px-Unbalanced_binary_tree.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Unbalanced_binary_tree.svg/502px-Unbalanced_binary_tree.svg.png 2x" data-file-width="800" data-file-height="800" height="251" width="251" /></p>

<p><em>An example of an <strong>unbalanced</strong> tree; following the path from the root to a node takes an average of 3.27 node accesses</em></p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/06/AVLtreef.svg/251px-AVLtreef.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/0/06/AVLtreef.svg/377px-AVLtreef.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/0/06/AVLtreef.svg/502px-AVLtreef.svg.png 2x" data-file-width="2223" data-file-height="990" height="112" width="251" /></p>

<p><em>The same tree after being height-balanced; the average path effort decreased to 3.00 node accesses</em></p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/300px-BinaryTreeRotations.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/450px-BinaryTreeRotations.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/600px-BinaryTreeRotations.svg.png 2x" data-file-width="405" data-file-height="224" height="166" width="300" /></p>

<p><em>Tree rotations are very common internal operations on self-balancing binary trees to keep perfect or near-to-perfect balance.</em></p>

<h3 id="b-tree">B-tree</h3>

<p>The <strong>B-tree</strong> is a generalization of a <em>binary search tree</em> in that a node can have more than two children. Unlike <em>self-balancing binary search trees</em>, the B-tree is optimaized for systems that read and write large blocks of data. B-trees are a good example of a data structure for external memory. It is commonly used in <em>databases</em> and <em>filesystems</em>.</p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/400px-B-tree.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/600px-B-tree.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/800px-B-tree.svg.png 2x" data-file-width="831" data-file-height="231" height="111" width="400" /></p>

<p><em>A B-tree (Bayer &amp; McCreight 1972) of order 5 (Knuth 1998).</em></p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/3/33/B_tree_insertion_example.png" class="thumbimage" data-file-width="180" data-file-height="391" height="391" width="180" /></p>

<p><em>A B Tree insertion example with each iteration. The nodes of this B tree have at most 3 children (Knuth order 3).</em></p>

<h3 id="b-tree-1">B+ tree</h3>

<p>A <strong>B+ tree</strong> can be viewed as a <em>B-tree</em> in which each node contains only keys (not key-values pairs), and to which an additional level is added at the bottom with linked leaves.</p>

<p>The primary value of a B+ tree is in storing data for efficient retrieval in a <em>block-oriented</em> storage context — in particular, filesystems. This is primarily because unlike <em>binary search trees</em>, B+ trees have very high fanout (number of pointers to child nodes in a node, typically on the order of 100 or more), which reduces the number of I/O operations required to find an element in the tree.</p>

<p><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/3/37/Bplustree.png/400px-Bplustree.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/37/Bplustree.png/600px-Bplustree.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/37/Bplustree.png/800px-Bplustree.png 2x" data-file-width="1121" data-file-height="516" height="184" width="400" /></p>

<p><em>A simple B+ tree example linking the keys 1–7 to data values d1-d7. The linked list (red) allows rapid in-order traversal. This particular tree’s branching factor is b=4.</em></p>

<h3 id="database-index">Database index</h3>

<p>The best way to improve the performance of <em>SELECT</em> operations is to create indexes on one or more of the columns that are tested in the query.</p>

<p>An index is a copy of select columns of data from a table. Some databases extend the power of indexing by letting developer create indices on fuctions or expressions. For example, an index could be created on <code class="language-plaintext highlighter-rouge">upper(last_name)</code>, which would only store the upper case versions of the <code class="language-plaintext highlighter-rouge">last_name</code> field in the index.</p>

<p>Indexes also add to the cost of inserts, updates, and deletes because each index must be updated.</p>

<ul>
  <li>
    <p>Non-clustered</p>

    <p>The data is present in arbitrary order, but the <strong>logical ordering</strong> is specified by the index. The data row may be spread throughout the table regardless of the value of the indexed column or expression.</p>

    <p>In a non-clustered index,</p>

    <ul>
      <li>
        <p>The physical order of the rows is not the same as the index order.</p>
      </li>
      <li>
        <p>The indexed columns are typically non-primary key columns used in <em>JOIN</em>, <em>WHERE</em>, and <em>ORDER BY</em> clauses.</p>
      </li>
    </ul>

    <p>There can be more than one non-clustered index on a database table.</p>
  </li>
  <li>
    <p>Clustered</p>

    <p>Clustering alters the data block into certain distinct order to match the index, resulting in the row data being stored in order.</p>

    <p>Clustered indices can greatly increase overall speed of retrieval, but usually only where the data is accessed sequentially in the same or reverse order of the clustered index, or when a range of items is selected.</p>

    <p>Only one clustered index can be created on a given database table.</p>
  </li>
  <li>
    <p>Multiple-Column Indexes</p>

    <p>The order that the index definition defines the columns in is important.</p>

    <p>Databases can use multiple-columns indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on.</p>
  </li>
  <li>
    <p>Comparison of B-Tree and Hash Indexes</p>
  </li>
</ul>

<p><strong>B-Tree Index</strong></p>

<p>A B-tree index can be used for column comparisons in expressions that use the <code class="language-plaintext highlighter-rouge">=,&gt;,&gt;=,&lt;,&lt;=</code>, or <code class="language-plaintext highlighter-rouge">BETWEEN</code> operators. The index also can be used for <code class="language-plaintext highlighter-rouge">LIKE</code> comparisons if the argument to <code class="language-plaintext highlighter-rouge">LIKE</code> is a constant string that does not start with a wildcard character.</p>

<p>The following SELECT statements use indexs:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM tbl_name WHERE key_col LIKE 'Patrick%';
SELECT * FROM tbl_name WHERE key_col LIKE 'Pat%_ck%';
</code></pre></div></div>

<p>The following <code class="language-plaintext highlighter-rouge">SELECT</code> statements do <em>not</em> use indexes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM tbl_name WHERE key_col LIKE '%Patrick%';
SELECT * FROM tbl_name WHERE key_col LIKE other_col;
</code></pre></div></div>

<p>A search using <strong>col_name</strong> <code class="language-plaintext highlighter-rouge">IS NULL</code> employs indexes if <strong>col_name</strong> is indexed.</p>

<p>Any index that does not span all <code class="language-plaintext highlighter-rouge">AND</code> levels in the <code class="language-plaintext highlighter-rouge">WHERE</code> clause is not used to optimize the query. In other words, to be able to use an index, a prefix of the index must be used in every <code class="language-plaintext highlighter-rouge">AND</code> group.</p>

<p>The following WHERE clauses use indexes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>... WHERE index_part1=1 AND index_part2=2 AND other_column=3

/* index = 1 OR index = 2 */
... WHERE index=1 OR A=10 AND index=2

/* optimized like "index_part1='hello'" */
... WHERE index_part1='hello' AND index_part3=5
        
/* Can use index on index1 but not on index2 or index3 */
... WHERE index1=1 AND index2=2 OR index1=3 AND index3=3;

These WHERE clauses do *not* use indexes:

/* index_part1 is not used */
... WHERE index_part2=1 AND index_part3=2
        
/*  Index is not used in both parts of the WHERE clause  */
... WHERE index=1 OR A=10

/* No index spans all rows  */
... WHERE index_part1=1 OR index_part2=10
</code></pre></div></div>

<p><strong>Hash Index</strong></p>

<ul>
  <li>
    <p>They are used only for equality comparisons that use the <code class="language-plaintext highlighter-rouge">=</code> or <code class="language-plaintext highlighter-rouge">&lt;=&gt;</code> operators (but are <em>very</em> fast). They are not used for comparison operators such as <code class="language-plaintext highlighter-rouge">&lt;</code> that find a range of values. Systems that rely on this type of single-value lookup are known as “key-value stores”.</p>
  </li>
  <li>
    <p>The optimizer cannot use a hash index to speed up <code class="language-plaintext highlighter-rouge">ORDER BY</code> operations. (This type of index cannot be used to search for the next entry in order.)</p>
  </li>
  <li>
    <p>Only whole keys can be used to search for a row. (With a B-tree index, any leftmost prefix of the key can be used to find rows.)</p>
  </li>
</ul>

<hr />

<h4 id="references">References</h4>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Database_index">Database index</a></li>
  <li><a href="https://www.quora.com/What-data-structure-does-mysql-use-to-store-data">What data structure does mysql use to store data?</a></li>
  <li><a href="http://dev.mysql.com/doc/refman/5.5/en/optimization-indexes.html">MySQL 5.5 Reference Manual  /  Optimization  /  Optimization and Indexes </a></li>
  <li><a href="https://technet.microsoft.com/en-us/library/ms177443%28v=sql.105%29.aspx">Clustered Index Structures</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Hash_table">Hash table</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Binary_tree">Wiki: Binary tree</a></li>
  <li><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html">CMU: Binary Trees</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary search tree</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Self-balancing binary search tree</a></li>
  <li><a href="https://en.wikipedia.org/wiki/B-tree">B-tree</a></li>
  <li><a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a></li>
  <li><a href="http://www.stoimen.com/blog/2012/07/03/computer-algorithms-balancing-a-binary-search-tree/">Computer Algorithms: Balancing a Binary Search Tree</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary search algorithm</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">Divide and conquer algorithms</a></li>
</ul>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
