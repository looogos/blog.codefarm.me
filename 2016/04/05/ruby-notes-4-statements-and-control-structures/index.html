<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ruby Notes 4 Statements and Control Structures | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Ruby Notes 4 Statements and Control Structures" />
<meta property="og:locale" content="en" />
<meta name="description" content="A sequential program that are executed one line of code after the other without branching or repetition. x = ARGV[0].to_f # Convert first argument to a number y = ARGV[1].to_f # Convert second argument to a number sum = x + y # Add the arguments puts sum # Print the sum Alter the sequential execution, or flow-of-control, of a program with Ruby’s control structures. Conditionals Loops Iterators and blocks Flow-altering satements like return and break Exceptions The special-case BEGIN and END statements The esoteric control structures known as fibers and continuations Conditionals if if expression code end The code between if and end is executed if (and only if) the expression evaluates to something other than false or nil. The code must be separated from the expression with a newline or semicolon or the keyword then. # If x is less than 10, increment it if x &lt; 10 # newline separator x += 1 end if x &lt; 10 then x += 1 end # then separator if x &lt; 10 then x += 1 end else if expression code else code end elsif if expression1 code1 elsif expression2 code2 . . . elsif expressionN codeN else code end Return value The return value of an if “statement” (i.e., the value that results from evaluating an if expression) is the value of the last expression in the code that was executed, or nil if no block of code was executed. if As a Modifer Instead of writing: if expression then code end we can simply write: code if expression unless unless, as a statement or a modifier, is the opposite of if: it executes code only if an associated expression evaluates to false or nil. Its syntax is just like if, except that elsif clauses are not allowed: # single-way unless statement unless condition code end # two-way unless statement unless condition code else code end # unless modifier code unless condition case The case statement is a multiway conditional. There are two forms of this statement. if/elsif/else name = case name = when x == 1 then &quot;one&quot; if x == 1 then &quot;one&quot; when x == 2 then &quot;two&quot; elsif x == 2 then &quot;two&quot; when x == 3 then &quot;three&quot; elsif x == 3 then &quot;three&quot; when x == 4 then &quot;four&quot; elsif x == 4 then &quot;four&quot; else &quot;many&quot; else &quot;many&quot; end end the then keyword replaced with a newline or semicolon case when x == 1 &quot;one&quot; when x == 2 &quot;two&quot; when x == 3 &quot;three&quot; end case equality name = case x when 1 # Just the value to compare to x &quot;one&quot; when 2 then &quot;two&quot; # Then keyword instead of newline when 3; &quot;three&quot; # Semicolon instead of newline else &quot;many&quot; # Optional else clause at end end same as name = case when 1 === x then &quot;one&quot; when 2 === x then &quot;two&quot; when 3 === x then &quot;three&quot; else &quot;many&quot; end eg.1 # Take different actions depending on the class of x puts case x when String then &quot;string&quot; when Numeric then &quot;number&quot; when TrueClass, FalseClass then &quot;boolean&quot; else &quot;other&quot; end eg.2 # Compute 2006 U.S. income tax using case and Range objects tax = case income when 0..7550 income * 0.1 when 7550..30650 755 + (income-7550)*0.15 when 30650..74200 4220 + (income-30655)*0.25 when 74200..154800 15107.5 + (income-74201)*0.28 when 154800..336550 37675.5 + (income-154800)*0.33 else 97653 + (income-336550)*0.35 end eg.3 # Get user&#39;s input and process it, ignoring comments and exiting # when the user enters the word &quot;quit&quot; while line=gets.chomp do # Loop, asking the user for input each time case line when /^\s*#/ # If input looks like a comment... next # skip to the next line. when /^quit$/i # If input is &quot;quit&quot; (case insensitive)... break # exit the loop. else # Otherwise... puts line.reverse # reverse the user&#39;s input and print it. end end Loops while and until while x = 10 # Initialize a loop counter variable while x &gt;= 0 do # Loop while x is greater than or equal to 0 puts x # Print out the value of x x = x - 1 # Subtract 1 from x end # The loop ends here until # Count back up to 10 using an until loop x = 0 # Start at 0 (instead of -1) until x &gt; 10 do # Loop until x is greater than 10 puts x x = x + 1 end # Loop ends here while and until As Modifiers while x = 0 # Initialize loop variable puts x = x + 1 while x &lt; 10 # Output and increment in a single expression until a = [1,2,3] # Initialize an array puts a.pop until a.empty? # Pop elements from array until empty The for/in Loop for var in collection do body end Altering Control Flow return Causes a method to exit and return a value to its caller. break Causes a loop (or iterator) to exit. next Causes a loop (or iterator) to skip the rest of the current iteration and move on to the next iteration. redo Restarts a loop or iterator from the begining. retry Restarts an iterator, reevaluating the entire expression. The retry keyword can aslo be used in exception handling. throw/catch A very general control struture that is named like and works like an exception progagation and handling mechanism. throw and catch are not Ruby’s primary exception mechanism (that would be raise and rescue). Instead, they are used as a kind of multilevel or labeled break. Exceptions and Exception Handling Exception Classes and Exception Objects Object +--Exception +--NoMemoryError +--ScriptError | +--LoadError | +--NotImplementedError | +--SyntaxError +--SecurityError # Was a StandardError in 1.8 +--SignalException | +--Interrupt +--SystemExit +--SystemStackError # Was a StandardError in 1.8 +--StandardError +--ArgumentError +--FiberError # New in 1.9 +--IOError | +--EOFError +--IndexError | +--KeyError # New in 1.9 | +--StopIteration # New in 1.9 +--LocalJumpError +--NameError | +--NoMethodError +--RangeError | +--FloatDomainError +--RegexpError +--RuntimeError +--SystemCallError +--ThreadError +--TypeError +--ZeroDivisionError The Ruby Exception Class Hierarchy The methods of exception objects message The message method returns a string that my provide human-readable details about what went wrong. backtrace The backtrace method returns an array of strings that represents the call stack at the point that exception was raised. Each element of the array is a string of the form: filename:linenumber:in `methodname&#39; Raising Exceptions with raise The Kernel method raise raises an exception. fail is a synonym that is sometimes used when the exceptation is that the exception will cause the program to exit. raise with on arguments If raise is called with no arguments, it creates a new RuntimeError object (with no message) and raises it. Or, if raise is used with no arguments inside a rescue clause, it simply re-raises the exception that was being handled. raise with a single Exception object If raise is called with a single Exception object as its argument, it raises that exception. Despite its simplicity, this is not actually a common way to use raise. ‘raise` with a single string argument If raise is called with a single string argument, it creates a new RuntimeError exception object, with the specified string as its message, and raises that exception. This is a very common way to use raise. raise with an object that has an exception method If the first argument to raise is an object that has an exception method, then raise invokes that method and raises the Exception object that its returns. The Exception class defines an exception method, so you can specify the class object for any kind of exception as the first argument to raise. raise accepts a string as its optional second argument to use as the exception message. raise also accepts an optional third argument. An array of strings may be specified here, and they will be used as the backtrace for the exception object. If this third argument is not specified, raise sets the backtrace of the exception itself (using the Kernel method caller). Handling Exceptions with rescue raise is a Kernel method. A rescue clause, by contrast, is a fundamental part of the Ruby language. rescue is not a statement in its own right, but rather a clause that can be attached to other Ruby statements. Most commonly, a rescue clause is attached to a begin statement. The begin statement exists simply to delimit the block of code within which exceptions are to be handled. begin # Any number of Ruby statements go here. # Usually, they are executed without exceptions and # execution continues after the end statement. rescue # This is the rescue clause; exception-handling code goes here. # If an exception is raised by the code above, or propagates up # from one of the methods called above, then execution jumps here. end Naming the exception object In a rescue clause, the global variable $! refers to the Exception object that is being handled. If your program includes the line: require &#39;English&#39; then you can use the global variable $ERROR_INFO instead. A better alternative to $! or $ERROR_INFO is to specify a variable name for the exception object in the rescue itself: rescue =&gt; ex The statements of this rescue clause can now use the varible ex to refer to the Exception object that describes the exception. begin # Handle exceptions in this block x = factorial(-1) # Note illegal argument rescue =&gt; ex # Store exception in variable ex puts &quot;#{ex.class}: #{ex.message}&quot; # Handle exception by printing message end # End the begin/rescue block Handling exceptions by type The rescue clause show here handle any exception that is a StandardError (or subclass) and ignore any Exception object that is not StandardError. If you want to handle nonstandard exceptions outside the StandardError hierarchy, or if you want to handle only specific types of exceptions, you must include one or more exception classes in the rescue clause. rescue Exception rescue ArgumentError =&gt; e rescue ArgumentError, TypeError =&gt; error The else Clause The else clause is an alternative to the rescue clauses; it is used if none of the rescue clauses are needed. The code in an else clause is executed if the code in the body of the begin statement runs to completion without exceptions. The ensure Clause The ensure clause contains code that always runs, no matter what happens with the code following begin: If the code runs to completion, then control jumps to the else clause—if there is one—and then to the ensure clause. If the code executes a return statement, then the execution skip the else clause and jump directly to the ensure clause before returing. If the code following begin raises an exception, then control jumps to the appropriate rescue clause, then to the ensure clause. If there no rescue clause, or if no rescue clause can handle the exception, then control jumps directly to the ensure clause. The code in the ensure clause is executed before the exception propagates out to containing blocks or up the call stack. The purpose of the ensure clause is to ensure that housekeeping details such as closing files, disconnecting database connections, and committing or aborting transactions get taken care of. rescue As a Statement Modifier # Compute factorial of x, or use 0 if the method raises an exception y = factorial(x) rescue 0 BEGIN and END BEGIN and END are reserved words in Ruby that declare code to be executed at the very beginning and very end of a Ruby program. If there is more than one BEGIN statement in a program, they are executed in the order which the interpreter encounters them. If there is more than one END statement, they are executed in the reverse of the order in which they are encountered—that is, the first one is executed last. These statements are not commonly used in Ruby. They are inherited from Perl, which in turn inherited them from the awk text-processing language. BEGIN { # The curly braces are required # Global initialization code goes here } END { # Global shutdown code goes here } Threads, Fibers, and Continuations Threads for Concurrency A thread of execution is a sequence of Ruby statements that run (or apear to run) in parallel with the main sequence of statements that the interpreter is running. Threads are represented by Thread objects, but they can also be thought of as control structures for concurrency. Call Thread.new and associate a block with it to create new threads that will start running the code in the block. # This method expects an array of filenames. # It returns an array of strings holding the content of the named files. # The method creates one thread for each named file. def readfiles(filenames) # Create an array of threads from the array of filenames. # Each thread starts reading a file. threads = filenames.map do |f| Thread.new { File.read(f) } end # Now create an array of file contents by calling the value # method of each thread. This method blocks, if necessary, # until the thread exits with a value. threads.map {|t| t.value } end Fibers for Coroutines The name “fiber” has been used elsewhere for a kind of lightweight thread, but Ruby’s fibers are better described as coroutines or, more accurately, semi-coroutines. The most common use for coroutines is to implement generators: objects that can compute a partial result, yield the result back to the caller, and save the state of the computaiton so that the caller can resume that compuation to obtain the next result. In Ruby, the Fiber class is used to enable the automatic conversion of internal iterators, such as the each method, into enumerators or external iterators. Create a fiber with Fiber.new, and associate a block with it to specify the code that the fiber to run. Unlike a thread, the body of a fiber does not start executing right away. To run a fiber, call the resume method of the Fiber object that represent it. The first time resume is called on a fiber, control is transferred to the begining of the fiber body. That fiber then runs unitl it reachs the end of the body, or unitl it executes the class method Fiber.yield. The Fiber.yield method transfer control back to the caller and makes the call to resume return. It also saves the state of the fiber, so that the next call to resume makes the fiber pick up where it left off. f = Fiber.new { # Line 1: Create a new fiber puts &quot;Fiber says Hello&quot; # Line 2: Fiber.yield # Line 3: puts &quot;Fiber says Goodbye&quot; # Line 4: goto line 11 } # Line 5: # Line 6: puts &quot;Caller says Hello&quot; # Line 7: f.resume # Line 8: goto line 2 puts &quot;Caller says Goodbye&quot; # Line 9: f.resume # Line 10: goto line 4 # Line 11: Fiber arguments and return values Fibers and their callers can exchange data through the arguments and return values of resume and yield. The arguments to the first call to resume are passed to the block associated with the fiber: they become the values of the block parameters. On subsequent calls, the arguments to resume become the return value of Fiber.yield. Conversely, any arguments to Fiber.yield become the return value of resume. And when the block exits, the value of the last expression evaluated also becomes the return value of resume. f = Fiber.new do |message| puts &quot;Caller said: #{message}&quot; message2 = Fiber.yield(&quot;Hello&quot;) # &quot;Hello&quot; returned by first resume puts &quot;Caller said: #{message2}&quot; &quot;Fine&quot; # &quot;Fine&quot; returned by second resume end response = f.resume(&quot;Hello&quot;) # &quot;Hello&quot; passed to block puts &quot;Fiber said: #{response}&quot; response2 = f.resume(&quot;How are you?&quot;) # &quot;How are you?&quot; returned by Fiber.yield puts &quot;Fiber said: #{response2}&quot; Implementing generators with fibers class FibonacciGenerator def initialize @x,@y = 0,1 @fiber = Fiber.new do loop do @x,@y = @y, @x+@y Fiber.yield @x end end end def next # Return the next Fibonacci number @fiber.resume end def rewind # Restart the sequence @x,@y = 0,1 end end g = FibonacciGenerator.new # Create a generator 10.times { print g.next, &quot; &quot; } # Print first 10 numbers g.rewind; puts # Start over, on a new line 10.times { print g.next, &quot; &quot; } # Print first 10 again Continuations A continuation is another complex and obscure control structure that most programmers will never need to use. A continuation takes the form of the Kernel method callcc and the Continuation object. Continuations are part of the core platformin Ruby 1.8, but they have been replaced by fibers and moved to the standard library in Ruby 1.9. References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto" />
<meta property="og:description" content="A sequential program that are executed one line of code after the other without branching or repetition. x = ARGV[0].to_f # Convert first argument to a number y = ARGV[1].to_f # Convert second argument to a number sum = x + y # Add the arguments puts sum # Print the sum Alter the sequential execution, or flow-of-control, of a program with Ruby’s control structures. Conditionals Loops Iterators and blocks Flow-altering satements like return and break Exceptions The special-case BEGIN and END statements The esoteric control structures known as fibers and continuations Conditionals if if expression code end The code between if and end is executed if (and only if) the expression evaluates to something other than false or nil. The code must be separated from the expression with a newline or semicolon or the keyword then. # If x is less than 10, increment it if x &lt; 10 # newline separator x += 1 end if x &lt; 10 then x += 1 end # then separator if x &lt; 10 then x += 1 end else if expression code else code end elsif if expression1 code1 elsif expression2 code2 . . . elsif expressionN codeN else code end Return value The return value of an if “statement” (i.e., the value that results from evaluating an if expression) is the value of the last expression in the code that was executed, or nil if no block of code was executed. if As a Modifer Instead of writing: if expression then code end we can simply write: code if expression unless unless, as a statement or a modifier, is the opposite of if: it executes code only if an associated expression evaluates to false or nil. Its syntax is just like if, except that elsif clauses are not allowed: # single-way unless statement unless condition code end # two-way unless statement unless condition code else code end # unless modifier code unless condition case The case statement is a multiway conditional. There are two forms of this statement. if/elsif/else name = case name = when x == 1 then &quot;one&quot; if x == 1 then &quot;one&quot; when x == 2 then &quot;two&quot; elsif x == 2 then &quot;two&quot; when x == 3 then &quot;three&quot; elsif x == 3 then &quot;three&quot; when x == 4 then &quot;four&quot; elsif x == 4 then &quot;four&quot; else &quot;many&quot; else &quot;many&quot; end end the then keyword replaced with a newline or semicolon case when x == 1 &quot;one&quot; when x == 2 &quot;two&quot; when x == 3 &quot;three&quot; end case equality name = case x when 1 # Just the value to compare to x &quot;one&quot; when 2 then &quot;two&quot; # Then keyword instead of newline when 3; &quot;three&quot; # Semicolon instead of newline else &quot;many&quot; # Optional else clause at end end same as name = case when 1 === x then &quot;one&quot; when 2 === x then &quot;two&quot; when 3 === x then &quot;three&quot; else &quot;many&quot; end eg.1 # Take different actions depending on the class of x puts case x when String then &quot;string&quot; when Numeric then &quot;number&quot; when TrueClass, FalseClass then &quot;boolean&quot; else &quot;other&quot; end eg.2 # Compute 2006 U.S. income tax using case and Range objects tax = case income when 0..7550 income * 0.1 when 7550..30650 755 + (income-7550)*0.15 when 30650..74200 4220 + (income-30655)*0.25 when 74200..154800 15107.5 + (income-74201)*0.28 when 154800..336550 37675.5 + (income-154800)*0.33 else 97653 + (income-336550)*0.35 end eg.3 # Get user&#39;s input and process it, ignoring comments and exiting # when the user enters the word &quot;quit&quot; while line=gets.chomp do # Loop, asking the user for input each time case line when /^\s*#/ # If input looks like a comment... next # skip to the next line. when /^quit$/i # If input is &quot;quit&quot; (case insensitive)... break # exit the loop. else # Otherwise... puts line.reverse # reverse the user&#39;s input and print it. end end Loops while and until while x = 10 # Initialize a loop counter variable while x &gt;= 0 do # Loop while x is greater than or equal to 0 puts x # Print out the value of x x = x - 1 # Subtract 1 from x end # The loop ends here until # Count back up to 10 using an until loop x = 0 # Start at 0 (instead of -1) until x &gt; 10 do # Loop until x is greater than 10 puts x x = x + 1 end # Loop ends here while and until As Modifiers while x = 0 # Initialize loop variable puts x = x + 1 while x &lt; 10 # Output and increment in a single expression until a = [1,2,3] # Initialize an array puts a.pop until a.empty? # Pop elements from array until empty The for/in Loop for var in collection do body end Altering Control Flow return Causes a method to exit and return a value to its caller. break Causes a loop (or iterator) to exit. next Causes a loop (or iterator) to skip the rest of the current iteration and move on to the next iteration. redo Restarts a loop or iterator from the begining. retry Restarts an iterator, reevaluating the entire expression. The retry keyword can aslo be used in exception handling. throw/catch A very general control struture that is named like and works like an exception progagation and handling mechanism. throw and catch are not Ruby’s primary exception mechanism (that would be raise and rescue). Instead, they are used as a kind of multilevel or labeled break. Exceptions and Exception Handling Exception Classes and Exception Objects Object +--Exception +--NoMemoryError +--ScriptError | +--LoadError | +--NotImplementedError | +--SyntaxError +--SecurityError # Was a StandardError in 1.8 +--SignalException | +--Interrupt +--SystemExit +--SystemStackError # Was a StandardError in 1.8 +--StandardError +--ArgumentError +--FiberError # New in 1.9 +--IOError | +--EOFError +--IndexError | +--KeyError # New in 1.9 | +--StopIteration # New in 1.9 +--LocalJumpError +--NameError | +--NoMethodError +--RangeError | +--FloatDomainError +--RegexpError +--RuntimeError +--SystemCallError +--ThreadError +--TypeError +--ZeroDivisionError The Ruby Exception Class Hierarchy The methods of exception objects message The message method returns a string that my provide human-readable details about what went wrong. backtrace The backtrace method returns an array of strings that represents the call stack at the point that exception was raised. Each element of the array is a string of the form: filename:linenumber:in `methodname&#39; Raising Exceptions with raise The Kernel method raise raises an exception. fail is a synonym that is sometimes used when the exceptation is that the exception will cause the program to exit. raise with on arguments If raise is called with no arguments, it creates a new RuntimeError object (with no message) and raises it. Or, if raise is used with no arguments inside a rescue clause, it simply re-raises the exception that was being handled. raise with a single Exception object If raise is called with a single Exception object as its argument, it raises that exception. Despite its simplicity, this is not actually a common way to use raise. ‘raise` with a single string argument If raise is called with a single string argument, it creates a new RuntimeError exception object, with the specified string as its message, and raises that exception. This is a very common way to use raise. raise with an object that has an exception method If the first argument to raise is an object that has an exception method, then raise invokes that method and raises the Exception object that its returns. The Exception class defines an exception method, so you can specify the class object for any kind of exception as the first argument to raise. raise accepts a string as its optional second argument to use as the exception message. raise also accepts an optional third argument. An array of strings may be specified here, and they will be used as the backtrace for the exception object. If this third argument is not specified, raise sets the backtrace of the exception itself (using the Kernel method caller). Handling Exceptions with rescue raise is a Kernel method. A rescue clause, by contrast, is a fundamental part of the Ruby language. rescue is not a statement in its own right, but rather a clause that can be attached to other Ruby statements. Most commonly, a rescue clause is attached to a begin statement. The begin statement exists simply to delimit the block of code within which exceptions are to be handled. begin # Any number of Ruby statements go here. # Usually, they are executed without exceptions and # execution continues after the end statement. rescue # This is the rescue clause; exception-handling code goes here. # If an exception is raised by the code above, or propagates up # from one of the methods called above, then execution jumps here. end Naming the exception object In a rescue clause, the global variable $! refers to the Exception object that is being handled. If your program includes the line: require &#39;English&#39; then you can use the global variable $ERROR_INFO instead. A better alternative to $! or $ERROR_INFO is to specify a variable name for the exception object in the rescue itself: rescue =&gt; ex The statements of this rescue clause can now use the varible ex to refer to the Exception object that describes the exception. begin # Handle exceptions in this block x = factorial(-1) # Note illegal argument rescue =&gt; ex # Store exception in variable ex puts &quot;#{ex.class}: #{ex.message}&quot; # Handle exception by printing message end # End the begin/rescue block Handling exceptions by type The rescue clause show here handle any exception that is a StandardError (or subclass) and ignore any Exception object that is not StandardError. If you want to handle nonstandard exceptions outside the StandardError hierarchy, or if you want to handle only specific types of exceptions, you must include one or more exception classes in the rescue clause. rescue Exception rescue ArgumentError =&gt; e rescue ArgumentError, TypeError =&gt; error The else Clause The else clause is an alternative to the rescue clauses; it is used if none of the rescue clauses are needed. The code in an else clause is executed if the code in the body of the begin statement runs to completion without exceptions. The ensure Clause The ensure clause contains code that always runs, no matter what happens with the code following begin: If the code runs to completion, then control jumps to the else clause—if there is one—and then to the ensure clause. If the code executes a return statement, then the execution skip the else clause and jump directly to the ensure clause before returing. If the code following begin raises an exception, then control jumps to the appropriate rescue clause, then to the ensure clause. If there no rescue clause, or if no rescue clause can handle the exception, then control jumps directly to the ensure clause. The code in the ensure clause is executed before the exception propagates out to containing blocks or up the call stack. The purpose of the ensure clause is to ensure that housekeeping details such as closing files, disconnecting database connections, and committing or aborting transactions get taken care of. rescue As a Statement Modifier # Compute factorial of x, or use 0 if the method raises an exception y = factorial(x) rescue 0 BEGIN and END BEGIN and END are reserved words in Ruby that declare code to be executed at the very beginning and very end of a Ruby program. If there is more than one BEGIN statement in a program, they are executed in the order which the interpreter encounters them. If there is more than one END statement, they are executed in the reverse of the order in which they are encountered—that is, the first one is executed last. These statements are not commonly used in Ruby. They are inherited from Perl, which in turn inherited them from the awk text-processing language. BEGIN { # The curly braces are required # Global initialization code goes here } END { # Global shutdown code goes here } Threads, Fibers, and Continuations Threads for Concurrency A thread of execution is a sequence of Ruby statements that run (or apear to run) in parallel with the main sequence of statements that the interpreter is running. Threads are represented by Thread objects, but they can also be thought of as control structures for concurrency. Call Thread.new and associate a block with it to create new threads that will start running the code in the block. # This method expects an array of filenames. # It returns an array of strings holding the content of the named files. # The method creates one thread for each named file. def readfiles(filenames) # Create an array of threads from the array of filenames. # Each thread starts reading a file. threads = filenames.map do |f| Thread.new { File.read(f) } end # Now create an array of file contents by calling the value # method of each thread. This method blocks, if necessary, # until the thread exits with a value. threads.map {|t| t.value } end Fibers for Coroutines The name “fiber” has been used elsewhere for a kind of lightweight thread, but Ruby’s fibers are better described as coroutines or, more accurately, semi-coroutines. The most common use for coroutines is to implement generators: objects that can compute a partial result, yield the result back to the caller, and save the state of the computaiton so that the caller can resume that compuation to obtain the next result. In Ruby, the Fiber class is used to enable the automatic conversion of internal iterators, such as the each method, into enumerators or external iterators. Create a fiber with Fiber.new, and associate a block with it to specify the code that the fiber to run. Unlike a thread, the body of a fiber does not start executing right away. To run a fiber, call the resume method of the Fiber object that represent it. The first time resume is called on a fiber, control is transferred to the begining of the fiber body. That fiber then runs unitl it reachs the end of the body, or unitl it executes the class method Fiber.yield. The Fiber.yield method transfer control back to the caller and makes the call to resume return. It also saves the state of the fiber, so that the next call to resume makes the fiber pick up where it left off. f = Fiber.new { # Line 1: Create a new fiber puts &quot;Fiber says Hello&quot; # Line 2: Fiber.yield # Line 3: puts &quot;Fiber says Goodbye&quot; # Line 4: goto line 11 } # Line 5: # Line 6: puts &quot;Caller says Hello&quot; # Line 7: f.resume # Line 8: goto line 2 puts &quot;Caller says Goodbye&quot; # Line 9: f.resume # Line 10: goto line 4 # Line 11: Fiber arguments and return values Fibers and their callers can exchange data through the arguments and return values of resume and yield. The arguments to the first call to resume are passed to the block associated with the fiber: they become the values of the block parameters. On subsequent calls, the arguments to resume become the return value of Fiber.yield. Conversely, any arguments to Fiber.yield become the return value of resume. And when the block exits, the value of the last expression evaluated also becomes the return value of resume. f = Fiber.new do |message| puts &quot;Caller said: #{message}&quot; message2 = Fiber.yield(&quot;Hello&quot;) # &quot;Hello&quot; returned by first resume puts &quot;Caller said: #{message2}&quot; &quot;Fine&quot; # &quot;Fine&quot; returned by second resume end response = f.resume(&quot;Hello&quot;) # &quot;Hello&quot; passed to block puts &quot;Fiber said: #{response}&quot; response2 = f.resume(&quot;How are you?&quot;) # &quot;How are you?&quot; returned by Fiber.yield puts &quot;Fiber said: #{response2}&quot; Implementing generators with fibers class FibonacciGenerator def initialize @x,@y = 0,1 @fiber = Fiber.new do loop do @x,@y = @y, @x+@y Fiber.yield @x end end end def next # Return the next Fibonacci number @fiber.resume end def rewind # Restart the sequence @x,@y = 0,1 end end g = FibonacciGenerator.new # Create a generator 10.times { print g.next, &quot; &quot; } # Print first 10 numbers g.rewind; puts # Start over, on a new line 10.times { print g.next, &quot; &quot; } # Print first 10 again Continuations A continuation is another complex and obscure control structure that most programmers will never need to use. A continuation takes the form of the Kernel method callcc and the Continuation object. Continuations are part of the core platformin Ruby 1.8, but they have been replaced by fibers and moved to the standard library in Ruby 1.9. References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto" />
<link rel="canonical" href="https://blog.codefarm.me/2016/04/05/ruby-notes-4-statements-and-control-structures/" />
<meta property="og:url" content="https://blog.codefarm.me/2016/04/05/ruby-notes-4-statements-and-control-structures/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-04-05T04:37:29+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ruby Notes 4 Statements and Control Structures" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-04-05T04:37:29+08:00","datePublished":"2016-04-05T04:37:29+08:00","description":"A sequential program that are executed one line of code after the other without branching or repetition. x = ARGV[0].to_f # Convert first argument to a number y = ARGV[1].to_f # Convert second argument to a number sum = x + y # Add the arguments puts sum # Print the sum Alter the sequential execution, or flow-of-control, of a program with Ruby’s control structures. Conditionals Loops Iterators and blocks Flow-altering satements like return and break Exceptions The special-case BEGIN and END statements The esoteric control structures known as fibers and continuations Conditionals if if expression code end The code between if and end is executed if (and only if) the expression evaluates to something other than false or nil. The code must be separated from the expression with a newline or semicolon or the keyword then. # If x is less than 10, increment it if x &lt; 10 # newline separator x += 1 end if x &lt; 10 then x += 1 end # then separator if x &lt; 10 then x += 1 end else if expression code else code end elsif if expression1 code1 elsif expression2 code2 . . . elsif expressionN codeN else code end Return value The return value of an if “statement” (i.e., the value that results from evaluating an if expression) is the value of the last expression in the code that was executed, or nil if no block of code was executed. if As a Modifer Instead of writing: if expression then code end we can simply write: code if expression unless unless, as a statement or a modifier, is the opposite of if: it executes code only if an associated expression evaluates to false or nil. Its syntax is just like if, except that elsif clauses are not allowed: # single-way unless statement unless condition code end # two-way unless statement unless condition code else code end # unless modifier code unless condition case The case statement is a multiway conditional. There are two forms of this statement. if/elsif/else name = case name = when x == 1 then &quot;one&quot; if x == 1 then &quot;one&quot; when x == 2 then &quot;two&quot; elsif x == 2 then &quot;two&quot; when x == 3 then &quot;three&quot; elsif x == 3 then &quot;three&quot; when x == 4 then &quot;four&quot; elsif x == 4 then &quot;four&quot; else &quot;many&quot; else &quot;many&quot; end end the then keyword replaced with a newline or semicolon case when x == 1 &quot;one&quot; when x == 2 &quot;two&quot; when x == 3 &quot;three&quot; end case equality name = case x when 1 # Just the value to compare to x &quot;one&quot; when 2 then &quot;two&quot; # Then keyword instead of newline when 3; &quot;three&quot; # Semicolon instead of newline else &quot;many&quot; # Optional else clause at end end same as name = case when 1 === x then &quot;one&quot; when 2 === x then &quot;two&quot; when 3 === x then &quot;three&quot; else &quot;many&quot; end eg.1 # Take different actions depending on the class of x puts case x when String then &quot;string&quot; when Numeric then &quot;number&quot; when TrueClass, FalseClass then &quot;boolean&quot; else &quot;other&quot; end eg.2 # Compute 2006 U.S. income tax using case and Range objects tax = case income when 0..7550 income * 0.1 when 7550..30650 755 + (income-7550)*0.15 when 30650..74200 4220 + (income-30655)*0.25 when 74200..154800 15107.5 + (income-74201)*0.28 when 154800..336550 37675.5 + (income-154800)*0.33 else 97653 + (income-336550)*0.35 end eg.3 # Get user&#39;s input and process it, ignoring comments and exiting # when the user enters the word &quot;quit&quot; while line=gets.chomp do # Loop, asking the user for input each time case line when /^\\s*#/ # If input looks like a comment... next # skip to the next line. when /^quit$/i # If input is &quot;quit&quot; (case insensitive)... break # exit the loop. else # Otherwise... puts line.reverse # reverse the user&#39;s input and print it. end end Loops while and until while x = 10 # Initialize a loop counter variable while x &gt;= 0 do # Loop while x is greater than or equal to 0 puts x # Print out the value of x x = x - 1 # Subtract 1 from x end # The loop ends here until # Count back up to 10 using an until loop x = 0 # Start at 0 (instead of -1) until x &gt; 10 do # Loop until x is greater than 10 puts x x = x + 1 end # Loop ends here while and until As Modifiers while x = 0 # Initialize loop variable puts x = x + 1 while x &lt; 10 # Output and increment in a single expression until a = [1,2,3] # Initialize an array puts a.pop until a.empty? # Pop elements from array until empty The for/in Loop for var in collection do body end Altering Control Flow return Causes a method to exit and return a value to its caller. break Causes a loop (or iterator) to exit. next Causes a loop (or iterator) to skip the rest of the current iteration and move on to the next iteration. redo Restarts a loop or iterator from the begining. retry Restarts an iterator, reevaluating the entire expression. The retry keyword can aslo be used in exception handling. throw/catch A very general control struture that is named like and works like an exception progagation and handling mechanism. throw and catch are not Ruby’s primary exception mechanism (that would be raise and rescue). Instead, they are used as a kind of multilevel or labeled break. Exceptions and Exception Handling Exception Classes and Exception Objects Object +--Exception +--NoMemoryError +--ScriptError | +--LoadError | +--NotImplementedError | +--SyntaxError +--SecurityError # Was a StandardError in 1.8 +--SignalException | +--Interrupt +--SystemExit +--SystemStackError # Was a StandardError in 1.8 +--StandardError +--ArgumentError +--FiberError # New in 1.9 +--IOError | +--EOFError +--IndexError | +--KeyError # New in 1.9 | +--StopIteration # New in 1.9 +--LocalJumpError +--NameError | +--NoMethodError +--RangeError | +--FloatDomainError +--RegexpError +--RuntimeError +--SystemCallError +--ThreadError +--TypeError +--ZeroDivisionError The Ruby Exception Class Hierarchy The methods of exception objects message The message method returns a string that my provide human-readable details about what went wrong. backtrace The backtrace method returns an array of strings that represents the call stack at the point that exception was raised. Each element of the array is a string of the form: filename:linenumber:in `methodname&#39; Raising Exceptions with raise The Kernel method raise raises an exception. fail is a synonym that is sometimes used when the exceptation is that the exception will cause the program to exit. raise with on arguments If raise is called with no arguments, it creates a new RuntimeError object (with no message) and raises it. Or, if raise is used with no arguments inside a rescue clause, it simply re-raises the exception that was being handled. raise with a single Exception object If raise is called with a single Exception object as its argument, it raises that exception. Despite its simplicity, this is not actually a common way to use raise. ‘raise` with a single string argument If raise is called with a single string argument, it creates a new RuntimeError exception object, with the specified string as its message, and raises that exception. This is a very common way to use raise. raise with an object that has an exception method If the first argument to raise is an object that has an exception method, then raise invokes that method and raises the Exception object that its returns. The Exception class defines an exception method, so you can specify the class object for any kind of exception as the first argument to raise. raise accepts a string as its optional second argument to use as the exception message. raise also accepts an optional third argument. An array of strings may be specified here, and they will be used as the backtrace for the exception object. If this third argument is not specified, raise sets the backtrace of the exception itself (using the Kernel method caller). Handling Exceptions with rescue raise is a Kernel method. A rescue clause, by contrast, is a fundamental part of the Ruby language. rescue is not a statement in its own right, but rather a clause that can be attached to other Ruby statements. Most commonly, a rescue clause is attached to a begin statement. The begin statement exists simply to delimit the block of code within which exceptions are to be handled. begin # Any number of Ruby statements go here. # Usually, they are executed without exceptions and # execution continues after the end statement. rescue # This is the rescue clause; exception-handling code goes here. # If an exception is raised by the code above, or propagates up # from one of the methods called above, then execution jumps here. end Naming the exception object In a rescue clause, the global variable $! refers to the Exception object that is being handled. If your program includes the line: require &#39;English&#39; then you can use the global variable $ERROR_INFO instead. A better alternative to $! or $ERROR_INFO is to specify a variable name for the exception object in the rescue itself: rescue =&gt; ex The statements of this rescue clause can now use the varible ex to refer to the Exception object that describes the exception. begin # Handle exceptions in this block x = factorial(-1) # Note illegal argument rescue =&gt; ex # Store exception in variable ex puts &quot;#{ex.class}: #{ex.message}&quot; # Handle exception by printing message end # End the begin/rescue block Handling exceptions by type The rescue clause show here handle any exception that is a StandardError (or subclass) and ignore any Exception object that is not StandardError. If you want to handle nonstandard exceptions outside the StandardError hierarchy, or if you want to handle only specific types of exceptions, you must include one or more exception classes in the rescue clause. rescue Exception rescue ArgumentError =&gt; e rescue ArgumentError, TypeError =&gt; error The else Clause The else clause is an alternative to the rescue clauses; it is used if none of the rescue clauses are needed. The code in an else clause is executed if the code in the body of the begin statement runs to completion without exceptions. The ensure Clause The ensure clause contains code that always runs, no matter what happens with the code following begin: If the code runs to completion, then control jumps to the else clause—if there is one—and then to the ensure clause. If the code executes a return statement, then the execution skip the else clause and jump directly to the ensure clause before returing. If the code following begin raises an exception, then control jumps to the appropriate rescue clause, then to the ensure clause. If there no rescue clause, or if no rescue clause can handle the exception, then control jumps directly to the ensure clause. The code in the ensure clause is executed before the exception propagates out to containing blocks or up the call stack. The purpose of the ensure clause is to ensure that housekeeping details such as closing files, disconnecting database connections, and committing or aborting transactions get taken care of. rescue As a Statement Modifier # Compute factorial of x, or use 0 if the method raises an exception y = factorial(x) rescue 0 BEGIN and END BEGIN and END are reserved words in Ruby that declare code to be executed at the very beginning and very end of a Ruby program. If there is more than one BEGIN statement in a program, they are executed in the order which the interpreter encounters them. If there is more than one END statement, they are executed in the reverse of the order in which they are encountered—that is, the first one is executed last. These statements are not commonly used in Ruby. They are inherited from Perl, which in turn inherited them from the awk text-processing language. BEGIN { # The curly braces are required # Global initialization code goes here } END { # Global shutdown code goes here } Threads, Fibers, and Continuations Threads for Concurrency A thread of execution is a sequence of Ruby statements that run (or apear to run) in parallel with the main sequence of statements that the interpreter is running. Threads are represented by Thread objects, but they can also be thought of as control structures for concurrency. Call Thread.new and associate a block with it to create new threads that will start running the code in the block. # This method expects an array of filenames. # It returns an array of strings holding the content of the named files. # The method creates one thread for each named file. def readfiles(filenames) # Create an array of threads from the array of filenames. # Each thread starts reading a file. threads = filenames.map do |f| Thread.new { File.read(f) } end # Now create an array of file contents by calling the value # method of each thread. This method blocks, if necessary, # until the thread exits with a value. threads.map {|t| t.value } end Fibers for Coroutines The name “fiber” has been used elsewhere for a kind of lightweight thread, but Ruby’s fibers are better described as coroutines or, more accurately, semi-coroutines. The most common use for coroutines is to implement generators: objects that can compute a partial result, yield the result back to the caller, and save the state of the computaiton so that the caller can resume that compuation to obtain the next result. In Ruby, the Fiber class is used to enable the automatic conversion of internal iterators, such as the each method, into enumerators or external iterators. Create a fiber with Fiber.new, and associate a block with it to specify the code that the fiber to run. Unlike a thread, the body of a fiber does not start executing right away. To run a fiber, call the resume method of the Fiber object that represent it. The first time resume is called on a fiber, control is transferred to the begining of the fiber body. That fiber then runs unitl it reachs the end of the body, or unitl it executes the class method Fiber.yield. The Fiber.yield method transfer control back to the caller and makes the call to resume return. It also saves the state of the fiber, so that the next call to resume makes the fiber pick up where it left off. f = Fiber.new { # Line 1: Create a new fiber puts &quot;Fiber says Hello&quot; # Line 2: Fiber.yield # Line 3: puts &quot;Fiber says Goodbye&quot; # Line 4: goto line 11 } # Line 5: # Line 6: puts &quot;Caller says Hello&quot; # Line 7: f.resume # Line 8: goto line 2 puts &quot;Caller says Goodbye&quot; # Line 9: f.resume # Line 10: goto line 4 # Line 11: Fiber arguments and return values Fibers and their callers can exchange data through the arguments and return values of resume and yield. The arguments to the first call to resume are passed to the block associated with the fiber: they become the values of the block parameters. On subsequent calls, the arguments to resume become the return value of Fiber.yield. Conversely, any arguments to Fiber.yield become the return value of resume. And when the block exits, the value of the last expression evaluated also becomes the return value of resume. f = Fiber.new do |message| puts &quot;Caller said: #{message}&quot; message2 = Fiber.yield(&quot;Hello&quot;) # &quot;Hello&quot; returned by first resume puts &quot;Caller said: #{message2}&quot; &quot;Fine&quot; # &quot;Fine&quot; returned by second resume end response = f.resume(&quot;Hello&quot;) # &quot;Hello&quot; passed to block puts &quot;Fiber said: #{response}&quot; response2 = f.resume(&quot;How are you?&quot;) # &quot;How are you?&quot; returned by Fiber.yield puts &quot;Fiber said: #{response2}&quot; Implementing generators with fibers class FibonacciGenerator def initialize @x,@y = 0,1 @fiber = Fiber.new do loop do @x,@y = @y, @x+@y Fiber.yield @x end end end def next # Return the next Fibonacci number @fiber.resume end def rewind # Restart the sequence @x,@y = 0,1 end end g = FibonacciGenerator.new # Create a generator 10.times { print g.next, &quot; &quot; } # Print first 10 numbers g.rewind; puts # Start over, on a new line 10.times { print g.next, &quot; &quot; } # Print first 10 again Continuations A continuation is another complex and obscure control structure that most programmers will never need to use. A continuation takes the form of the Kernel method callcc and the Continuation object. Continuations are part of the core platformin Ruby 1.8, but they have been replaced by fibers and moved to the standard library in Ruby 1.9. References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto","headline":"Ruby Notes 4 Statements and Control Structures","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2016/04/05/ruby-notes-4-statements-and-control-structures/"},"url":"https://blog.codefarm.me/2016/04/05/ruby-notes-4-statements-and-control-structures/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Ruby Notes 4 Statements and Control Structures</h1><p class="c-post-meta">05 Apr 2016</p>
  </header>

  <div class="c-post-content">
    <p>A sequential program that are executed one line of code after the other without branching or repetition.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = ARGV[0].to_f # Convert first argument to a number
y = ARGV[1].to_f # Convert second argument to a number
sum = x + y      # Add the arguments
puts sum         # Print the sum
</code></pre></div></div>

<p>Alter the sequential execution, or <em>flow-of-control</em>, of a program with Ruby’s <strong>control structures</strong>.</p>

<ul>
  <li>Conditionals</li>
  <li>Loops</li>
  <li>Iterators and blocks</li>
  <li>Flow-altering satements like <strong>return</strong> and <strong>break</strong></li>
  <li>Exceptions</li>
  <li>The special-case BEGIN and END statements</li>
  <li>The esoteric control structures known as <strong>fibers</strong> and <strong>continuations</strong></li>
</ul>

<h3 id="conditionals">Conditionals</h3>

<ol>
  <li>
    <p>if</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if expression
     code
 end
</code></pre></div>    </div>

    <p>The <code class="language-plaintext highlighter-rouge">code</code> between <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">end</code> is executed if (and only if) the <code class="language-plaintext highlighter-rouge">expression</code> evaluates to something other than <code class="language-plaintext highlighter-rouge">false</code> or <code class="language-plaintext highlighter-rouge">nil</code>.</p>

    <p>The <code class="language-plaintext highlighter-rouge">code</code> must be separated from the <code class="language-plaintext highlighter-rouge">expression</code> with a <em>newline</em> or <em>semicolon</em> or the keyword <code class="language-plaintext highlighter-rouge">then</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # If x is less than 10, increment it

    if x &lt; 10 # newline separator
    x += 1
    end
       
    if x &lt; 10 then x += 1 end # then separator
       
    if x &lt; 10 then
        x += 1
    end
</code></pre></div>    </div>

    <ul>
      <li>
        <p><strong>else</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if expression
      code
  else
      code
  end
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>elsif</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if expression1
      code1
  elsif expression2
      code2
      .
      .
      .
  elsif expressionN
      codeN
  else
      code
  end
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>Return value</strong></p>

        <p>The return value of an <code class="language-plaintext highlighter-rouge">if</code> “statement” (i.e., the value that results from evaluating an if expression) is <em>the value of the last expression</em> in the code that was executed, or <code class="language-plaintext highlighter-rouge">nil</code> if no block of code was executed.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>if As a Modifer</p>

    <p>Instead of writing:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if expression then code end
</code></pre></div>    </div>

    <p>we can simply write:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> code if expression
</code></pre></div>    </div>
  </li>
  <li>
    <p>unless</p>

    <p><code class="language-plaintext highlighter-rouge">unless</code>, as a statement or a modifier, is the opposite of <code class="language-plaintext highlighter-rouge">if</code>: it executes code only if an associated expression evaluates to <code class="language-plaintext highlighter-rouge">false</code> or <code class="language-plaintext highlighter-rouge">nil</code>. Its syntax is just like <code class="language-plaintext highlighter-rouge">if</code>, except that <code class="language-plaintext highlighter-rouge">elsif</code> clauses are <em>not</em> allowed:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> # single-way unless statement
 unless condition
     code
 end
    
 # two-way unless statement
 unless condition
     code
 else
     code
 end
    
 # unless modifier
 code unless condition
</code></pre></div>    </div>
  </li>
  <li>
    <p>case</p>

    <p>The <code class="language-plaintext highlighter-rouge">case</code> statement is a multiway conditional. There are two forms of this statement.</p>

    <ul>
      <li>
        <p><em>if/elsif/else</em></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  name = case                             name =
  when x == 1 then "one"                  if x == 1 then "one" 
  when x == 2 then "two"                  elsif x == 2 then "two"
  when x == 3 then "three"                elsif x == 3 then "three"
  when x == 4 then "four"                 elsif x == 4 then "four"
  else "many"                             else "many"
  end                                     end
</code></pre></div>        </div>

        <p><em>the <code class="language-plaintext highlighter-rouge">then</code> keyword replaced with a newline or semicolon</em></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  case
  when x == 1
      "one"
  when x == 2
      "two"
  when x == 3
      "three"
  end
</code></pre></div>        </div>
      </li>
      <li>
        <p><em>case equality</em></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  name = 
  case x
  when 1              # Just the value to compare to x
      "one"
  when 2 then "two"   # Then keyword instead of newline
  when 3; "three"     # Semicolon instead of newline
  else "many"         # Optional else clause at end
  end
</code></pre></div>        </div>

        <p><em>same as</em></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  name = case
  when 1 === x then "one"
  when 2 === x then "two" 
  when 3 === x then "three" 
  else "many"
  end
</code></pre></div>        </div>

        <p><em>eg.1</em></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Take different actions depending on the class of x 
  puts case x
  when String then "string"
  when Numeric then "number"
  when TrueClass, FalseClass then "boolean"
  else "other"
  end
</code></pre></div>        </div>

        <p><em>eg.2</em></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Compute 2006 U.S. income tax using case and Range objects
  tax = case income
        when 0..7550
            income * 0.1
        when 7550..30650
            755 + (income-7550)*0.15
        when 30650..74200
            4220 + (income-30655)*0.25
        when 74200..154800
            15107.5 + (income-74201)*0.28
        when 154800..336550
            37675.5 + (income-154800)*0.33
        else
            97653 + (income-336550)*0.35
        end
</code></pre></div>        </div>

        <p><em>eg.3</em></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Get user's input and process it, ignoring comments and exiting
  # when the user enters the word "quit"
  while line=gets.chomp do    # Loop, asking the user for input each time
      case line
      when /^\s*#/            # If input looks like a comment...
          next                # skip to the next line.
      when /^quit$/i          # If input is "quit" (case insensitive)...
          break               # exit the loop.
      else                    # Otherwise...
          puts line.reverse   # reverse the user's input and print it.
      end
  end
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h4 id="loops">Loops</h4>

<ol>
  <li>while and until
    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">while</code></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x = 10          # Initialize a loop counter variable
  while x &gt;= 0 do # Loop while x is greater than or equal to 0
      puts x      # Print out the value of x
      x = x - 1    # Subtract 1 from x
  end             # The loop ends here
</code></pre></div>        </div>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">until</code></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Count back up to 10 using an until loop
  x = 0           # Start at 0 (instead of -1)
  until x &gt; 10 do # Loop until x is greater than 10
      puts x
      x = x + 1 
  end             # Loop ends here
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>while and until As Modifiers</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">while</code></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x = 0                       # Initialize loop variable
  puts x = x + 1 while x &lt; 10 # Output and increment in a single expression
</code></pre></div>        </div>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">until</code></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  a = [1,2,3]                 # Initialize an array
  puts a.pop until a.empty?   # Pop elements from array until empty
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>The for/in Loop</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> for var in collection do
     body
 end
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="altering-control-flow">Altering Control Flow</h3>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">return</code></p>

    <p>Causes a method to exit and return a value to its caller.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">break</code></p>

    <p>Causes a loop (or iterator) to exit.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">next</code></p>

    <p>Causes a loop (or iterator) to skip the rest of the current iteration and move on to the next iteration.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">redo</code></p>

    <p>Restarts a loop or iterator from the begining.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">retry</code></p>

    <p>Restarts an iterator, reevaluating the entire expression. The <code class="language-plaintext highlighter-rouge">retry</code> keyword can aslo be used in exception handling.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">throw/catch</code></p>

    <p>A very general control struture that is named like and works like an exception progagation and handling mechanism. <code class="language-plaintext highlighter-rouge">throw</code> and <code class="language-plaintext highlighter-rouge">catch</code> are not Ruby’s primary exception mechanism (that would be <code class="language-plaintext highlighter-rouge">raise</code> and <code class="language-plaintext highlighter-rouge">rescue</code>). Instead, they are used as a kind of multilevel or labeled <code class="language-plaintext highlighter-rouge">break</code>.</p>
  </li>
</ul>

<h3 id="exceptions-and-exception-handling">Exceptions and Exception Handling</h3>

<ol>
  <li>
    <p>Exception Classes and Exception Objects</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Object
     +--Exception
         +--NoMemoryError
         +--ScriptError
         | +--LoadError
         | +--NotImplementedError
         | +--SyntaxError
     +--SecurityError        # Was a StandardError in 1.8
     +--SignalException
     | +--Interrupt
     +--SystemExit
     +--SystemStackError     # Was a StandardError in 1.8
     +--StandardError
         +--ArgumentError
         +--FiberError       # New in 1.9
         +--IOError
         | +--EOFError
         +--IndexError
         | +--KeyError       # New in 1.9
         | +--StopIteration  # New in 1.9
         +--LocalJumpError
         +--NameError
         | +--NoMethodError
         +--RangeError
         | +--FloatDomainError
         +--RegexpError
         +--RuntimeError
         +--SystemCallError
         +--ThreadError
         +--TypeError
         +--ZeroDivisionError
</code></pre></div>    </div>

    <p><em>The Ruby Exception Class Hierarchy</em></p>

    <ul>
      <li>
        <p><strong>The methods of exception objects</strong></p>

        <ul>
          <li>
            <p><code class="language-plaintext highlighter-rouge">message</code></p>

            <p>The <code class="language-plaintext highlighter-rouge">message</code> method returns a string that my provide human-readable details about what went wrong.</p>
          </li>
          <li>
            <p><code class="language-plaintext highlighter-rouge">backtrace</code></p>

            <p>The <code class="language-plaintext highlighter-rouge">backtrace</code> method returns an array of strings that represents the call stack at the point that exception was raised.</p>

            <p>Each element of the array is a string of the form:</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  filename:linenumber:in `methodname'
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Raising Exceptions with <code class="language-plaintext highlighter-rouge">raise</code></p>

    <p>The <em>Kernel</em> method <code class="language-plaintext highlighter-rouge">raise</code> raises an exception. <code class="language-plaintext highlighter-rouge">fail</code> is a synonym that is sometimes used when the exceptation is that the exception will cause the program to exit.</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">raise</code> with on arguments</p>

        <p>If <code class="language-plaintext highlighter-rouge">raise</code> is called with no arguments, it creates a new <code class="language-plaintext highlighter-rouge">RuntimeError</code> object (with no message) and raises it. Or, if <code class="language-plaintext highlighter-rouge">raise</code> is used with no arguments inside a <code class="language-plaintext highlighter-rouge">rescue</code> clause, it simply re-raises the exception that was being handled.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">raise</code> with a single <code class="language-plaintext highlighter-rouge">Exception</code> object</p>

        <p>If <code class="language-plaintext highlighter-rouge">raise</code> is called with a single <code class="language-plaintext highlighter-rouge">Exception</code> object as its argument, it raises that exception. Despite its simplicity, this is <em>not actually a common way</em> to use <code class="language-plaintext highlighter-rouge">raise</code>.</p>
      </li>
      <li>
        <p>‘raise` with a single string argument</p>

        <p>If <code class="language-plaintext highlighter-rouge">raise</code> is called with a single string argument, it creates a new <code class="language-plaintext highlighter-rouge">RuntimeError</code> exception object, with the specified string as its message, and raises that exception. This is a <em>very common way</em> to use <code class="language-plaintext highlighter-rouge">raise</code>.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">raise</code> with an object that has an <code class="language-plaintext highlighter-rouge">exception</code> method</p>

        <p>If the first argument to <code class="language-plaintext highlighter-rouge">raise</code> is an object that has an <code class="language-plaintext highlighter-rouge">exception</code> method, then <code class="language-plaintext highlighter-rouge">raise</code> invokes that method and raises the <code class="language-plaintext highlighter-rouge">Exception</code> object that its returns. The <code class="language-plaintext highlighter-rouge">Exception</code> class defines an <code class="language-plaintext highlighter-rouge">exception</code> method, so you can specify the class object for any kind of exception as the first argument to <code class="language-plaintext highlighter-rouge">raise</code>.</p>

        <p><code class="language-plaintext highlighter-rouge">raise</code> accepts a string as its optional second argument to use as the exception message.</p>

        <p><code class="language-plaintext highlighter-rouge">raise</code> also accepts an optional third argument. An array of strings may be specified here, and they will be used as the backtrace for the exception object. If this third argument is not specified, <code class="language-plaintext highlighter-rouge">raise</code> sets the backtrace of the exception itself (using the <em>Kernel</em> method <code class="language-plaintext highlighter-rouge">caller</code>).</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Handling Exceptions with <code class="language-plaintext highlighter-rouge">rescue</code></p>

    <p><code class="language-plaintext highlighter-rouge">raise</code> is a <em>Kernel</em> method.</p>

    <p>A <code class="language-plaintext highlighter-rouge">rescue</code> clause, by contrast, is a fundamental part of the Ruby language.</p>

    <p><code class="language-plaintext highlighter-rouge">rescue</code> is not a statement in its own right, but rather a clause that can be attached to other Ruby statements.</p>

    <p>Most commonly, a <code class="language-plaintext highlighter-rouge">rescue</code> clause is attached to a <code class="language-plaintext highlighter-rouge">begin</code> statement.</p>

    <p>The <code class="language-plaintext highlighter-rouge">begin</code> statement exists simply to delimit the block of code within which exceptions are to be handled.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> begin
     # Any number of Ruby statements go here.
     # Usually, they are executed without exceptions and # execution continues after the end statement.
 rescue
     # This is the rescue clause; exception-handling code goes here.
     # If an exception is raised by the code above, or propagates up
     # from one of the methods called above, then execution jumps here.
 end
</code></pre></div>    </div>

    <ul>
      <li>
        <p><strong>Naming the exception object</strong></p>

        <p>In a <code class="language-plaintext highlighter-rouge">rescue</code> clause, the global variable <code class="language-plaintext highlighter-rouge">$!</code> refers to the <code class="language-plaintext highlighter-rouge">Exception</code> object that is being handled.</p>

        <p>If your program includes the line:</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  require 'English'
</code></pre></div>        </div>

        <p>then you can use the global variable <code class="language-plaintext highlighter-rouge">$ERROR_INFO</code> instead.</p>

        <p>A better alternative to <code class="language-plaintext highlighter-rouge">$!</code> or <code class="language-plaintext highlighter-rouge">$ERROR_INFO</code> is to specify a variable name for the exception object in the <code class="language-plaintext highlighter-rouge">rescue</code> itself:</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  rescue =&gt; ex
</code></pre></div>        </div>

        <p>The statements of this <code class="language-plaintext highlighter-rouge">rescue</code> clause can now use the varible <code class="language-plaintext highlighter-rouge">ex</code> to refer to the <code class="language-plaintext highlighter-rouge">Exception</code> object that describes the exception.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  begin                                 # Handle exceptions in this block
      x = factorial(-1)                 # Note illegal argument
  rescue =&gt; ex                          # Store exception in variable ex
      puts "#{ex.class}: #{ex.message}" # Handle exception by printing message
  end                                   # End the begin/rescue block
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>Handling exceptions by type</strong></p>

        <p>The <code class="language-plaintext highlighter-rouge">rescue</code> clause show here handle any exception that is a <code class="language-plaintext highlighter-rouge">StandardError</code> (or subclass) and ignore any <code class="language-plaintext highlighter-rouge">Exception</code> object that is not <code class="language-plaintext highlighter-rouge">StandardError</code>.</p>

        <p>If you want to handle nonstandard exceptions outside the <code class="language-plaintext highlighter-rouge">StandardError</code> hierarchy, or if you want to handle only specific types of exceptions, you must include one or more exception classes in the <code class="language-plaintext highlighter-rouge">rescue</code> clause.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  rescue Exception

  rescue ArgumentError =&gt; e

  rescue ArgumentError, TypeError =&gt; error
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">else</code> Clause</p>

    <p>The <code class="language-plaintext highlighter-rouge">else</code> clause is an alternative to the <code class="language-plaintext highlighter-rouge">rescue</code> clauses; it is used if none of the <code class="language-plaintext highlighter-rouge">rescue</code> clauses are needed.</p>

    <p>The code in an <code class="language-plaintext highlighter-rouge">else</code> clause is executed if the code in the body of the begin statement runs to completion <em>without exceptions</em>.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">ensure</code> Clause</p>

    <p>The <code class="language-plaintext highlighter-rouge">ensure</code> clause contains code that always runs, no matter what happens with the code following <code class="language-plaintext highlighter-rouge">begin</code>:</p>

    <ul>
      <li>
        <p>If the code <em>runs to completion</em>, then control jumps to the <code class="language-plaintext highlighter-rouge">else</code> clause—if there is one—and then to the <code class="language-plaintext highlighter-rouge">ensure</code> clause.</p>
      </li>
      <li>
        <p>If the code executes a <code class="language-plaintext highlighter-rouge">return</code> statement, then the execution skip the <code class="language-plaintext highlighter-rouge">else</code> clause and jump directly to the <code class="language-plaintext highlighter-rouge">ensure</code> clause before returing.</p>
      </li>
      <li>
        <p>If the code following <code class="language-plaintext highlighter-rouge">begin</code> raises an exception, then control jumps to the appropriate <code class="language-plaintext highlighter-rouge">rescue</code> clause, then to the <code class="language-plaintext highlighter-rouge">ensure</code> clause.</p>
      </li>
      <li>
        <p>If there no <code class="language-plaintext highlighter-rouge">rescue</code> clause, or if no <code class="language-plaintext highlighter-rouge">rescue</code> clause can handle the exception, then control jumps directly to the <code class="language-plaintext highlighter-rouge">ensure</code> clause. The code in the <code class="language-plaintext highlighter-rouge">ensure</code> clause is executed before the exception propagates out to containing blocks or up the call stack.</p>
      </li>
    </ul>

    <p>The purpose of the <code class="language-plaintext highlighter-rouge">ensure</code> clause is to ensure that housekeeping details such as closing files, disconnecting database connections, and committing or aborting transactions get taken care of.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">rescue</code> As a Statement Modifier</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> # Compute factorial of x, or use 0 if the method raises an exception 
 y = factorial(x) rescue 0
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="begin-and-end">BEGIN and END</h3>

<p><code class="language-plaintext highlighter-rouge">BEGIN</code> and <code class="language-plaintext highlighter-rouge">END</code> are reserved words in Ruby that declare code to be executed at the very beginning and very end of a Ruby program.</p>

<p>If there is more than one <code class="language-plaintext highlighter-rouge">BEGIN</code> statement in a program, they are executed in the order which the interpreter encounters them.</p>

<p>If there is more than one <code class="language-plaintext highlighter-rouge">END</code> statement, they are executed in the reverse of the order in which they are encountered—that is, the first one is executed last.</p>

<p>These statements are not commonly used in Ruby. They are inherited from Perl, which in turn inherited them from the awk text-processing language.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    BEGIN { # The curly braces are required
        # Global initialization code goes here
    }
    
    END {
        # Global shutdown code goes here
    }
</code></pre></div></div>

<h3 id="threads-fibers-and-continuations">Threads, Fibers, and Continuations</h3>

<ol>
  <li>
    <p>Threads for Concurrency</p>

    <p>A <em>thread of execution</em> is a sequence of Ruby statements that run (or apear to run) in parallel with the main sequence of statements that the interpreter is running.</p>

    <p>Threads are represented by <code class="language-plaintext highlighter-rouge">Thread</code> objects, but they can also be thought of as control structures for concurrency.</p>

    <p>Call <code class="language-plaintext highlighter-rouge">Thread.new</code> and associate a block with it to create new threads that will start running the code in the block.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> # This method expects an array of filenames.
 # It returns an array of strings holding the content of the named files.
 # The method creates one thread for each named file.
 def readfiles(filenames)
     # Create an array of threads from the array of filenames.
     # Each thread starts reading a file.
     threads = filenames.map do |f|
         Thread.new { File.read(f) }
     end
    
     # Now create an array of file contents by calling the value 
     # method of each thread. This method blocks, if necessary, 
     # until the thread exits with a value.
     threads.map {|t| t.value }
 end
</code></pre></div>    </div>
  </li>
  <li>
    <p>Fibers for Coroutines</p>

    <p>The name “fiber” has been used elsewhere for a kind of lightweight thread, but Ruby’s fibers are better described as <em>coroutines</em> or, more accurately, <em>semi-coroutines</em>.</p>

    <p>The most common use for coroutines is to implement <em>generators</em>: objects that can compute a partial result, <em>yield</em> the result back to the caller, and save the state of the computaiton so that the caller can <em>resume</em> that compuation to obtain the next result.</p>

    <p>In Ruby, the <code class="language-plaintext highlighter-rouge">Fiber</code> class is used to enable the automatic conversion of internal iterators, such as the <code class="language-plaintext highlighter-rouge">each</code> method, into enumerators or external iterators.</p>

    <p>Create a fiber with <code class="language-plaintext highlighter-rouge">Fiber.new</code>, and associate a block with it to specify the code that the fiber to run.</p>

    <p>Unlike a thread, the body of a fiber does not start executing right away.</p>

    <p>To run a fiber, call the <code class="language-plaintext highlighter-rouge">resume</code> method of the <code class="language-plaintext highlighter-rouge">Fiber</code> object that represent it.</p>

    <p>The first time <code class="language-plaintext highlighter-rouge">resume</code> is called on a fiber, control is transferred to the begining of the fiber body.</p>

    <p>That fiber then runs unitl it reachs the end of the body, or unitl it executes the class method <code class="language-plaintext highlighter-rouge">Fiber.yield</code>.</p>

    <p>The <code class="language-plaintext highlighter-rouge">Fiber.yield</code> method transfer control back to the caller and makes the call to <code class="language-plaintext highlighter-rouge">resume</code> return. It also saves the state of the fiber, so that the next call to <code class="language-plaintext highlighter-rouge">resume</code> makes the fiber pick up where it left off.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     f = Fiber.new {                 # Line 1: Create a new fiber
         puts "Fiber says Hello"     # Line 2:
         Fiber.yield                 # Line 3:
         puts "Fiber says Goodbye"   # Line 4: goto line 11
     }                               # Line 5:
                                     # Line 6:
     puts "Caller says Hello"        # Line 7:
     f.resume                        # Line 8: goto line 2
     puts "Caller says Goodbye"      # Line 9:
     f.resume                        # Line 10: goto line 4
                                     # Line 11:
</code></pre></div>    </div>

    <ul>
      <li>
        <p><strong>Fiber arguments and return values</strong></p>

        <p>Fibers and their callers can exchange data through the arguments and return values of <code class="language-plaintext highlighter-rouge">resume</code> and <code class="language-plaintext highlighter-rouge">yield</code>.</p>

        <p>The arguments to the first call to <code class="language-plaintext highlighter-rouge">resume</code> are passed to the block associated with the fiber: they become the values of the block parameters.</p>

        <p>On subsequent calls, the arguments to <code class="language-plaintext highlighter-rouge">resume</code> become the return value of <code class="language-plaintext highlighter-rouge">Fiber.yield</code>.</p>

        <p>Conversely, any arguments to <code class="language-plaintext highlighter-rouge">Fiber.yield</code> become the return value of <code class="language-plaintext highlighter-rouge">resume</code>.</p>

        <p>And when the block exits, the value of the <em>last expression</em> evaluated also becomes the return value of <em>resume</em>.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  f = Fiber.new do |message|
      puts "Caller said: #{message}" 
      message2 = Fiber.yield("Hello") # "Hello" returned by first resume
      puts "Caller said: #{message2}"
      "Fine"                          # "Fine" returned by second resume
  end
        
  response = f.resume("Hello")         # "Hello" passed to block
  puts "Fiber said: #{response}"
  response2 = f.resume("How are you?") # "How are you?" returned by Fiber.yield 
  puts "Fiber said: #{response2}"
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>Implementing generators with fibers</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class FibonacciGenerator
      def initialize
          @x,@y = 0,1
          @fiber = Fiber.new do
              loop do
                  @x,@y = @y, @x+@y
                  Fiber.yield @x
              end
          end
      end
        
      def next    # Return the next Fibonacci number
          @fiber.resume
      end
        
      def rewind  # Restart the sequence
          @x,@y = 0,1
      end
  end
        
  g = FibonacciGenerator.new     # Create a generator
  10.times { print g.next, " " } # Print first 10 numbers
  g.rewind; puts                 # Start over, on a new line
  10.times { print g.next, " " } # Print first 10 again
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>Continuations</p>
  </li>
</ol>

<p>A <code class="language-plaintext highlighter-rouge">continuation</code> is another complex and obscure control structure that most programmers will <em>never need to use</em>.</p>

<p>A <code class="language-plaintext highlighter-rouge">continuation</code> takes the form of the Kernel method callcc and the <code class="language-plaintext highlighter-rouge">Continuation</code> object.</p>

<p>Continuations are part of the core platformin Ruby 1.8, but they have been replaced by fibers and moved to the standard library in Ruby 1.9.</p>

<hr />

<h4 id="references">References</h4>

<ul>
  <li><a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177/ref=sr_1_1?ie=UTF8&amp;qid=1459784613&amp;sr=8-1&amp;keywords=The+Ruby+Programming+Language">The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto</a></li>
</ul>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
