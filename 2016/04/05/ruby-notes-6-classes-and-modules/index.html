<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ruby Notes 6 Classes and Modules | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Ruby Notes 6 Classes and Modules" />
<meta property="og:locale" content="en" />
<meta name="description" content="Classes can include—or inherit methods fom—modules. Ruby’s objects are strictly encapsulated: their state can be access only through the methods they define. Any Ruby program can add methods to existing classes, and it is even possible to add “singleton methods” to individual objects. Classes Defining a Simple Class class Point @@n = 0 # How many points have created @@totalX = 0 # The sum of all X coordinates @@totlalY = 0 # The sum of all Y coordinates def intialize(x,y) @x, @y = x, y @@n += 1 @@totalX += x @@totalY += y end ORIGIN = Point.new(0, 0) UNIT_X = Point.new(1, 0) UNIT_Y = Point.new(0, 1) def x @x end def x=(value) @x = value end def y @y end def y=(value) @y = value end def +(other) raise TypeError, &quot;Point argument expected&quot; unless other.is_a? Point Point.new(@x + other.x, @y + other.y) end def -(other) raise TypeError, &quot;Point argument expected&quot; unless other.is_a? Point Point.new(@x - other.x, @y - other.y) end def *(scalar) Point.new(@x*scalar, @y*scalar) end def [](index) case index when 0, -2: @x when 1, -1: @y when :x, &quot;x&quot;: @x when :y, &quot;y&quot;: @y else nil end end def each yield @x yield @y end def ==(o) @x == o.x &amp;&amp; @y == o.y rescue false end # alias eql? == # Often, we want eql? to work just like == operator. def eql?(o) if o.instance_of? Point @x.eql?(o.x) &amp;&amp; @y.eql?(o.y) elsif false end end def hash code = 17 code = 37*code + @x.hash code = 37*code + @y.hash code end def &lt;=&gt;(other) return nil unless other.instance_of? Point @x**2 + @y**2 &lt;=&gt; other.x**2 + other.y**2 end def self.sum(*points) # def Point.sum(*points) x = y = 0 points.each { |p| x += p.x; y += p.y } Point.new(x, y) end def to_s &quot;(#{@x},#{@y})&quot; end end Accessors and Attributes class Point def intialize(x,y) @x, @y = x, y end def x # The accessor (or getter) method for @x @x end def y # The accessor (or getter) method for @y @y end end class MutablePoint def initialize(x,y); @x, @y = x, y; end def x; @x; end # The getter method for @x def y; @y; end # The getter method for @y def x=(value) # The setter method for @x @x = value end def y=(value) # The setter method for @y @y = value end end p = Point.new(1,1) p.x = 0 p.y = 0 metaprogramming attr, attr_reader, and attr_accessor The attr_reader and attr_accessor methods are defined by Module class. Both methods take any number of symbols naming attributes. attr_reader creates trivial getter methods for the instance variables with the same name. attr_accessor creates getter and setter methods. class Point attr_accessor :x, :y # Define accessor methods for our instance variables end class Point attr_reader :x, :y # Define reader methods for our instance variable # attr_reader &quot;x&quot;, &quot;y&quot; Equivalently. end attr is a similar method with a shorted name as a synonym for attr_reader. attr :x # Define a trivial getter method x for @x attr :y, true # Define getter and setter methods for @y The attr, attr_reader, and attr_accessor methods create instance method for us (metaprogramming). Method Visibility: Public, Protected, Private Methods are normally public unless they are explicitly declared to be private or protected. The initialize method is always implicitly private. Global funcitons are defined as private instance methods of Object. A private method is internal to the implementation of a class, and it can only be called by other instance method of the class. Private methods are implicityly invoked on self, and may not be explicitly invoked on an object. A protected method is like a private method in that it can only be invoked from within the implementation of a calss or its subclasses. Protected methods may be explicitly invoked on any instance of the class, and it is not restricted to implicit invocation on self. Protected methods are the least commonly defined and also the most difficult to understand. Method visibility is declared with three methods named public, private, and protected. These are instance method of the Module class. All classes are modules, and inside a class definition (both outside method definitions), self refers to class being defined. class Point # public methods go here # The following methods are protected protected # protected methods go here # The following methods are private private # private methods go here end class Widget def x # Accessor method for @x @x end protected :x # Make it protected def utility_method # Define a method nil end private :utility_method # And make it private end Instance and class variables are encapsulated and effectively private, and constants are effectively public. There is no way to make an instance variable accessible from outside a class. And there is no way to define a constant that is inaccessible to outside use. private_class_method and public_class_method You can make a private class method private with private_class_method. private_class_method :new You can make a private class method public again with public_class_method. Subclassing and inheritance In Ruby 1.9, Object is no longer the root of the class hierarchy. A new class named BasicObject serves that purpose, and Object is a subclass of BasicObject. BasicObject is a very simple class, with almost no methods of its own, and is useful as the superclass of delegating wrapper classes. When you create a class in Ruby 1.9, you still extend Object unless you explicity specify the superclass, and most programmer will need to use or extend BasicObject. The syntax for extending a class is to add &lt; character and the name of the superclass to your class statement. class Point3D &lt; Point # Define class Point3D as a subclass of Point end Subclassing a Struct class Point3D &lt; Struct.new(&quot;Point3D&quot;, :x, :y, :z) # Superclass struct gives us acess method, ==, to_s, etc # Add point-specific methods here end Overriding Methods # Greet the World class WorldGreeter def greet # Display a greeting puts &quot;#{greeting} #{who}&quot; end def greeting # What greeting to use &quot;Hello&quot; end def who # Who to greet &quot;World&quot; end end # Greet the world in Spanish class SpanishWorldGreeter &lt; WorldGreeter def greeting # Override the greeting &quot;Hola&quot; end end # We call a mehtod defined in WorldGreeter, which calls the overriden # version of greeting in SpanishWorldGreeter, and prints &quot;Hola World&quot; SpanishWorldGreeter.new.greet abstract vs concrete # This class is abstract; it doesn&#39;t define greeting or who # No special syntax is required: any class that invokes methods that are # intended for a subclass to implement is abstract. class AbstractGreeter def greet puts &quot;#{greeting} #{who}&quot; end end # A concrete subclass class WorldGreeter &lt; AbstractGreeter def greeting; &quot;Hello&quot;; end def who; &quot;World&quot;; end end WorldGreeter.new.greet # Displays &quot;Hello World&quot; Overriding private methods Privates methods are inherited by subclass. Subclasses can invoke and override private methods. You should only subclass when you are familiar with the implementation of the superclass. Compositition &gt; Inheritance super super works like a special method invocation: it invokes a method with the same name as the current one, in the superclass of the current class. If you use super as a bare keyword—with no arguments and no parentheses—then all of the arguments that were passed to the current method are passed to the superclass method. class Point3D &lt; Point def initialize(x,y,z) # Pass our first two arguments along to the superclass initialize method super(x , y) # And deal with the third argument ourself @z = z; end end Inheritance of Class Methods Class methods may be inherited and overriden just as instance methods can be. As a stylistic matter, it is preferable to invoke class methods through the class object on which they are defined. Class methods can use super just as instance methods can to invoke the same-named method in the superclass. class Point def self.sum(*args) s = 0 args.each { |x| s += x } s end end class Point3D &lt; Point def self.sum(*args) puts &quot;Point3D&quot; super(*args) end end Inheritance and Instance Variables Inheritance variables often appear to be inherited in Ruby. class Point3D &lt; Point def initialize(x,y,z) super(x , y) @z = z; end def to_s &quot;(#@x, #@y, #@z)&quot; # Variables @x and @y inherited? end end Inheritance and Class Variables Class variables are shared by a class and all of its subclasses. Inheritance of Constants Constants are inherited can can be overriden, much like instance methods can. class Point ORGIN = Point.new 0, 0 def initialize(x, y) @x, @y = x, y end end class Point3D ORGIN = Point3D.new 0, 0, 0 def initialize(x, y, z) super x, y @z = z end end Object Creation and Intialization new, allocate, and intialize Every class inerits the class method new. new method has two jobs: it must allocate a new object—actually bring the object into existence—and it must intialize the object. The new metho would look something like this: def new(*args) o = self.allocate # Create a new object of this class o.intialize(*args) # Call the object&#39;s intialize method with our args o # Return new object; ignore return value of intialize end allocate allocate is an instance method of Class, and it is inherited by all class objects. Its purpose is to create a new instance of the class. You can call it yourself to create uninitialized instances of a class. But don’t try to override it; Ruby always inovkes this mehtod directly, ignoring any overriding versions you may have defined. initalize initialze is an instance method and usually to create instance variables for the obect and set them to their initial values. Ruby implicitly makes the initialize method private. Class::new and Class#new The class method Class::new is the Class class’ own version of the method, and it can be used to create new classes. Factory Methods class Point # Define an initialize method as usual... def initialize(x,y) # Expects Cartesian coordinates @x,@y = x,y end # But make the factory method new private private_class_method :new def Point.cartesian(x,y) # Factory method for Cartesian coordinates new(x,y) # We can still call new from other class methods end def Point.polar(r, theta) # Factory method for polar coordinates new(r*Math.cos(theta), r*Math.sin(theta)) end end dup,clone, and intialize_copy marshal_dump and marshal_load The Singleton Pattern require &#39;singleton&#39; # Singleton module is not built-in class PointSats # Define a class include Singleton # Make it as singleton def intialize # A normal initialization method @n, @totalX, @totalY = 0, 0.0, 0.0 end def record(point) # Record a new point @n += 1 @totalX += point.x @totalY += point.y end def report # Report point statistics puts &quot;Number of points created: #@n&quot; puts &quot;Average X coordinate: #{@totalX/@n}&quot; puts &quot;Average Y coordinate: #{@totalY/@n}&quot; end end class Point def initialize(x,y) @x, @y = x, y PointSats.instance.record(self) end end The Singleton module automatically creates the instance class method for us. PointSats.instance.report Modules Like a class, a module is a named group of methods, constants, and class variables. Modules stand alone; there is no “module hierarchy” of ineritance. Modules are used as namespaces and as mixins. Modules as Namespaces Modules are a good way to group related methods when object-oriented programming is not necessary. def base64_encode end def base64_decode end To define the two methods within a Base64 module to prevent namespace collisions. module Base64 # Note the module names must begin with a capital letter. def self.encode # def Base64.encode end def self.decode # def Base64.decode end Modules may also contain constants. module Base64 DIGITS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; \ &#39;abcdefghijklmnopqrstuvwxyz&#39; \ &#39; 0123456789+/ &#39; end Outside the Base64 module, this constant can be referred to as Base64::DIGITS. If the two methods had some need to share nonconstant data, they could use a class variable (with a @@ prefix), just as they could if they were defined in class. Nested namespaces Modules, including classes, may be nested. This creates nested namespaces but has no other effect: a class or module nested within another has no special access to the class or module it is nested within. module Base64 DIGITS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39; class Encoder def encode end end class Decoder def decode end end # A utility function for use by both classes def Base64.helper end end By structuring our code this way, we’ve defined two new classes, Base64::Encoder and Base64::Decoder. Inside the Base64 module, the two classes can refer to each other by their unqualified names, without the Base64 prefix. And each of the classes can use the DIGITS constant without a prefix. Modules As Mixins If a module defines instance methods instead of the class methods, those instance methods can be mixed in to other classes. Enumerable and Comparable are well-known examples of mixin modules. Enumerable defines useful iterators that are implemented in terms of an each iterator. Enumerable doesn’t define the each mehtod itself, but any class that defines it can mix in the Enumerable module to instantly add many useful iterators. And class that defines &lt;=&gt; can be mixed in Comparable to get &lt;,&lt;=,==,&gt;=, and between? for free. To mix a module into a class, use include. class Point include Comparable end In fact, it is a private instance method of Module, implicitly invoked on self—the class into which the module is being included. The inclusion of a module affects the type-checking method is_a? and the switch-equality operator ===. &quot;text&quot;.is_a? Comparable # =&gt; true Enumerable === &quot;text&quot; # =&gt; true in Ruby 1.8, false in 1.9 Note the instance_of? only checks the class of its receiver, not superclasses or modules, so the following is false. &quot;text&quot;.instance_of? Comparable # =&gt; false The normal way to mix in a module is with the `Module.include` method. Another way is with `Object.extend`. This method makes the instance methods of the specified module or modules into singleton methods of the receiver object. (And if the receiver object is a Class instance, then the methods of the receiver become class methods of that class.) countdown = Object.new # A plain old object def countdown.each # The each iterator as a singleton mehtod yield 3 yield 2 yield 1 end countdown.extend(Enumerable) # Now the object has all Enumerable methods print countdown.sort # Prints &quot;[1, 2, 3]&quot; Includable Namespace Modules It is possible to define modules that define a namespace but still allow their methods to be mixed in. Math.sin(0) # =&gt; 0.0: Math is a namespace include &#39;Math&#39; # The Math namespace can be included sin(0) # =&gt; 0.0: Now we have easy access to the functions The Kernel module also works like this: we can invoke its methods through the Kernel namespace, or as private method of Object, into which it is included. If you want to create a module like Math or Kernel, define your methods as instance methods of the module. Then use module_function to convert those methods to “module functions”. module_funciton is a private instance method of Module, much like the public, protected, and private methods. It accepts any number of method names (as symbols or strings) as arguments. The primary effect of calling module_function is that it makes class method copies of the specified methods. A secondary effect is that it makes the instance methods private. Like the public, protected, and private methods, the module_funciton mehtod can also be invoked with no arguments. When invoked in this way, any instance methods subsequently defined in the module will be modue funciton: they will become public class methods and private instance methods. Loading and Requiring Modules Ruby programs may be broken up into multiple files, and the most natural way to partition a program is to place each nontrivial class or module into a separate file. These separate files can then be reassembled into a single program (and, if well-designed, can be reused by other programs) using require or load which are global functions defined in Kernel, but are used like language keywords. If the file to load is specified with an absolute path, or is relative to ~ (the user’s home directory), then that specific file is loaded. Usually, however, the file is specified as a relative path, and load and require search for it relative to the directories of Ruby’s load path. load, require andrequire_relative In addition to loading source code, require can also load binary extensions to Ruby. Binary extensions are, of course, implementation-dependent, but in C-based implementations, they typically take the form of shared library files with extension like .so or .dll. load expects a complete filename including an extension. require is usually passed a library name, with no extension, rather than a filename. In that case, it searchs for a file that has the library name as its base name and an approriate source or native library extension. If a direcotry contains both an .rb source file and a binary extension file, require will load the source file instead of the binary file. load can load the same file multiple times. require tries to prevent multiple loads of the same file. require keeps track of the files that have been loaded by appending them to the global array $&quot; (also known as $LOAD_FEATURES). load loads the specified file at the current $SAFE level. require loads the specified library with $SAFE set to 0, even if the code that called require has a higher value for that variable. require_relative, a special version of require, searchs and loads file from the current direcotry. The Load Path Ruby’s load path is an array that you can access using either of the global variables $LOAD_PATH or $:. Each element of the array is the name of a direcotry that Ruby will search for files to load. Direcotories at the start of the array are searched before direcotories at the end of the array. The elements of $LOAD_PATH must be strings in Ruby 1.8, but in Ruby 1.9, they may be strings or any object that has a to_path method that returns a string. Executing Loaded Code load and require execute the code in the specified file immediately. Files loaded with load or require are executed in a new top-level scope that is different from the one in which load or require was invoked. The loaded file can see all global variables and constants that have been defined at the time it is loaded, but it does not have access to the local scope from which the load was initiated. The local variables defined in the scope from which load or require is invoked are not visible to the loaded file. Any local variables created by the loaded file are discarded once the load is complete; they are never visible outside the file in which they are defined. At the start of the loaded file, the value of self is always the main object, just as it is when the Ruby interpreter starts running. The current module nesting is ignored within the loaded file. You cannot, for example, open a class and then load a file of method definitions. The file will be processed in a top-level socpe, not inside any class or module. Autoloading Modules The autoload methods of Kernel and Module allow lazy loading of files on an as-needed basis. The global autoload function allows you to register the name of an undefined constant (typically a class or module name) and a name of the library that defines it. When that constant is first referenced, the named library is loaded using require. For example: # Require &#39;socket&#39; if and when the TCPSocket is first used autoload :TCPSocket, &quot;socket&quot; The Module class defines its own version of autoload to work with constants nested within another module. Singleton Methods and the Eigenclass To define a singleton method sum on an object Point, we’d write: def Point.sum # Method body goes here end The singleton methods of an object are instance methods of the anonymous eigenchass associated with that object. “Eigen” is a German word meaning (roughly) “self”, “own”, “particular to,” or “characteristic of.” The eigenclass is also called the singleton class or the metaclass. Ruby defines a syntax for opening the eigenclass of an object and adding methods to it thats provides an alternative to defining singleton methods one by one. To open the eigenclass of the object o, use class « o. For example, we can define class methods of Point like this: class &lt;&lt; Point def class_method1 # This is an instance method of the eigenclass. end def class_method2 end end Method Lookup When Ruby evaluates a method invocation expression, it must first figure out which method is to be invoked. The process for doing this is called method lookup or method name resolution. For the method invocation expression o.m, Ruby performs name resolution with the following steps: First, it checks the eigenclass of o for singleton methods named m. If no method m is found in the eigenclass, Ruby searchs the class of o for an instance method named m. If no method m is found in the class, Ruby searchs the instance methods of any modules included by the class of o. If that class includes more than one module, then the most recently included module is searched first. If no instance method m is found in the class of o or in its modules, then the search moves up the inheritance hierarchy to the superclass. If no method named m is found after completing the search, then a method named method_missing is invoked instead. In order to find an appropriate definitions of this method, the name resolution algorith starts over at step 1. The Kernel module provides a default implementation of method_missing. What it does is raise an exception of NoMethodError. The name resolution algorithm for class methods is exactly the same as it is for instance method. Constant Lookup When a constant is referenced without any qualifying namespace, the Ruby interpreter must find the appropriate definition of the constant. Ruby first attempts to resolve a constant reference in the lexical scope of the reference. This means that it first checks the class or module that encloses the constant reference to see if that class or module defines the constant. If not, it checks the next enclosing class or module. This continues untils there are no more enclosing classes or modules. Note that top-level or “global” constants are not considered part of the lexical scope and are not considered during this part of constant lookup. The class method Module.nesting returns the list of clases and modules that are searched in this step, in the order they are searched. If no constant definition is foud in the lexically enclosing scope, Ruby next tries to resolve the constant in the inheritance hierarchy by checking the ancesstors of the class or module that referred to the constant. The ancestors method of the containing class or module returns the list of classes and modules searched in this step. If no constant definition is found in the inheritance hierarchy, then top-level constant definitions are checked. If no definition can be found for the desired constant, then the const_missing method—if there is one—of the containing class or module is called and given the opportunity to provide a value for the constant. A few points about this constant lookup algorithm. Constants defined in enclosing modules are found in preference to constants defined in included modules. The modules included by a class are searched before the superclass of the class. The Object class is part of the inheritance hierarchy of all classes. The Kernel module is an ancestor of Object. module Kernel # Constants defined in Kernel A = B = C = D = E = F = &quot;defined in Kernel&quot; end # Top-level or &quot;global&quot; constants defined in Object A = B = C = D = E = &quot;defined at Top-level&quot; class Super A = B = C = D = &quot;defined in superclass&quot; end module Included # Constants defined in an included module A = B = C = &quot;defined in included module&quot; end module Enclosing # Constants defined in an enclosing module A = B = &quot;defined in enclosing module&quot; class Local &lt; Super include Included # Locally defined constant A = &quot;defined locally&quot; # The list of modules searched, in the order searched # [Enclosing::Local, Enclosing, Inclued, Super, Object, Kernel] search = (Module.nesting + self.ancestors + Object.ancestors).uniq puts A # Prints &quot;defined locally&quot; puts B # Prints &quot;defined in enclosing module&quot; puts C # Prints &quot;defined in included module&quot; puts D # Prints &quot;defined in superclass&quot; puts E # Prints &quot;defined at toplevel&quot; puts F # Prints &quot;defined in kernel&quot; end end References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto" />
<meta property="og:description" content="Classes can include—or inherit methods fom—modules. Ruby’s objects are strictly encapsulated: their state can be access only through the methods they define. Any Ruby program can add methods to existing classes, and it is even possible to add “singleton methods” to individual objects. Classes Defining a Simple Class class Point @@n = 0 # How many points have created @@totalX = 0 # The sum of all X coordinates @@totlalY = 0 # The sum of all Y coordinates def intialize(x,y) @x, @y = x, y @@n += 1 @@totalX += x @@totalY += y end ORIGIN = Point.new(0, 0) UNIT_X = Point.new(1, 0) UNIT_Y = Point.new(0, 1) def x @x end def x=(value) @x = value end def y @y end def y=(value) @y = value end def +(other) raise TypeError, &quot;Point argument expected&quot; unless other.is_a? Point Point.new(@x + other.x, @y + other.y) end def -(other) raise TypeError, &quot;Point argument expected&quot; unless other.is_a? Point Point.new(@x - other.x, @y - other.y) end def *(scalar) Point.new(@x*scalar, @y*scalar) end def [](index) case index when 0, -2: @x when 1, -1: @y when :x, &quot;x&quot;: @x when :y, &quot;y&quot;: @y else nil end end def each yield @x yield @y end def ==(o) @x == o.x &amp;&amp; @y == o.y rescue false end # alias eql? == # Often, we want eql? to work just like == operator. def eql?(o) if o.instance_of? Point @x.eql?(o.x) &amp;&amp; @y.eql?(o.y) elsif false end end def hash code = 17 code = 37*code + @x.hash code = 37*code + @y.hash code end def &lt;=&gt;(other) return nil unless other.instance_of? Point @x**2 + @y**2 &lt;=&gt; other.x**2 + other.y**2 end def self.sum(*points) # def Point.sum(*points) x = y = 0 points.each { |p| x += p.x; y += p.y } Point.new(x, y) end def to_s &quot;(#{@x},#{@y})&quot; end end Accessors and Attributes class Point def intialize(x,y) @x, @y = x, y end def x # The accessor (or getter) method for @x @x end def y # The accessor (or getter) method for @y @y end end class MutablePoint def initialize(x,y); @x, @y = x, y; end def x; @x; end # The getter method for @x def y; @y; end # The getter method for @y def x=(value) # The setter method for @x @x = value end def y=(value) # The setter method for @y @y = value end end p = Point.new(1,1) p.x = 0 p.y = 0 metaprogramming attr, attr_reader, and attr_accessor The attr_reader and attr_accessor methods are defined by Module class. Both methods take any number of symbols naming attributes. attr_reader creates trivial getter methods for the instance variables with the same name. attr_accessor creates getter and setter methods. class Point attr_accessor :x, :y # Define accessor methods for our instance variables end class Point attr_reader :x, :y # Define reader methods for our instance variable # attr_reader &quot;x&quot;, &quot;y&quot; Equivalently. end attr is a similar method with a shorted name as a synonym for attr_reader. attr :x # Define a trivial getter method x for @x attr :y, true # Define getter and setter methods for @y The attr, attr_reader, and attr_accessor methods create instance method for us (metaprogramming). Method Visibility: Public, Protected, Private Methods are normally public unless they are explicitly declared to be private or protected. The initialize method is always implicitly private. Global funcitons are defined as private instance methods of Object. A private method is internal to the implementation of a class, and it can only be called by other instance method of the class. Private methods are implicityly invoked on self, and may not be explicitly invoked on an object. A protected method is like a private method in that it can only be invoked from within the implementation of a calss or its subclasses. Protected methods may be explicitly invoked on any instance of the class, and it is not restricted to implicit invocation on self. Protected methods are the least commonly defined and also the most difficult to understand. Method visibility is declared with three methods named public, private, and protected. These are instance method of the Module class. All classes are modules, and inside a class definition (both outside method definitions), self refers to class being defined. class Point # public methods go here # The following methods are protected protected # protected methods go here # The following methods are private private # private methods go here end class Widget def x # Accessor method for @x @x end protected :x # Make it protected def utility_method # Define a method nil end private :utility_method # And make it private end Instance and class variables are encapsulated and effectively private, and constants are effectively public. There is no way to make an instance variable accessible from outside a class. And there is no way to define a constant that is inaccessible to outside use. private_class_method and public_class_method You can make a private class method private with private_class_method. private_class_method :new You can make a private class method public again with public_class_method. Subclassing and inheritance In Ruby 1.9, Object is no longer the root of the class hierarchy. A new class named BasicObject serves that purpose, and Object is a subclass of BasicObject. BasicObject is a very simple class, with almost no methods of its own, and is useful as the superclass of delegating wrapper classes. When you create a class in Ruby 1.9, you still extend Object unless you explicity specify the superclass, and most programmer will need to use or extend BasicObject. The syntax for extending a class is to add &lt; character and the name of the superclass to your class statement. class Point3D &lt; Point # Define class Point3D as a subclass of Point end Subclassing a Struct class Point3D &lt; Struct.new(&quot;Point3D&quot;, :x, :y, :z) # Superclass struct gives us acess method, ==, to_s, etc # Add point-specific methods here end Overriding Methods # Greet the World class WorldGreeter def greet # Display a greeting puts &quot;#{greeting} #{who}&quot; end def greeting # What greeting to use &quot;Hello&quot; end def who # Who to greet &quot;World&quot; end end # Greet the world in Spanish class SpanishWorldGreeter &lt; WorldGreeter def greeting # Override the greeting &quot;Hola&quot; end end # We call a mehtod defined in WorldGreeter, which calls the overriden # version of greeting in SpanishWorldGreeter, and prints &quot;Hola World&quot; SpanishWorldGreeter.new.greet abstract vs concrete # This class is abstract; it doesn&#39;t define greeting or who # No special syntax is required: any class that invokes methods that are # intended for a subclass to implement is abstract. class AbstractGreeter def greet puts &quot;#{greeting} #{who}&quot; end end # A concrete subclass class WorldGreeter &lt; AbstractGreeter def greeting; &quot;Hello&quot;; end def who; &quot;World&quot;; end end WorldGreeter.new.greet # Displays &quot;Hello World&quot; Overriding private methods Privates methods are inherited by subclass. Subclasses can invoke and override private methods. You should only subclass when you are familiar with the implementation of the superclass. Compositition &gt; Inheritance super super works like a special method invocation: it invokes a method with the same name as the current one, in the superclass of the current class. If you use super as a bare keyword—with no arguments and no parentheses—then all of the arguments that were passed to the current method are passed to the superclass method. class Point3D &lt; Point def initialize(x,y,z) # Pass our first two arguments along to the superclass initialize method super(x , y) # And deal with the third argument ourself @z = z; end end Inheritance of Class Methods Class methods may be inherited and overriden just as instance methods can be. As a stylistic matter, it is preferable to invoke class methods through the class object on which they are defined. Class methods can use super just as instance methods can to invoke the same-named method in the superclass. class Point def self.sum(*args) s = 0 args.each { |x| s += x } s end end class Point3D &lt; Point def self.sum(*args) puts &quot;Point3D&quot; super(*args) end end Inheritance and Instance Variables Inheritance variables often appear to be inherited in Ruby. class Point3D &lt; Point def initialize(x,y,z) super(x , y) @z = z; end def to_s &quot;(#@x, #@y, #@z)&quot; # Variables @x and @y inherited? end end Inheritance and Class Variables Class variables are shared by a class and all of its subclasses. Inheritance of Constants Constants are inherited can can be overriden, much like instance methods can. class Point ORGIN = Point.new 0, 0 def initialize(x, y) @x, @y = x, y end end class Point3D ORGIN = Point3D.new 0, 0, 0 def initialize(x, y, z) super x, y @z = z end end Object Creation and Intialization new, allocate, and intialize Every class inerits the class method new. new method has two jobs: it must allocate a new object—actually bring the object into existence—and it must intialize the object. The new metho would look something like this: def new(*args) o = self.allocate # Create a new object of this class o.intialize(*args) # Call the object&#39;s intialize method with our args o # Return new object; ignore return value of intialize end allocate allocate is an instance method of Class, and it is inherited by all class objects. Its purpose is to create a new instance of the class. You can call it yourself to create uninitialized instances of a class. But don’t try to override it; Ruby always inovkes this mehtod directly, ignoring any overriding versions you may have defined. initalize initialze is an instance method and usually to create instance variables for the obect and set them to their initial values. Ruby implicitly makes the initialize method private. Class::new and Class#new The class method Class::new is the Class class’ own version of the method, and it can be used to create new classes. Factory Methods class Point # Define an initialize method as usual... def initialize(x,y) # Expects Cartesian coordinates @x,@y = x,y end # But make the factory method new private private_class_method :new def Point.cartesian(x,y) # Factory method for Cartesian coordinates new(x,y) # We can still call new from other class methods end def Point.polar(r, theta) # Factory method for polar coordinates new(r*Math.cos(theta), r*Math.sin(theta)) end end dup,clone, and intialize_copy marshal_dump and marshal_load The Singleton Pattern require &#39;singleton&#39; # Singleton module is not built-in class PointSats # Define a class include Singleton # Make it as singleton def intialize # A normal initialization method @n, @totalX, @totalY = 0, 0.0, 0.0 end def record(point) # Record a new point @n += 1 @totalX += point.x @totalY += point.y end def report # Report point statistics puts &quot;Number of points created: #@n&quot; puts &quot;Average X coordinate: #{@totalX/@n}&quot; puts &quot;Average Y coordinate: #{@totalY/@n}&quot; end end class Point def initialize(x,y) @x, @y = x, y PointSats.instance.record(self) end end The Singleton module automatically creates the instance class method for us. PointSats.instance.report Modules Like a class, a module is a named group of methods, constants, and class variables. Modules stand alone; there is no “module hierarchy” of ineritance. Modules are used as namespaces and as mixins. Modules as Namespaces Modules are a good way to group related methods when object-oriented programming is not necessary. def base64_encode end def base64_decode end To define the two methods within a Base64 module to prevent namespace collisions. module Base64 # Note the module names must begin with a capital letter. def self.encode # def Base64.encode end def self.decode # def Base64.decode end Modules may also contain constants. module Base64 DIGITS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; \ &#39;abcdefghijklmnopqrstuvwxyz&#39; \ &#39; 0123456789+/ &#39; end Outside the Base64 module, this constant can be referred to as Base64::DIGITS. If the two methods had some need to share nonconstant data, they could use a class variable (with a @@ prefix), just as they could if they were defined in class. Nested namespaces Modules, including classes, may be nested. This creates nested namespaces but has no other effect: a class or module nested within another has no special access to the class or module it is nested within. module Base64 DIGITS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39; class Encoder def encode end end class Decoder def decode end end # A utility function for use by both classes def Base64.helper end end By structuring our code this way, we’ve defined two new classes, Base64::Encoder and Base64::Decoder. Inside the Base64 module, the two classes can refer to each other by their unqualified names, without the Base64 prefix. And each of the classes can use the DIGITS constant without a prefix. Modules As Mixins If a module defines instance methods instead of the class methods, those instance methods can be mixed in to other classes. Enumerable and Comparable are well-known examples of mixin modules. Enumerable defines useful iterators that are implemented in terms of an each iterator. Enumerable doesn’t define the each mehtod itself, but any class that defines it can mix in the Enumerable module to instantly add many useful iterators. And class that defines &lt;=&gt; can be mixed in Comparable to get &lt;,&lt;=,==,&gt;=, and between? for free. To mix a module into a class, use include. class Point include Comparable end In fact, it is a private instance method of Module, implicitly invoked on self—the class into which the module is being included. The inclusion of a module affects the type-checking method is_a? and the switch-equality operator ===. &quot;text&quot;.is_a? Comparable # =&gt; true Enumerable === &quot;text&quot; # =&gt; true in Ruby 1.8, false in 1.9 Note the instance_of? only checks the class of its receiver, not superclasses or modules, so the following is false. &quot;text&quot;.instance_of? Comparable # =&gt; false The normal way to mix in a module is with the `Module.include` method. Another way is with `Object.extend`. This method makes the instance methods of the specified module or modules into singleton methods of the receiver object. (And if the receiver object is a Class instance, then the methods of the receiver become class methods of that class.) countdown = Object.new # A plain old object def countdown.each # The each iterator as a singleton mehtod yield 3 yield 2 yield 1 end countdown.extend(Enumerable) # Now the object has all Enumerable methods print countdown.sort # Prints &quot;[1, 2, 3]&quot; Includable Namespace Modules It is possible to define modules that define a namespace but still allow their methods to be mixed in. Math.sin(0) # =&gt; 0.0: Math is a namespace include &#39;Math&#39; # The Math namespace can be included sin(0) # =&gt; 0.0: Now we have easy access to the functions The Kernel module also works like this: we can invoke its methods through the Kernel namespace, or as private method of Object, into which it is included. If you want to create a module like Math or Kernel, define your methods as instance methods of the module. Then use module_function to convert those methods to “module functions”. module_funciton is a private instance method of Module, much like the public, protected, and private methods. It accepts any number of method names (as symbols or strings) as arguments. The primary effect of calling module_function is that it makes class method copies of the specified methods. A secondary effect is that it makes the instance methods private. Like the public, protected, and private methods, the module_funciton mehtod can also be invoked with no arguments. When invoked in this way, any instance methods subsequently defined in the module will be modue funciton: they will become public class methods and private instance methods. Loading and Requiring Modules Ruby programs may be broken up into multiple files, and the most natural way to partition a program is to place each nontrivial class or module into a separate file. These separate files can then be reassembled into a single program (and, if well-designed, can be reused by other programs) using require or load which are global functions defined in Kernel, but are used like language keywords. If the file to load is specified with an absolute path, or is relative to ~ (the user’s home directory), then that specific file is loaded. Usually, however, the file is specified as a relative path, and load and require search for it relative to the directories of Ruby’s load path. load, require andrequire_relative In addition to loading source code, require can also load binary extensions to Ruby. Binary extensions are, of course, implementation-dependent, but in C-based implementations, they typically take the form of shared library files with extension like .so or .dll. load expects a complete filename including an extension. require is usually passed a library name, with no extension, rather than a filename. In that case, it searchs for a file that has the library name as its base name and an approriate source or native library extension. If a direcotry contains both an .rb source file and a binary extension file, require will load the source file instead of the binary file. load can load the same file multiple times. require tries to prevent multiple loads of the same file. require keeps track of the files that have been loaded by appending them to the global array $&quot; (also known as $LOAD_FEATURES). load loads the specified file at the current $SAFE level. require loads the specified library with $SAFE set to 0, even if the code that called require has a higher value for that variable. require_relative, a special version of require, searchs and loads file from the current direcotry. The Load Path Ruby’s load path is an array that you can access using either of the global variables $LOAD_PATH or $:. Each element of the array is the name of a direcotry that Ruby will search for files to load. Direcotories at the start of the array are searched before direcotories at the end of the array. The elements of $LOAD_PATH must be strings in Ruby 1.8, but in Ruby 1.9, they may be strings or any object that has a to_path method that returns a string. Executing Loaded Code load and require execute the code in the specified file immediately. Files loaded with load or require are executed in a new top-level scope that is different from the one in which load or require was invoked. The loaded file can see all global variables and constants that have been defined at the time it is loaded, but it does not have access to the local scope from which the load was initiated. The local variables defined in the scope from which load or require is invoked are not visible to the loaded file. Any local variables created by the loaded file are discarded once the load is complete; they are never visible outside the file in which they are defined. At the start of the loaded file, the value of self is always the main object, just as it is when the Ruby interpreter starts running. The current module nesting is ignored within the loaded file. You cannot, for example, open a class and then load a file of method definitions. The file will be processed in a top-level socpe, not inside any class or module. Autoloading Modules The autoload methods of Kernel and Module allow lazy loading of files on an as-needed basis. The global autoload function allows you to register the name of an undefined constant (typically a class or module name) and a name of the library that defines it. When that constant is first referenced, the named library is loaded using require. For example: # Require &#39;socket&#39; if and when the TCPSocket is first used autoload :TCPSocket, &quot;socket&quot; The Module class defines its own version of autoload to work with constants nested within another module. Singleton Methods and the Eigenclass To define a singleton method sum on an object Point, we’d write: def Point.sum # Method body goes here end The singleton methods of an object are instance methods of the anonymous eigenchass associated with that object. “Eigen” is a German word meaning (roughly) “self”, “own”, “particular to,” or “characteristic of.” The eigenclass is also called the singleton class or the metaclass. Ruby defines a syntax for opening the eigenclass of an object and adding methods to it thats provides an alternative to defining singleton methods one by one. To open the eigenclass of the object o, use class « o. For example, we can define class methods of Point like this: class &lt;&lt; Point def class_method1 # This is an instance method of the eigenclass. end def class_method2 end end Method Lookup When Ruby evaluates a method invocation expression, it must first figure out which method is to be invoked. The process for doing this is called method lookup or method name resolution. For the method invocation expression o.m, Ruby performs name resolution with the following steps: First, it checks the eigenclass of o for singleton methods named m. If no method m is found in the eigenclass, Ruby searchs the class of o for an instance method named m. If no method m is found in the class, Ruby searchs the instance methods of any modules included by the class of o. If that class includes more than one module, then the most recently included module is searched first. If no instance method m is found in the class of o or in its modules, then the search moves up the inheritance hierarchy to the superclass. If no method named m is found after completing the search, then a method named method_missing is invoked instead. In order to find an appropriate definitions of this method, the name resolution algorith starts over at step 1. The Kernel module provides a default implementation of method_missing. What it does is raise an exception of NoMethodError. The name resolution algorithm for class methods is exactly the same as it is for instance method. Constant Lookup When a constant is referenced without any qualifying namespace, the Ruby interpreter must find the appropriate definition of the constant. Ruby first attempts to resolve a constant reference in the lexical scope of the reference. This means that it first checks the class or module that encloses the constant reference to see if that class or module defines the constant. If not, it checks the next enclosing class or module. This continues untils there are no more enclosing classes or modules. Note that top-level or “global” constants are not considered part of the lexical scope and are not considered during this part of constant lookup. The class method Module.nesting returns the list of clases and modules that are searched in this step, in the order they are searched. If no constant definition is foud in the lexically enclosing scope, Ruby next tries to resolve the constant in the inheritance hierarchy by checking the ancesstors of the class or module that referred to the constant. The ancestors method of the containing class or module returns the list of classes and modules searched in this step. If no constant definition is found in the inheritance hierarchy, then top-level constant definitions are checked. If no definition can be found for the desired constant, then the const_missing method—if there is one—of the containing class or module is called and given the opportunity to provide a value for the constant. A few points about this constant lookup algorithm. Constants defined in enclosing modules are found in preference to constants defined in included modules. The modules included by a class are searched before the superclass of the class. The Object class is part of the inheritance hierarchy of all classes. The Kernel module is an ancestor of Object. module Kernel # Constants defined in Kernel A = B = C = D = E = F = &quot;defined in Kernel&quot; end # Top-level or &quot;global&quot; constants defined in Object A = B = C = D = E = &quot;defined at Top-level&quot; class Super A = B = C = D = &quot;defined in superclass&quot; end module Included # Constants defined in an included module A = B = C = &quot;defined in included module&quot; end module Enclosing # Constants defined in an enclosing module A = B = &quot;defined in enclosing module&quot; class Local &lt; Super include Included # Locally defined constant A = &quot;defined locally&quot; # The list of modules searched, in the order searched # [Enclosing::Local, Enclosing, Inclued, Super, Object, Kernel] search = (Module.nesting + self.ancestors + Object.ancestors).uniq puts A # Prints &quot;defined locally&quot; puts B # Prints &quot;defined in enclosing module&quot; puts C # Prints &quot;defined in included module&quot; puts D # Prints &quot;defined in superclass&quot; puts E # Prints &quot;defined at toplevel&quot; puts F # Prints &quot;defined in kernel&quot; end end References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto" />
<link rel="canonical" href="https://blog.codefarm.me/2016/04/05/ruby-notes-6-classes-and-modules/" />
<meta property="og:url" content="https://blog.codefarm.me/2016/04/05/ruby-notes-6-classes-and-modules/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-04-05T13:04:35+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ruby Notes 6 Classes and Modules" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-04-05T13:04:35+08:00","datePublished":"2016-04-05T13:04:35+08:00","description":"Classes can include—or inherit methods fom—modules. Ruby’s objects are strictly encapsulated: their state can be access only through the methods they define. Any Ruby program can add methods to existing classes, and it is even possible to add “singleton methods” to individual objects. Classes Defining a Simple Class class Point @@n = 0 # How many points have created @@totalX = 0 # The sum of all X coordinates @@totlalY = 0 # The sum of all Y coordinates def intialize(x,y) @x, @y = x, y @@n += 1 @@totalX += x @@totalY += y end ORIGIN = Point.new(0, 0) UNIT_X = Point.new(1, 0) UNIT_Y = Point.new(0, 1) def x @x end def x=(value) @x = value end def y @y end def y=(value) @y = value end def +(other) raise TypeError, &quot;Point argument expected&quot; unless other.is_a? Point Point.new(@x + other.x, @y + other.y) end def -(other) raise TypeError, &quot;Point argument expected&quot; unless other.is_a? Point Point.new(@x - other.x, @y - other.y) end def *(scalar) Point.new(@x*scalar, @y*scalar) end def [](index) case index when 0, -2: @x when 1, -1: @y when :x, &quot;x&quot;: @x when :y, &quot;y&quot;: @y else nil end end def each yield @x yield @y end def ==(o) @x == o.x &amp;&amp; @y == o.y rescue false end # alias eql? == # Often, we want eql? to work just like == operator. def eql?(o) if o.instance_of? Point @x.eql?(o.x) &amp;&amp; @y.eql?(o.y) elsif false end end def hash code = 17 code = 37*code + @x.hash code = 37*code + @y.hash code end def &lt;=&gt;(other) return nil unless other.instance_of? Point @x**2 + @y**2 &lt;=&gt; other.x**2 + other.y**2 end def self.sum(*points) # def Point.sum(*points) x = y = 0 points.each { |p| x += p.x; y += p.y } Point.new(x, y) end def to_s &quot;(#{@x},#{@y})&quot; end end Accessors and Attributes class Point def intialize(x,y) @x, @y = x, y end def x # The accessor (or getter) method for @x @x end def y # The accessor (or getter) method for @y @y end end class MutablePoint def initialize(x,y); @x, @y = x, y; end def x; @x; end # The getter method for @x def y; @y; end # The getter method for @y def x=(value) # The setter method for @x @x = value end def y=(value) # The setter method for @y @y = value end end p = Point.new(1,1) p.x = 0 p.y = 0 metaprogramming attr, attr_reader, and attr_accessor The attr_reader and attr_accessor methods are defined by Module class. Both methods take any number of symbols naming attributes. attr_reader creates trivial getter methods for the instance variables with the same name. attr_accessor creates getter and setter methods. class Point attr_accessor :x, :y # Define accessor methods for our instance variables end class Point attr_reader :x, :y # Define reader methods for our instance variable # attr_reader &quot;x&quot;, &quot;y&quot; Equivalently. end attr is a similar method with a shorted name as a synonym for attr_reader. attr :x # Define a trivial getter method x for @x attr :y, true # Define getter and setter methods for @y The attr, attr_reader, and attr_accessor methods create instance method for us (metaprogramming). Method Visibility: Public, Protected, Private Methods are normally public unless they are explicitly declared to be private or protected. The initialize method is always implicitly private. Global funcitons are defined as private instance methods of Object. A private method is internal to the implementation of a class, and it can only be called by other instance method of the class. Private methods are implicityly invoked on self, and may not be explicitly invoked on an object. A protected method is like a private method in that it can only be invoked from within the implementation of a calss or its subclasses. Protected methods may be explicitly invoked on any instance of the class, and it is not restricted to implicit invocation on self. Protected methods are the least commonly defined and also the most difficult to understand. Method visibility is declared with three methods named public, private, and protected. These are instance method of the Module class. All classes are modules, and inside a class definition (both outside method definitions), self refers to class being defined. class Point # public methods go here # The following methods are protected protected # protected methods go here # The following methods are private private # private methods go here end class Widget def x # Accessor method for @x @x end protected :x # Make it protected def utility_method # Define a method nil end private :utility_method # And make it private end Instance and class variables are encapsulated and effectively private, and constants are effectively public. There is no way to make an instance variable accessible from outside a class. And there is no way to define a constant that is inaccessible to outside use. private_class_method and public_class_method You can make a private class method private with private_class_method. private_class_method :new You can make a private class method public again with public_class_method. Subclassing and inheritance In Ruby 1.9, Object is no longer the root of the class hierarchy. A new class named BasicObject serves that purpose, and Object is a subclass of BasicObject. BasicObject is a very simple class, with almost no methods of its own, and is useful as the superclass of delegating wrapper classes. When you create a class in Ruby 1.9, you still extend Object unless you explicity specify the superclass, and most programmer will need to use or extend BasicObject. The syntax for extending a class is to add &lt; character and the name of the superclass to your class statement. class Point3D &lt; Point # Define class Point3D as a subclass of Point end Subclassing a Struct class Point3D &lt; Struct.new(&quot;Point3D&quot;, :x, :y, :z) # Superclass struct gives us acess method, ==, to_s, etc # Add point-specific methods here end Overriding Methods # Greet the World class WorldGreeter def greet # Display a greeting puts &quot;#{greeting} #{who}&quot; end def greeting # What greeting to use &quot;Hello&quot; end def who # Who to greet &quot;World&quot; end end # Greet the world in Spanish class SpanishWorldGreeter &lt; WorldGreeter def greeting # Override the greeting &quot;Hola&quot; end end # We call a mehtod defined in WorldGreeter, which calls the overriden # version of greeting in SpanishWorldGreeter, and prints &quot;Hola World&quot; SpanishWorldGreeter.new.greet abstract vs concrete # This class is abstract; it doesn&#39;t define greeting or who # No special syntax is required: any class that invokes methods that are # intended for a subclass to implement is abstract. class AbstractGreeter def greet puts &quot;#{greeting} #{who}&quot; end end # A concrete subclass class WorldGreeter &lt; AbstractGreeter def greeting; &quot;Hello&quot;; end def who; &quot;World&quot;; end end WorldGreeter.new.greet # Displays &quot;Hello World&quot; Overriding private methods Privates methods are inherited by subclass. Subclasses can invoke and override private methods. You should only subclass when you are familiar with the implementation of the superclass. Compositition &gt; Inheritance super super works like a special method invocation: it invokes a method with the same name as the current one, in the superclass of the current class. If you use super as a bare keyword—with no arguments and no parentheses—then all of the arguments that were passed to the current method are passed to the superclass method. class Point3D &lt; Point def initialize(x,y,z) # Pass our first two arguments along to the superclass initialize method super(x , y) # And deal with the third argument ourself @z = z; end end Inheritance of Class Methods Class methods may be inherited and overriden just as instance methods can be. As a stylistic matter, it is preferable to invoke class methods through the class object on which they are defined. Class methods can use super just as instance methods can to invoke the same-named method in the superclass. class Point def self.sum(*args) s = 0 args.each { |x| s += x } s end end class Point3D &lt; Point def self.sum(*args) puts &quot;Point3D&quot; super(*args) end end Inheritance and Instance Variables Inheritance variables often appear to be inherited in Ruby. class Point3D &lt; Point def initialize(x,y,z) super(x , y) @z = z; end def to_s &quot;(#@x, #@y, #@z)&quot; # Variables @x and @y inherited? end end Inheritance and Class Variables Class variables are shared by a class and all of its subclasses. Inheritance of Constants Constants are inherited can can be overriden, much like instance methods can. class Point ORGIN = Point.new 0, 0 def initialize(x, y) @x, @y = x, y end end class Point3D ORGIN = Point3D.new 0, 0, 0 def initialize(x, y, z) super x, y @z = z end end Object Creation and Intialization new, allocate, and intialize Every class inerits the class method new. new method has two jobs: it must allocate a new object—actually bring the object into existence—and it must intialize the object. The new metho would look something like this: def new(*args) o = self.allocate # Create a new object of this class o.intialize(*args) # Call the object&#39;s intialize method with our args o # Return new object; ignore return value of intialize end allocate allocate is an instance method of Class, and it is inherited by all class objects. Its purpose is to create a new instance of the class. You can call it yourself to create uninitialized instances of a class. But don’t try to override it; Ruby always inovkes this mehtod directly, ignoring any overriding versions you may have defined. initalize initialze is an instance method and usually to create instance variables for the obect and set them to their initial values. Ruby implicitly makes the initialize method private. Class::new and Class#new The class method Class::new is the Class class’ own version of the method, and it can be used to create new classes. Factory Methods class Point # Define an initialize method as usual... def initialize(x,y) # Expects Cartesian coordinates @x,@y = x,y end # But make the factory method new private private_class_method :new def Point.cartesian(x,y) # Factory method for Cartesian coordinates new(x,y) # We can still call new from other class methods end def Point.polar(r, theta) # Factory method for polar coordinates new(r*Math.cos(theta), r*Math.sin(theta)) end end dup,clone, and intialize_copy marshal_dump and marshal_load The Singleton Pattern require &#39;singleton&#39; # Singleton module is not built-in class PointSats # Define a class include Singleton # Make it as singleton def intialize # A normal initialization method @n, @totalX, @totalY = 0, 0.0, 0.0 end def record(point) # Record a new point @n += 1 @totalX += point.x @totalY += point.y end def report # Report point statistics puts &quot;Number of points created: #@n&quot; puts &quot;Average X coordinate: #{@totalX/@n}&quot; puts &quot;Average Y coordinate: #{@totalY/@n}&quot; end end class Point def initialize(x,y) @x, @y = x, y PointSats.instance.record(self) end end The Singleton module automatically creates the instance class method for us. PointSats.instance.report Modules Like a class, a module is a named group of methods, constants, and class variables. Modules stand alone; there is no “module hierarchy” of ineritance. Modules are used as namespaces and as mixins. Modules as Namespaces Modules are a good way to group related methods when object-oriented programming is not necessary. def base64_encode end def base64_decode end To define the two methods within a Base64 module to prevent namespace collisions. module Base64 # Note the module names must begin with a capital letter. def self.encode # def Base64.encode end def self.decode # def Base64.decode end Modules may also contain constants. module Base64 DIGITS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; \\ &#39;abcdefghijklmnopqrstuvwxyz&#39; \\ &#39; 0123456789+/ &#39; end Outside the Base64 module, this constant can be referred to as Base64::DIGITS. If the two methods had some need to share nonconstant data, they could use a class variable (with a @@ prefix), just as they could if they were defined in class. Nested namespaces Modules, including classes, may be nested. This creates nested namespaces but has no other effect: a class or module nested within another has no special access to the class or module it is nested within. module Base64 DIGITS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39; class Encoder def encode end end class Decoder def decode end end # A utility function for use by both classes def Base64.helper end end By structuring our code this way, we’ve defined two new classes, Base64::Encoder and Base64::Decoder. Inside the Base64 module, the two classes can refer to each other by their unqualified names, without the Base64 prefix. And each of the classes can use the DIGITS constant without a prefix. Modules As Mixins If a module defines instance methods instead of the class methods, those instance methods can be mixed in to other classes. Enumerable and Comparable are well-known examples of mixin modules. Enumerable defines useful iterators that are implemented in terms of an each iterator. Enumerable doesn’t define the each mehtod itself, but any class that defines it can mix in the Enumerable module to instantly add many useful iterators. And class that defines &lt;=&gt; can be mixed in Comparable to get &lt;,&lt;=,==,&gt;=, and between? for free. To mix a module into a class, use include. class Point include Comparable end In fact, it is a private instance method of Module, implicitly invoked on self—the class into which the module is being included. The inclusion of a module affects the type-checking method is_a? and the switch-equality operator ===. &quot;text&quot;.is_a? Comparable # =&gt; true Enumerable === &quot;text&quot; # =&gt; true in Ruby 1.8, false in 1.9 Note the instance_of? only checks the class of its receiver, not superclasses or modules, so the following is false. &quot;text&quot;.instance_of? Comparable # =&gt; false The normal way to mix in a module is with the `Module.include` method. Another way is with `Object.extend`. This method makes the instance methods of the specified module or modules into singleton methods of the receiver object. (And if the receiver object is a Class instance, then the methods of the receiver become class methods of that class.) countdown = Object.new # A plain old object def countdown.each # The each iterator as a singleton mehtod yield 3 yield 2 yield 1 end countdown.extend(Enumerable) # Now the object has all Enumerable methods print countdown.sort # Prints &quot;[1, 2, 3]&quot; Includable Namespace Modules It is possible to define modules that define a namespace but still allow their methods to be mixed in. Math.sin(0) # =&gt; 0.0: Math is a namespace include &#39;Math&#39; # The Math namespace can be included sin(0) # =&gt; 0.0: Now we have easy access to the functions The Kernel module also works like this: we can invoke its methods through the Kernel namespace, or as private method of Object, into which it is included. If you want to create a module like Math or Kernel, define your methods as instance methods of the module. Then use module_function to convert those methods to “module functions”. module_funciton is a private instance method of Module, much like the public, protected, and private methods. It accepts any number of method names (as symbols or strings) as arguments. The primary effect of calling module_function is that it makes class method copies of the specified methods. A secondary effect is that it makes the instance methods private. Like the public, protected, and private methods, the module_funciton mehtod can also be invoked with no arguments. When invoked in this way, any instance methods subsequently defined in the module will be modue funciton: they will become public class methods and private instance methods. Loading and Requiring Modules Ruby programs may be broken up into multiple files, and the most natural way to partition a program is to place each nontrivial class or module into a separate file. These separate files can then be reassembled into a single program (and, if well-designed, can be reused by other programs) using require or load which are global functions defined in Kernel, but are used like language keywords. If the file to load is specified with an absolute path, or is relative to ~ (the user’s home directory), then that specific file is loaded. Usually, however, the file is specified as a relative path, and load and require search for it relative to the directories of Ruby’s load path. load, require andrequire_relative In addition to loading source code, require can also load binary extensions to Ruby. Binary extensions are, of course, implementation-dependent, but in C-based implementations, they typically take the form of shared library files with extension like .so or .dll. load expects a complete filename including an extension. require is usually passed a library name, with no extension, rather than a filename. In that case, it searchs for a file that has the library name as its base name and an approriate source or native library extension. If a direcotry contains both an .rb source file and a binary extension file, require will load the source file instead of the binary file. load can load the same file multiple times. require tries to prevent multiple loads of the same file. require keeps track of the files that have been loaded by appending them to the global array $&quot; (also known as $LOAD_FEATURES). load loads the specified file at the current $SAFE level. require loads the specified library with $SAFE set to 0, even if the code that called require has a higher value for that variable. require_relative, a special version of require, searchs and loads file from the current direcotry. The Load Path Ruby’s load path is an array that you can access using either of the global variables $LOAD_PATH or $:. Each element of the array is the name of a direcotry that Ruby will search for files to load. Direcotories at the start of the array are searched before direcotories at the end of the array. The elements of $LOAD_PATH must be strings in Ruby 1.8, but in Ruby 1.9, they may be strings or any object that has a to_path method that returns a string. Executing Loaded Code load and require execute the code in the specified file immediately. Files loaded with load or require are executed in a new top-level scope that is different from the one in which load or require was invoked. The loaded file can see all global variables and constants that have been defined at the time it is loaded, but it does not have access to the local scope from which the load was initiated. The local variables defined in the scope from which load or require is invoked are not visible to the loaded file. Any local variables created by the loaded file are discarded once the load is complete; they are never visible outside the file in which they are defined. At the start of the loaded file, the value of self is always the main object, just as it is when the Ruby interpreter starts running. The current module nesting is ignored within the loaded file. You cannot, for example, open a class and then load a file of method definitions. The file will be processed in a top-level socpe, not inside any class or module. Autoloading Modules The autoload methods of Kernel and Module allow lazy loading of files on an as-needed basis. The global autoload function allows you to register the name of an undefined constant (typically a class or module name) and a name of the library that defines it. When that constant is first referenced, the named library is loaded using require. For example: # Require &#39;socket&#39; if and when the TCPSocket is first used autoload :TCPSocket, &quot;socket&quot; The Module class defines its own version of autoload to work with constants nested within another module. Singleton Methods and the Eigenclass To define a singleton method sum on an object Point, we’d write: def Point.sum # Method body goes here end The singleton methods of an object are instance methods of the anonymous eigenchass associated with that object. “Eigen” is a German word meaning (roughly) “self”, “own”, “particular to,” or “characteristic of.” The eigenclass is also called the singleton class or the metaclass. Ruby defines a syntax for opening the eigenclass of an object and adding methods to it thats provides an alternative to defining singleton methods one by one. To open the eigenclass of the object o, use class « o. For example, we can define class methods of Point like this: class &lt;&lt; Point def class_method1 # This is an instance method of the eigenclass. end def class_method2 end end Method Lookup When Ruby evaluates a method invocation expression, it must first figure out which method is to be invoked. The process for doing this is called method lookup or method name resolution. For the method invocation expression o.m, Ruby performs name resolution with the following steps: First, it checks the eigenclass of o for singleton methods named m. If no method m is found in the eigenclass, Ruby searchs the class of o for an instance method named m. If no method m is found in the class, Ruby searchs the instance methods of any modules included by the class of o. If that class includes more than one module, then the most recently included module is searched first. If no instance method m is found in the class of o or in its modules, then the search moves up the inheritance hierarchy to the superclass. If no method named m is found after completing the search, then a method named method_missing is invoked instead. In order to find an appropriate definitions of this method, the name resolution algorith starts over at step 1. The Kernel module provides a default implementation of method_missing. What it does is raise an exception of NoMethodError. The name resolution algorithm for class methods is exactly the same as it is for instance method. Constant Lookup When a constant is referenced without any qualifying namespace, the Ruby interpreter must find the appropriate definition of the constant. Ruby first attempts to resolve a constant reference in the lexical scope of the reference. This means that it first checks the class or module that encloses the constant reference to see if that class or module defines the constant. If not, it checks the next enclosing class or module. This continues untils there are no more enclosing classes or modules. Note that top-level or “global” constants are not considered part of the lexical scope and are not considered during this part of constant lookup. The class method Module.nesting returns the list of clases and modules that are searched in this step, in the order they are searched. If no constant definition is foud in the lexically enclosing scope, Ruby next tries to resolve the constant in the inheritance hierarchy by checking the ancesstors of the class or module that referred to the constant. The ancestors method of the containing class or module returns the list of classes and modules searched in this step. If no constant definition is found in the inheritance hierarchy, then top-level constant definitions are checked. If no definition can be found for the desired constant, then the const_missing method—if there is one—of the containing class or module is called and given the opportunity to provide a value for the constant. A few points about this constant lookup algorithm. Constants defined in enclosing modules are found in preference to constants defined in included modules. The modules included by a class are searched before the superclass of the class. The Object class is part of the inheritance hierarchy of all classes. The Kernel module is an ancestor of Object. module Kernel # Constants defined in Kernel A = B = C = D = E = F = &quot;defined in Kernel&quot; end # Top-level or &quot;global&quot; constants defined in Object A = B = C = D = E = &quot;defined at Top-level&quot; class Super A = B = C = D = &quot;defined in superclass&quot; end module Included # Constants defined in an included module A = B = C = &quot;defined in included module&quot; end module Enclosing # Constants defined in an enclosing module A = B = &quot;defined in enclosing module&quot; class Local &lt; Super include Included # Locally defined constant A = &quot;defined locally&quot; # The list of modules searched, in the order searched # [Enclosing::Local, Enclosing, Inclued, Super, Object, Kernel] search = (Module.nesting + self.ancestors + Object.ancestors).uniq puts A # Prints &quot;defined locally&quot; puts B # Prints &quot;defined in enclosing module&quot; puts C # Prints &quot;defined in included module&quot; puts D # Prints &quot;defined in superclass&quot; puts E # Prints &quot;defined at toplevel&quot; puts F # Prints &quot;defined in kernel&quot; end end References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto","headline":"Ruby Notes 6 Classes and Modules","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2016/04/05/ruby-notes-6-classes-and-modules/"},"url":"https://blog.codefarm.me/2016/04/05/ruby-notes-6-classes-and-modules/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Ruby Notes 6 Classes and Modules</h1><p class="c-post-meta">05 Apr 2016</p>
  </header>

  <div class="c-post-content">
    <p>Classes can include—or inherit methods fom—modules.</p>

<p>Ruby’s objects are strictly encapsulated: their state can be access only through the methods they define.</p>

<p>Any Ruby program can add methods to existing classes, and it is even possible to add “singleton methods” to individual objects.</p>

<h3 id="classes">Classes</h3>

<h4 id="defining-a-simple-class">Defining a Simple Class</h4>

<figure class="highlight"><pre><code class="language-rb" data-lang="rb"><span class="k">class</span> <span class="nc">Point</span>
  <span class="vc">@@n</span> <span class="o">=</span> <span class="mi">0</span>        <span class="c1"># How many points have created</span>
  <span class="vc">@@totalX</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># The sum of all X coordinates</span>
  <span class="vc">@@totlalY</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># The sum of all Y coordinates</span>

  <span class="k">def</span> <span class="nf">intialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="vc">@@n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="vc">@@totalX</span> <span class="o">+=</span> <span class="n">x</span>
    <span class="vc">@@totalY</span> <span class="o">+=</span> <span class="n">y</span>
  <span class="k">end</span>

  <span class="no">ORIGIN</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="no">UNIT_X</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="no">UNIT_Y</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">x</span>
    <span class="vi">@x</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">x</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@x</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">y</span>
    <span class="vi">@y</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">y</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@y</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">TypeError</span><span class="p">,</span> <span class="s2">"Point argument expected"</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Point</span>
    <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@x</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="nf">x</span><span class="p">,</span> <span class="vi">@y</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="nf">y</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">-</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">TypeError</span><span class="p">,</span> <span class="s2">"Point argument expected"</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Point</span>
    <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@x</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="nf">x</span><span class="p">,</span> <span class="vi">@y</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="nf">y</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">*</span><span class="p">(</span><span class="n">scalar</span><span class="p">)</span>
    <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@x</span><span class="o">*</span><span class="n">scalar</span><span class="p">,</span> <span class="vi">@y</span><span class="o">*</span><span class="n">scalar</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">index</span>
    <span class="k">when</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="vi">@x</span>
    <span class="k">when</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="vi">@y</span>
    <span class="k">when</span> <span class="ss">:x</span><span class="p">,</span> <span class="s2">"x"</span><span class="p">:</span> <span class="vi">@x</span>
    <span class="k">when</span> <span class="ss">:y</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">:</span> <span class="vi">@y</span>
    <span class="k">else</span> <span class="kp">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">yield</span> <span class="vi">@x</span>
    <span class="k">yield</span> <span class="vi">@y</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="vi">@x</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="nf">x</span> <span class="o">&amp;&amp;</span> <span class="vi">@y</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="nf">y</span>
  <span class="k">rescue</span>
    <span class="kp">false</span>
  <span class="k">end</span>

  <span class="c1"># alias eql? == # Often, we want eql? to work just like == operator.</span>

  <span class="k">def</span> <span class="nf">eql?</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">instance_of?</span> <span class="no">Point</span>
      <span class="vi">@x</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="vi">@y</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">y</span><span class="p">)</span>
    <span class="k">elsif</span>
      <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">hash</span>
    <span class="n">code</span> <span class="o">=</span> <span class="mi">17</span>
    <span class="n">code</span> <span class="o">=</span> <span class="mi">37</span><span class="o">*</span><span class="n">code</span> <span class="o">+</span> <span class="vi">@x</span><span class="p">.</span><span class="nf">hash</span>
    <span class="n">code</span> <span class="o">=</span> <span class="mi">37</span><span class="o">*</span><span class="n">code</span> <span class="o">+</span> <span class="vi">@y</span><span class="p">.</span><span class="nf">hash</span>
    <span class="n">code</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">&lt;</span><span class="o">=&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">nil</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span> <span class="no">Point</span>
    <span class="vi">@x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="vi">@y</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=&gt;</span> <span class="n">other</span><span class="p">.</span><span class="nf">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="nf">y</span><span class="o">**</span><span class="mi">2</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">sum</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">)</span> <span class="c1"># def Point.sum(*points)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">points</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="n">x</span> <span class="o">+=</span> <span class="nb">p</span><span class="p">.</span><span class="nf">x</span><span class="p">;</span> <span class="n">y</span> <span class="o">+=</span> <span class="nb">p</span><span class="p">.</span><span class="nf">y</span> <span class="p">}</span>
    <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="s2">"(</span><span class="si">#{</span><span class="vi">@x</span><span class="si">}</span><span class="s2">,</span><span class="si">#{</span><span class="vi">@y</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<ul>
  <li>Accessors and Attributes</li>
</ul>

<figure class="highlight"><pre><code class="language-rb" data-lang="rb"><span class="k">class</span> <span class="nc">Point</span>
  <span class="k">def</span> <span class="nf">intialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">x</span>   <span class="c1"># The accessor (or getter) method for @x</span>
    <span class="vi">@x</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">y</span>   <span class="c1"># The accessor (or getter) method for @y</span>
    <span class="vi">@y</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MutablePoint</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> <span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="k">end</span>

  <span class="k">def</span> <span class="nf">x</span><span class="p">;</span> <span class="vi">@x</span><span class="p">;</span> <span class="k">end</span> <span class="c1"># The getter method for @x</span>
  <span class="k">def</span> <span class="nf">y</span><span class="p">;</span> <span class="vi">@y</span><span class="p">;</span> <span class="k">end</span> <span class="c1"># The getter method for @y</span>

  <span class="k">def</span> <span class="nf">x</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># The setter method for @x</span>
    <span class="vi">@x</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">y</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># The setter method for @y</span>
    <span class="vi">@y</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="mi">0</span></code></pre></figure>

<ul>
  <li>
    <p><em>metaprogramming</em></p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">attr</code>, <code class="language-plaintext highlighter-rouge">attr_reader</code>, and <code class="language-plaintext highlighter-rouge">attr_accessor</code></p>

        <p>The <code class="language-plaintext highlighter-rouge">attr_reader</code> and <code class="language-plaintext highlighter-rouge">attr_accessor</code> methods are defined by <code class="language-plaintext highlighter-rouge">Module</code> class. Both methods take any number of symbols naming attributes.</p>

        <p><code class="language-plaintext highlighter-rouge">attr_reader</code> creates trivial getter methods for the instance variables with the same name.</p>

        <p><code class="language-plaintext highlighter-rouge">attr_accessor</code> creates getter and setter methods.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Point
    attr_accessor :x, :y  # Define accessor methods for our instance variables
  end

  class Point
    attr_reader :x, :y    # Define reader methods for our instance variable
    # attr_reader "x", "y" Equivalently.
  end
</code></pre></div>        </div>

        <p><code class="language-plaintext highlighter-rouge">attr</code> is a similar method with a shorted name as a synonym for <code class="language-plaintext highlighter-rouge">attr_reader</code>.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  attr :x       # Define a trivial getter method x for @x
  attr :y, true # Define getter and setter methods for @y
</code></pre></div>        </div>

        <p>The <code class="language-plaintext highlighter-rouge">attr</code>, <code class="language-plaintext highlighter-rouge">attr_reader</code>, and <code class="language-plaintext highlighter-rouge">attr_accessor</code> methods create instance method for us (<em>metaprogramming</em>).</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="method-visibility-public-protected-private">Method Visibility: Public, Protected, Private</h4>

<p>Methods are normally public unless they are explicitly declared to be private or protected.</p>

<p>The <code class="language-plaintext highlighter-rouge">initialize</code> method is always implicitly private.</p>

<p>Global funcitons are defined as private instance methods of <code class="language-plaintext highlighter-rouge">Object</code>.</p>

<p>A private method is internal to the implementation of a class, and it can only be called by other instance method of the class.</p>

<p>Private methods are implicityly invoked on <code class="language-plaintext highlighter-rouge">self</code>, and may not be explicitly invoked on an object.</p>

<p>A protected method is like a private method in that it can only be invoked from within the implementation of a calss or its subclasses.</p>

<p>Protected methods may be explicitly invoked on any instance of the class, and it is not restricted to implicit invocation on <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>Protected methods are the least commonly defined and also the most difficult to understand.</p>

<p>Method visibility is declared with three methods named <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">private</code>, and <code class="language-plaintext highlighter-rouge">protected</code>. These are instance method of the <code class="language-plaintext highlighter-rouge">Module</code> class.</p>

<p>All classes are modules, and inside a class definition (both outside method definitions), <code class="language-plaintext highlighter-rouge">self</code> refers to class being defined.</p>

<figure class="highlight"><pre><code class="language-rb" data-lang="rb"><span class="k">class</span> <span class="nc">Point</span>
  <span class="c1"># public methods go here</span>

  <span class="c1"># The following methods are protected</span>
  <span class="kp">protected</span>

  <span class="c1"># protected methods go here</span>

  <span class="c1"># The following methods are private</span>
  <span class="kp">private</span>

  <span class="c1"># private methods go here</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Widget</span>
  <span class="k">def</span> <span class="nf">x</span>                   <span class="c1"># Accessor method for @x</span>
    <span class="vi">@x</span>
  <span class="k">end</span>
  <span class="kp">protected</span> <span class="ss">:x</span>            <span class="c1"># Make it protected</span>

  <span class="k">def</span> <span class="nf">utility_method</span>      <span class="c1"># Define a method</span>
    <span class="kp">nil</span>
  <span class="k">end</span>
  <span class="kp">private</span> <span class="ss">:utility_method</span> <span class="c1"># And make it private</span>
<span class="k">end</span></code></pre></figure>

<p><em>Instance and class variables are encapsulated and effectively private, and constants are effectively public.</em></p>

<p><em>There is no way to make an instance variable accessible from outside a class. And there is no way to define a constant that is inaccessible to outside use.</em></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">private_class_method</code> and <code class="language-plaintext highlighter-rouge">public_class_method</code></p>

    <p>You can make a private class method private with <code class="language-plaintext highlighter-rouge">private_class_method</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private_class_method :new
</code></pre></div>    </div>

    <p>You can make a private class method public again with <code class="language-plaintext highlighter-rouge">public_class_method</code>.</p>
  </li>
</ul>

<h4 id="subclassing-and-inheritance">Subclassing and inheritance</h4>

<p><em>In Ruby 1.9, <code class="language-plaintext highlighter-rouge">Object</code> is no longer the root of the class hierarchy. A new class named <code class="language-plaintext highlighter-rouge">BasicObject</code> serves that purpose, and <code class="language-plaintext highlighter-rouge">Object</code> is a subclass of <code class="language-plaintext highlighter-rouge">BasicObject</code>. <code class="language-plaintext highlighter-rouge">BasicObject</code> is a very simple class, with almost no methods of its own, and is useful as the superclass of delegating wrapper classes.</em></p>

<p>When you create a class in Ruby 1.9, you still extend <code class="language-plaintext highlighter-rouge">Object</code> unless you explicity specify the superclass, and most programmer will need to use or extend <code class="language-plaintext highlighter-rouge">BasicObject</code>.</p>

<p>The syntax for extending a class is to add <strong>&lt;</strong> character and the name of the superclass to your <code class="language-plaintext highlighter-rouge">class</code> statement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point3D &lt; Point   # Define class Point3D as a subclass of Point
end
</code></pre></div></div>

<p><em>Subclassing a Struct</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point3D &lt; Struct.new("Point3D", :x, :y, :z)
    # Superclass struct gives us acess method, ==, to_s, etc
    # Add point-specific methods here
end
</code></pre></div></div>

<ul>
  <li>
    <p>Overriding Methods</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Greet the World
  class WorldGreeter
      def greet           # Display a greeting
          puts "#{greeting} #{who}"
      end
        
      def greeting        # What greeting to use
          "Hello"
      end
        
      def who             # Who to greet
          "World"
      end
  end
    
  # Greet the world in Spanish
  class SpanishWorldGreeter &lt; WorldGreeter
      def greeting        # Override the greeting
          "Hola"
      end
  end
    
  # We call a mehtod defined in WorldGreeter, which calls the overriden
  # version of greeting in SpanishWorldGreeter, and prints "Hola World"
  SpanishWorldGreeter.new.greet
</code></pre></div>    </div>

    <ul>
      <li>
        <p>abstract vs concrete</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # This class is abstract; it doesn't define greeting or who
  # No special syntax is required: any class that invokes methods that are
  # intended for a subclass to implement is abstract.
  class AbstractGreeter
    def greet
      puts "#{greeting} #{who}"
    end
  end
        
  # A concrete subclass
  class WorldGreeter &lt; AbstractGreeter
    def greeting; "Hello"; end
    def who; "World"; end
  end
        
  WorldGreeter.new.greet # Displays "Hello World"
</code></pre></div>        </div>
      </li>
      <li>
        <p>Overriding private methods</p>

        <p>Privates methods are inherited by subclass.</p>

        <p>Subclasses can invoke and override private methods.</p>

        <p>You should only subclass when you are familiar with the implementation of the superclass.</p>

        <p><em>Compositition &gt; Inheritance</em></p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">super</code></p>

        <p><code class="language-plaintext highlighter-rouge">super</code> works like a special method invocation: it invokes a method with the same name as the current one, in the superclass of the current class.</p>

        <p>If you use <code class="language-plaintext highlighter-rouge">super</code> as a bare keyword—with no arguments and no parentheses—then all of the arguments that were passed to the current method are passed to the superclass method.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Point3D &lt; Point
    def initialize(x,y,z)
      # Pass our first two arguments along to the superclass initialize method
      super(x , y)
      # And deal with the third argument ourself
      @z = z;
    end
  end
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>Inheritance of Class Methods</p>

    <p>Class methods may be inherited and overriden just as instance methods can be.</p>

    <p>As a stylistic matter, it is preferable to invoke class methods through the class object on which they are defined.</p>

    <p>Class methods can use <code class="language-plaintext highlighter-rouge">super</code> just as instance methods can to invoke the same-named method in the superclass.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Point
    def self.sum(*args)
      s = 0
      args.each { |x| s += x }
      s
    end
  end
    
  class Point3D &lt; Point
    def self.sum(*args)
      puts "Point3D"
      super(*args)
    end
  end
</code></pre></div>    </div>
  </li>
  <li>
    <p>Inheritance and Instance Variables</p>

    <p>Inheritance variables often appear to be inherited in Ruby.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Point3D &lt; Point
    def initialize(x,y,z)
      super(x , y)
      @z = z;
    end
    def to_s
      "(#@x, #@y, #@z)" # Variables @x and @y inherited?
    end
  end
</code></pre></div>    </div>
  </li>
  <li>
    <p>Inheritance and Class Variables</p>

    <p>Class variables are shared by a class and all of its subclasses.</p>
  </li>
  <li>
    <p>Inheritance of Constants</p>

    <p>Constants are inherited can can be overriden, much like instance methods can.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Point
    ORGIN = Point.new 0, 0
      
    def initialize(x, y)
      @x, @y = x, y
    end
  end
    
  class Point3D
    ORGIN = Point3D.new 0, 0, 0
      
    def initialize(x, y, z)
      super x, y
      @z = z
    end
  end
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="object-creation-and-intialization">Object Creation and Intialization</h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">new</code>, <code class="language-plaintext highlighter-rouge">allocate</code>, and <code class="language-plaintext highlighter-rouge">intialize</code></p>

    <p>Every class inerits the class method <code class="language-plaintext highlighter-rouge">new</code>.</p>

    <p><code class="language-plaintext highlighter-rouge">new</code> method has two jobs: it must <code class="language-plaintext highlighter-rouge">allocate</code> a new object—actually bring the object into existence—and it must <code class="language-plaintext highlighter-rouge">intialize</code> the object.</p>

    <p>The <code class="language-plaintext highlighter-rouge">new</code> metho would look something like this:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def new(*args)
    o = self.allocate     # Create a new object of this class
    o.intialize(*args)    # Call the object's intialize method with our args
    o                     # Return new object; ignore return value of intialize
  end
</code></pre></div>    </div>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">allocate</code></p>

        <p><code class="language-plaintext highlighter-rouge">allocate</code> is an instance method of <code class="language-plaintext highlighter-rouge">Class</code>, and it is inherited by all class objects.</p>

        <p>Its purpose is to create a new instance of the class.</p>

        <p>You can call it yourself to create uninitialized instances of a class.</p>

        <p>But don’t try to override it; Ruby always inovkes this mehtod directly, ignoring any overriding versions you may have defined.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">initalize</code></p>

        <p><code class="language-plaintext highlighter-rouge">initialze</code> is an instance method and usually to create instance variables for the obect and set them to their initial values.</p>

        <p>Ruby implicitly makes the <code class="language-plaintext highlighter-rouge">initialize</code> method private.</p>

        <ul>
          <li>
            <p>Class::new and Class#new</p>

            <p>The class method <code class="language-plaintext highlighter-rouge">Class::new</code> is the <code class="language-plaintext highlighter-rouge">Class</code> class’ own version of the method, and it can be used to create new classes.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Factory Methods</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Point
    # Define an initialize method as usual...
    def initialize(x,y) # Expects Cartesian coordinates
      @x,@y = x,y
    end
    
    # But make the factory method new private
    private_class_method :new
    
    def Point.cartesian(x,y) # Factory method for Cartesian coordinates
      new(x,y)
      # We can still call new from other class methods
    end
    
    def Point.polar(r, theta) # Factory method for polar coordinates
      new(r*Math.cos(theta), r*Math.sin(theta))
    end
  end
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">dup</code>,<code class="language-plaintext highlighter-rouge">clone</code>, and <code class="language-plaintext highlighter-rouge">intialize_copy</code></p>
  </li>
  <li>
    <p>marshal_dump and marshal_load</p>
  </li>
  <li>
    <p>The Singleton Pattern</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  require 'singleton'         # Singleton module is not built-in
    
  class PointSats             # Define a class
    include Singleton         # Make it as singleton
    
    def intialize             # A normal initialization method
      @n, @totalX, @totalY = 0, 0.0, 0.0
    end
    
    def record(point)         # Record a new point
      @n += 1
      @totalX += point.x
      @totalY += point.y
    end
    
    def report                # Report point statistics
      puts "Number of points created: #@n"
      puts "Average X coordinate: #{@totalX/@n}"
      puts "Average Y coordinate: #{@totalY/@n}"
    end
  end
    
  class Point
      def initialize(x,y)
          @x, @y = x, y
          PointSats.instance.record(self)
      end
  end
</code></pre></div>    </div>

    <p>The <code class="language-plaintext highlighter-rouge">Singleton</code> module automatically creates the <code class="language-plaintext highlighter-rouge">instance</code> class method for us.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  PointSats.instance.report
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="modules">Modules</h3>

<p>Like a class, a <strong><em>module</em></strong> is a named group of methods, constants, and class variables.</p>

<p>Modules stand alone; there is no “module hierarchy” of ineritance.</p>

<p>Modules are used as namespaces and as mixins.</p>

<h4 id="modules-as-namespaces">Modules as Namespaces</h4>

<p>Modules are a good way to group related methods when object-oriented programming is not necessary.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def base64_encode
end

def base64_decode
end
</code></pre></div></div>

<p>To define the two methods within a <code class="language-plaintext highlighter-rouge">Base64</code> module to prevent namespace collisions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Base64   # Note the module names must begin with a capital letter.
def self.encode # def Base64.encode
end

def self.decode # def Base64.decode
end
</code></pre></div></div>

<p>Modules may also contain constants.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Base64
    DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' \
             'abcdefghijklmnopqrstuvwxyz' \
             ' 0123456789+/ '
end
</code></pre></div></div>

<p>Outside the <code class="language-plaintext highlighter-rouge">Base64</code> module, this constant can be referred to as <code class="language-plaintext highlighter-rouge">Base64::DIGITS</code>.</p>

<p>If the two methods had some need to share nonconstant data, they could use a class variable (with a <strong>@@</strong> prefix), just as they could if they were defined in class.</p>

<ul>
  <li>
    <p>Nested namespaces</p>

    <p>Modules, including classes, may be nested.</p>

    <p>This creates nested namespaces but has no other effect: a class or module nested within another has no special access to the class or module it is nested within.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  module Base64
    DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    
    class Encoder
      def encode
      end
    end
    
    class Decoder
      def decode
      end
    end
    
    # A utility function for use by both classes
    def Base64.helper
    end
  end
</code></pre></div>    </div>

    <p>By structuring our code this way, we’ve defined two new classes, <code class="language-plaintext highlighter-rouge">Base64::Encoder</code> and <code class="language-plaintext highlighter-rouge">Base64::Decoder</code>.</p>

    <p>Inside the <code class="language-plaintext highlighter-rouge">Base64</code> module, the two classes can refer to each other by their unqualified names, without the <code class="language-plaintext highlighter-rouge">Base64</code> prefix.</p>

    <p>And each of the classes can use the <code class="language-plaintext highlighter-rouge">DIGITS</code> constant without a prefix.</p>
  </li>
  <li>
    <p>Modules As Mixins</p>
  </li>
</ul>

<p>If a module defines instance methods instead of the class methods, those instance methods can be mixed in to other classes.</p>

<p><code class="language-plaintext highlighter-rouge">Enumerable</code> and <code class="language-plaintext highlighter-rouge">Comparable</code> are well-known examples of mixin modules.</p>

<p><em>Enumerable</em> defines useful iterators that are implemented in terms of an <code class="language-plaintext highlighter-rouge">each</code> iterator.</p>

<p><em>Enumerable</em> doesn’t define the <code class="language-plaintext highlighter-rouge">each</code> mehtod itself, but any class that defines it can mix in the <em>Enumerable</em> module to instantly add many useful iterators.</p>

<p>And class that defines <code class="language-plaintext highlighter-rouge">&lt;=&gt;</code> can be mixed in <code class="language-plaintext highlighter-rouge">Comparable</code> to get <code class="language-plaintext highlighter-rouge">&lt;</code>,<code class="language-plaintext highlighter-rouge">&lt;=</code>,<code class="language-plaintext highlighter-rouge">==</code>,<code class="language-plaintext highlighter-rouge">&gt;=</code>, and <code class="language-plaintext highlighter-rouge">between?</code> for free.</p>

<p>To mix a module into a class, use <code class="language-plaintext highlighter-rouge">include</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point
  include Comparable
end
</code></pre></div></div>

<p>In fact, it is a private instance method of <code class="language-plaintext highlighter-rouge">Module</code>, implicitly invoked on <code class="language-plaintext highlighter-rouge">self</code>—the class into which the module is being included.</p>

<p>The inclusion of a module affects the type-checking method <code class="language-plaintext highlighter-rouge">is_a?</code> and the switch-equality operator <code class="language-plaintext highlighter-rouge">===</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"text".is_a? Comparable     # =&gt; true
Enumerable === "text"       # =&gt; true in Ruby 1.8, false in 1.9
</code></pre></div></div>

<p>Note the <code class="language-plaintext highlighter-rouge">instance_of?</code> only checks the class of its receiver, not superclasses or modules, so the following is false.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"text".instance_of? Comparable  # =&gt; false

The normal way to mix in a module is with the `Module.include` method. Another way is with `Object.extend`. This method makes the instance methods of the specified module or modules into singleton methods of the receiver object. (And if the receiver object is a Class instance, then the methods of the receiver become class methods of that class.)

    countdown = Object.new          # A plain old object
    def countdown.each              # The each iterator as a singleton mehtod
      yield 3
      yield 2
      yield 1
    end
    countdown.extend(Enumerable)    # Now the object has all Enumerable methods
    print countdown.sort            # Prints "[1, 2, 3]"
</code></pre></div></div>

<ul>
  <li>
    <p>Includable Namespace Modules</p>

    <p>It is possible to define modules that define a namespace but still allow their methods to be mixed in.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Math.sin(0)     # =&gt; 0.0: Math is a namespace
  include 'Math'  # The Math namespace can be included
  sin(0)          # =&gt; 0.0: Now we have easy access to the functions
</code></pre></div>    </div>

    <p>The <strong>Kernel</strong> module also works like this: we can invoke its methods through the <strong>Kernel</strong> namespace, or as private method of <strong>Object</strong>, into which it is included.</p>

    <p>If you want to create a module like <strong>Math</strong> or <strong>Kernel</strong>, define your methods as instance methods of the module. Then use <code class="language-plaintext highlighter-rouge">module_function</code> to convert those methods to “module functions”.</p>

    <p><strong>module_funciton</strong> is a private instance method of <strong>Module</strong>, much like the <strong>public</strong>, <strong>protected</strong>, and <strong>private</strong> methods. It accepts any number of method names (as symbols or strings) as arguments.</p>

    <p>The primary effect of calling <strong>module_function</strong> is that it makes class method copies of the specified methods.</p>

    <p>A secondary effect is that it makes the instance methods private.</p>

    <p>Like the <strong>public</strong>, <strong>protected</strong>, and <strong>private</strong> methods, the <strong>module_funciton</strong> mehtod can also be invoked with no arguments. When invoked in this way, any instance methods subsequently defined in the module will be modue funciton: they will become public class methods and private instance methods.</p>
  </li>
</ul>

<h4 id="loading-and-requiring-modules">Loading and Requiring Modules</h4>

<p>Ruby programs may be broken up into multiple files, and the most natural way to partition a program is to place each nontrivial class or module into a separate file.</p>

<p>These separate files can then be reassembled into a single program (and, if well-designed, can be reused by other programs) using <strong>require</strong> or <strong>load</strong> which are global functions defined in <strong>Kernel</strong>, but are used like language keywords.</p>

<p>If the file to load is specified with an <strong><em>absolute path</em></strong>, or is relative to <strong><em>~</em></strong> (the user’s home directory), then that specific file is loaded.</p>

<p>Usually, however, the file is specified as a <strong><em>relative path</em></strong>, and <strong>load</strong> and <strong>require</strong> search for it relative to the directories of Ruby’s <strong><em>load path</em></strong>.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">require</code> and<code class="language-plaintext highlighter-rouge">require_relative</code></p>

    <ul>
      <li>
        <p>In addition to loading source code, <strong>require</strong> can also load binary extensions to Ruby.</p>

        <p>Binary extensions are, of course, implementation-dependent, but in C-based implementations, they typically take the form of shared library files with extension like <em>.so</em> or <em>.dll</em>.</p>
      </li>
      <li>
        <p><strong>load</strong> expects a complete filename including an extension.</p>

        <p><strong>require</strong> is usually passed a library name, with no extension, rather than a filename. In that case, it searchs for a file that has the library name as its base name and an approriate source or native library extension. If a direcotry contains both an <em>.rb</em> source file and a binary extension file, <strong>require</strong> will load the source file instead of the binary file.</p>
      </li>
      <li>
        <p><strong>load</strong> can load the same file multiple times.</p>

        <p><strong>require</strong> tries to prevent multiple loads of the same file.</p>

        <p><strong>require</strong> keeps track of the files that have been loaded by appending them to the global array <code class="language-plaintext highlighter-rouge">$"</code> (also known as $LOAD_FEATURES).</p>
      </li>
      <li>
        <p><strong>load</strong> loads the specified file at the current $SAFE level.</p>

        <p><strong>require</strong> loads the specified library with $SAFE set to 0, even if the code that called <strong>require</strong> has a higher value for that variable.</p>
      </li>
      <li>
        <p><strong>require_relative</strong>, a special version of <strong>require</strong>, searchs and loads file from the current direcotry.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>The Load Path</p>

    <p>Ruby’s load path is an array that you can access using either of the global variables <code class="language-plaintext highlighter-rouge">$LOAD_PATH</code> or <code class="language-plaintext highlighter-rouge">$:</code>.</p>

    <p>Each element of the array is the name of a direcotry that Ruby will search for files to load.</p>

    <p>Direcotories at the start of the array are searched before direcotories at the end of the array.</p>

    <p>The elements of <strong>$LOAD_PATH</strong> must be strings in Ruby 1.8, but in Ruby 1.9, they may be strings or any object that has a <code class="language-plaintext highlighter-rouge">to_path</code> method that returns a string.</p>
  </li>
  <li>
    <p>Executing Loaded Code</p>

    <p><strong>load</strong> and <strong>require</strong> execute the code in the specified file immediately.</p>

    <p>Files loaded with <strong>load</strong> or <strong>require</strong> are executed in a new top-level scope that is different from the one in which <strong>load</strong> or <strong>require</strong> was invoked.</p>

    <p>The loaded file can see all global variables and constants that have been defined at the time it is loaded, but it does not have access to the local scope from which the load was initiated.</p>

    <ul>
      <li>
        <p>The local variables defined in the scope from which <strong>load</strong> or <strong>require</strong> is invoked are not visible to the loaded file.</p>
      </li>
      <li>
        <p>Any local variables created by the loaded file are discarded once the load is complete; they are never visible outside the file in which they are defined.</p>
      </li>
      <li>
        <p>At the start of the loaded file, the value of <strong>self</strong> is always the main object, just as it is when the Ruby interpreter starts running.</p>
      </li>
      <li>
        <p>The current module nesting is ignored within the loaded file. You cannot, for example, open a class and then load a file of method definitions. The file will be processed in a top-level socpe, not inside any class or module.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Autoloading Modules</p>

    <p>The <strong>autoload</strong> methods of <strong>Kernel</strong> and <strong>Module</strong> allow lazy loading of files on an as-needed basis. The global <strong>autoload</strong> function allows you to register the name of an undefined constant (typically a class or module name) and a name of the library that defines it. When that constant is first referenced, the named library is loaded using <strong>require</strong>. For example:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Require 'socket' if and when the TCPSocket is first used
  autoload :TCPSocket, "socket"
</code></pre></div>    </div>

    <p>The <strong>Module</strong> class defines its own version of <strong>autoload</strong> to work with constants nested within another module.</p>
  </li>
</ul>

<h4 id="singleton-methods-and-the-eigenclass">Singleton Methods and the Eigenclass</h4>

<p>To define a singleton method <strong>sum</strong> on an object <strong>Point</strong>, we’d write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def Point.sum
  # Method body goes here
end
</code></pre></div></div>

<p>The singleton methods of an object are instance methods of the anonymous <em>eigenchass</em> associated with that object.</p>

<p>“Eigen” is a German word meaning (roughly) “self”, “own”, “particular to,” or “characteristic of.”</p>

<p>The eigenclass is also called the <em>singleton class</em> or the <em>metaclass</em>.</p>

<p>Ruby defines a syntax for opening the eigenclass of an object and adding methods to it thats provides an alternative to defining singleton methods one by one.</p>

<p>To open the eigenclass of the object <strong>o</strong>, use <strong>class « o</strong>. For example, we can define class methods of <strong>Point</strong> like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class &lt;&lt; Point
  def class_method1     # This is an instance method of the eigenclass.
  end

  def class_method2
  end
end
</code></pre></div></div>

<h4 id="method-lookup">Method Lookup</h4>

<p>When Ruby evaluates a method invocation expression, it must first figure out which method is to be invoked. The process for doing this is called <strong><em>method lookup</em></strong> or <strong><em>method name resolution</em></strong>.</p>

<p>For the method invocation expression <code class="language-plaintext highlighter-rouge">o.m</code>, Ruby performs name resolution with the following steps:</p>

<ol>
  <li>
    <p>First, it checks the eigenclass of <strong>o</strong> for <strong><em>singleton methods</em></strong> named <strong>m</strong>.</p>
  </li>
  <li>
    <p>If no method <strong>m</strong> is found in the eigenclass, Ruby searchs the class of <strong>o</strong> for an <strong><em>instance method</em></strong> named <strong>m</strong>.</p>
  </li>
  <li>
    <p>If no method <strong>m</strong> is found in the class, Ruby searchs the <strong><em>instance methods of any modules</em></strong> included by the class of <strong>o</strong>. If that class includes more than one module, then the most recently included module is searched first.</p>
  </li>
  <li>
    <p>If no instance method <strong>m</strong> is found in the class of <strong>o</strong> or in its modules, then the search moves up the <strong><em>inheritance hierarchy to the superclass</em></strong>.</p>
  </li>
  <li>
    <p>If no method named <strong>m</strong> is found after completing the search, then a method named <strong>method_missing</strong> is invoked instead. In order to find an appropriate definitions of this method, the name resolution algorith starts over at step 1.</p>
  </li>
</ol>

<p>The <strong>Kernel</strong> module provides a default implementation of <strong>method_missing</strong>. What it does is raise an exception of <em>NoMethodError</em>.</p>

<p>The name resolution algorithm for class methods is exactly the same as it is for instance method.</p>

<h4 id="constant-lookup">Constant Lookup</h4>

<p>When a constant is referenced without any qualifying namespace, the Ruby interpreter must find the appropriate definition of the constant.</p>

<ul>
  <li>
    <p>Ruby first attempts to resolve a constant reference in the lexical scope of the reference.</p>

    <p>This means that it first checks the class or module that encloses the constant reference to see if that class or module defines the constant.
  If not, it checks the next enclosing class or module.</p>

    <p>This continues untils there are no more enclosing classes or modules.</p>

    <p>Note that top-level or “global” constants are not considered part of the lexical scope and are not considered during this part of constant lookup.</p>

    <p>The class method <strong>Module.nesting</strong> returns the list of clases and modules that are searched in this step, in the order they are searched.</p>
  </li>
  <li>
    <p>If no constant definition is foud in the lexically enclosing scope, Ruby next tries to resolve the constant in the inheritance hierarchy by checking the ancesstors of the class or module that referred to the constant.</p>

    <p>The <strong>ancestors</strong> method of the containing class or module returns the list of classes and modules searched in this step.</p>
  </li>
  <li>
    <p>If no constant definition is found in the inheritance hierarchy, then top-level constant definitions are checked.</p>
  </li>
  <li>
    <p>If no definition can be found for the desired constant, then the <strong>const_missing</strong> method—if there is one—of the containing class or module is called and given the opportunity to provide a value for the constant.</p>
  </li>
</ul>

<p>A few points about this constant lookup algorithm.</p>

<ul>
  <li>
    <p>Constants defined in enclosing modules are found in preference to constants defined in included modules.</p>
  </li>
  <li>
    <p>The modules included by a class are searched before the superclass of the class.</p>
  </li>
  <li>
    <p>The <strong>Object</strong> class is part of the inheritance hierarchy of all classes.</p>
  </li>
  <li>
    <p>The <strong>Kernel</strong> module is an ancestor of <strong>Object</strong>.</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-rb" data-lang="rb"><span class="k">module</span> <span class="nn">Kernel</span>
  <span class="c1"># Constants defined in Kernel</span>
  <span class="no">A</span> <span class="o">=</span> <span class="no">B</span> <span class="o">=</span> <span class="no">C</span> <span class="o">=</span> <span class="no">D</span> <span class="o">=</span> <span class="no">E</span> <span class="o">=</span> <span class="no">F</span> <span class="o">=</span> <span class="s2">"defined in Kernel"</span>
<span class="k">end</span>

<span class="c1"># Top-level or "global" constants defined in Object</span>
<span class="no">A</span> <span class="o">=</span> <span class="no">B</span> <span class="o">=</span> <span class="no">C</span> <span class="o">=</span> <span class="no">D</span> <span class="o">=</span> <span class="no">E</span> <span class="o">=</span> <span class="s2">"defined at Top-level"</span>

<span class="k">class</span> <span class="nc">Super</span>
  <span class="no">A</span> <span class="o">=</span> <span class="no">B</span> <span class="o">=</span> <span class="no">C</span> <span class="o">=</span> <span class="no">D</span> <span class="o">=</span> <span class="s2">"defined in superclass"</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Included</span>
  <span class="c1"># Constants defined in an included module</span>
  <span class="no">A</span> <span class="o">=</span> <span class="no">B</span> <span class="o">=</span> <span class="no">C</span> <span class="o">=</span> <span class="s2">"defined in included module"</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Enclosing</span>
  <span class="c1"># Constants defined in an enclosing module</span>
  <span class="no">A</span> <span class="o">=</span> <span class="no">B</span> <span class="o">=</span> <span class="s2">"defined in enclosing module"</span>

  <span class="k">class</span> <span class="nc">Local</span> <span class="o">&lt;</span> <span class="no">Super</span>
    <span class="kp">include</span> <span class="no">Included</span>

    <span class="c1"># Locally defined constant</span>
    <span class="no">A</span> <span class="o">=</span> <span class="s2">"defined locally"</span>

    <span class="c1"># The list of modules searched, in the order searched</span>
    <span class="c1"># [Enclosing::Local, Enclosing, Inclued, Super, Object, Kernel]</span>

    <span class="n">search</span> <span class="o">=</span> <span class="p">(</span><span class="no">Module</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">+</span> <span class="nb">self</span><span class="p">.</span><span class="nf">ancestors</span> <span class="o">+</span> <span class="no">Object</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">).</span><span class="nf">uniq</span>
    <span class="nb">puts</span> <span class="no">A</span> <span class="c1"># Prints "defined locally"</span>
    <span class="nb">puts</span> <span class="no">B</span> <span class="c1"># Prints "defined in enclosing module"</span>
    <span class="nb">puts</span> <span class="no">C</span> <span class="c1"># Prints "defined in included module"</span>
    <span class="nb">puts</span> <span class="no">D</span> <span class="c1"># Prints "defined in superclass"</span>
    <span class="nb">puts</span> <span class="no">E</span> <span class="c1"># Prints "defined at toplevel"</span>
    <span class="nb">puts</span> <span class="no">F</span> <span class="c1"># Prints "defined in kernel"</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<hr />

<h4 id="references">References</h4>

<ul>
  <li><a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177/ref=sr_1_1?ie=UTF8&amp;qid=1459784613&amp;sr=8-1&amp;keywords=The+Ruby+Programming+Language">The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto</a></li>
</ul>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
