<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ruby Notes 3 Expression and Operators | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Ruby Notes 3 Expression and Operators" />
<meta property="og:locale" content="en" />
<meta name="description" content="An expression is a chunk of Ruby code that the Ruby interpreter can evaluate to produce a value. In Ruby, they is no clear distinction between statements and expressions; everything in Ruby, including class and method definitions, can be evaluated as expression and will return a value. Literals and Keyword Literals Primary Expressions, Compound Expression Literals are values such as 1.0, &#39;hello world&#39;, and [] that are embedded directly into your program text. Certain Ruby keywords are primary expression can can be considered Keyword literals or specialized forms of variable reference: nil Evaluates to the nil value, of class NilClass. true Evaluates to the singleton instance of class TrueClass, an object that represents the Boolean value true. false Evaluates to the singleton instance of class FalseClass, an object that represents the Boolean value false. self Evaluates to the current object. __FILE__ Evaluates to a string that names the file that the Ruby interpreter is executing. This can be useful in error messages. __LINE__ Evaluates to an integer that specifies the line number within FILE of the current line of code. __ENCODING__ Evaluates to an Encoding object that specifies the encoding of the current file. (Ruby 1.9 only.) Variable References A variable is simply a name for a value. When the name of a variable appears in a program anywhere other than lefthand side of an assignment, it is a variable refernece expression and evaluates to the value of the variable: one = 1.0 # This is an assignment expression one # This varible reference expression evaluates to 1.0 There are four kinds of variables in Ruby. global variables Variables that begin with $ are global variables, visible throughout a Ruby program. instance variables and class variables Variables that begin with @ and @@ are instance variables and class varibles, used in object-oriented programming. local varibles Varibles whose names begin with an underscore or a lowercase letter are locale varibles, defined only within the current method or block. Uninitialized Variables In general, you should always assign a value to, or initialize, your variables before using them in expressions. In some cirumstances, however, Ruby will allow you to use variables that have not yet been intialized. Class varibles Class variables must always have a value assign to them before they are used. Ruby raises a NameError if you refer to a class variable to which no value has been assigned. Instance variables If you refer to an unitialized instance variable, Ruby returns nil. It is considered bad programming to reply on this behavior, however. Ruby will issue a warning about the unitialized variable if you run it with the -w option. Global varialbes Unitialized global variables are like unitialzied instance variables: they evaluate to nil, but cause a warning when Ruby is run with the -w flag. Local variables If the Ruby interpreter has seen an assignment to a local variable, it knows it is a variable and not a method, and it can return the value of the varialbe. If there has been no assignment, then Ruby treats the expression as a method invocation. If no method by that name exists, Ruby raises a NameError. A variable that exists but has not been assigned a value is given the default value nil. a = 0.0 if false # This assignment is never executed print a # Prints nil: the variable exits but is not assigned print b # NameError: no variable or method named b exists Constant References The Ruby interpreter does not actually enforce the constancy of constants, but it does issue a warning if a program changes the value of a constant. Lexically, the names of constants look like the name of local variables, execpt that they begin with a capital letter. By convention, most constants are written in all upcase with underscores to separate words, LIKE_THIS. Ruby class and module names are also constants, but they are conventionally written using initial capital letters and camel case, LikeThis. A constant reference is an expression that evaluates to the value of the named constant. :: :: is used to separate the name of the constant from the class or module in which it is defined. The lefthand side of the :: may be an arbitrary expression that evaluates to a class or module object. The righthand side of the :: is the name of a constant defined by the class or module. The lefthand side of the :: may be omitted, in which case the constant is looked up in the global scope. CM_PER_INCH = 2.54 # Define a constant. CM_PER_INCH # Refer to the constant. Evaluates to 2.54. Conversions::CM_PER_INCH # Constant defined in the Conversions module modules[0]::NAME # Constant defined by an element of an array Conversions::Area::HECTARES_PER_ACRE # Modules may be nested. ::ARGV # The left side of the :: may be omitted. Note that there is not actually a “global scope” for constants. Like global funcitons, global constants are defined (and looked up) within the Object class. The expression ::ARGV, therefore, is simply shorthand for Object::ARGV. When Ruby evaluates a constant reference expression, it returns the value of the constant, or it raises a NameError exception if no constant by that name could be found. Note that constants do not exist unitl a value is acctually assigned to them. Method Invocations A method invocation expression has four parts: An arbitrary expression whose value is the object on which the method is invoked. This expression is followed by . or :: to separate it from the method name that follows. The expression and separator are optional; if omitted, the method invoked on self. The name of the method beging invoked. The argument values being passed to the method. An optional block of code delimited by curly braces or by a do/end pair. The value of a method invocation expression is the value of the last evaluated epxression in th body of the mehtod. Methods defined by Kernel are global functions, and global fuctions are defined as private methods of the Object class. If a variable named x exists (that is, if the Ruby interpreter has seen an assignment to x), then this is a variable reference expression. If no such variable exits, then this is an invocation of the method x, with no arguments, on self. Assignments An assignment expression specifies on or more values for one or more lvalues. lvalue is the term for something that can appear on the lefthand side of an assignment operator. (Values on the righthand side of an assignment operator are sometimes called rvalues by contrast.) Variables, constants, attributes, and array elements are lvalues in Ruby. The value of an assignment expression is the value (or an array of the values) assigned. The assignment operator is “right-associative”—if multiple assignments appear in a single expression, they are evaluated from right to left. x = 1 # Set the lvalue x to the value 1 x += 1 # Set the lvalue x to the value x + 1 x,y,z = 1,2,3 # Set x to 1, y to 2 and z to 3 x = y = 0 # Set x and y to 0 Assiging to Variables A simple expression such as x could refer to a local variable named x or a method of self named x. To resolve this ambiguity, Ruby treats an identifier as a local variable if it has been seen any previous assignment to the variable. It does this even if that assignment was never executed. class Ambiguous def x; 1; end # A method named &quot;x&quot;. Always returns 1 def test puts x # No variable has been seen; refers to method above: prints 1 # The line below is never evaluated, because of the &quot;if false&quot; clause. But # the parser sees it and treats x as a variable for the rest of the method. x = 0 if false puts x # x is a variable, but has never been assigned to: prints nil x = 2 # This assignment does get evaluated puts x # So now this line prints 2 end end Assigning to Constants Assignment to a constant that already extists causes Ruby to issue a warning. Assignment to constants is not allowed within the body of a method. Unlike variables, constants do not come into extistence until the Ruby interpreter actually executes the assignment expression. Assigning to Arributes and Array Elements Assignment to an attribute or array element is actually Ruby shorthand for mehtod invocation. o.m = v o.m=(v) o[x] = y o[](x,y) o[x,y] = z o[](x,y,z) Abbreviated Assigment x += y x = x + y x -= y x = x - y x *= y x = x * y x /= y x = x / y x %= y x = x % y x **= y x = x ** y x &amp;&amp;= y x = x &amp;&amp; y x ||= y x = x || y x &amp;= y x = x &amp; y x |= y x = x | y x ^= y x = x ^ y x &lt;&lt;= y x = x &lt;&lt; y x &gt;&gt;= y x = x &gt;&gt; y Parallel Assignment Same number of lvalues and rvalues x, y, z = 1, 2, 3 # x=1; y=2; z=3 x, y = y, x # Parallel: swap the value of two variables One lvalue, multiple rvalues x = 1, 2, 3 # x = [1, 2, 3] x, = 1, 2, 3 # x = 1; other values are discarded Multiple lvalues, single array rvalue x, y, z = [1, 2, 3] # Same as x,y,z = 1,2,3 x = [1,2] # x becomes [1,2]: this is not parallel assignment x, = [1,2] # x becomes 1: the trailing comma makes it parallel Different numbers of lvalues and rvalues x, y, z = 1, 2 # x=1, y=2; z=nil x, y = 1, 2, 3 # x=1, y=2, 3 is not assigned anywhere The splat operator lvalues and rvalues may be prefixed with , which is sometimes called the *splat operator, though it is not a true operator. x, y, z = 1, *[2,3] # Same as x,y,z = 1,2,3 x, *y = 1, 2, 3 # x=1; y=[2,3] x, *y = 1, 2 # x=1; y=[2] x, *y = 1 # x=1; y=[] *x, y = 1, 2, 3 # x=[1,2]; y=3 *x,y = 1, 2 # x=[1]; y=2 *x,y = 1 # x=[]; y=1 x, y , *z = 1, *[2,3,4] # x=1; y=2; z=[3,4] Parentheses in parallel assigment x, (y,z) = a, b # x = a; y, z = b x, y, z = 1,[2,3] # No parens: x=1;y=[2,3];z=nil x,(y,z) = 1,[2,3] # Parens: x=1; y=2; z=3 a,b,c,d = [1,[2,[3,[4]]]] # No parens: a=1; b=[2,[3,4]]; c=d=nil a,(b,(c,(d))) = [1,[2,[3,[4]]]] # parens: a=1;b=2;c=3;d=4 The value of parallel assignment The return value of a parallel assignment expression is the array of rvalues. Parallel Assignment and Method Invocation puts x,y=1,2 # puts (x,y=1,2) puts ((x,y=1,2)) Operators Ruby operators, by precedence (high to low), with arity (N), associativity (A), and definability (M) Operator(s) N A M Operation ! ~ + 1 R Y Boolean NOT, bitwise complement, unary plusa ** 2 R Y Exponentiation - 1 R Y Unary minus (define with -@) * / % 2 L Y Multiplication, division, modulo (remainder) + - 2 L Y Addition (or concatenation), subtraction &lt;&lt; &gt;&gt; 2 L Y Bitwise shift-left (or append), bitwise shift-right &amp; 2 L Y Bitwise AND | ^ 2 L Y Bitwise OR, bitwise XOR &lt; &lt;= &gt;= &gt; 2 L Y Ordering == === != =~ !~ &lt;=&gt; 2 N Y Equality, pattern matching, comparisonb &amp;&amp; 2 L N Boolean AND || 2 L N Boolean OR .. ... 2 N N Range creation and Boolean flip-flops ?: 3 R N Conditional rescue 2 L N Exception-handling modifier = 2 R N Assignment **= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;&amp;= &amp;= ||= |= ^= defined? 1 N N Test variable definition and type not 1 R N Boolean NOT (low precedence) and or 2 L N Boolean AND, Boolean OR (low precedence) if unless while until 2 N N Conditional and loop modifiers Nonoperators () Parenthese are an optinal part of method definition and invocation syntax. Parentheses are also used for grouping to affect the order of evaluation of subexpressions. [] Square brackets are used in array literals and for quering and setting array and hash values. In that context, they are syntactic sugar for method invocation and behave somewhat like redefinable operators with arbitrary arity. {} Curly braces are alternative to do/end in blocks, and are also used in hash literals. . and :: . and :: are used in qualified names. ;,, and =&gt; The semicolon ; is used to separate stateemnts on the same line; the comma , is used to separate method arguments and the elements of array and hash literals; and the arrow =&gt; is used to separate hash keys from hash values in hash literals. : A colon is used to prefix symbol literals and is also used in Ruby 1.9 hash syntax. *,&amp; and &lt; Putting * before array in an assinment or method invocation expression expands or unpacks the array into its individual elements. &amp; can be used in a method declaration before the name of the last method argument, and this cause any block passed to the method to be assigned to that argument. &lt; is used in class definitions to specify the superclass of class. References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto" />
<meta property="og:description" content="An expression is a chunk of Ruby code that the Ruby interpreter can evaluate to produce a value. In Ruby, they is no clear distinction between statements and expressions; everything in Ruby, including class and method definitions, can be evaluated as expression and will return a value. Literals and Keyword Literals Primary Expressions, Compound Expression Literals are values such as 1.0, &#39;hello world&#39;, and [] that are embedded directly into your program text. Certain Ruby keywords are primary expression can can be considered Keyword literals or specialized forms of variable reference: nil Evaluates to the nil value, of class NilClass. true Evaluates to the singleton instance of class TrueClass, an object that represents the Boolean value true. false Evaluates to the singleton instance of class FalseClass, an object that represents the Boolean value false. self Evaluates to the current object. __FILE__ Evaluates to a string that names the file that the Ruby interpreter is executing. This can be useful in error messages. __LINE__ Evaluates to an integer that specifies the line number within FILE of the current line of code. __ENCODING__ Evaluates to an Encoding object that specifies the encoding of the current file. (Ruby 1.9 only.) Variable References A variable is simply a name for a value. When the name of a variable appears in a program anywhere other than lefthand side of an assignment, it is a variable refernece expression and evaluates to the value of the variable: one = 1.0 # This is an assignment expression one # This varible reference expression evaluates to 1.0 There are four kinds of variables in Ruby. global variables Variables that begin with $ are global variables, visible throughout a Ruby program. instance variables and class variables Variables that begin with @ and @@ are instance variables and class varibles, used in object-oriented programming. local varibles Varibles whose names begin with an underscore or a lowercase letter are locale varibles, defined only within the current method or block. Uninitialized Variables In general, you should always assign a value to, or initialize, your variables before using them in expressions. In some cirumstances, however, Ruby will allow you to use variables that have not yet been intialized. Class varibles Class variables must always have a value assign to them before they are used. Ruby raises a NameError if you refer to a class variable to which no value has been assigned. Instance variables If you refer to an unitialized instance variable, Ruby returns nil. It is considered bad programming to reply on this behavior, however. Ruby will issue a warning about the unitialized variable if you run it with the -w option. Global varialbes Unitialized global variables are like unitialzied instance variables: they evaluate to nil, but cause a warning when Ruby is run with the -w flag. Local variables If the Ruby interpreter has seen an assignment to a local variable, it knows it is a variable and not a method, and it can return the value of the varialbe. If there has been no assignment, then Ruby treats the expression as a method invocation. If no method by that name exists, Ruby raises a NameError. A variable that exists but has not been assigned a value is given the default value nil. a = 0.0 if false # This assignment is never executed print a # Prints nil: the variable exits but is not assigned print b # NameError: no variable or method named b exists Constant References The Ruby interpreter does not actually enforce the constancy of constants, but it does issue a warning if a program changes the value of a constant. Lexically, the names of constants look like the name of local variables, execpt that they begin with a capital letter. By convention, most constants are written in all upcase with underscores to separate words, LIKE_THIS. Ruby class and module names are also constants, but they are conventionally written using initial capital letters and camel case, LikeThis. A constant reference is an expression that evaluates to the value of the named constant. :: :: is used to separate the name of the constant from the class or module in which it is defined. The lefthand side of the :: may be an arbitrary expression that evaluates to a class or module object. The righthand side of the :: is the name of a constant defined by the class or module. The lefthand side of the :: may be omitted, in which case the constant is looked up in the global scope. CM_PER_INCH = 2.54 # Define a constant. CM_PER_INCH # Refer to the constant. Evaluates to 2.54. Conversions::CM_PER_INCH # Constant defined in the Conversions module modules[0]::NAME # Constant defined by an element of an array Conversions::Area::HECTARES_PER_ACRE # Modules may be nested. ::ARGV # The left side of the :: may be omitted. Note that there is not actually a “global scope” for constants. Like global funcitons, global constants are defined (and looked up) within the Object class. The expression ::ARGV, therefore, is simply shorthand for Object::ARGV. When Ruby evaluates a constant reference expression, it returns the value of the constant, or it raises a NameError exception if no constant by that name could be found. Note that constants do not exist unitl a value is acctually assigned to them. Method Invocations A method invocation expression has four parts: An arbitrary expression whose value is the object on which the method is invoked. This expression is followed by . or :: to separate it from the method name that follows. The expression and separator are optional; if omitted, the method invoked on self. The name of the method beging invoked. The argument values being passed to the method. An optional block of code delimited by curly braces or by a do/end pair. The value of a method invocation expression is the value of the last evaluated epxression in th body of the mehtod. Methods defined by Kernel are global functions, and global fuctions are defined as private methods of the Object class. If a variable named x exists (that is, if the Ruby interpreter has seen an assignment to x), then this is a variable reference expression. If no such variable exits, then this is an invocation of the method x, with no arguments, on self. Assignments An assignment expression specifies on or more values for one or more lvalues. lvalue is the term for something that can appear on the lefthand side of an assignment operator. (Values on the righthand side of an assignment operator are sometimes called rvalues by contrast.) Variables, constants, attributes, and array elements are lvalues in Ruby. The value of an assignment expression is the value (or an array of the values) assigned. The assignment operator is “right-associative”—if multiple assignments appear in a single expression, they are evaluated from right to left. x = 1 # Set the lvalue x to the value 1 x += 1 # Set the lvalue x to the value x + 1 x,y,z = 1,2,3 # Set x to 1, y to 2 and z to 3 x = y = 0 # Set x and y to 0 Assiging to Variables A simple expression such as x could refer to a local variable named x or a method of self named x. To resolve this ambiguity, Ruby treats an identifier as a local variable if it has been seen any previous assignment to the variable. It does this even if that assignment was never executed. class Ambiguous def x; 1; end # A method named &quot;x&quot;. Always returns 1 def test puts x # No variable has been seen; refers to method above: prints 1 # The line below is never evaluated, because of the &quot;if false&quot; clause. But # the parser sees it and treats x as a variable for the rest of the method. x = 0 if false puts x # x is a variable, but has never been assigned to: prints nil x = 2 # This assignment does get evaluated puts x # So now this line prints 2 end end Assigning to Constants Assignment to a constant that already extists causes Ruby to issue a warning. Assignment to constants is not allowed within the body of a method. Unlike variables, constants do not come into extistence until the Ruby interpreter actually executes the assignment expression. Assigning to Arributes and Array Elements Assignment to an attribute or array element is actually Ruby shorthand for mehtod invocation. o.m = v o.m=(v) o[x] = y o[](x,y) o[x,y] = z o[](x,y,z) Abbreviated Assigment x += y x = x + y x -= y x = x - y x *= y x = x * y x /= y x = x / y x %= y x = x % y x **= y x = x ** y x &amp;&amp;= y x = x &amp;&amp; y x ||= y x = x || y x &amp;= y x = x &amp; y x |= y x = x | y x ^= y x = x ^ y x &lt;&lt;= y x = x &lt;&lt; y x &gt;&gt;= y x = x &gt;&gt; y Parallel Assignment Same number of lvalues and rvalues x, y, z = 1, 2, 3 # x=1; y=2; z=3 x, y = y, x # Parallel: swap the value of two variables One lvalue, multiple rvalues x = 1, 2, 3 # x = [1, 2, 3] x, = 1, 2, 3 # x = 1; other values are discarded Multiple lvalues, single array rvalue x, y, z = [1, 2, 3] # Same as x,y,z = 1,2,3 x = [1,2] # x becomes [1,2]: this is not parallel assignment x, = [1,2] # x becomes 1: the trailing comma makes it parallel Different numbers of lvalues and rvalues x, y, z = 1, 2 # x=1, y=2; z=nil x, y = 1, 2, 3 # x=1, y=2, 3 is not assigned anywhere The splat operator lvalues and rvalues may be prefixed with , which is sometimes called the *splat operator, though it is not a true operator. x, y, z = 1, *[2,3] # Same as x,y,z = 1,2,3 x, *y = 1, 2, 3 # x=1; y=[2,3] x, *y = 1, 2 # x=1; y=[2] x, *y = 1 # x=1; y=[] *x, y = 1, 2, 3 # x=[1,2]; y=3 *x,y = 1, 2 # x=[1]; y=2 *x,y = 1 # x=[]; y=1 x, y , *z = 1, *[2,3,4] # x=1; y=2; z=[3,4] Parentheses in parallel assigment x, (y,z) = a, b # x = a; y, z = b x, y, z = 1,[2,3] # No parens: x=1;y=[2,3];z=nil x,(y,z) = 1,[2,3] # Parens: x=1; y=2; z=3 a,b,c,d = [1,[2,[3,[4]]]] # No parens: a=1; b=[2,[3,4]]; c=d=nil a,(b,(c,(d))) = [1,[2,[3,[4]]]] # parens: a=1;b=2;c=3;d=4 The value of parallel assignment The return value of a parallel assignment expression is the array of rvalues. Parallel Assignment and Method Invocation puts x,y=1,2 # puts (x,y=1,2) puts ((x,y=1,2)) Operators Ruby operators, by precedence (high to low), with arity (N), associativity (A), and definability (M) Operator(s) N A M Operation ! ~ + 1 R Y Boolean NOT, bitwise complement, unary plusa ** 2 R Y Exponentiation - 1 R Y Unary minus (define with -@) * / % 2 L Y Multiplication, division, modulo (remainder) + - 2 L Y Addition (or concatenation), subtraction &lt;&lt; &gt;&gt; 2 L Y Bitwise shift-left (or append), bitwise shift-right &amp; 2 L Y Bitwise AND | ^ 2 L Y Bitwise OR, bitwise XOR &lt; &lt;= &gt;= &gt; 2 L Y Ordering == === != =~ !~ &lt;=&gt; 2 N Y Equality, pattern matching, comparisonb &amp;&amp; 2 L N Boolean AND || 2 L N Boolean OR .. ... 2 N N Range creation and Boolean flip-flops ?: 3 R N Conditional rescue 2 L N Exception-handling modifier = 2 R N Assignment **= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;&amp;= &amp;= ||= |= ^= defined? 1 N N Test variable definition and type not 1 R N Boolean NOT (low precedence) and or 2 L N Boolean AND, Boolean OR (low precedence) if unless while until 2 N N Conditional and loop modifiers Nonoperators () Parenthese are an optinal part of method definition and invocation syntax. Parentheses are also used for grouping to affect the order of evaluation of subexpressions. [] Square brackets are used in array literals and for quering and setting array and hash values. In that context, they are syntactic sugar for method invocation and behave somewhat like redefinable operators with arbitrary arity. {} Curly braces are alternative to do/end in blocks, and are also used in hash literals. . and :: . and :: are used in qualified names. ;,, and =&gt; The semicolon ; is used to separate stateemnts on the same line; the comma , is used to separate method arguments and the elements of array and hash literals; and the arrow =&gt; is used to separate hash keys from hash values in hash literals. : A colon is used to prefix symbol literals and is also used in Ruby 1.9 hash syntax. *,&amp; and &lt; Putting * before array in an assinment or method invocation expression expands or unpacks the array into its individual elements. &amp; can be used in a method declaration before the name of the last method argument, and this cause any block passed to the method to be assigned to that argument. &lt; is used in class definitions to specify the superclass of class. References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto" />
<link rel="canonical" href="https://blog.codefarm.me/2016/04/05/ruby-notes-3-expression-and-operators/" />
<meta property="og:url" content="https://blog.codefarm.me/2016/04/05/ruby-notes-3-expression-and-operators/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-04-05T04:35:28+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ruby Notes 3 Expression and Operators" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-04-05T04:35:28+08:00","datePublished":"2016-04-05T04:35:28+08:00","description":"An expression is a chunk of Ruby code that the Ruby interpreter can evaluate to produce a value. In Ruby, they is no clear distinction between statements and expressions; everything in Ruby, including class and method definitions, can be evaluated as expression and will return a value. Literals and Keyword Literals Primary Expressions, Compound Expression Literals are values such as 1.0, &#39;hello world&#39;, and [] that are embedded directly into your program text. Certain Ruby keywords are primary expression can can be considered Keyword literals or specialized forms of variable reference: nil Evaluates to the nil value, of class NilClass. true Evaluates to the singleton instance of class TrueClass, an object that represents the Boolean value true. false Evaluates to the singleton instance of class FalseClass, an object that represents the Boolean value false. self Evaluates to the current object. __FILE__ Evaluates to a string that names the file that the Ruby interpreter is executing. This can be useful in error messages. __LINE__ Evaluates to an integer that specifies the line number within FILE of the current line of code. __ENCODING__ Evaluates to an Encoding object that specifies the encoding of the current file. (Ruby 1.9 only.) Variable References A variable is simply a name for a value. When the name of a variable appears in a program anywhere other than lefthand side of an assignment, it is a variable refernece expression and evaluates to the value of the variable: one = 1.0 # This is an assignment expression one # This varible reference expression evaluates to 1.0 There are four kinds of variables in Ruby. global variables Variables that begin with $ are global variables, visible throughout a Ruby program. instance variables and class variables Variables that begin with @ and @@ are instance variables and class varibles, used in object-oriented programming. local varibles Varibles whose names begin with an underscore or a lowercase letter are locale varibles, defined only within the current method or block. Uninitialized Variables In general, you should always assign a value to, or initialize, your variables before using them in expressions. In some cirumstances, however, Ruby will allow you to use variables that have not yet been intialized. Class varibles Class variables must always have a value assign to them before they are used. Ruby raises a NameError if you refer to a class variable to which no value has been assigned. Instance variables If you refer to an unitialized instance variable, Ruby returns nil. It is considered bad programming to reply on this behavior, however. Ruby will issue a warning about the unitialized variable if you run it with the -w option. Global varialbes Unitialized global variables are like unitialzied instance variables: they evaluate to nil, but cause a warning when Ruby is run with the -w flag. Local variables If the Ruby interpreter has seen an assignment to a local variable, it knows it is a variable and not a method, and it can return the value of the varialbe. If there has been no assignment, then Ruby treats the expression as a method invocation. If no method by that name exists, Ruby raises a NameError. A variable that exists but has not been assigned a value is given the default value nil. a = 0.0 if false # This assignment is never executed print a # Prints nil: the variable exits but is not assigned print b # NameError: no variable or method named b exists Constant References The Ruby interpreter does not actually enforce the constancy of constants, but it does issue a warning if a program changes the value of a constant. Lexically, the names of constants look like the name of local variables, execpt that they begin with a capital letter. By convention, most constants are written in all upcase with underscores to separate words, LIKE_THIS. Ruby class and module names are also constants, but they are conventionally written using initial capital letters and camel case, LikeThis. A constant reference is an expression that evaluates to the value of the named constant. :: :: is used to separate the name of the constant from the class or module in which it is defined. The lefthand side of the :: may be an arbitrary expression that evaluates to a class or module object. The righthand side of the :: is the name of a constant defined by the class or module. The lefthand side of the :: may be omitted, in which case the constant is looked up in the global scope. CM_PER_INCH = 2.54 # Define a constant. CM_PER_INCH # Refer to the constant. Evaluates to 2.54. Conversions::CM_PER_INCH # Constant defined in the Conversions module modules[0]::NAME # Constant defined by an element of an array Conversions::Area::HECTARES_PER_ACRE # Modules may be nested. ::ARGV # The left side of the :: may be omitted. Note that there is not actually a “global scope” for constants. Like global funcitons, global constants are defined (and looked up) within the Object class. The expression ::ARGV, therefore, is simply shorthand for Object::ARGV. When Ruby evaluates a constant reference expression, it returns the value of the constant, or it raises a NameError exception if no constant by that name could be found. Note that constants do not exist unitl a value is acctually assigned to them. Method Invocations A method invocation expression has four parts: An arbitrary expression whose value is the object on which the method is invoked. This expression is followed by . or :: to separate it from the method name that follows. The expression and separator are optional; if omitted, the method invoked on self. The name of the method beging invoked. The argument values being passed to the method. An optional block of code delimited by curly braces or by a do/end pair. The value of a method invocation expression is the value of the last evaluated epxression in th body of the mehtod. Methods defined by Kernel are global functions, and global fuctions are defined as private methods of the Object class. If a variable named x exists (that is, if the Ruby interpreter has seen an assignment to x), then this is a variable reference expression. If no such variable exits, then this is an invocation of the method x, with no arguments, on self. Assignments An assignment expression specifies on or more values for one or more lvalues. lvalue is the term for something that can appear on the lefthand side of an assignment operator. (Values on the righthand side of an assignment operator are sometimes called rvalues by contrast.) Variables, constants, attributes, and array elements are lvalues in Ruby. The value of an assignment expression is the value (or an array of the values) assigned. The assignment operator is “right-associative”—if multiple assignments appear in a single expression, they are evaluated from right to left. x = 1 # Set the lvalue x to the value 1 x += 1 # Set the lvalue x to the value x + 1 x,y,z = 1,2,3 # Set x to 1, y to 2 and z to 3 x = y = 0 # Set x and y to 0 Assiging to Variables A simple expression such as x could refer to a local variable named x or a method of self named x. To resolve this ambiguity, Ruby treats an identifier as a local variable if it has been seen any previous assignment to the variable. It does this even if that assignment was never executed. class Ambiguous def x; 1; end # A method named &quot;x&quot;. Always returns 1 def test puts x # No variable has been seen; refers to method above: prints 1 # The line below is never evaluated, because of the &quot;if false&quot; clause. But # the parser sees it and treats x as a variable for the rest of the method. x = 0 if false puts x # x is a variable, but has never been assigned to: prints nil x = 2 # This assignment does get evaluated puts x # So now this line prints 2 end end Assigning to Constants Assignment to a constant that already extists causes Ruby to issue a warning. Assignment to constants is not allowed within the body of a method. Unlike variables, constants do not come into extistence until the Ruby interpreter actually executes the assignment expression. Assigning to Arributes and Array Elements Assignment to an attribute or array element is actually Ruby shorthand for mehtod invocation. o.m = v o.m=(v) o[x] = y o[](x,y) o[x,y] = z o[](x,y,z) Abbreviated Assigment x += y x = x + y x -= y x = x - y x *= y x = x * y x /= y x = x / y x %= y x = x % y x **= y x = x ** y x &amp;&amp;= y x = x &amp;&amp; y x ||= y x = x || y x &amp;= y x = x &amp; y x |= y x = x | y x ^= y x = x ^ y x &lt;&lt;= y x = x &lt;&lt; y x &gt;&gt;= y x = x &gt;&gt; y Parallel Assignment Same number of lvalues and rvalues x, y, z = 1, 2, 3 # x=1; y=2; z=3 x, y = y, x # Parallel: swap the value of two variables One lvalue, multiple rvalues x = 1, 2, 3 # x = [1, 2, 3] x, = 1, 2, 3 # x = 1; other values are discarded Multiple lvalues, single array rvalue x, y, z = [1, 2, 3] # Same as x,y,z = 1,2,3 x = [1,2] # x becomes [1,2]: this is not parallel assignment x, = [1,2] # x becomes 1: the trailing comma makes it parallel Different numbers of lvalues and rvalues x, y, z = 1, 2 # x=1, y=2; z=nil x, y = 1, 2, 3 # x=1, y=2, 3 is not assigned anywhere The splat operator lvalues and rvalues may be prefixed with , which is sometimes called the *splat operator, though it is not a true operator. x, y, z = 1, *[2,3] # Same as x,y,z = 1,2,3 x, *y = 1, 2, 3 # x=1; y=[2,3] x, *y = 1, 2 # x=1; y=[2] x, *y = 1 # x=1; y=[] *x, y = 1, 2, 3 # x=[1,2]; y=3 *x,y = 1, 2 # x=[1]; y=2 *x,y = 1 # x=[]; y=1 x, y , *z = 1, *[2,3,4] # x=1; y=2; z=[3,4] Parentheses in parallel assigment x, (y,z) = a, b # x = a; y, z = b x, y, z = 1,[2,3] # No parens: x=1;y=[2,3];z=nil x,(y,z) = 1,[2,3] # Parens: x=1; y=2; z=3 a,b,c,d = [1,[2,[3,[4]]]] # No parens: a=1; b=[2,[3,4]]; c=d=nil a,(b,(c,(d))) = [1,[2,[3,[4]]]] # parens: a=1;b=2;c=3;d=4 The value of parallel assignment The return value of a parallel assignment expression is the array of rvalues. Parallel Assignment and Method Invocation puts x,y=1,2 # puts (x,y=1,2) puts ((x,y=1,2)) Operators Ruby operators, by precedence (high to low), with arity (N), associativity (A), and definability (M) Operator(s) N A M Operation ! ~ + 1 R Y Boolean NOT, bitwise complement, unary plusa ** 2 R Y Exponentiation - 1 R Y Unary minus (define with -@) * / % 2 L Y Multiplication, division, modulo (remainder) + - 2 L Y Addition (or concatenation), subtraction &lt;&lt; &gt;&gt; 2 L Y Bitwise shift-left (or append), bitwise shift-right &amp; 2 L Y Bitwise AND | ^ 2 L Y Bitwise OR, bitwise XOR &lt; &lt;= &gt;= &gt; 2 L Y Ordering == === != =~ !~ &lt;=&gt; 2 N Y Equality, pattern matching, comparisonb &amp;&amp; 2 L N Boolean AND || 2 L N Boolean OR .. ... 2 N N Range creation and Boolean flip-flops ?: 3 R N Conditional rescue 2 L N Exception-handling modifier = 2 R N Assignment **= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;&amp;= &amp;= ||= |= ^= defined? 1 N N Test variable definition and type not 1 R N Boolean NOT (low precedence) and or 2 L N Boolean AND, Boolean OR (low precedence) if unless while until 2 N N Conditional and loop modifiers Nonoperators () Parenthese are an optinal part of method definition and invocation syntax. Parentheses are also used for grouping to affect the order of evaluation of subexpressions. [] Square brackets are used in array literals and for quering and setting array and hash values. In that context, they are syntactic sugar for method invocation and behave somewhat like redefinable operators with arbitrary arity. {} Curly braces are alternative to do/end in blocks, and are also used in hash literals. . and :: . and :: are used in qualified names. ;,, and =&gt; The semicolon ; is used to separate stateemnts on the same line; the comma , is used to separate method arguments and the elements of array and hash literals; and the arrow =&gt; is used to separate hash keys from hash values in hash literals. : A colon is used to prefix symbol literals and is also used in Ruby 1.9 hash syntax. *,&amp; and &lt; Putting * before array in an assinment or method invocation expression expands or unpacks the array into its individual elements. &amp; can be used in a method declaration before the name of the last method argument, and this cause any block passed to the method to be assigned to that argument. &lt; is used in class definitions to specify the superclass of class. References The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto","headline":"Ruby Notes 3 Expression and Operators","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2016/04/05/ruby-notes-3-expression-and-operators/"},"url":"https://blog.codefarm.me/2016/04/05/ruby-notes-3-expression-and-operators/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Ruby Notes 3 Expression and Operators</h1><p class="c-post-meta">05 Apr 2016</p>
  </header>

  <div class="c-post-content">
    <p>An <em>expression</em> is a chunk of Ruby code that the Ruby interpreter can evaluate to produce a value.</p>

<p>In Ruby, they is no clear distinction between statements and expressions; everything in Ruby, including class and method definitions, can be evaluated as expression and will return a value.</p>

<h3 id="literals-and-keyword-literals">Literals and Keyword Literals</h3>

<p><em>Primary Expressions</em>, <em>Compound Expression</em></p>

<p><strong>Literals</strong> are values such as <code class="language-plaintext highlighter-rouge">1.0</code>, <code class="language-plaintext highlighter-rouge">'hello world'</code>, and <code class="language-plaintext highlighter-rouge">[]</code> that are embedded directly into your program text.</p>

<p>Certain Ruby keywords are primary expression can can be considered <strong>Keyword literals</strong> or specialized forms of variable reference:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">nil</code></p>

    <p>Evaluates to the nil value, of class NilClass.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">true</code></p>
  </li>
</ul>

<p>Evaluates to the singleton instance of class TrueClass, an object that represents the Boolean value true.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">false</code></p>

    <p>Evaluates to the singleton instance of class FalseClass, an object that represents the Boolean value false.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">self</code></p>

    <p>Evaluates to the current object.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__FILE__</code></p>

    <p>Evaluates to a string that names the file that the Ruby interpreter is executing. This can be useful in error messages.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__LINE__</code></p>

    <p>Evaluates to an integer that specifies the line number within <strong>FILE</strong> of the current line of code.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__ENCODING__</code></p>

    <p>Evaluates to an Encoding object that specifies the encoding of the current file. (Ruby 1.9 only.)</p>
  </li>
</ul>

<h3 id="variable-references">Variable References</h3>

<p>A <em>variable</em> is simply a name for a value.</p>

<p>When the name of a variable appears in a program anywhere other than lefthand side of an assignment, it is a variable refernece expression and evaluates to the value of the variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>one = 1.0   # This is an assignment expression
one         # This varible reference expression evaluates to 1.0
</code></pre></div></div>

<ul>
  <li>
    <p>There are four kinds of variables in Ruby.</p>

    <ul>
      <li>
        <p>global variables</p>

        <p>Variables that begin with <code class="language-plaintext highlighter-rouge">$</code> are global variables, visible throughout a Ruby program.</p>
      </li>
      <li>
        <p>instance variables and class variables</p>

        <p>Variables that begin with <code class="language-plaintext highlighter-rouge">@</code> and <code class="language-plaintext highlighter-rouge">@@</code> are instance variables and class varibles, used in object-oriented programming.</p>
      </li>
      <li>
        <p>local varibles</p>

        <p>Varibles whose names begin with an <em>underscore</em> or a <em>lowercase</em> letter are locale varibles, defined only within the current method or block.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="uninitialized-variables">Uninitialized Variables</h4>

<p>In general, you should always assign a value to, or <em>initialize</em>, your variables before using them in expressions.</p>

<p>In some cirumstances, however, Ruby will allow you to use variables that have not yet been intialized.</p>

<ul>
  <li>
    <p>Class varibles</p>

    <p>Class variables must always have a value assign to them before they are used.</p>

    <p>Ruby raises a <code class="language-plaintext highlighter-rouge">NameError</code> if you refer to a class variable to which no value has been assigned.</p>
  </li>
  <li>
    <p>Instance variables</p>

    <p>If you refer to an unitialized instance variable, Ruby returns <code class="language-plaintext highlighter-rouge">nil</code>.</p>

    <p>It is considered bad programming to reply on this behavior, however.</p>

    <p>Ruby will issue a warning about the unitialized variable if you run it with the <code class="language-plaintext highlighter-rouge">-w</code> option.</p>
  </li>
  <li>
    <p>Global varialbes</p>

    <p>Unitialized global variables are like unitialzied instance variables: they evaluate to <code class="language-plaintext highlighter-rouge">nil</code>, but cause a warning when Ruby is run with the <code class="language-plaintext highlighter-rouge">-w</code> flag.</p>
  </li>
  <li>
    <p>Local variables</p>

    <p>If the Ruby interpreter has seen an assignment to a local variable, it knows it is a variable and not a method, and it can return the value of the varialbe.</p>

    <p>If there has been no assignment, then Ruby treats the expression as a method invocation.</p>

    <p>If no method by that name exists, Ruby raises a <code class="language-plaintext highlighter-rouge">NameError</code>.</p>

    <p>A variable that exists but has not been assigned a value is given the default value <code class="language-plaintext highlighter-rouge">nil</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  a = 0.0 if false    # This assignment is never executed
  print a             # Prints nil: the variable exits but is not assigned
  print b             # NameError: no variable or method named b exists
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="constant-references">Constant References</h3>

<p>The Ruby interpreter does not actually enforce the constancy of constants, but it does issue a warning if a program changes the value of a constant.</p>

<p>Lexically, the names of constants look like the name of local variables, execpt that they begin with a <em>capital letter</em>.</p>

<p>By convention, most constants are written in all upcase with underscores to separate words, <code class="language-plaintext highlighter-rouge">LIKE_THIS</code>.</p>

<p>Ruby class and module names are also constants, but they are conventionally written using initial capital letters and camel case, <code class="language-plaintext highlighter-rouge">LikeThis</code>.</p>

<p>A constant reference is an expression that evaluates to the value of the named constant.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">::</code></p>

    <p><code class="language-plaintext highlighter-rouge">::</code> is used to separate the name of the constant from the class or module in which it is defined.</p>

    <p>The lefthand side of the <code class="language-plaintext highlighter-rouge">::</code> may be an arbitrary expression that evaluates to a class or module object. The righthand side of the <code class="language-plaintext highlighter-rouge">::</code> is the name of a constant defined by the class or module.</p>
  </li>
</ul>

<p>The lefthand side of the :: may be omitted, in which case the constant is looked up in the global scope.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CM_PER_INCH = 2.54          # Define a constant.
CM_PER_INCH                 # Refer to the constant. Evaluates to 2.54.

Conversions::CM_PER_INCH    # Constant defined in the Conversions module
modules[0]::NAME            # Constant defined by an element of an array

Conversions::Area::HECTARES_PER_ACRE    # Modules may be nested.

::ARGV      # The left side of the :: may be omitted.
</code></pre></div></div>

<p><em>Note that there is not actually a “global scope” for constants. Like global funcitons, global constants are defined (and looked up) within the <code class="language-plaintext highlighter-rouge">Object</code> class. The expression <code class="language-plaintext highlighter-rouge">::ARGV</code>, therefore, is simply shorthand for <code class="language-plaintext highlighter-rouge">Object::ARGV</code>.</em></p>

<p>When Ruby evaluates a constant reference expression, it returns the value of the constant, or it raises a <code class="language-plaintext highlighter-rouge">NameError</code> exception if no constant by that name could be found.</p>

<p>Note that constants do not exist unitl a value is acctually assigned to them.</p>

<h3 id="method-invocations">Method Invocations</h3>

<p>A method invocation expression has four parts:</p>

<ul>
  <li>
    <p>An arbitrary expression whose value is the object on which the method is invoked. This expression is followed by <code class="language-plaintext highlighter-rouge">.</code> or <code class="language-plaintext highlighter-rouge">::</code> to separate it from the method name that follows. The expression and separator are optional; if omitted, the method invoked on <code class="language-plaintext highlighter-rouge">self</code>.</p>
  </li>
  <li>
    <p>The name of the method beging invoked.</p>
  </li>
  <li>
    <p>The argument values being passed to the method.</p>
  </li>
  <li>
    <p>An optional block of code delimited by curly braces or by a <code class="language-plaintext highlighter-rouge">do/end</code> pair.</p>
  </li>
</ul>

<p>The value of a method invocation expression is the value of the last evaluated epxression in th body of the mehtod.</p>

<p>Methods defined by <code class="language-plaintext highlighter-rouge">Kernel</code> are global functions, and global fuctions are defined as private methods of the <code class="language-plaintext highlighter-rouge">Object</code> class.</p>

<p>If a variable named <em>x</em> exists (that is, if the Ruby interpreter has seen an assignment to <em>x</em>), then this is a variable reference expression. If no such variable exits, then this is an invocation of the method <em>x</em>, with no arguments, on <code class="language-plaintext highlighter-rouge">self</code>.</p>

<h3 id="assignments">Assignments</h3>

<p>An assignment expression specifies on or more values for one or more lvalues.</p>

<p><strong>lvalue</strong> is the term for something that can appear on the lefthand side of an assignment operator. (Values on the righthand side of an assignment operator are sometimes called <strong>rvalues</strong> by contrast.)</p>

<p>Variables, constants, attributes, and array elements are lvalues in Ruby.</p>

<p>The value of an assignment expression is the value (or an array of the values) assigned.</p>

<p>The assignment operator is “right-associative”—if multiple assignments appear in a single expression, they are evaluated from right to left.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 1           # Set the lvalue x to the value 1
x += 1          # Set the lvalue x to the value x + 1
x,y,z = 1,2,3   # Set x to 1, y to 2 and z to 3
x = y = 0       # Set x and y to 0
</code></pre></div></div>

<ul>
  <li>Assiging to Variables</li>
</ul>

<p>A simple expression such as <code class="language-plaintext highlighter-rouge">x</code> could refer to a local variable named <code class="language-plaintext highlighter-rouge">x</code> or a method of <code class="language-plaintext highlighter-rouge">self</code> named <code class="language-plaintext highlighter-rouge">x</code>. To resolve this ambiguity, Ruby treats an identifier as a local variable if it has been seen any previous assignment to the variable. It does this even if that assignment was never executed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Ambiguous
  def x; 1; end # A method named "x". Always returns 1

  def test
    puts x      # No variable has been seen; refers to method above: prints 1

    # The line below is never evaluated, because of the "if false" clause. But
    # the parser sees it and treats x as a variable for the rest of the method.
    x = 0 if false

    puts x    # x is a variable, but has never been assigned to: prints nil

    x = 2     # This assignment does get evaluated
    puts x    # So now this line prints 2
  end
end
</code></pre></div></div>

<ul>
  <li>
    <p>Assigning to Constants</p>

    <ul>
      <li>
        <p>Assignment to a constant that already extists causes Ruby to issue a warning.</p>
      </li>
      <li>
        <p>Assignment to constants is not allowed within the body of a method.</p>
      </li>
      <li>
        <p>Unlike variables, constants do not come into extistence until the Ruby interpreter actually executes the assignment expression.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Assigning to Arributes and Array Elements</p>
  </li>
</ul>

<p>Assignment to an attribute or array element is actually Ruby shorthand for mehtod invocation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>o.m = v
o.m=(v)

o[x] = y
o[](x,y)

o[x,y] = z
o[](x,y,z)
</code></pre></div></div>

<ul>
  <li>
    <p>Abbreviated Assigment</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x += y       x = x + y
  x -= y       x = x - y
  x *= y       x = x * y
  x /= y       x = x / y
  x %= y       x = x % y
  x **= y      x = x ** y
  x &amp;&amp;= y      x = x &amp;&amp; y
  x ||= y      x = x || y
  x &amp;= y       x = x &amp; y
  x |= y       x = x | y
  x ^= y       x = x ^ y
  x &lt;&lt;= y      x = x &lt;&lt; y
  x &gt;&gt;= y      x = x &gt;&gt; y
</code></pre></div>    </div>
  </li>
  <li>
    <p>Parallel Assignment</p>

    <ul>
      <li>
        <p>Same number of lvalues and rvalues</p>

        <p>x, y, z = 1, 2, 3   # x=1; y=2; z=3
  x, y = y, x         # Parallel: swap the value of two variables</p>
      </li>
      <li>
        <p>One lvalue, multiple rvalues</p>

        <p>x = 1, 2, 3         # x = [1, 2, 3]
  x, = 1, 2, 3        # x = 1; other values are discarded</p>
      </li>
      <li>
        <p>Multiple lvalues, single array rvalue</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x, y, z = [1, 2, 3] # Same as x,y,z = 1,2,3

  x = [1,2]  # x becomes [1,2]: this is not parallel assignment
  x, = [1,2] # x becomes 1: the trailing comma makes it parallel
</code></pre></div>        </div>
      </li>
      <li>
        <p>Different numbers of lvalues and rvalues</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x, y, z = 1, 2  # x=1, y=2; z=nil
  x, y  = 1, 2, 3 # x=1, y=2, 3 is not assigned anywhere
</code></pre></div>        </div>
      </li>
      <li>
        <p>The splat operator</p>

        <p>lvalues and rvalues may be prefixed with <em>, which is sometimes called the *splat operator</em>, though it is not a true operator.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x, y, z = 1, *[2,3] # Same as x,y,z = 1,2,3
  x, *y = 1, 2, 3 # x=1; y=[2,3]
  x, *y = 1, 2    # x=1; y=[2]
  x, *y = 1       # x=1; y=[]

  *x, y = 1, 2, 3 # x=[1,2]; y=3
  *x,y  = 1, 2    # x=[1]; y=2
  *x,y  = 1       # x=[]; y=1

  x, y , *z = 1, *[2,3,4] # x=1; y=2; z=[3,4]
</code></pre></div>        </div>
      </li>
      <li>
        <p>Parentheses in parallel assigment</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x, (y,z) = a, b # x = a; y, z = b

  x, y, z = 1,[2,3]   # No parens: x=1;y=[2,3];z=nil
  x,(y,z) = 1,[2,3]   # Parens: x=1; y=2; z=3

  a,b,c,d = [1,[2,[3,[4]]]]  # No parens: a=1; b=[2,[3,4]]; c=d=nil
  a,(b,(c,(d))) = [1,[2,[3,[4]]]] # parens: a=1;b=2;c=3;d=4
</code></pre></div>        </div>
      </li>
      <li>
        <p>The value of parallel assignment</p>

        <p>The return value of a parallel assignment expression is the array of rvalues.</p>

        <ul>
          <li>
            <p>Parallel Assignment and Method Invocation</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  puts x,y=1,2    # puts (x,y=1,2)

  puts ((x,y=1,2))
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="operators">Operators</h3>

<p><em>Ruby operators, by precedence (high to low), with arity (N), associativity (A), and definability (M)</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Operator(s)            N    A    M    Operation

! ~ +                  1    R    Y    Boolean NOT, bitwise complement, unary plusa
**                     2    R    Y    Exponentiation
-                      1    R    Y    Unary minus (define with -@)
* / %                  2    L    Y    Multiplication, division, modulo (remainder)
+ -                    2    L    Y    Addition (or concatenation), subtraction
&lt;&lt; &gt;&gt;                  2    L    Y    Bitwise shift-left (or append), bitwise shift-right
&amp;                      2    L    Y    Bitwise AND
| ^                    2    L    Y    Bitwise OR, bitwise XOR
&lt; &lt;= &gt;= &gt;              2    L    Y    Ordering
== === != =~ !~ &lt;=&gt;    2    N    Y    Equality, pattern matching, comparisonb
&amp;&amp;                     2    L    N    Boolean AND
||                     2    L    N    Boolean OR
.. ...                 2    N    N    Range creation and Boolean flip-flops
?:                     3    R    N    Conditional
rescue                 2    L    N    Exception-handling modifier
=                      2    R    N    Assignment
**= *= /= %= += -=        
&lt;&lt;= &gt;&gt;=
&amp;&amp;= &amp;= ||= |= ^=
defined?               1    N    N    Test variable definition and type
not                    1    R    N    Boolean NOT (low precedence)
and or                 2    L    N    Boolean AND, Boolean OR (low precedence)
if unless while until  2    N    N    Conditional and loop modifiers
</code></pre></div></div>

<ul>
  <li>
    <p>Nonoperators</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">()</code></p>

        <p>Parenthese are an optinal part of method definition and invocation syntax.</p>

        <p>Parentheses are also used for grouping to affect the order of evaluation of subexpressions.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">[]</code></p>

        <p>Square brackets are used in array literals and for quering and setting array and hash values. In that context, they are syntactic sugar for method invocation and behave somewhat like redefinable operators with arbitrary arity.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">{}</code></p>

        <p>Curly braces are alternative to <code class="language-plaintext highlighter-rouge">do/end</code> in blocks, and are also used in hash literals.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">.</code> and <code class="language-plaintext highlighter-rouge">::</code></p>

        <p><code class="language-plaintext highlighter-rouge">.</code> and <code class="language-plaintext highlighter-rouge">::</code> are used in qualified names.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">;</code>,<code class="language-plaintext highlighter-rouge">,</code> and <code class="language-plaintext highlighter-rouge">=&gt;</code></p>

        <p>The semicolon <code class="language-plaintext highlighter-rouge">;</code> is used to separate stateemnts on the same line;</p>

        <p>the comma <code class="language-plaintext highlighter-rouge">,</code> is used to separate method arguments and the elements of array and hash literals;</p>

        <p>and the arrow <code class="language-plaintext highlighter-rouge">=&gt;</code> is used to separate hash keys from hash values in hash literals.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">:</code></p>

        <p>A colon is used to prefix symbol literals and is also used in Ruby 1.9 hash syntax.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">*</code>,<code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">&lt;</code></p>

        <p>Putting <code class="language-plaintext highlighter-rouge">*</code> before array in an assinment or method invocation expression expands or unpacks the array into its individual elements.</p>

        <p><code class="language-plaintext highlighter-rouge">&amp;</code> can be used in a method declaration before the name of the last method argument, and this cause any block passed to the method to be assigned to that argument.</p>

        <p><code class="language-plaintext highlighter-rouge">&lt;</code> is used in class definitions to specify the superclass of class.</p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="references">References</h3>

<ul>
  <li><a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177/ref=sr_1_1?ie=UTF8&amp;qid=1459784613&amp;sr=8-1&amp;keywords=The+Ruby+Programming+Language">The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto</a></li>
</ul>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
