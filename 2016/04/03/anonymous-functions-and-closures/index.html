<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Anonymous functions and closures | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Anonymous functions and closures" />
<meta property="og:locale" content="en" />
<meta name="description" content="Anonymous functions &amp; lambda expression An anonymous funciton (also function literal or lambda abstraction) is a function definition that is not bound to an identifier. In other world, an anonymous function is only a function without function name. Anonymous functions are sometimes called lambda expressions. Python a = [&#39;house&#39;, &#39;car&#39;, &#39;bike&#39;] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; print a [&#39;bike&#39;, &#39;car&#39;, &#39;house&#39;] &gt;&gt;&gt; a.sort(lambda x,y: cmp(len(x), len(y))) &gt;&gt;&gt; print a [&#39;car&#39;, &#39;bike&#39;, &#39;house&#39;] Go package main import ( &quot;fmt&quot; ) func main() { f := func(name string) { fmt.Printf(&quot;Hello, %s\n&quot;, name) } f(&quot;World&quot;) } ES6 alert((x =&gt; x*x)(10)); Closures Wiki: In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure-unlike a plain function-allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope. MDN: Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure ‘remembers’ the environment in which it was created. Keypoints a function together with an environment unlike a plain function variables that are used locally, but defined in an enclosing scope which name was bound when the closure was created Lexical scoping function init() { var name = &quot;Mozilla&quot;; // name is a local variable created by init function displayName() { // displayName() is the inner function, a closure alert (name); // displayName() uses variable declared in the parent function } displayName(); } init(); init() creates a local variable name and then a function called displayName(). displayName() is an inner function that is defined inside init() and is only available within the body of that function. displayName() has no local variables of its own, however it has access to the variables of outer functions and so can use the variable name declared in the parent function. Closure function makeFunc() { var name = &quot;Mozilla&quot;; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); This code still works may seem unintuitive. Normally, the local variables within a function only exits for the duration of that function’s execution. Once makeFunc() has finished executing, it is reasonable to expect that the name variable will no longer be accessible. Since the code still works as expected, this is obviously not the case. The solution to this puzzle is that myFunc has become a closure. A closure is a special kind of object that combines two things: a function, and the environment in which that function was created. The environment consists of any local variables that were in-scope at the time that the closure was created. In this case, myFunc is a closure that incorporates both the displayName function and the “Mozilla” string that existed when the closure was created. A closure lets you associate some data (the environment) with a function that operates on that data. This has obvious parallels to the object oriented programming, where objects allow us to associate some data (the object’s properties) with on or more methods. Consequently, you can use a closure anywhere that you might normally use an object with only a single method. Enulating private methods with closures var makeCounter = function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } }; var counter1 = makeCounter(); var counter2 = makeCounter(); alert(counter1.value()); /* Alerts 0 */ counter1.increment(); counter1.increment(); alert(counter1.value()); /* Alerts 2 */ counter1.decrement(); alert(counter1.value()); /* Alerts 1 */ alert(counter2.value()); /* Alerts 0 */ Creating closures in loops: A common mistake JavaScript &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Closures&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var lists = document.getElementsByTagName(&quot;li&quot;); for(var i = 0; i &lt; lists.length; i++) { // Three closures have been created, but each one shares the same single environment. // By the time the onclick callbacks are executed, the loop has run its course // and the i variable (shared by all the closures) has been left pointing to the last with a value 2. lists[i].onclick = function(){ alert(i); // not work as expected. }; } // solution 1 // for(var i = 0; i &lt; lists.length; i++) { // var f = function(j) { // lists[j].onclick = function(){ // alert(j); // }; // }(i); // } // solution 2 // for(var i = 0; i &lt; lists.length; i++) { // var f = function() { // var j = i; // lists[j].onclick = function(){ // alert(j); // }; // }(); // } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; golang func Serve(queue chan *Request) { for req := range queue { sem &lt;- 1 go func() { process(req) // Buggy; see explanation below. &lt;-sem }() } } The bug is that in a Go for loop, the loop variable is reused for each iteration, so the req variable is shared across all goroutines. Here’s one way to do that, passing the value of req as an argument to the closure in the goroutine: func Serve(queue chan *Request) { for req := range queue { sem &lt;- 1 go func(req *Request) { process(req) &lt;-sem }(req) } } Another solution is just to create a new variable with the same name, as the belows: Serve(queue chan *Request) { for req := range queue { req := req // Create new instance of req for the goroutine. sem &lt;- 1 go func() { process(req) &lt;-sem }() } } Performance considerations It is unwise to unnecessarily create functions within other function if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption. Implementation and theory Closures are typically implemented with a special data structure that contains a pointer to the function code, plus a representation of the function’s lexical environment (i.e., the set of available variables) at the time when the closure was created. The referencing environment binds the non-local names to the corresponding variables in the lexical environment at the time the closure is created, additionally extending their lifetime to at least as long as the lifetime of the closure itself. When the closure is entered at a later time, possibly with a different lexical environment, the function is executed with its non-local variables referring to the ones captured by the closure, not the current environment. References Closures Closure (computer programming) Lambda calculus Anonymous function Functional programming Subroutine What is the difference between a ‘closure’ and a ‘lambda’? Effective Go JavaScript closure inside loops – simple practical example" />
<meta property="og:description" content="Anonymous functions &amp; lambda expression An anonymous funciton (also function literal or lambda abstraction) is a function definition that is not bound to an identifier. In other world, an anonymous function is only a function without function name. Anonymous functions are sometimes called lambda expressions. Python a = [&#39;house&#39;, &#39;car&#39;, &#39;bike&#39;] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; print a [&#39;bike&#39;, &#39;car&#39;, &#39;house&#39;] &gt;&gt;&gt; a.sort(lambda x,y: cmp(len(x), len(y))) &gt;&gt;&gt; print a [&#39;car&#39;, &#39;bike&#39;, &#39;house&#39;] Go package main import ( &quot;fmt&quot; ) func main() { f := func(name string) { fmt.Printf(&quot;Hello, %s\n&quot;, name) } f(&quot;World&quot;) } ES6 alert((x =&gt; x*x)(10)); Closures Wiki: In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure-unlike a plain function-allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope. MDN: Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure ‘remembers’ the environment in which it was created. Keypoints a function together with an environment unlike a plain function variables that are used locally, but defined in an enclosing scope which name was bound when the closure was created Lexical scoping function init() { var name = &quot;Mozilla&quot;; // name is a local variable created by init function displayName() { // displayName() is the inner function, a closure alert (name); // displayName() uses variable declared in the parent function } displayName(); } init(); init() creates a local variable name and then a function called displayName(). displayName() is an inner function that is defined inside init() and is only available within the body of that function. displayName() has no local variables of its own, however it has access to the variables of outer functions and so can use the variable name declared in the parent function. Closure function makeFunc() { var name = &quot;Mozilla&quot;; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); This code still works may seem unintuitive. Normally, the local variables within a function only exits for the duration of that function’s execution. Once makeFunc() has finished executing, it is reasonable to expect that the name variable will no longer be accessible. Since the code still works as expected, this is obviously not the case. The solution to this puzzle is that myFunc has become a closure. A closure is a special kind of object that combines two things: a function, and the environment in which that function was created. The environment consists of any local variables that were in-scope at the time that the closure was created. In this case, myFunc is a closure that incorporates both the displayName function and the “Mozilla” string that existed when the closure was created. A closure lets you associate some data (the environment) with a function that operates on that data. This has obvious parallels to the object oriented programming, where objects allow us to associate some data (the object’s properties) with on or more methods. Consequently, you can use a closure anywhere that you might normally use an object with only a single method. Enulating private methods with closures var makeCounter = function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } }; var counter1 = makeCounter(); var counter2 = makeCounter(); alert(counter1.value()); /* Alerts 0 */ counter1.increment(); counter1.increment(); alert(counter1.value()); /* Alerts 2 */ counter1.decrement(); alert(counter1.value()); /* Alerts 1 */ alert(counter2.value()); /* Alerts 0 */ Creating closures in loops: A common mistake JavaScript &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Closures&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var lists = document.getElementsByTagName(&quot;li&quot;); for(var i = 0; i &lt; lists.length; i++) { // Three closures have been created, but each one shares the same single environment. // By the time the onclick callbacks are executed, the loop has run its course // and the i variable (shared by all the closures) has been left pointing to the last with a value 2. lists[i].onclick = function(){ alert(i); // not work as expected. }; } // solution 1 // for(var i = 0; i &lt; lists.length; i++) { // var f = function(j) { // lists[j].onclick = function(){ // alert(j); // }; // }(i); // } // solution 2 // for(var i = 0; i &lt; lists.length; i++) { // var f = function() { // var j = i; // lists[j].onclick = function(){ // alert(j); // }; // }(); // } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; golang func Serve(queue chan *Request) { for req := range queue { sem &lt;- 1 go func() { process(req) // Buggy; see explanation below. &lt;-sem }() } } The bug is that in a Go for loop, the loop variable is reused for each iteration, so the req variable is shared across all goroutines. Here’s one way to do that, passing the value of req as an argument to the closure in the goroutine: func Serve(queue chan *Request) { for req := range queue { sem &lt;- 1 go func(req *Request) { process(req) &lt;-sem }(req) } } Another solution is just to create a new variable with the same name, as the belows: Serve(queue chan *Request) { for req := range queue { req := req // Create new instance of req for the goroutine. sem &lt;- 1 go func() { process(req) &lt;-sem }() } } Performance considerations It is unwise to unnecessarily create functions within other function if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption. Implementation and theory Closures are typically implemented with a special data structure that contains a pointer to the function code, plus a representation of the function’s lexical environment (i.e., the set of available variables) at the time when the closure was created. The referencing environment binds the non-local names to the corresponding variables in the lexical environment at the time the closure is created, additionally extending their lifetime to at least as long as the lifetime of the closure itself. When the closure is entered at a later time, possibly with a different lexical environment, the function is executed with its non-local variables referring to the ones captured by the closure, not the current environment. References Closures Closure (computer programming) Lambda calculus Anonymous function Functional programming Subroutine What is the difference between a ‘closure’ and a ‘lambda’? Effective Go JavaScript closure inside loops – simple practical example" />
<link rel="canonical" href="https://blog.codefarm.me/2016/04/03/anonymous-functions-and-closures/" />
<meta property="og:url" content="https://blog.codefarm.me/2016/04/03/anonymous-functions-and-closures/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-04-03T06:36:48+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Anonymous functions and closures" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-04-03T06:36:48+08:00","datePublished":"2016-04-03T06:36:48+08:00","description":"Anonymous functions &amp; lambda expression An anonymous funciton (also function literal or lambda abstraction) is a function definition that is not bound to an identifier. In other world, an anonymous function is only a function without function name. Anonymous functions are sometimes called lambda expressions. Python a = [&#39;house&#39;, &#39;car&#39;, &#39;bike&#39;] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; print a [&#39;bike&#39;, &#39;car&#39;, &#39;house&#39;] &gt;&gt;&gt; a.sort(lambda x,y: cmp(len(x), len(y))) &gt;&gt;&gt; print a [&#39;car&#39;, &#39;bike&#39;, &#39;house&#39;] Go package main import ( &quot;fmt&quot; ) func main() { f := func(name string) { fmt.Printf(&quot;Hello, %s\\n&quot;, name) } f(&quot;World&quot;) } ES6 alert((x =&gt; x*x)(10)); Closures Wiki: In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure-unlike a plain function-allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope. MDN: Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure ‘remembers’ the environment in which it was created. Keypoints a function together with an environment unlike a plain function variables that are used locally, but defined in an enclosing scope which name was bound when the closure was created Lexical scoping function init() { var name = &quot;Mozilla&quot;; // name is a local variable created by init function displayName() { // displayName() is the inner function, a closure alert (name); // displayName() uses variable declared in the parent function } displayName(); } init(); init() creates a local variable name and then a function called displayName(). displayName() is an inner function that is defined inside init() and is only available within the body of that function. displayName() has no local variables of its own, however it has access to the variables of outer functions and so can use the variable name declared in the parent function. Closure function makeFunc() { var name = &quot;Mozilla&quot;; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); This code still works may seem unintuitive. Normally, the local variables within a function only exits for the duration of that function’s execution. Once makeFunc() has finished executing, it is reasonable to expect that the name variable will no longer be accessible. Since the code still works as expected, this is obviously not the case. The solution to this puzzle is that myFunc has become a closure. A closure is a special kind of object that combines two things: a function, and the environment in which that function was created. The environment consists of any local variables that were in-scope at the time that the closure was created. In this case, myFunc is a closure that incorporates both the displayName function and the “Mozilla” string that existed when the closure was created. A closure lets you associate some data (the environment) with a function that operates on that data. This has obvious parallels to the object oriented programming, where objects allow us to associate some data (the object’s properties) with on or more methods. Consequently, you can use a closure anywhere that you might normally use an object with only a single method. Enulating private methods with closures var makeCounter = function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } }; var counter1 = makeCounter(); var counter2 = makeCounter(); alert(counter1.value()); /* Alerts 0 */ counter1.increment(); counter1.increment(); alert(counter1.value()); /* Alerts 2 */ counter1.decrement(); alert(counter1.value()); /* Alerts 1 */ alert(counter2.value()); /* Alerts 0 */ Creating closures in loops: A common mistake JavaScript &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Closures&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var lists = document.getElementsByTagName(&quot;li&quot;); for(var i = 0; i &lt; lists.length; i++) { // Three closures have been created, but each one shares the same single environment. // By the time the onclick callbacks are executed, the loop has run its course // and the i variable (shared by all the closures) has been left pointing to the last with a value 2. lists[i].onclick = function(){ alert(i); // not work as expected. }; } // solution 1 // for(var i = 0; i &lt; lists.length; i++) { // var f = function(j) { // lists[j].onclick = function(){ // alert(j); // }; // }(i); // } // solution 2 // for(var i = 0; i &lt; lists.length; i++) { // var f = function() { // var j = i; // lists[j].onclick = function(){ // alert(j); // }; // }(); // } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; golang func Serve(queue chan *Request) { for req := range queue { sem &lt;- 1 go func() { process(req) // Buggy; see explanation below. &lt;-sem }() } } The bug is that in a Go for loop, the loop variable is reused for each iteration, so the req variable is shared across all goroutines. Here’s one way to do that, passing the value of req as an argument to the closure in the goroutine: func Serve(queue chan *Request) { for req := range queue { sem &lt;- 1 go func(req *Request) { process(req) &lt;-sem }(req) } } Another solution is just to create a new variable with the same name, as the belows: Serve(queue chan *Request) { for req := range queue { req := req // Create new instance of req for the goroutine. sem &lt;- 1 go func() { process(req) &lt;-sem }() } } Performance considerations It is unwise to unnecessarily create functions within other function if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption. Implementation and theory Closures are typically implemented with a special data structure that contains a pointer to the function code, plus a representation of the function’s lexical environment (i.e., the set of available variables) at the time when the closure was created. The referencing environment binds the non-local names to the corresponding variables in the lexical environment at the time the closure is created, additionally extending their lifetime to at least as long as the lifetime of the closure itself. When the closure is entered at a later time, possibly with a different lexical environment, the function is executed with its non-local variables referring to the ones captured by the closure, not the current environment. References Closures Closure (computer programming) Lambda calculus Anonymous function Functional programming Subroutine What is the difference between a ‘closure’ and a ‘lambda’? Effective Go JavaScript closure inside loops – simple practical example","headline":"Anonymous functions and closures","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2016/04/03/anonymous-functions-and-closures/"},"url":"https://blog.codefarm.me/2016/04/03/anonymous-functions-and-closures/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Anonymous functions and closures</h1><p class="c-post-meta">03 Apr 2016</p>
  </header>

  <div class="c-post-content">
    <h3 id="anonymous-functions--lambda-expression">Anonymous functions &amp; lambda expression</h3>

<p>An <strong>anonymous funciton</strong> (also <strong>function literal</strong> or <strong>lambda abstraction</strong>) is a <em>function</em> definition that is not <em>bound</em> to an <em>identifier</em>. In other world, an anonymous function is only a function without function name.</p>

<p>Anonymous functions are sometimes called lambda expressions.</p>

<ul>
  <li>Python</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">house</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">car</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">bike</span><span class="sh">'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
<span class="p">[</span><span class="sh">'</span><span class="s">bike</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">car</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">house</span><span class="sh">'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="nf">cmp</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
<span class="p">[</span><span class="sh">'</span><span class="s">car</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">bike</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">house</span><span class="sh">'</span><span class="p">]</span></code></pre></figure>

<ul>
  <li>Go</li>
</ul>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">f</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<ul>
  <li>ES6</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nf">alert</span><span class="p">((</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="o">*</span><span class="nx">x</span><span class="p">)(</span><span class="mi">10</span><span class="p">));</span></code></pre></figure>

<h3 id="closures">Closures</h3>

<p><em>Wiki</em>: In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing <strong>a function together with an environment</strong>: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was <strong>bound when the closure was created</strong>. A closure-<strong><em>unlike a plain function</em></strong>-allows the function to access those <strong><em>captured variables</em></strong> through the closure’s reference to them, even when the function is invoked outside their scope.</p>

<p><em>MDN</em>: Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure ‘remembers’ the environment in which it was created.</p>

<p><em>Keypoints</em></p>

<ul>
  <li><em>a function together with an environment</em></li>
  <li><em>unlike a plain function</em></li>
  <li><em>variables that are used locally, but defined in an enclosing scope which name was bound when the closure was created</em></li>
</ul>

<h4 id="lexical-scoping">Lexical scoping</h4>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Mozilla</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// name is a local variable created by init</span>
    <span class="kd">function</span> <span class="nf">displayName</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// displayName() is the inner function, a closure</span>
        <span class="nf">alert </span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// displayName() uses variable declared in the parent function    </span>
    <span class="p">}</span>
    <span class="nf">displayName</span><span class="p">();</span>    
<span class="p">}</span>
<span class="nf">init</span><span class="p">();</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">init()</code> creates a local variable <code class="language-plaintext highlighter-rouge">name</code> and then a function called <code class="language-plaintext highlighter-rouge">displayName()</code>. <code class="language-plaintext highlighter-rouge">displayName()</code> is an inner function that is defined inside <code class="language-plaintext highlighter-rouge">init()</code> and is only available within the body of that function. <code class="language-plaintext highlighter-rouge">displayName()</code> has no local variables of its own, however it has access to the variables of outer functions and so can use the variable <code class="language-plaintext highlighter-rouge">name</code> declared in the parent function.</p>

<h4 id="closure">Closure</h4>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nf">makeFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Mozilla</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nf">displayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">alert</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">displayName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myFunc</span> <span class="o">=</span> <span class="nf">makeFunc</span><span class="p">();</span>
<span class="nf">myFunc</span><span class="p">();</span></code></pre></figure>

<p>This code still works may seem unintuitive. Normally, the local variables within a function only exits for the duration of that function’s execution. Once <code class="language-plaintext highlighter-rouge">makeFunc()</code> has finished executing, it is reasonable to expect that the <code class="language-plaintext highlighter-rouge">name</code> variable will no longer be accessible. Since the code still works as expected, this is obviously not the case.</p>

<p>The solution to this puzzle is that <code class="language-plaintext highlighter-rouge">myFunc</code> has become a <em>closure</em>. A closure is a special kind of object that combines two things: a function, and the environment in which that function was created. The environment consists of any local variables that were in-scope at the time that the closure was created. In this case, <code class="language-plaintext highlighter-rouge">myFunc</code> is a closure that incorporates both the <code class="language-plaintext highlighter-rouge">displayName</code> function and the “Mozilla” string that existed when the closure was created.</p>

<p>A closure lets you associate some data (the environment) with a function that operates on that data. This has obvious parallels to the object oriented programming, where objects allow us to associate some data (the object’s properties) with on or more methods.</p>

<p>Consequently, you can use a closure anywhere that you might normally use an object with only a single method.</p>

<h4 id="enulating-private-methods-with-closures">Enulating private methods with closures</h4>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">makeCounter</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">privateCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nf">changeBy</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">privateCounter</span> <span class="o">+=</span> <span class="nx">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">increment</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">changeBy</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">decrement</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">changeBy</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">value</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">privateCounter</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>  
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">counter1</span> <span class="o">=</span> <span class="nf">makeCounter</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">counter2</span> <span class="o">=</span> <span class="nf">makeCounter</span><span class="p">();</span>
<span class="nf">alert</span><span class="p">(</span><span class="nx">counter1</span><span class="p">.</span><span class="nf">value</span><span class="p">());</span> <span class="cm">/* Alerts 0 */</span>
<span class="nx">counter1</span><span class="p">.</span><span class="nf">increment</span><span class="p">();</span>
<span class="nx">counter1</span><span class="p">.</span><span class="nf">increment</span><span class="p">();</span>
<span class="nf">alert</span><span class="p">(</span><span class="nx">counter1</span><span class="p">.</span><span class="nf">value</span><span class="p">());</span> <span class="cm">/* Alerts 2 */</span>
<span class="nx">counter1</span><span class="p">.</span><span class="nf">decrement</span><span class="p">();</span>
<span class="nf">alert</span><span class="p">(</span><span class="nx">counter1</span><span class="p">.</span><span class="nf">value</span><span class="p">());</span> <span class="cm">/* Alerts 1 */</span>
<span class="nf">alert</span><span class="p">(</span><span class="nx">counter2</span><span class="p">.</span><span class="nf">value</span><span class="p">());</span> <span class="cm">/* Alerts 0 */</span></code></pre></figure>

<h4 id="creating-closures-in-loops-a-common-mistake">Creating closures in loops: A common mistake</h4>

<ul>
  <li><em>JavaScript</em></li>
</ul>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="o">&lt;!</span><span class="nx">DOCTYPE</span> <span class="nx">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">title</span><span class="o">&gt;</span><span class="nx">Closures</span><span class="o">&lt;</span><span class="sr">/title</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">meta</span> <span class="nx">charset</span><span class="o">=</span><span class="dl">"</span><span class="s2">utf-8</span><span class="dl">"</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span><span class="o">&gt;</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">lists</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">"</span><span class="s2">li</span><span class="dl">"</span><span class="p">);</span>
            
            <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">lists</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Three closures have been created, but each one shares the same single environment.</span>
                <span class="c1">// By the time the onclick callbacks are executed, the loop has run its course</span>
                <span class="c1">// and the i variable (shared by all the closures) has been left pointing to the last with a value 2.</span>
                <span class="nx">lists</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
                    <span class="nf">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// not work as expected.</span>
                <span class="p">};</span>
            <span class="p">}</span>
            
            <span class="c1">// solution 1</span>
            <span class="c1">// for(var i = 0; i &lt; lists.length; i++) {</span>
            <span class="c1">//     var f = function(j) {</span>
            <span class="c1">//         lists[j].onclick = function(){</span>
            <span class="c1">//             alert(j);</span>
            <span class="c1">//         };</span>
            <span class="c1">//     }(i);</span>
            <span class="c1">// }</span>
            
            <span class="c1">// solution 2</span>
            <span class="c1">// for(var i = 0; i &lt; lists.length; i++) {</span>
            <span class="c1">//     var f = function() {</span>
            <span class="c1">//         var j = i;</span>
            <span class="c1">//         lists[j].onclick = function(){</span>
            <span class="c1">//             alert(j);</span>
            <span class="c1">//         };</span>
            <span class="c1">//     }();</span>
            <span class="c1">// }</span>
        <span class="p">};</span>
    <span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/head</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="mi">2</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/html&gt;</span></code></pre></figure>

<ul>
  <li><em>golang</em></li>
</ul>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Serve</span><span class="p">(</span><span class="n">queue</span> <span class="k">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">sem</span> <span class="o">&lt;-</span> <span class="m">1</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">process</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="c">// Buggy; see explanation below.</span>
            <span class="o">&lt;-</span><span class="n">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The bug is that in a Go <em>for loop</em>, <em>the loop variable is reused for each iteration</em>, so the <code class="language-plaintext highlighter-rouge">req</code> variable is shared across all goroutines.</p>

<p>Here’s one way to do that, passing the value of <code class="language-plaintext highlighter-rouge">req</code> as an argument to the <em>closure</em> in the goroutine:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Serve</span><span class="p">(</span><span class="n">queue</span> <span class="k">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">sem</span> <span class="o">&lt;-</span> <span class="m">1</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">req</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">process</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="n">sem</span>
        <span class="p">}(</span><span class="n">req</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Another solution is just to create a new variable with the same name, as the belows:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">Serve</span><span class="p">(</span><span class="n">queue</span> <span class="k">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">req</span> <span class="o">:=</span> <span class="n">req</span> <span class="c">// Create new instance of req for the goroutine.</span>
        <span class="n">sem</span> <span class="o">&lt;-</span> <span class="m">1</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">process</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="n">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h4 id="performance-considerations">Performance considerations</h4>

<p>It is unwise to unnecessarily create functions within other function if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption.</p>

<h4 id="implementation-and-theory">Implementation and theory</h4>

<p>Closures are typically implemented with a special data structure that contains a pointer to the function code, plus a representation of the function’s lexical environment (i.e., the set of available variables) at the time when the closure was created. The referencing environment binds the non-local names to the corresponding variables in the lexical environment at the time the closure is created, additionally extending their lifetime to at least as long as the lifetime of the closure itself. When the closure is entered at a later time, possibly with a different lexical environment, the function is executed with its non-local variables referring to the ones captured by the closure, not the current environment.</p>

<hr />

<h4 id="references">References</h4>

<ul>
  <li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures">Closures</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29">Closure (computer programming)</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Lambda_calculus">Lambda calculus</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Anonymous_function">Anonymous function</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Functional_programming">Functional programming</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Subroutine">Subroutine</a></li>
  <li><a href="http://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda">What is the difference between a ‘closure’ and a ‘lambda’?</a></li>
  <li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
  <li><a href="http://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example">JavaScript closure inside loops – simple practical example</a></li>
</ul>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
