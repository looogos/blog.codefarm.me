<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>How to write Go code | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="How to write Go code" />
<meta property="og:locale" content="en" />
<meta name="description" content="Except as noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license. Reference: How to Write Go Code How to Write Go Code Introduction Code organization Workspaces The GOPATH environment variable Package paths Your first program Your first library Package names Testing Remote packages What’s next Getting help Introduction This document demonstrates the development of a simple Go package and introduces the go tool, the standard way to fetch, build, and install Go packages and commands. The go tool requires you to organize your code in a specific way. Please read this document carefully. It explains the simplest way to get up and running with your Go installtion. A similar explanation is available as a screencast Code organization Workspaces The go tool is designed to work with open source code maintained in public repositories. Although you don’t need to publish code, the model for how the enviroment is set up works the same whether you do or not. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root: src contains Go source files organized into package (one package per directory), pkg contains packages objects, and bin contains executable commands. The go tools builds source packages and installs the resulting binaries to the pkg and bin directories. The src subdirectory typically contains multiple version control respositories (such as for git or Mercurial) that track the development of one or more source packages. To give you an idea of how a workspace looks in practice, here’s an example: bin/ hello # command executable outyet # command executable pkg/ linux_amd64/ github.com/golang/example/ stringutil.a # package object src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source outyet/ main.go # command source main_test.go # test source stringutil/ reverse.go # package source reverse_test.go # test source This workspace contains one repository (example) comprising two commands (hello and outyet) and one library (stringutil). A typical workspace would contain many source repositories containing many packages and commands. Most Go programmers keep all their Go source code and dependencies in a single workspace. Commands and libraries are built from diffrent kinds of soruce packages. We will discuss the distinction later. The GOPATH environment variable The GOPATH environment variable specifies the location of your workspace. It is likely the only enviroment variable you’ll need to set when developing Go code. To get started, create a workspace directory and set GOPATH accordingly. Your workspace can be located wherever you like, but we’ll use $HOME/work in this document. Note this must not be the same path as your Go installation. (Another common setup is to set GOPATH=$HOME.) $ mkdir $HOME/work $ export GOPATH=$HOME/work For convenience, add the workspace’s bin subdirectory to your PATH: $ export PATH=$PATH:$GOPATH/bin To learn more about setting up the GOPATH environment variable, please see go help gopath Package paths The packages from the standard library are given short paths such as “fmt” and “net/http”. For your own package, you must choose a base path that is unlikely to collide with future additions to the standard library or other external libraries. If you keep your code in a source repository somewhere, then you should use the root of that source repository as your base path. For instance, if you hanve a GitHub account at github.com/user, that should be your base path. Note that you don’t need to publish your code to a remote repository before you can build it. It’s just a good habit to orgnaize your code as if you will publish it someday. In practice you can choose any arbitrary path names, as long as it is unique to the standard library and greater Go ecosystem. We’ll use github.com/user as our base path. Create a direcotry inside your workspace in which to keep source code: $ mkdir -p $GOPATH/src/github.com/user Your first program To compile and run a simple program, first choose a package path (we’ll use github.com/user/hello) and create a conrresponding package directory inside your workspace: $ mkdir $GOPATH/src/github.com/user/hello Next, create a file named hello.go inside that directory, containing the following Go code. package main import &quot;fmt&quot; func main() { fmt.Printf(&quot;Hello, world.\n&quot;) } Now you can build and install that program with the go tool: $ go install github.com/user/hello Note that you can run this command from anywhere on your system. The go tool finds the source code by looking for the github.com/user/hello package inside the workspace specified by GOPATH. You can also omit the package path if you run go install from the package directory: $ cd $GOPATH/src/github.com/user/hello $ go install This command builds the hello command, producing an executable binary. It then installs that binary to the workspace’s bin directory as hello (or, under Windows, hello.exe). In our example, that will be $GOPATH/bin/hello, which is $HOME/work/bin/hello. The go tools will only print output when an error occurs, so if these commands produce no output they have executed successfully. You can now run the program by typing its full path at the command line: $ $GOPATH/bin/hello Hello, world. Or, as you have added $GOAPTH/bin to your PATH, just type binary name: $ hello Hello, world. If you’re using a source control system, now would be a good time to initialize a repository, add the files, and commit your first change. Again, this step is optional: you do not need to use source control to write Go code. $ cd $GOPATH/src/github.com/user/hello $ git init Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/ $ git add hello.go $ git commit -m &quot;initial commit&quot; [master (root-commit) 0b4507d] initial commit 1 file changed, 1 insertion(+) create mode 100644 hello.go Pushing the code to a remote repository is left as an exercise for the reader. Your first library Let’s write a library and use it from hello program. Again, the first step is to choose a package path (we’ll use github.com/user/stringutil) and create the package directory: $ mkdir $GOAPTH/src/github.com/user/stringutil Next, create a file named reverse.go in that directory with the following contents. // Package stringutil contains utility functions for working with strings. package stringutil // Reverse returns its argument string reversed rune-wise left to right. func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) } Now, test that the package compiles with go build: $ go build github.com/user/stringutil Or, if you are working in the package’s source directory, just: $ go build This won’t produce an output file. To do that, you must use go install, which places the package object inside the pkg directory of the workspace. After confirming that stringutil package builds, modify your original hello.go (which is in $GOPATH/src/github.com/user/hello) to use it: package main import ( &quot;fmt&quot; &quot;github.com/user/stringutil&quot; ) func main() { fmt.Printf(stirngutil.Reverse(&quot;!oG ,olleH&quot;)) } Whenever the go tool installs a package or binary, it also installs whatever depedencies it has. So when you install the hello program $ go install github.com/user/hello the stringutil package will be installed as well, automatically. Running the new version of the program, you should see a new, reversed message: $ hello Hello, Go! After the steps above, your workspace should look like this: bin/ hello # command executable pkg/ linux_amd64/ # this will reflect your OS and architecture github.com/user/ stringutil.a # package object src/ github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source Note that go install placed the stringutil.a object in a directory inside pkg/linux_amd64 that mirrors its source directory. This is so that future invocations of the go tool can find the package object and avoid recompiling the package unnecessarily. The linux_amd64 part is there to aid in cross-complilation, and will reflect the operating system and architecture of your system. Go command exetuables are statically linked; the package objects need not be present to run Go programs. Package names This first statement in a Go source file must be package name where name is the package’s default name for imports. (All files in a package must use the same name.) Go’s convention is that the package name is the last element of the import path: the package imported as “crypto/rot13” should be named rot13. Executable commands must always use package main. There is no requirement that package names be unique across all packages linked into a single binary, only that the import paths (their full file names) be unique. See Effective Go to learn more about Go’s naming conventions. Testing Go has a lightweight test framework composed of the go test command and the testing package. You write a test by creating a file with a name ending in _test.go that contains functions named TestXXX with signature func (t *testing.T). The test framework runs each such function; if the function calls a failure function such as *t.Error or t.Fail, the test is considered to have failed. Add a test to the stringutil package by creating the file $GOPATH/src/github.com/user/stringutil/reverse_test.go containing follwing Go code. package stringutil import &quot;testing&quot; func TestReverse(t *testing.T) { cases := []struct { in, want string }{ {&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;}, {&quot;Hello, 世界&quot;, &quot;界世 ,olleH&quot;}, {&quot;&quot;, &quot;&quot;}, } for _, c := range cases { got := Reverse(c.in) if got != c.want { t.Errorf(&quot;Reverse(%q) == %q, want %q&quot;, c.in, got, c.want) } } } Then run the test with go test: $ go test github.com/user/stringutil ok github.com/user/stringutil 0.165s As always, if you are running the go tool from the package directory, you can omit the package path: $go test ok github.com/user/stringutil 0.165s Run go help test and see testing package documentation for more detail. Remote packages An important path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The go tool uses this property to autmatically fetch packages from repositories. For instance, the examples described in this document are also kept in a Git repository hosted at GitHub github.com/golang/example. If you include the repository URL in the packages’s import path, go get will fetch, build, and install it automatically: $ go get github.com/golang/example/hello $ $GOPATH/bin/hello Hello, Go examples! If the specified package is not present in a workspace, go get will place it inside the first workspace specified by GOPATH. (If the package does already exist, go get skips the remote fetch and behaves the same as go install.) Alfter issuing the above go get command, the workspace directory tree should now look like this: bin/ hello # command executable pkg/ linux_amd64/ github.com/golang/example/ stringutil.a # package object github.com/user/ stringutil.a # package object src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source The hello command hosted at GitHub dependends on the stringutil package within the same repository. The import in hello.go file use the same import path convention, so the go get command is able to locate and install the depdendent package, too. import &quot;gitnhub.com/golang/example/stringutil&quot; This convention is the easiest way to make your Go packages available for others to use. The Go Wiki and godoc.org provide lists of external Go Projects. For more information on using remote repositories with the go tool, see go help importpath. What’s next Subscribe to the golang-announce mailing list to be notified when a new stable version of Go is released. See Effective Go for tips on writing clear, idiomatic Go code. Take A Tour of Go to learn the language proper. Visit the documentation page for a set of in-depth articles about the Go language and its libraries and tools. Getting help For real-time help, ask the helpful gophers in #go-nuts on the Freenode IRC server. The official mailing list for discussion of the Go language is Go nuts. Report bugs using the Go issue tracker." />
<meta property="og:description" content="Except as noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license. Reference: How to Write Go Code How to Write Go Code Introduction Code organization Workspaces The GOPATH environment variable Package paths Your first program Your first library Package names Testing Remote packages What’s next Getting help Introduction This document demonstrates the development of a simple Go package and introduces the go tool, the standard way to fetch, build, and install Go packages and commands. The go tool requires you to organize your code in a specific way. Please read this document carefully. It explains the simplest way to get up and running with your Go installtion. A similar explanation is available as a screencast Code organization Workspaces The go tool is designed to work with open source code maintained in public repositories. Although you don’t need to publish code, the model for how the enviroment is set up works the same whether you do or not. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root: src contains Go source files organized into package (one package per directory), pkg contains packages objects, and bin contains executable commands. The go tools builds source packages and installs the resulting binaries to the pkg and bin directories. The src subdirectory typically contains multiple version control respositories (such as for git or Mercurial) that track the development of one or more source packages. To give you an idea of how a workspace looks in practice, here’s an example: bin/ hello # command executable outyet # command executable pkg/ linux_amd64/ github.com/golang/example/ stringutil.a # package object src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source outyet/ main.go # command source main_test.go # test source stringutil/ reverse.go # package source reverse_test.go # test source This workspace contains one repository (example) comprising two commands (hello and outyet) and one library (stringutil). A typical workspace would contain many source repositories containing many packages and commands. Most Go programmers keep all their Go source code and dependencies in a single workspace. Commands and libraries are built from diffrent kinds of soruce packages. We will discuss the distinction later. The GOPATH environment variable The GOPATH environment variable specifies the location of your workspace. It is likely the only enviroment variable you’ll need to set when developing Go code. To get started, create a workspace directory and set GOPATH accordingly. Your workspace can be located wherever you like, but we’ll use $HOME/work in this document. Note this must not be the same path as your Go installation. (Another common setup is to set GOPATH=$HOME.) $ mkdir $HOME/work $ export GOPATH=$HOME/work For convenience, add the workspace’s bin subdirectory to your PATH: $ export PATH=$PATH:$GOPATH/bin To learn more about setting up the GOPATH environment variable, please see go help gopath Package paths The packages from the standard library are given short paths such as “fmt” and “net/http”. For your own package, you must choose a base path that is unlikely to collide with future additions to the standard library or other external libraries. If you keep your code in a source repository somewhere, then you should use the root of that source repository as your base path. For instance, if you hanve a GitHub account at github.com/user, that should be your base path. Note that you don’t need to publish your code to a remote repository before you can build it. It’s just a good habit to orgnaize your code as if you will publish it someday. In practice you can choose any arbitrary path names, as long as it is unique to the standard library and greater Go ecosystem. We’ll use github.com/user as our base path. Create a direcotry inside your workspace in which to keep source code: $ mkdir -p $GOPATH/src/github.com/user Your first program To compile and run a simple program, first choose a package path (we’ll use github.com/user/hello) and create a conrresponding package directory inside your workspace: $ mkdir $GOPATH/src/github.com/user/hello Next, create a file named hello.go inside that directory, containing the following Go code. package main import &quot;fmt&quot; func main() { fmt.Printf(&quot;Hello, world.\n&quot;) } Now you can build and install that program with the go tool: $ go install github.com/user/hello Note that you can run this command from anywhere on your system. The go tool finds the source code by looking for the github.com/user/hello package inside the workspace specified by GOPATH. You can also omit the package path if you run go install from the package directory: $ cd $GOPATH/src/github.com/user/hello $ go install This command builds the hello command, producing an executable binary. It then installs that binary to the workspace’s bin directory as hello (or, under Windows, hello.exe). In our example, that will be $GOPATH/bin/hello, which is $HOME/work/bin/hello. The go tools will only print output when an error occurs, so if these commands produce no output they have executed successfully. You can now run the program by typing its full path at the command line: $ $GOPATH/bin/hello Hello, world. Or, as you have added $GOAPTH/bin to your PATH, just type binary name: $ hello Hello, world. If you’re using a source control system, now would be a good time to initialize a repository, add the files, and commit your first change. Again, this step is optional: you do not need to use source control to write Go code. $ cd $GOPATH/src/github.com/user/hello $ git init Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/ $ git add hello.go $ git commit -m &quot;initial commit&quot; [master (root-commit) 0b4507d] initial commit 1 file changed, 1 insertion(+) create mode 100644 hello.go Pushing the code to a remote repository is left as an exercise for the reader. Your first library Let’s write a library and use it from hello program. Again, the first step is to choose a package path (we’ll use github.com/user/stringutil) and create the package directory: $ mkdir $GOAPTH/src/github.com/user/stringutil Next, create a file named reverse.go in that directory with the following contents. // Package stringutil contains utility functions for working with strings. package stringutil // Reverse returns its argument string reversed rune-wise left to right. func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) } Now, test that the package compiles with go build: $ go build github.com/user/stringutil Or, if you are working in the package’s source directory, just: $ go build This won’t produce an output file. To do that, you must use go install, which places the package object inside the pkg directory of the workspace. After confirming that stringutil package builds, modify your original hello.go (which is in $GOPATH/src/github.com/user/hello) to use it: package main import ( &quot;fmt&quot; &quot;github.com/user/stringutil&quot; ) func main() { fmt.Printf(stirngutil.Reverse(&quot;!oG ,olleH&quot;)) } Whenever the go tool installs a package or binary, it also installs whatever depedencies it has. So when you install the hello program $ go install github.com/user/hello the stringutil package will be installed as well, automatically. Running the new version of the program, you should see a new, reversed message: $ hello Hello, Go! After the steps above, your workspace should look like this: bin/ hello # command executable pkg/ linux_amd64/ # this will reflect your OS and architecture github.com/user/ stringutil.a # package object src/ github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source Note that go install placed the stringutil.a object in a directory inside pkg/linux_amd64 that mirrors its source directory. This is so that future invocations of the go tool can find the package object and avoid recompiling the package unnecessarily. The linux_amd64 part is there to aid in cross-complilation, and will reflect the operating system and architecture of your system. Go command exetuables are statically linked; the package objects need not be present to run Go programs. Package names This first statement in a Go source file must be package name where name is the package’s default name for imports. (All files in a package must use the same name.) Go’s convention is that the package name is the last element of the import path: the package imported as “crypto/rot13” should be named rot13. Executable commands must always use package main. There is no requirement that package names be unique across all packages linked into a single binary, only that the import paths (their full file names) be unique. See Effective Go to learn more about Go’s naming conventions. Testing Go has a lightweight test framework composed of the go test command and the testing package. You write a test by creating a file with a name ending in _test.go that contains functions named TestXXX with signature func (t *testing.T). The test framework runs each such function; if the function calls a failure function such as *t.Error or t.Fail, the test is considered to have failed. Add a test to the stringutil package by creating the file $GOPATH/src/github.com/user/stringutil/reverse_test.go containing follwing Go code. package stringutil import &quot;testing&quot; func TestReverse(t *testing.T) { cases := []struct { in, want string }{ {&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;}, {&quot;Hello, 世界&quot;, &quot;界世 ,olleH&quot;}, {&quot;&quot;, &quot;&quot;}, } for _, c := range cases { got := Reverse(c.in) if got != c.want { t.Errorf(&quot;Reverse(%q) == %q, want %q&quot;, c.in, got, c.want) } } } Then run the test with go test: $ go test github.com/user/stringutil ok github.com/user/stringutil 0.165s As always, if you are running the go tool from the package directory, you can omit the package path: $go test ok github.com/user/stringutil 0.165s Run go help test and see testing package documentation for more detail. Remote packages An important path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The go tool uses this property to autmatically fetch packages from repositories. For instance, the examples described in this document are also kept in a Git repository hosted at GitHub github.com/golang/example. If you include the repository URL in the packages’s import path, go get will fetch, build, and install it automatically: $ go get github.com/golang/example/hello $ $GOPATH/bin/hello Hello, Go examples! If the specified package is not present in a workspace, go get will place it inside the first workspace specified by GOPATH. (If the package does already exist, go get skips the remote fetch and behaves the same as go install.) Alfter issuing the above go get command, the workspace directory tree should now look like this: bin/ hello # command executable pkg/ linux_amd64/ github.com/golang/example/ stringutil.a # package object github.com/user/ stringutil.a # package object src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source The hello command hosted at GitHub dependends on the stringutil package within the same repository. The import in hello.go file use the same import path convention, so the go get command is able to locate and install the depdendent package, too. import &quot;gitnhub.com/golang/example/stringutil&quot; This convention is the easiest way to make your Go packages available for others to use. The Go Wiki and godoc.org provide lists of external Go Projects. For more information on using remote repositories with the go tool, see go help importpath. What’s next Subscribe to the golang-announce mailing list to be notified when a new stable version of Go is released. See Effective Go for tips on writing clear, idiomatic Go code. Take A Tour of Go to learn the language proper. Visit the documentation page for a set of in-depth articles about the Go language and its libraries and tools. Getting help For real-time help, ask the helpful gophers in #go-nuts on the Freenode IRC server. The official mailing list for discussion of the Go language is Go nuts. Report bugs using the Go issue tracker." />
<link rel="canonical" href="https://blog.codefarm.me/2016/03/26/how-to-write-go-code/" />
<meta property="og:url" content="https://blog.codefarm.me/2016/03/26/how-to-write-go-code/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-03-26T00:24:56+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="How to write Go code" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-03-26T00:24:56+08:00","datePublished":"2016-03-26T00:24:56+08:00","description":"Except as noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license. Reference: How to Write Go Code How to Write Go Code Introduction Code organization Workspaces The GOPATH environment variable Package paths Your first program Your first library Package names Testing Remote packages What’s next Getting help Introduction This document demonstrates the development of a simple Go package and introduces the go tool, the standard way to fetch, build, and install Go packages and commands. The go tool requires you to organize your code in a specific way. Please read this document carefully. It explains the simplest way to get up and running with your Go installtion. A similar explanation is available as a screencast Code organization Workspaces The go tool is designed to work with open source code maintained in public repositories. Although you don’t need to publish code, the model for how the enviroment is set up works the same whether you do or not. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root: src contains Go source files organized into package (one package per directory), pkg contains packages objects, and bin contains executable commands. The go tools builds source packages and installs the resulting binaries to the pkg and bin directories. The src subdirectory typically contains multiple version control respositories (such as for git or Mercurial) that track the development of one or more source packages. To give you an idea of how a workspace looks in practice, here’s an example: bin/ hello # command executable outyet # command executable pkg/ linux_amd64/ github.com/golang/example/ stringutil.a # package object src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source outyet/ main.go # command source main_test.go # test source stringutil/ reverse.go # package source reverse_test.go # test source This workspace contains one repository (example) comprising two commands (hello and outyet) and one library (stringutil). A typical workspace would contain many source repositories containing many packages and commands. Most Go programmers keep all their Go source code and dependencies in a single workspace. Commands and libraries are built from diffrent kinds of soruce packages. We will discuss the distinction later. The GOPATH environment variable The GOPATH environment variable specifies the location of your workspace. It is likely the only enviroment variable you’ll need to set when developing Go code. To get started, create a workspace directory and set GOPATH accordingly. Your workspace can be located wherever you like, but we’ll use $HOME/work in this document. Note this must not be the same path as your Go installation. (Another common setup is to set GOPATH=$HOME.) $ mkdir $HOME/work $ export GOPATH=$HOME/work For convenience, add the workspace’s bin subdirectory to your PATH: $ export PATH=$PATH:$GOPATH/bin To learn more about setting up the GOPATH environment variable, please see go help gopath Package paths The packages from the standard library are given short paths such as “fmt” and “net/http”. For your own package, you must choose a base path that is unlikely to collide with future additions to the standard library or other external libraries. If you keep your code in a source repository somewhere, then you should use the root of that source repository as your base path. For instance, if you hanve a GitHub account at github.com/user, that should be your base path. Note that you don’t need to publish your code to a remote repository before you can build it. It’s just a good habit to orgnaize your code as if you will publish it someday. In practice you can choose any arbitrary path names, as long as it is unique to the standard library and greater Go ecosystem. We’ll use github.com/user as our base path. Create a direcotry inside your workspace in which to keep source code: $ mkdir -p $GOPATH/src/github.com/user Your first program To compile and run a simple program, first choose a package path (we’ll use github.com/user/hello) and create a conrresponding package directory inside your workspace: $ mkdir $GOPATH/src/github.com/user/hello Next, create a file named hello.go inside that directory, containing the following Go code. package main import &quot;fmt&quot; func main() { fmt.Printf(&quot;Hello, world.\\n&quot;) } Now you can build and install that program with the go tool: $ go install github.com/user/hello Note that you can run this command from anywhere on your system. The go tool finds the source code by looking for the github.com/user/hello package inside the workspace specified by GOPATH. You can also omit the package path if you run go install from the package directory: $ cd $GOPATH/src/github.com/user/hello $ go install This command builds the hello command, producing an executable binary. It then installs that binary to the workspace’s bin directory as hello (or, under Windows, hello.exe). In our example, that will be $GOPATH/bin/hello, which is $HOME/work/bin/hello. The go tools will only print output when an error occurs, so if these commands produce no output they have executed successfully. You can now run the program by typing its full path at the command line: $ $GOPATH/bin/hello Hello, world. Or, as you have added $GOAPTH/bin to your PATH, just type binary name: $ hello Hello, world. If you’re using a source control system, now would be a good time to initialize a repository, add the files, and commit your first change. Again, this step is optional: you do not need to use source control to write Go code. $ cd $GOPATH/src/github.com/user/hello $ git init Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/ $ git add hello.go $ git commit -m &quot;initial commit&quot; [master (root-commit) 0b4507d] initial commit 1 file changed, 1 insertion(+) create mode 100644 hello.go Pushing the code to a remote repository is left as an exercise for the reader. Your first library Let’s write a library and use it from hello program. Again, the first step is to choose a package path (we’ll use github.com/user/stringutil) and create the package directory: $ mkdir $GOAPTH/src/github.com/user/stringutil Next, create a file named reverse.go in that directory with the following contents. // Package stringutil contains utility functions for working with strings. package stringutil // Reverse returns its argument string reversed rune-wise left to right. func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) } Now, test that the package compiles with go build: $ go build github.com/user/stringutil Or, if you are working in the package’s source directory, just: $ go build This won’t produce an output file. To do that, you must use go install, which places the package object inside the pkg directory of the workspace. After confirming that stringutil package builds, modify your original hello.go (which is in $GOPATH/src/github.com/user/hello) to use it: package main import ( &quot;fmt&quot; &quot;github.com/user/stringutil&quot; ) func main() { fmt.Printf(stirngutil.Reverse(&quot;!oG ,olleH&quot;)) } Whenever the go tool installs a package or binary, it also installs whatever depedencies it has. So when you install the hello program $ go install github.com/user/hello the stringutil package will be installed as well, automatically. Running the new version of the program, you should see a new, reversed message: $ hello Hello, Go! After the steps above, your workspace should look like this: bin/ hello # command executable pkg/ linux_amd64/ # this will reflect your OS and architecture github.com/user/ stringutil.a # package object src/ github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source Note that go install placed the stringutil.a object in a directory inside pkg/linux_amd64 that mirrors its source directory. This is so that future invocations of the go tool can find the package object and avoid recompiling the package unnecessarily. The linux_amd64 part is there to aid in cross-complilation, and will reflect the operating system and architecture of your system. Go command exetuables are statically linked; the package objects need not be present to run Go programs. Package names This first statement in a Go source file must be package name where name is the package’s default name for imports. (All files in a package must use the same name.) Go’s convention is that the package name is the last element of the import path: the package imported as “crypto/rot13” should be named rot13. Executable commands must always use package main. There is no requirement that package names be unique across all packages linked into a single binary, only that the import paths (their full file names) be unique. See Effective Go to learn more about Go’s naming conventions. Testing Go has a lightweight test framework composed of the go test command and the testing package. You write a test by creating a file with a name ending in _test.go that contains functions named TestXXX with signature func (t *testing.T). The test framework runs each such function; if the function calls a failure function such as *t.Error or t.Fail, the test is considered to have failed. Add a test to the stringutil package by creating the file $GOPATH/src/github.com/user/stringutil/reverse_test.go containing follwing Go code. package stringutil import &quot;testing&quot; func TestReverse(t *testing.T) { cases := []struct { in, want string }{ {&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;}, {&quot;Hello, 世界&quot;, &quot;界世 ,olleH&quot;}, {&quot;&quot;, &quot;&quot;}, } for _, c := range cases { got := Reverse(c.in) if got != c.want { t.Errorf(&quot;Reverse(%q) == %q, want %q&quot;, c.in, got, c.want) } } } Then run the test with go test: $ go test github.com/user/stringutil ok github.com/user/stringutil 0.165s As always, if you are running the go tool from the package directory, you can omit the package path: $go test ok github.com/user/stringutil 0.165s Run go help test and see testing package documentation for more detail. Remote packages An important path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The go tool uses this property to autmatically fetch packages from repositories. For instance, the examples described in this document are also kept in a Git repository hosted at GitHub github.com/golang/example. If you include the repository URL in the packages’s import path, go get will fetch, build, and install it automatically: $ go get github.com/golang/example/hello $ $GOPATH/bin/hello Hello, Go examples! If the specified package is not present in a workspace, go get will place it inside the first workspace specified by GOPATH. (If the package does already exist, go get skips the remote fetch and behaves the same as go install.) Alfter issuing the above go get command, the workspace directory tree should now look like this: bin/ hello # command executable pkg/ linux_amd64/ github.com/golang/example/ stringutil.a # package object github.com/user/ stringutil.a # package object src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source The hello command hosted at GitHub dependends on the stringutil package within the same repository. The import in hello.go file use the same import path convention, so the go get command is able to locate and install the depdendent package, too. import &quot;gitnhub.com/golang/example/stringutil&quot; This convention is the easiest way to make your Go packages available for others to use. The Go Wiki and godoc.org provide lists of external Go Projects. For more information on using remote repositories with the go tool, see go help importpath. What’s next Subscribe to the golang-announce mailing list to be notified when a new stable version of Go is released. See Effective Go for tips on writing clear, idiomatic Go code. Take A Tour of Go to learn the language proper. Visit the documentation page for a set of in-depth articles about the Go language and its libraries and tools. Getting help For real-time help, ask the helpful gophers in #go-nuts on the Freenode IRC server. The official mailing list for discussion of the Go language is Go nuts. Report bugs using the Go issue tracker.","headline":"How to write Go code","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2016/03/26/how-to-write-go-code/"},"url":"https://blog.codefarm.me/2016/03/26/how-to-write-go-code/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">How to write Go code</h1><p class="c-post-meta">26 Mar 2016</p>
  </header>

  <div class="c-post-content">
    <h6 id="except-as-noted-the-content-of-this-page-is-licensed-under-the-creative-commons-attribution-30-license-and-code-is-licensed-under-a-bsd-license">Except as noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license.</h6>

<p><a href="https://golang.org/doc/code.html">Reference: How to Write Go Code</a></p>

<h3 id="how-to-write-go-code"><a href="https://golang.org/doc/code.html">How to Write Go Code</a></h3>

<ul>
  <li>Introduction</li>
  <li>Code organization
    <ul>
      <li>Workspaces</li>
      <li>The GOPATH environment variable</li>
      <li>Package paths</li>
      <li>Your first program</li>
      <li>Your first library</li>
      <li>Package names</li>
    </ul>
  </li>
  <li>Testing</li>
  <li>Remote packages</li>
  <li>What’s next</li>
  <li>Getting help</li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>This document demonstrates the development of a simple Go package and introduces the <a href="https://golang.org/cmd/go/">go tool</a>, the standard way to fetch, build, and install Go packages and commands.</p>

<p>The <em>go</em> tool requires you to organize your code in a specific way. Please read this document carefully. It explains the simplest way to get up and running with your Go installtion.</p>

<p>A similar explanation is available as a <a href="https://www.youtube.com/watch?v=XCsL89YtqCs">screencast</a></p>

<h3 id="code-organization">Code organization</h3>

<p><strong>Workspaces</strong></p>

<p>The <em>go</em> tool is designed to work with open source code maintained in public repositories. Although you don’t need to publish code, the model for how the enviroment is set up works the same whether you do or not.</p>

<p>Go code must be kept inside a <em>workspace</em>. A workspace is a directory hierarchy with three directories at its root:</p>

<ul>
  <li><em>src</em> contains Go source files organized into package (one package per directory),</li>
  <li><em>pkg</em> contains packages objects, and</li>
  <li><em>bin</em> contains executable commands.</li>
</ul>

<p>The <em>go</em> tools builds source packages and installs the resulting binaries to the <em>pkg</em> and <em>bin</em> directories.</p>

<p>The <em>src</em> subdirectory typically contains multiple version control respositories (such as for git or Mercurial) that track the development of one or more source packages.</p>

<p>To give you an idea of how a workspace looks in practice, here’s an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/
    hello                          # command executable
    outyet                         # command executable
pkg/
    linux_amd64/
        github.com/golang/example/
            stringutil.a           # package object
src/
    github.com/golang/example/
        .git/                      # Git repository metadata
    hello/
        hello.go               # command source
    outyet/
        main.go                # command source
        main_test.go           # test source
    stringutil/
        reverse.go             # package source
        reverse_test.go        # test source 
</code></pre></div></div>

<p>This workspace contains one repository (example) comprising two commands (<em>hello</em> and <em>outyet</em>) and one library (<em>stringutil</em>).</p>

<p>A typical workspace would contain many source repositories containing many packages and commands. Most Go programmers keep <em>all</em> their Go source code and dependencies in a single workspace.</p>

<p>Commands and libraries are built from diffrent kinds of soruce packages. We will discuss the distinction later.</p>

<h3 id="the-gopath-environment-variable">The <code class="language-plaintext highlighter-rouge">GOPATH</code> environment variable</h3>

<p>The <em>GOPATH</em> environment variable specifies the location of your workspace. It is likely the only enviroment variable you’ll need to set when developing Go code.</p>

<p>To get started, create a workspace directory and set <em>GOPATH</em> accordingly. Your workspace can be located wherever you like, but we’ll use <em>$HOME/work</em> in this document. Note this must <strong>not</strong> be the same path as your Go installation. (Another common setup is to set <em>GOPATH=$HOME</em>.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir $HOME/work
$ export GOPATH=$HOME/work
</code></pre></div></div>

<p>For convenience, add the workspace’s <em>bin</em> subdirectory to your <em>PATH</em>:
    $ export PATH=$PATH:$GOPATH/bin</p>

<p>To learn more about setting up the <em>GOPATH</em> environment variable, please see <a href="https://golang.org/cmd/go/#hdr-GOPATH_environment_variable">go help gopath</a></p>

<h3 id="package-paths">Package paths</h3>

<p>The packages from the standard library are given short paths such as <em>“fmt”</em> and <em>“net/http”</em>. For your own package, you must choose a base path that is unlikely to collide with future additions to the standard library or other external libraries.</p>

<p>If you keep your code in a source repository somewhere, then you should use the root of that source repository as your base path. For instance, if you hanve a <a href="https://github.com/">GitHub</a> account at <em>github.com/user</em>, that should be your base path.</p>

<p>Note that you don’t need to publish your code to a remote repository before you can build it. It’s just a good habit to orgnaize your code as if you will publish it someday. In practice you can choose any arbitrary path names, as long as it is unique to the standard library and greater Go ecosystem.</p>

<p>We’ll use <em>github.com/user</em> as our base path. Create a direcotry inside your workspace in which to keep source code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir -p $GOPATH/src/github.com/user
</code></pre></div></div>

<h3 id="your-first-program">Your first program</h3>

<p>To compile and run a simple program, first choose a package path (we’ll use <em>github.com/user/hello</em>) and create a conrresponding package directory inside your workspace:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir $GOPATH/src/github.com/user/hello
</code></pre></div></div>

<p>Next, create a file named <em>hello.go</em> inside that directory, containing the following Go code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import "fmt"

func main() {
    fmt.Printf("Hello, world.\n")
}
</code></pre></div></div>

<p>Now you can build and install that program with the <em>go</em> tool:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go install github.com/user/hello
</code></pre></div></div>

<p>Note that you can run this command from anywhere on your system. The <em>go</em> tool finds the source code by looking for the <em>github.com/user/hello</em> package inside the workspace specified by <em>GOPATH</em>.</p>

<p>You can also omit the package path if you run <em>go install</em> from the package directory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd $GOPATH/src/github.com/user/hello
$ go install
</code></pre></div></div>

<p>This command builds the <em>hello</em> command, producing an executable binary. It then installs that binary to the workspace’s <em>bin</em> directory as <em>hello</em> (or, under Windows, <em>hello.exe</em>). In our example, that will be <em>$GOPATH/bin/hello</em>, which is <em>$HOME/work/bin/hello</em>.</p>

<p>The <em>go</em> tools will only print output when an error occurs, so if these commands produce no output they have executed successfully.</p>

<p>You can now run the program by typing its full path at the command line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ $GOPATH/bin/hello
Hello, world.
</code></pre></div></div>

<p>Or, as you have added <em>$GOAPTH/bin</em> to your <em>PATH</em>, just type binary name:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ hello
Hello, world.
</code></pre></div></div>

<p>If you’re using a source control system, now would be a good time to initialize a repository, add the files, and commit your first change. Again, this step is optional: you do not need to use source control to write Go code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd $GOPATH/src/github.com/user/hello
$ git init
Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/
$ git add hello.go
$ git commit -m "initial commit"
[master (root-commit) 0b4507d] initial commit
 1 file changed, 1 insertion(+)
  create mode 100644 hello.go
</code></pre></div></div>

<p>Pushing the code to a remote repository is left as an exercise for the reader.</p>

<h3 id="your-first-library">Your first library</h3>

<p>Let’s write a library and use it from <em>hello</em> program.</p>

<p>Again, the first step is to choose a package path (we’ll use <em>github.com/user/stringutil</em>) and create the package directory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir $GOAPTH/src/github.com/user/stringutil
</code></pre></div></div>

<p>Next, create a file named <em>reverse.go</em> in that directory with the following contents.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Package stringutil contains utility functions for working with strings.
package stringutil

// Reverse returns its argument string reversed rune-wise left to right.
func Reverse(s string) string {
    r := []rune(s)
    for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {
        r[i], r[j] = r[j], r[i]
    }
    return string(r)
}
</code></pre></div></div>

<p>Now, test that the package compiles with <em>go build</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go build github.com/user/stringutil
</code></pre></div></div>

<p>Or, if you are working in the package’s source directory, just:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go build
</code></pre></div></div>

<p>This won’t produce an output file. To do that, you must use <em>go install</em>, which places the package object inside the <em>pkg</em> directory of the workspace.</p>

<p>After confirming that <em>stringutil</em> package builds, modify your original <em>hello.go</em> (which is in <em>$GOPATH/src/github.com/user/hello</em>) to use it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
    "fmt"
    "github.com/user/stringutil"
)

func main() {
    fmt.Printf(stirngutil.Reverse("!oG ,olleH"))
}
</code></pre></div></div>

<p>Whenever the <em>go</em> tool installs a package or binary, it also installs whatever depedencies it has. So when you install the <em>hello</em> program</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go install github.com/user/hello
</code></pre></div></div>

<p>the <em>stringutil</em> package will be installed as well, automatically.</p>

<p>Running the new version of the program, you should see a new, reversed message:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ hello
Hello, Go!
</code></pre></div></div>

<p>After the steps above, your workspace should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/
    hello                 # command executable
pkg/
    linux_amd64/          # this will reflect your OS and architecture
        github.com/user/
            stringutil.a  # package object
src/
    github.com/user/
        hello/
            hello.go      # command source
        stringutil/
            reverse.go    # package source
</code></pre></div></div>

<p>Note that <em>go install</em> placed the <em>stringutil.a</em> object in a directory inside <em>pkg/linux_amd64</em> that mirrors its source directory. This is so that future invocations of the <em>go</em> tool can find the package object and avoid recompiling the package unnecessarily. The <em>linux_amd64</em> part is there to aid in cross-complilation, and will reflect the operating system and architecture of your system.</p>

<p>Go command exetuables are statically linked; the package objects need not be present to run Go programs.</p>

<h3 id="package-names">Package names</h3>

<p>This first statement in a Go source file must be</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package name
</code></pre></div></div>

<p>where <em>name</em> is the package’s default name for imports. (All files in a package must use the same <em>name</em>.)</p>

<p>Go’s convention is that the package name is the last element of the import path: the package imported as <em>“crypto/rot13”</em> should be named <em>rot13</em>.</p>

<p>Executable commands must always use <em>package main</em>.</p>

<p>There is no requirement that package names be unique across all packages linked into a single binary, only that the import paths (their full file names) be unique.</p>

<p>See <a href="https://golang.org/doc/effective_go.html#names">Effective Go</a> to learn more about Go’s naming conventions.</p>

<h3 id="testing">Testing</h3>

<p>Go has a lightweight test framework composed of the <em>go test</em> command and the <em>testing</em> package.</p>

<p>You write a test by creating a file with a name ending in <em>_test.go</em> that contains functions named <em>TestXXX</em> with signature <em>func (t *testing.T). The test framework runs each such function; if the function calls a failure function such as *t.Error</em> or <em>t.Fail</em>, the test is considered to have failed.</p>

<p>Add a test to the <em>stringutil</em> package by creating the file <em>$GOPATH/src/github.com/user/stringutil/reverse_test.go</em> containing follwing Go code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package stringutil

import "testing"

func TestReverse(t *testing.T) {
    cases := []struct {
        in, want string
    }{
        {"Hello, world", "dlrow ,olleH"},
        {"Hello, 世界", "界世 ,olleH"},
        {"", ""},
    }
    for _, c := range cases {
        got := Reverse(c.in)
        if got != c.want {
            t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want)
        }
    }
}
</code></pre></div></div>

<p>Then run the test with <em>go test</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go test github.com/user/stringutil
ok      github.com/user/stringutil 0.165s
</code></pre></div></div>

<p>As always, if you are running the <em>go</em> tool from the package directory, you can omit the package path:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$go test
ok      github.com/user/stringutil 0.165s
</code></pre></div></div>

<p>Run <a href="https://golang.org/cmd/go/#hdr-Test_packages">go help test</a> and see <a href="https://golang.org/pkg/testing/">testing package documentation</a> for more detail.</p>

<h3 id="remote-packages">Remote packages</h3>

<p>An important path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The <em>go</em> tool uses this property to autmatically fetch packages from repositories. For instance, the examples described in this document are also kept in a Git repository hosted at GitHub <a href="https://github.com/golang/example">github.com/golang/example</a>. If you include the repository URL in the packages’s import path, <em>go get</em> will fetch, build, and install it automatically:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go get github.com/golang/example/hello
$ $GOPATH/bin/hello
Hello, Go examples!
</code></pre></div></div>

<p>If the specified package is not present in a workspace, <em>go get</em> will place it inside the first workspace specified by <em>GOPATH</em>. (If the package does already exist, <em>go get</em> skips the remote fetch and behaves the same as <em>go install</em>.)</p>

<p>Alfter issuing the above <em>go get</em> command, the workspace directory tree should now look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/
    hello                           # command executable
pkg/
    linux_amd64/
        github.com/golang/example/
            stringutil.a            # package object
        github.com/user/
            stringutil.a            # package object
src/
    github.com/golang/example/
    .git/                       # Git repository metadata
        hello/
            hello.go                # command source
        stringutil/
            reverse.go              # package source
            reverse_test.go         # test source
    github.com/user/
        hello/
            hello.go                # command source
        stringutil/
            reverse.go              # package source
            reverse_test.go         # test source
</code></pre></div></div>

<p>The <em>hello</em> command hosted at GitHub dependends on the <em>stringutil</em> package within the same repository. The import in <em>hello.go</em> file use the same import path convention, so the <em>go get</em> command is able to locate and install the depdendent package, too.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import "gitnhub.com/golang/example/stringutil"
</code></pre></div></div>

<p>This convention is the easiest way to make your Go packages available for others to use. The <a href="https://golang.org/wiki/Projects">Go Wiki</a> and <a href="https://godoc.org/">godoc.org</a> provide lists of external Go Projects.</p>

<p>For more information on using remote repositories with the <em>go</em> tool, see <a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">go help importpath</a>.</p>

<h3 id="whats-next">What’s next</h3>

<p>Subscribe to the <a href="https://groups.google.com/group/golang-announce">golang-announce</a> mailing list to be notified when a new stable version of Go is released.</p>

<p>See <a href="https://golang.org/doc/effective_go.html">Effective Go</a> for tips on writing clear, idiomatic Go code.</p>

<p>Take <a href="https://tour.golang.org/">A Tour of Go</a> to learn the language proper.</p>

<p>Visit the <a href="https://golang.org/doc/#articles">documentation page</a> for a set of in-depth articles about the Go language and its libraries and tools.</p>

<h3 id="getting-help">Getting help</h3>

<p>For real-time help, ask the helpful gophers in <em>#go-nuts</em> on the <a href="http://freenode.net/">Freenode</a> IRC server.</p>

<p>The official mailing list for discussion of the Go language is <a href="https://groups.google.com/group/golang-nuts">Go nuts</a>.</p>

<p>Report bugs using the <a href="https://golang.org/issue">Go issue tracker</a>.</p>

<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
