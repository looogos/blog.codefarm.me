<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Entity Framework in .NET | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Entity Framework in .NET" />
<meta property="og:locale" content="en" />
<meta name="description" content="Entity Framework (EF) Core is a lightweight, extensible, open source and cross-platform version of the popular Entity Framework data access technology, which can serve as an object-relational mapper (O/RM). [1] With EF, data access is performed using a model, which is made up of entity classes and a context object that represents a session to query and save data with the database. EF supports the following model development approaches: Generate a model from an existing database. Hand-code a model to match the database. Once a model is created, use EF Migrations to create a database from the model, which allow evolving the database as the model changes. Instances of the entity classes are retrieved from the database using Language Integrated Query (LINQ). Data is created, deleted, and modified in the database using instances of the entity classes. 1. Installing Entity Framework Core 2. DbContext 2.1. Lifetime, Configuration, and Initialization 2.2. DbContext Pooling 2.3. Connection Pooling 3. Model 3.1. Entity Types 3.2. Entity Properties 3.3. Keys 3.4. Generated Values 3.5. Shadow and Indexer Properties 3.6. Relationships 3.6.1. Foreign and Principal keys 3.6.2. Navigations 3.7. Indexes 3.8. Check Constraints 4. Schemas 4.1. Migrations 4.1.1. Managing Migrations 4.1.2. Applying Migrations 5. Querying 5.1. Tracking vs. no-tracking 5.2. Pagination 5.3. Indexes 5.4. Projections 5.5. SQL queries 6. Saving 6.1. SaveChanges, ExecuteUpdate and ExecuteDelete 6.2. Transactions 6.3. Optimistic concurrency 7. Logging, events, and diagnostics 8. Performance diagnosis 8.1. Identifying slow database commands via logging 8.2. Correlating database commands to LINQ queries 8.3. Inspecting query execution plans 9. Dapper References 1. Installing Entity Framework Core Entity Framework Core (EF Core) is distributed as NuGet packages, with the necessary packages determined by the database system (SQL Server, SQLite, etc.) and required EF Core features. [2][3] Make sure to install the same version of all EF Core packages shipped by Microsoft. For example, if version 5.0.3 of Microsoft.EntityFrameworkCore.SqlServer is installed, then all other Microsoft.EntityFrameworkCore.* packages must also be at 5.0.3. Use of tooling for EF Core migrations and reverse engineering (scaffolding) from an existing database requires installation of the appropriate tooling package: Always use the version of the tools package that matches the major version of the runtime packages. dotnet-ef for cross-platform command line tooling # dotnet ef must be installed as a global or local tool dotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design # dotnet ef can also be used as a local tool dotnet new tool-manifest dotnet tool install dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Microsoft.EntityFrameworkCore.Tasks for MSBuild tasks allowing build-time integration. Microsoft.EntityFrameworkCore.Tools for PowerShell tooling that works in the Visual Studio Package Manager Console 2. DbContext A DbContext is a combination of the Unit Of Work and Repository patterns that represents a session with the database and can be used to query and save instances of entities. A DbContext instance, designed for a single unit-of-work, has a typically short lifespan, beginning with its creation and ending with its disposal. A typical unit-of-work when using Entity Framework Core (EF Core) involves: creating a DbContext instance tracking entities that returned from a query or added or attached to the context making changes to those tracked entities as needed to implement the business rule calling SaveChanges or SaveChangesAsync to persist the changes to the database. disposing the DbContext instance. A DbContext is not thread-safe and doesn&#8217;t support parallel operations. Don&#8217;t share contexts between threads. Make sure to await all async calls before continuing to use the context instance. Use separate DbContext instances for concurrent operations Any code that explicitly executes multiple threads in parallel should ensure that DbContext instances aren&#8217;t ever accessed concurrently. 2.1. Lifetime, Configuration, and Initialization Each DbContext instance must be configured to use one and only one database provider using a specific Use* call. public class ApplicationDbContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { // use the SQL Server database provider optionsBuilder.UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;); } } Other DbContext configuration can be chained either before or after (it makes no difference which) the Use* call. builder.Services.AddDbContext&lt;ApplicationDbContext&gt;( options =&gt; options .EnableSensitiveDataLogging() .UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) ); EF Core can be integrated into applications using dependency injection, typically via the AddDbContext method. The AddDbContext extension method registers DbContext types with a scoped lifetime by default. In many web applications, each HTTP request corresponds to a single unit-of-work. var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;) ?? throw new InvalidOperationException(&quot;Connection string &#39;DefaultConnection&#39; not found.&quot;); builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(connectionString)); // builder.Services.AddDbContext&lt;ApplicationDbContext&gt;( // options =&gt; options.UseSqlServer(connectionString), // contextLifetime: ServiceLifetime.Scoped, // optionsLifetime: ServiceLifetime.Scoped); The ApplicationDbContext class must expose a public constructor with a DbContextOptions&lt;ApplicationDbContext&gt; parameter. public class ApplicationDbContext : DbContext { public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) { } } DbContext can be created with new, configured either by overriding OnConfiguring or by passing options to the constructor. public class ApplicationDbContext : DbContext { private readonly string? _connectionString; public ApplicationDbContext() : this( connectionString: @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) { } public ApplicationDbContext(string connectionString) =&gt; _connectionString = connectionString; public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) { } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { if (_connectionString is not null) optionsBuilder.UseSqlServer(_connectionString); } } using var context = new ApplicationDbContext(); using var context = new ApplicationDbContext( connectionString: @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;); var contextOptions = new DbContextOptionsBuilder&lt;ApplicationDbContext&gt;() .UseSqlServer(@&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) .Options; using var context = new ApplicationDbContext(contextOptions); In applications where dependency injection doesn&#8217;t provide a suitable DbContext lifetime or multiple units-of-work are needed within a scope, AddDbContextFactory can register a factory for creating individual DbContext instances. builder.Services.AddDbContextFactory&lt;ApplicationDbContext&gt;( options =&gt; options.UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;)); public sealed class MyService(IDbContextFactory&lt;ApplicationDbContext&gt; contextFactory) { public async Task DoWorkAsync() { var tasks = Enumerable.Range(1, 10).Select(_ =&gt; { using var context = contextFactory.CreateDbContext(); // ... return Task.CompletedTask; }); await Task.WhenAll(tasks); } } 2.2. DbContext Pooling While generally lightweight, creating and disposing DbContext instances can introduce overhead in high-performance scenarios, which EF Core mitigates through context pooling, reusing instances from an internal pool to minimize setup costs at program startup, rather than continuously. Note that context pooling is orthogonal to database connection pooling, which is managed at a lower level in the database driver. To enable context pooling, simply replace AddDbContext with AddDbContextPool: builder.Services.AddDbContextPool&lt;ApplicationDbContext&gt;( options =&gt; options.UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;), poolSize: 1024); The poolSize parameter of AddDbContextPool sets the maximum number of instances retained by the pool (defaults to 1024). Once poolSize is exceeded, new context instances are not cached and EF falls back to the non-pooling behavior of creating instances on demand. To use context pooling without dependency injection, initialize a PooledDbContextFactory and request context instances from it: var options = new DbContextOptionsBuilder&lt;PooledBloggingContext&gt;() .UseSqlServer(@&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) .Options; var factory = new PooledDbContextFactory&lt;PooledBloggingContext&gt;(options); using var context = factory.CreateDbContext(); var allPosts = await context.Posts.ToListAsync(); 2.3. Connection Pooling With most databases, a long-lived connection is required for performing database operations, and such connections can be expensive to open and close. EF Core relies on the underlying database driver (e.g., ADO.NET) for connection pooling, a client-side mechanism that reuses database connections to reduce the overhead of opening and closing connections repeatedly. While generally enabled by default and configurable at the driver level (e.g., via connection string), connection pooling is separate from EF Core&#8217;s context pooling, which optimizes DbContext instance reuse. EF Core typically opens and closes connections around each operation, returning them to the pool quickly. 3. Model EF Core uses a metadata model to describe how the application&#8217;s entity types are mapped to the underlying database. EF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API. The model is built using a set of conventions - heuristics that look for common patterns. The model can then be customized to override the configuration performed by conventions using mapping attributes (a.k.a., data annotations) and/or calls to the ModelBuilder methods (a.k.a., fluent API) in OnModelCreating. Fluent API configuration has the highest precedence and will override conventions and data annotations. internal sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Url) .IsRequired(); } } public class Blog { public int BlogId { get; set; } public string? Url { get; set; } } Data annotations will override conventions, but will be overridden by Fluent API configuration. internal sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } } [Table(&quot;Blogs&quot;)] public class Blog { public int BlogId { get; set; } [Required] public string? Url { get; set; } } EF Core model building conventions are classes that contain logic that is triggered based on changes being made to the model as it is being built. EF Core includes many model building conventions that are enabled by default, which can be found in the list of classes that implement the IConvention interface. Applications can remove or replace any of these conventions, as well as add new custom conventions that apply configuration for patterns that are not recognized by EF out of the box. internal sealed class BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : DbContext(options) { protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder) { configurationBuilder.Conventions.Remove(typeof(ForeignKeyIndexConvention)); } } While most configuration is data store-agnostic, providers can offer store-specific configurations and ignore unsupported ones. The model builder debug view can be accessed in the debugger or directly from code. Console.WriteLine(context.Model.ToDebugString()); Model: EntityType: Blog Properties: BlogId (int) Required PK AfterSave:Throw ValueGenerated.OnAdd Url (string) Required Keys: BlogId PK A DbSet included in a DbContext registers its type as an entity in EF Core&#8217;s model, enabling EF Core to read/write instances to/from the database and, for relational databases, create tables via migrations. 3.1. Entity Types A model includes entities through DbSet properties exposed on the context, specified in the OnModelCreating, and any types that are found by recursively exploring the navigation properties of other discovered entity types. internal sealed class MyContext : DbContext { // exposed in a DbSet property public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { // explicitly specified in OnModelCreating modelBuilder.Entity&lt;AuditEntry&gt;(); } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } // discovered via the Blog.Posts navigation property. public List&lt;Post&gt; Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public Blog Blog { get; set; } } public class AuditEntry { public int AuditEntryId { get; set; } public string Username { get; set; } public string Action { get; set; } } To exclude types from the model: // Data Annotations [NotMapped] public class BlogMetadata { public DateTime LoadedFromDatabase { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Ignore&lt;BlogMetadata&gt;(); } To exclude from migrations: protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;IdentityUser&gt;() .ToTable(&quot;AspNetUsers&quot;, t =&gt; t.ExcludeFromMigrations()); } By convention, each entity type will be set up to map to a database table with the same name as the DbSet property that exposes the entity. If no DbSet exists for the given entity, the class name is used. // Data Annotations [Table(&quot;blogs&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .ToTable(&quot;blogs&quot;); } When using a relational database, tables are by convention created in the database&#8217;s default schema. // Data Annotations [Table(&quot;blogs&quot;, Schema = &quot;blogging&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .ToTable(&quot;blogs&quot;, schema: &quot;blogging&quot;); } // define the default schema at the model level protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.HasDefaultSchema(&quot;blogging&quot;); } Entity types can be mapped to database views using the Fluent API. modelBuilder.Entity&lt;Blog&gt;() .ToView(&quot;blogsView&quot;, schema: &quot;blogging&quot;); It&#8217;s possible to map an entity type to a parameterless table-valued function (TVF) instead of a table in the database. modelBuilder.Entity&lt;BlogWithMultiplePosts&gt;().HasNoKey().ToFunction(&quot;BlogsWithMultiplePosts&quot;); An arbitrary text comment can be set on the database table to document the schema in the database. // Data Annotations [Comment(&quot;Blogs managed on the website&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;().ToTable( tableBuilder =&gt; tableBuilder.HasComment(&quot;Blogs managed on the website&quot;)); } Shared-type entity types (those using the same CLR type) require a unique name for configuration and usage, necessitating a Set call for the corresponding DbSet property. internal class MyContext : DbContext { public DbSet&lt;Dictionary&lt;string, object&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;string, object&gt;&gt;(&quot;Blog&quot;); protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.SharedTypeEntity&lt;Dictionary&lt;string, object&gt;&gt;( &quot;Blog&quot;, bb =&gt; { bb.Property&lt;int&gt;(&quot;BlogId&quot;); bb.Property&lt;string&gt;(&quot;Url&quot;); bb.Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); }); } } 3.2. Entity Properties Each entity type in a model has properties that EF Core reads and writes from the database; in relational databases, these properties map to table columns. By convention, all public properties with a getter and a setter will be included in the model. Specific properties can be excluded as follows: // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [NotMapped] public DateTime LoadedFromDatabase { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Ignore(b =&gt; b.LoadedFromDatabase); } By convention, when using a relational database, entity properties are mapped to table columns having the same name as the property. // Data Annotations public class Blog { [Column(&quot;blog_id&quot;)] public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.BlogId) .HasColumnName(&quot;blog_id&quot;); } When using a relational database, the database provider selects a data type based on the .NET type of the property. // Data Annotations public class Blog { public int BlogId { get; set; } [Column(TypeName = &quot;varchar(200)&quot;)] public string Url { get; set; } [Column(TypeName = &quot;decimal(5, 2)&quot;)] public decimal Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;( eb =&gt; { eb.Property(b =&gt; b.Url).HasColumnType(&quot;varchar(200)&quot;); eb.Property(b =&gt; b.Rating).HasColumnType(&quot;decimal(5, 2)&quot;); }); } Configuring a maximum length provides a hint to the database provider about the appropriate column data type to choose for a given array data type property, such as string and byte[]. // Data Annotations public class Blog { public int BlogId { get; set; } [MaxLength(500)] public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Url) .HasMaxLength(500); } Some relational data types support the precision and scale facets; these control what values can be stored, and how much storage is needed for the column. // Data Annotations public class Blog { public int BlogId { get; set; } [Precision(14, 2)] public decimal Score { get; set; } [Precision(3)] public DateTime LastUpdated { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Score) .HasPrecision(14, 2); modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.LastUpdated) .HasPrecision(3); } Text properties are configured as Unicode by default. // Data Annotations public class Book { public int Id { get; set; } public string Title { get; set; } [Unicode(false)] [MaxLength(22)] public string Isbn { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Book&gt;() .Property(b =&gt; b.Isbn) .IsUnicode(false); } When mapping to a relational database schema, required properties are created as non-nullable columns, and optional properties are created as nullable columns. A property is considered optional if it is valid for it to contain null. If null is not a valid value to be assigned to a property then it is considered to be a required property. By convention, a property whose .NET type can contain null will be configured as optional, whereas properties whose .NET type cannot contain null will be configured as required. If nullable reference types are disabled, all properties with .NET reference types are configured as optional by convention (for example, string). // Without NRT public class CustomerWithoutNullableReferenceTypes { public int Id { get; set; } [Required] // Data annotations needed to configure as required public string FirstName { get; set; } [Required] // Data annotations needed to configure as required public string LastName { get; set; } public string MiddleName { get; set; } // Optional by convention } // Without NRT with Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;CustomerWithoutNullableReferenceTypes&gt;(c =&gt; { c.Property(c =&gt; c.FirstName).IsRequired(); c.Property(c =&gt; c.LastName).IsRequired(); }); } If nullable reference types are enabled, properties will be configured based on the C# nullability of their .NET type: string? will be configured as optional, but string will be configured as required. // With NRT public class Customer { public int Id { get; set; } public string FirstName { get; set; } // Required by convention public string LastName { get; set; } // Required by convention public string? MiddleName { get; set; } // Optional by convention // Note the following use of constructor binding, which avoids compiled warnings // for uninitialized non-nullable properties. public Customer(string firstName, string lastName, string? middleName = null) { FirstName = firstName; LastName = lastName; MiddleName = middleName; } } A collation can be defined on text columns, determining how they are compared and ordered. // column level modelBuilder.Entity&lt;Customer&gt;().Property(c =&gt; c.Name) .UseCollation(&quot;SQL_Latin1_General_CP1_CI_AS&quot;); // database level modelBuilder.UseCollation(&quot;SQL_Latin1_General_CP1_CI_AS&quot;); 3.3. Keys A key (primary key or alternate key) serves as a unique identifier for each entity instance. By convention, a property named Id or &lt;type name&gt;Id will be configured as the primary key of an entity. internal class Car { public string Id { get; set; } public string Make { get; set; } public string Model { get; set; } } internal class Truck { public string TruckId { get; set; } public string Make { get; set; } public string Model { get; set; } } An entity&#8217;s primary key can also be explicitly configured using a single property or a composite key (multiple properties). // Data Annotations internal class Car { [Key] public string LicensePlate { get; set; } public string Make { get; set; } public string Model { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Car&gt;() .HasKey(c =&gt; c.LicensePlate); } // Data Annotations [PrimaryKey(nameof(State), nameof(LicensePlate))] internal class Car { public string State { get; set; } public string LicensePlate { get; set; } public string Make { get; set; } public string Model { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Car&gt;() .HasKey(c =&gt; new { c.State, c.LicensePlate }); } By convention, on relational databases primary keys are created with the name PK_&lt;type name&gt;. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasKey(b =&gt; b.BlogId) .HasName(&quot;PrimaryKey_BlogId&quot;); } An alternate key serves as an alternate unique identifier for each entity instance in addition to the primary key; it can be used as the target of a relationship. When using a relational database this maps to the concept of a unique index/constraint on the alternate key column(s) and one or more foreign key constraints that reference the column(s). For simple uniqueness constraints, use a unique index; alternate keys in EF Core are read-only and can also serve as foreign key targets. Alternate keys are usually created automatically by EF Core when a non-primary key property is used as the target of a relationship, so manual configuration is typically unnecessary. By convention, the index and constraint that are introduced for an alternate key will be named AK_&lt;type name&gt;_&lt;property name&gt; (for composite alternate keys &lt;property name&gt; becomes an underscore separated list of property names). 3.4. Generated Values Database columns can have their values generated in various ways: primary key columns are frequently auto-incrementing integers, other columns have default or computed values, etc. On relational databases, a column can be configured with a default value; if a row is inserted without a value for that column, the default value will be used. // a default value protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Rating) .HasDefaultValue(3); } // a SQL fragment protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Created) .HasDefaultValueSql(&quot;getdate()&quot;); } On most relational databases, a column can be configured to have its value computed in the database, typically with an expression referring to other columns: // a virtual computed column modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.DisplayName) .HasComputedColumnSql(&quot;[LastName] + &#39;, &#39; + [FirstName]&quot;); // // a physical computed column modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.NameLength) .HasComputedColumnSql(&quot;LEN([LastName]) + LEN([FirstName])&quot;, stored: true); By convention, non-composite primary keys of type short, int, long, or Guid are set up to have values generated for inserted entities if a value isn&#8217;t provided by the application. A property can be explicitly configured to have its value generated on add or update: // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public DateTime Inserted { get; set; } } // Fluent API // protected override void OnModelCreating(ModelBuilder modelBuilder) // { // modelBuilder.Entity&lt;Blog&gt;() // .Property(b =&gt; b.Inserted) // .ValueGeneratedOnAdd(); // } // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [DatabaseGenerated(DatabaseGeneratedOption.Computed)] public DateTime LastUpdated { get; set; } } // Fluent API // protected override void OnModelCreating(ModelBuilder modelBuilder) // { // modelBuilder.Entity&lt;Blog&gt;() // .Property(b =&gt; b.LastUpdated) // .ValueGeneratedOnAddOrUpdate(); // } Unlike with default values or computed columns, how the values are to be generated depends on the database provider being used. Database providers may automatically set up value generation for some property types, but others may require to manually set up how the value is generated. For example, on SQL Server, when a GUID property is configured as a primary key, the provider automatically performs value generation client-side, using an algorithm to generate optimal sequential GUID values. Similarly, byte[] properties that are configured as generated on add or update and marked as concurrency tokens are set up with the rowversion data type, so that values are automatically generated in the database. A common request is to have a database column which contains the date/time for when the row was first inserted (value generated on add), or for when it was last updated (value generated on add or update). Configuring a date/time column to have the creation timestamp of the row is usually a matter of configuring a default value with the appropriate SQL function. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Created) .HasDefaultValueSql(&quot;getdate()&quot;); } Although stored computed columns seem like a good solution for managing last-updated timestamps, databases usually don&#8217;t allow specifying functions such as GETDATE() in a computed column. As an alternative, set up a database trigger to achieve the same effect: CREATE TRIGGER [dbo].[Blogs_UPDATE] ON [dbo].[Blogs] AFTER UPDATE AS BEGIN SET NOCOUNT ON; IF ((SELECT TRIGGER_NESTLEVEL()) &gt; 1) RETURN; UPDATE B SET LastUpdated = GETDATE() FROM dbo.Blogs AS B INNER JOIN INSERTED AS I ON B.BlogId = I.BlogId END To override value generation with an explicit value, simply set the property to any value that is not the CLR default value for that property&#8217;s type (null for string, 0 for int, Guid.Empty for Guid, etc.). var product = new Product { // To override the auto-generated CreatedDate, set it to something other than DateTime.MinValue: CreatedDate = DateTime.Now.AddYears(-10) }; await context.AddAsync(product); await context.SaveChangesAsync(); public class Product { public Guid Id { get; set; } // Will be auto-generated by default (often) public string? Name { get; set; } // modelBuilder.Entity&lt;Product&gt;().Property(p =&gt; p.CreatedDate).HasDefaultValueSql(&quot;getdate()&quot;); public DateTime CreatedDate { get; set; } // Will be auto-generated (often) } To disable value generation that has been set up by convention. // Data Annotations public class Blog { [DatabaseGenerated(DatabaseGeneratedOption.None)] public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.BlogId) .ValueGeneratedNever(); } 3.5. Shadow and Indexer Properties Shadow properties are properties that aren&#8217;t defined in .NET entity class but are defined for that entity type in the EF Core model, which are maintained purely in the Change Tracker and are useful when there&#8217;s data in the database that shouldn&#8217;t be exposed on the mapped entity types. Indexer properties are entity type properties, which are backed by an indexer in .NET entity class to add additional properties to the entity type without changing the CLR class. Shadow properties are most often used for foreign key properties, where they are added to the model by convention when no foreign key property has been found by convention or configured explicitly. The relationship is represented by navigation properties, but in the database it is enforced by a foreign key constraint, and the value for the foreign key column is stored in the corresponding shadow property. The property will be named &lt;navigation property name&gt;&lt;principal key property name&gt; (the navigation on the dependent entity, which points to the principal entity, is used for the naming). If the principal key property name starts with the name of the navigation property, then the name will just be &lt;principal key property name&gt;. If there is no navigation property on the dependent entity, then the principal type name concatenated with the primary or alternate key property name is used in its place &lt;principal type name&gt;&lt;principal key property name&gt;. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public DbSet&lt;Post&gt; Posts { get; set; } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List&lt;Post&gt; Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } // Since there is no CLR property which holds the foreign // key for this relationship, a shadow property is created. public Blog Blog { get; set; } } var post = new Post { Blog = new() }; await context.AddAsync(post); await context.SaveChangesAsync(); var blogId = (int)context.Entry(post).Property(nameof(Blog.BlogId)).CurrentValue!; Debug.Assert(post.Blog.BlogId == blogId); Shadow properties can be configured using the Fluent API to call the string overload of Property&lt;TProperty&gt;(String) to chain any of the configuration calls for other properties. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } } Shadow property values can be referenced in LINQ queries via the EF.Property static method or obtained and changed through the ChangeTracker API. var blogs = context.Blogs .OrderBy(b =&gt; EF.Property&lt;DateTime&gt;(b, &quot;LastUpdated&quot;)); context.Entry(myBlog).Property(&quot;LastUpdated&quot;).CurrentValue = DateTime.Now; Indexer properties can be configured using the Fluent API to call the method IndexerProperty to chain any of the configuration calls for other properties. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;().IndexerProperty&lt;DateTime&gt;(&quot;LastUpdated&quot;); } } public class Blog { private readonly Dictionary&lt;string, object&gt; _data = new Dictionary&lt;string, object&gt;(); public int BlogId { get; set; } public object this[string key] { get =&gt; _data[key]; set =&gt; _data[key] = value; } } Indexer properties can be referenced in LINQ queries via the EF.Property static method or by using the CLR indexer property. var blog = new Blog(); blog[&quot;LastUpdated&quot;] = DateTime.Now; await context.AddAsync(blog); await context.SaveChangesAsync(); var lastUpdated = await context.Blogs .Select(b =&gt; EF.Property&lt;DateTime&gt;(b, &quot;LastUpdated&quot;)) .FirstAsync(); Console.WriteLine(lastUpdated); Entity types that contain only indexer properties are known as property bag entity types. internal class MyContext : DbContext { public DbSet&lt;Dictionary&lt;string, object&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;string, object&gt;&gt;(&quot;Blog&quot;); protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.SharedTypeEntity&lt;Dictionary&lt;string, object&gt;&gt;( &quot;Blog&quot;, bb =&gt; { bb.Property&lt;int&gt;(&quot;BlogId&quot;); bb.Property&lt;string&gt;(&quot;Url&quot;); bb.Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); }); } } 3.6. Relationships A relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model. A one-to-many relationship is used when a single entity is associated with any number of other entities. CREATE TABLE [Blogs] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Blogs] PRIMARY KEY ([Id]) ); CREATE TABLE [Posts] ( [Id] int NOT NULL IDENTITY, [BlogId] int NOT NULL, CONSTRAINT [PK_Posts] PRIMARY KEY ([Id]), CONSTRAINT [FK_Posts_Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [Blogs] ([Id]) ON DELETE CASCADE ); CREATE INDEX [IX_Posts_BlogId] ON [Posts] ([BlogId]); // Principal (parent) public class Blog { public int Id { get; set; } (1) public ICollection&lt;Post&gt; Posts { get; } = []; // Collection navigation containing dependents (3) } // Dependent (child) public class Post { public int Id { get; set; } public int BlogId { get; set; } // Required foreign key property (2) public Blog Blog { get; set; } = null!; // Required reference navigation to principal (4) // public int? BlogId { get; set; } // Optional foreign key property // public Blog? Blog { get; set; } // Optional reference navigation to principal } A one-to-many relationship is made up from: 1 One or more primary or alternate key properties on the principal entity; that is the &quot;one&quot; end of the relationship. 2 One or more foreign key properties on the dependent entity; that is the &quot;many&quot; end of the relationship. 3 Optionally, a collection navigation on the principal entity referencing the dependent entities. 4 Optionally, a reference navigation on the dependent entity referencing the principal entity. For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasForeignKey(e =&gt; e.BlogId) .IsRequired(); // .IsRequired(false); } As with all relationships, it is exactly equivalent to start with dependent entity type (Post) and use HasOne followed by WithMany. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasOne(e =&gt; e.Blog) .WithMany(e =&gt; e.Posts) .HasForeignKey(e =&gt; e.BlogId) .IsRequired(); // .IsRequired(false); } A one-to-one relationship is used when one entity is associated with at most one other entity. CREATE TABLE [Blogs] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Blogs] PRIMARY KEY ([Id]) ); CREATE TABLE [BlogHeader] ( [Id] int NOT NULL IDENTITY, [BlogId] int NOT NULL, CONSTRAINT [PK_BlogHeader] PRIMARY KEY ([Id]), CONSTRAINT [FK_BlogHeader_Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [Blogs] ([Id]) ON DELETE CASCADE ); CREATE UNIQUE INDEX [IX_BlogHeader_BlogId] ON [BlogHeader] ([BlogId]); -- UNIQUE INDEX // Principal (parent) public class Blog { public int Id { get; set; } (1) public BlogHeader? Header { get; set; } // Reference navigation to dependent (3) } // Dependent (child) public class BlogHeader { public int Id { get; set; } public int BlogId { get; set; } // Required foreign key property (2) public Blog Blog { get; set; } = null!; // Required reference navigation to principal (4) // public int? BlogId { get; set; } // Optional foreign key property // public Blog? Blog { get; set; } // Optional reference navigation to principal } A one-to-many relationship is made up from: 1 One or more primary or alternate key properties on the principal entity; that is the &quot;one&quot; end of the relationship. 2 One or more foreign key properties on the dependent entity; that is the &quot;many&quot; end of the relationship. 3 Optionally, a reference navigation on the principal entity referencing the dependent entities. 4 Optionally, a reference navigation on the dependent entity referencing the principal entity. For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasOne(e =&gt; e.Header) .WithOne(e =&gt; e.Blog) .HasForeignKey&lt;BlogHeader&gt;(e =&gt; e.BlogId) .IsRequired(); } As with all relationships, it is exactly equivalent to start with dependent entity type (BlogHeader) instead. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;BlogHeader&gt;() .HasOne(e =&gt; e.Blog) .WithOne(e =&gt; e.Header) .HasForeignKey&lt;BlogHeader&gt;(e =&gt; e.BlogId) .IsRequired(); } A many-to-many relationship is used when any number entities of one entity type is associated with any number of entities of the same or another entity type. A many-to-many relationship requires a join entity (and table) to link the two sides, as a single foreign key is insufficient. CREATE TABLE [Posts] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Posts] PRIMARY KEY ([Id]) ); CREATE TABLE [Tag] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Tag] PRIMARY KEY ([Id]) ); CREATE TABLE [PostTag] ( [PostsId] int NOT NULL, [TagsId] int NOT NULL, CONSTRAINT [PK_PostTag] PRIMARY KEY ([PostsId], [TagsId]), CONSTRAINT [FK_PostTag_Posts_PostsId] FOREIGN KEY ([PostsId]) REFERENCES [Posts] ([Id]) ON DELETE CASCADE, CONSTRAINT [FK_PostTag_Tag_TagsId] FOREIGN KEY ([TagsId]) REFERENCES [Tag] ([Id]) ON DELETE CASCADE ); CREATE INDEX [IX_PostTag_TagsId] ON [PostTag] ([TagsId]); EF Core can hide the join entity type and manage it behind the scenes that allows the navigations of a many-to-many relationship to be used in a natural manner, adding or removing entities from each side as needed. public class Post { public int Id { get; set; } public List&lt;Tag&gt; Tags { get; } = []; } public class Tag { public int Id { get; set; } public List&lt;Post&gt; Posts { get; } = []; } 3.6.1. Foreign and Principal keys One-to-one and one-to-many relationships are defined by a foreign key on the dependent entity referencing the principal key (primary or alternate) of the principal entity. Many-to-many relationships are formed by two one-to-many relationships, each with its own foreign key referencing a principal key. The property or properties that make up foreign key are often discovered by convention, and can also be configured explicitly using either mapping attributes or with HasForeignKey in the model building API. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasForeignKey(e =&gt; e.ContainingBlogId); // lambda expression. // .HasForeignKey(&quot;ContainingBlogId&quot;); // property name // composite foreign key // .HasForeignKey(e =&gt; new { e.ContainingBlogId1, e.ContainingBlogId2 }); // .HasForeignKey(&quot;ContainingBlogId1&quot;, &quot;ContainingBlogId2&quot;); } By convention, foreign keys are constrained to the primary key at the principal end of the relationship. However, an alternate key can be used instead using HasPrincipalKey on the model building API. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasPrincipalKey(e =&gt; e.AlternateId); // lambda expression. // .HasPrincipalKey(&quot;AlternateId&quot;); // property name // composite key // .HasPrincipalKey(e =&gt; new { e.AlternateId1, e.AlternateId2 }); // .HasPrincipalKey(&quot;AlternateId1&quot;, &quot;AlternateId2&quot;); } The order of the properties in the principal and foreign key must match, which is also the order in which the key is defined in the database schema. There is no need to call HasAlternateKey to define the alternate key on the principal entity when HasPrincipalKey is used with properties that are not the primary key properties. In many-to-many relationships, the foreign keys are defined on the join entity type and mapped to foreign key constraints in the join table. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasMany(e =&gt; e.Tags) .WithMany(e =&gt; e.Posts) .UsingEntity( l =&gt; l.HasOne(typeof(Tag)).WithMany().HasConstraintName(&quot;TagForeignKey_Constraint&quot;), r =&gt; r.HasOne(typeof(Post)).WithMany().HasConstraintName(&quot;PostForeignKey_Constraint&quot;)); } 3.6.2. Navigations EF Core relationships are defined by foreign keys. Navigations are layered over foreign keys to provide a natural, object-oriented view for reading and manipulating relationships. By using navigations, applications can work with graphs of entities without being concerned with what is happening to the foreign key values. A navigation from dependent to principal is required if the relationship is required, which in turn means that the foreign key property is non-nullable. Conversely, the navigation is optional if the foreign key is nullable, and the relationship is therefore optional. Reference navigations are simple object references to another entity, which represent the &quot;one&quot; side(s) of one-to-many and one-to-one relationships. Reference navigations must have a setter, although it does not need to be public. Reference navigations should not be automatically initialized to a non-null default value; doing so is equivalent to asserting that an entity exists when it does not. When using C# nullable reference types, reference navigations must be nullable for optional relationships: Reference navigations for required relationships can be nullable or non-nullable. public Blog? TheBlog { get; set; } Collection navigations are instances of a .NET collection type; that is, any type implementing ICollection&lt;T&gt;, which represent the &quot;many&quot; side(s) of one-to-many and many-to-many relationships. Collection navigations do not need to have a setter. It is common to initialize the collection inline, thereby removing the need to ever check if the property is null. public ICollection&lt;Post&gt; ThePosts { get; } = []; Don&#8217;t accidentally create an expression bodied property, such as public ICollection&lt;Post&gt; ThePosts =&gt; [];, which will create a new, empty collection instance each time the property is accessed, and will therefore be useless as a navigation. 3.7. Indexes Indexes are a common concept across many data store to make lookups based on a column (or set of columns) more efficient. // Data Annotations [Index(nameof(Url))] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url); } By convention, an index is created in each property (or set of properties) that are used as a foreign key. A composite index, spanning more than one column, speeds up queries which filter on index&#8217;s columns, but also queries which only filter on the first columns covered by the index. // Data Annotations [Index(nameof(FirstName), nameof(LastName))] public class Person { public int PersonId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }); } By default, indexes aren&#8217;t unique: multiple rows are allowed to have the same value(s) for the index&#8217;s column set. // Data Annotations [Index(nameof(Url), IsUnique = true)] // UNIQUE INDEX public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url) .IsUnique(); // UNIQUE INDEX } In most databases, each column covered by an index can be either ascending or descending. For indexes covering only one column, this typically does not matter: the database can traverse the index in reverse order as needed. However, for composite indexes, the ordering can be crucial for good performance, and can mean the difference between an index getting used by a query or not. In general, the index columns&#39; sort orders should correspond to those specified in the ORDER BY clause of a query. The index sort order is ascending by default. // Data Annotations [Index(nameof(Url), nameof(Rating), AllDescending = true)] // make all columns as descending order public class Blog { public int BlogId { get; set; } public string Url { get; set; } public int Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; new { b.Url, b.Rating }) .IsDescending(); // make all columns as descending order } The index may also be specified the sort order on a column-by-column basis. // Data Annotations [Index(nameof(Url), nameof(Rating), IsDescending = new[] { false, true })] public class Blog { public int BlogId { get; set; } public string Url { get; set; } public int Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; new { b.Url, b.Rating }) .IsDescending(false, true); } To create multiple indexes over the same set of properties, pass a name to the HasIndex, which will be used to identify the index in the EF model, and to distinguish it from other indexes over the same properties. // Fluent API modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }, &quot;IX_Names_Ascending&quot;); modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }, &quot;IX_Names_Descending&quot;) .IsDescending(); // Data Annotations [Index(nameof(FirstName), nameof(LastName), Name = &quot;IX_Names_Ascending&quot;)] [Index(nameof(FirstName), nameof(LastName), Name = &quot;IX_Names_Descending&quot;, AllDescending = true)] public class Person { public int PersonId { get; set; } public string? FirstName { get; set; } public string? LastName { get; set; } } A filtered index is an index that includes a WHERE clause, effectively indexing only a subset of the rows in a table to index only a subset of a column&#8217;s values, reducing the index&#8217;s size and improving both performance and disk space usage. [4] Filtered indexes are not supported by all RDBMS. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url) .HasFilter(&quot;[Url] IS NOT NULL&quot;); } An index with nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns. [5] protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasIndex(p =&gt; p.Url) .IncludeProperties( p =&gt; new { p.Title, p.PublishedOn }); } Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data isn&#8217;t accessed resulting in fewer disk I/O operations. 3.8. Check Constraints Check constraints are a standard database feature that enforces a condition on all table rows; inserts or updates violating the condition will fail. Check constraints are similar to non-null and unique constraints but allow for arbitrary SQL expressions. modelBuilder.Entity&lt;Product&gt;() .ToTable(b =&gt; { b.HasCheckConstraint(&quot;CK_Prices&quot;, &quot;[Price] &gt; [DiscountedPrice]&quot;); b.HasCheckConstraint(&quot;CK_PositivePrice&quot;, &quot;[Price] &gt; 0&quot;); b.HasCheckConstraint(&quot;CK_PositiveDiscountedPrice&quot;, &quot;[DiscountedPrice] &gt;= 0&quot;); }); 4. Schemas EF Core offers two ways to synchronize a model and database schema: Migrations (model as the source of truth, incrementally applying schema changes) and Reverse Engineering (database as the source of truth, scaffolding a model from the existing schema). 4.1. Migrations The migrations feature in EF Core provides a way to incrementally update the database schema to keep it in sync with the application&#8217;s data model while preserving existing data in the database. When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration describing the updates necessary to keep the database schema in sync. EF Core compares the current model against a snapshot of the old model to determine the differences, and generates migration source files; the files can be tracked in the project&#8217;s source control like any other source file. Once a new migration has been generated, it can be applied to a database in various ways. EF Core records all applied migrations in a special history table, allowing it to know which migrations have been applied and which haven&#8217;t. Create and Drop APIs The EnsureCreatedAsync and EnsureDeletedAsync methods provide a lightweight alternative to Migrations for managing the database schema, which are useful in scenarios when the data is transient and can be dropped when the schema changes, such as during development. EnsureCreatedAsync and Migrations don&#8217;t work well together. // Drop the database if it exists await dbContext.Database.EnsureDeletedAsync(); // Create the database if it doesn&#39;t exist dbContext.Database.EnsureCreatedAsync(); // Get the SQL used by EnsureCreatedAsync var sql = dbContext.Database.GenerateCreateScript(); Install the EF Core command-line tools. # globally dotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design # locally dotnet new tool-manifest dotnet tool install dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Set up a .NET generic host for app startup and lifetime management. # create a new project dotnet new console -o getting-started &amp;&amp; cd getting-started/ # install SQLite provider dotnet add package Microsoft.EntityFrameworkCore.Sqlite # install generic host package dotnet add package Microsoft.Extensions.Hosting // Program.cs var builder = Host.CreateApplicationBuilder(args); builder.Services.AddDbContext&lt;BloggingContext&gt;(options =&gt; options.UseSqlite(&quot;Data Source=:memory:&quot;)); // &quot;:memory:&quot; creates in-memory DB var app = builder.Build(); // Create and Drop APIs // using (var scope = app.Services.CreateScope()) // { // using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); // await context.Database.EnsureDeletedAsync(); // await context.Database.EnsureCreatedAsync(); // } sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } } public class Blog { public int Id { get; set; } public string? Name { get; set; } } 4.1.1. Managing Migrations As the model changes, migrations are added and removed as part of normal development, and the migration files are checked into the project&#8217;s source control. dotnet ef migrations add // add a migration dotnet ef migrations add InitialCreate EF Core will create a directory called Migrations in the project, and generate some files. $ tree ./Migrations/ ./Migrations/ ├── 20250213080400_InitialCreate.cs (1) ├── 20250213080400_InitialCreate.Designer.cs (2) └── BloggingContextModelSnapshot.cs (3) 1 The main migrations file that contains the operations necessary to apply the migration (in Up) and to revert it (in Down). 2 The migrations metadata file that contains information used by EF. 3 A snapshot of the current model used to determine what changed when adding the next migration. It&#8217;s a good idea to inspect what exactly EF Core generated - and possibly amend it. dotnet ef migrations list $ dotnet ef migrations list Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (9ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT COUNT(*) FROM &quot;sqlite_master&quot; WHERE &quot;name&quot; = &#39;__EFMigrationsHistory&#39; AND &quot;type&quot; = &#39;table&#39;; 20250213080400_InitialCreate (Pending) dotnet ef migrations remove Avoid removing any migrations which have already been applied to production databases. $ dotnet ef migrations remove Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (10ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT COUNT(*) FROM &quot;sqlite_master&quot; WHERE &quot;name&quot; = &#39;__EFMigrationsHistory&#39; AND &quot;type&quot; = &#39;table&#39;; Removing migration &#39;20250213080400_InitialCreate&#39;. Removing model snapshot. Done. 4.1.2. Applying Migrations The recommended way to deploy migrations to a production database is by generating SQL scripts. SQL scripts can be reviewed for accuracy; this is important since applying schema changes to production databases is a potentially dangerous operation that could involve data loss. In some cases, the scripts can be tuned to fit the specific needs of a production database. SQL scripts can be used in conjunction with a deployment technology, and can even be generated as part of a CI process. SQL scripts can be provided to a DBA, and can be managed and archived separately. # generate a SQL script from a blank database to the latest migration dotnet ef migrations script # generate a SQL script from the given migration to the latest migration. dotnet ef migrations script AddNewTables # generate a SQL script from the specified from migration to the specified to migration dotnet ef migrations script AddNewTables AddAuditTable # generate idempotent migrations dotnet ef migrations script --idempotent The EF command-line tools can be productively used to apply migrations during local development and testing, but are not ideal for managing production databases. The SQL commands are applied directly by the tool, without giving the developer a chance to inspect or modify them, which can be dangerous in a production environment. The .NET SDK and the EF tool must be installed on production servers and requires the project&#8217;s source code. # update database to the latest migration dotnet ef database update # update or roll back database to a given migration dotnet ef database update AddNewTables Migration bundles are single-file executables that can be used to apply migrations to a databaseto ddress some of the shortcomings of the SQL script and command-line tools. Executing SQL scripts requires additional tools. The transaction handling and continue-on-error behavior of these tools are inconsistent and sometimes unexpected, which can leave the database in an undefined state if a failure occurs when applying migrations. Bundles can be generated as part of a CI process and easily executed later as part of the deployment process. Bundles are executable without the .NET SDK, EF Tool, or even the .NET Runtime (if self-contained), and they don&#8217;t require source code. # generate a bundle dotnet ef migrations bundle # generate a self-contained bundle for Linux dotnet ef migrations bundle --self-contained -r linux-x64 The resulting executable is named efbundle by default, which can be used to update the database to the latest migration. $ ./efbundle --help Entity Framework Core Migrations Bundle 9.0.2 Usage: efbundle [arguments] [options] [[--] &lt;arg&gt;...]] Arguments: &lt;MIGRATION&gt; The target migration. If &#39;0&#39;, all migrations will be reverted. Defaults to the last migration. Options: --connection &lt;CONNECTION&gt; The connection string to the database. Defaults to the one specified in AddDbContext or OnConfiguring. --version Show version information -h|--help Show help information -v|--verbose Show verbose output. --no-color Don&#39;t colorize output. --prefix-output Prefix output with level. The migrations can be programmatically applied by calling context.Database.MigrateAsync() for local development and testing. var builder = Host.CreateApplicationBuilder(args); // . . . var app = builder.Build(); using (var scope = app.Services.CreateScope()) { using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); await context.Database.MigrateAsync(); } 5. Querying Entity Framework Core uses Language-Integrated Query (LINQ) to query data from the database. EF Core passes a representation of the LINQ query to the database provider. Database providers in turn translate it to database-specific query language (for example, SQL for a relational database). Queries are always executed against the database even if the entities returned in the result already exist in the context. // SELECT [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] var blogs = await context.Blogs.ToListAsync(); // SELECT TOP(1) [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] // WHERE [b].[Id] = 1 var blog = await context.Blogs.SingleOrDefaultAsync(b =&gt; b.Id == 1); // SELECT [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] // WHERE [b].[Url] IS NOT NULL AND [b].[Url] LIKE N&#39;%dotnet%&#39; var filteredBlogs = await context.Blogs .Where(b =&gt; b.Url != null &amp;&amp; b.Url.Contains(&quot;dotnet&quot;)).ToListAsync(); Tracking behavior controls if Entity Framework Core keeps information about an entity instance in its change tracker. If an entity is tracked, any changes detected in the entity are persisted to the database during SaveChanges. EF Core also fixes up navigation properties between the entities in a tracking query result and the entities that are in the change tracker. By default, queries that return entity types are tracking. If EF Core finds an existing entity, then the same instance is returned, which can potentially use less memory and be faster than a no-tracking query. EF Core doesn&#8217;t overwrite current and original values of the entity&#8217;s properties in the entry with the database values. If the entity isn&#8217;t found in the context, EF Core creates a new entity instance and attaches it to the context. Query results don&#8217;t contain any entity which is added to the context but not yet saved to the database. var blog = await context.Blogs.SingleOrDefaultAsync(b =&gt; b.BlogId == 1); blog.Rating = 5; await context.SaveChangesAsync(); 5.1. Tracking vs. no-tracking No-tracking queries are useful when the results are used in a read-only scenario, which are generally quicker to execute because there&#8217;s no need to set up the change tracking information. If the entities retrieved from the database don&#8217;t need to be updated, then a no-tracking query should be used. An individual query can be set to be no-tracking. var blogs = await context.Blogs .AsNoTracking() .ToListAsync(); A no-tracking query also give results based on what&#8217;s in the database disregarding any local changes or added entities. The default tracking behavior can be changed at the context instance level. context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; var blogs = await context.Blogs.ToListAsync(); To make all the queries no-tracking by default. protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder .UseSqlServer(@&quot;Server=(localdb)\mssqllocaldb;Database=EFQuerying.Tracking&quot;) .UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking); } // You can still add AsTracking to make specific queries tracking. var blogs = await context.Blogs.AsNoTracking().ToListAsync(); 5.2. Pagination Keyset pagination is appropriate for pagination interfaces where the user navigates forwards and backwards, but does not support random access, where the user can jump to any specific page. A common way to implement pagination with databases is to use the Skip and Take LINQ operators (OFFSET and LIMIT in SQL). var posts = await context.Blogs .OrderBy(b =&gt; b.Id) .Skip(20) // page index .Take(10) // page size .ToListAsync(); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (14ms) [Parameters=[@__p_0=&#39;20&#39;, @__p_1=&#39;10&#39;], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT [b].[Id], [b].[Name], [b].[Url] FROM [Blogs] AS [b] ORDER BY [b].[Id] OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY The recommended alternative to offset-based pagination - sometimes called keyset pagination or seek-based pagination - is to simply use a WHERE clause to skip rows, instead of an offset. int lastId = 55; var posts = await context.Blogs .OrderBy(b =&gt; b.Id) .Where(b =&gt; b.Id &gt; lastId) .Take(10) .ToListAsync(); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (136ms) [Parameters=[@__p_1=&#39;10&#39;, @__lastId_0=&#39;55&#39;], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT TOP(@__p_1) [b].[Id], [b].[Name], [b].[Url] FROM [Blogs] AS [b] WHERE [b].[Id] &gt; @__lastId_0 ORDER BY [b].[Id] 5.3. Indexes A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via a database&#8217;s favorite tool. While indexes speed up queries, they also slow down updates since they need to be kept up-to-date. Avoid defining indexes which aren&#8217;t needed, and consider using index filters to limit the index to a subset of the rows. Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don&#8217;t filter on all the index&#8217;s columns - depending on ordering. For example, an index on columns A and B speeds up queries filtering by A and B as well as queries filtering only by A, but it does not speed up queries only filtering over B. If a query filters by an expression over a column (e.g. price / 2), a simple index cannot be used. However, a stored persisted column can be defined for the expression, and create an index over that. Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression. 5.4. Projections For read-only queries with multiple columns, project into anonymous types, but be aware that updates become more complex since EF Core change tracking relies on entities, though partial updates are possible with advanced techniques. // SELECT TOP(2) [p].[FirstName], [p].[LastName] // FROM [People] AS [p] // WHERE [p].[FirstName] = N&#39;John&#39; var p = await context.People .Select(p =&gt; new { p.FirstName, p.LastName }) // projection .SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); 5.5. SQL queries Entity Framework Core allows dropping down to SQL queries when working with a relational database, which are useful if the query can&#8217;t be expressed using LINQ, or if a LINQ query causes EF to generate inefficient SQL. Basic SQL queries // a LINQ query based on a SQL query var blogs = await context.Blogs .FromSql($&quot;SELECT * FROM dbo.Blogs&quot;) .ToListAsync(); // execute a stored procedure var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogs&quot;) .ToListAsync(); // string interpolation var user = &quot;johndoe&quot;; var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogsForUser {user}&quot;) .ToListAsync(); // named parameters var user = new SqlParameter(&quot;user&quot;, &quot;johndoe&quot;); var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogsForUser @filterByUser={user}&quot;) .ToListAsync(); // executing non-querying SQL var rowsModified = context.Database.ExecuteSql($&quot;UPDATE [Blogs] SET [Url] = NULL&quot;); // executing non-querying SQL var tranMode = context.Database.SqlQueryRaw&lt;string&gt;( &quot;SELECT IIF(@@OPTIONS&amp;2 = 0, &#39;Implicit Transaction Off&#39;, &#39;Implicit Transaction On&#39;) AS TranMode&quot;) .ToList() .FirstOrDefault(); // use the underlying ADO.NET connection directly using var connection = context.Database.GetDbConnection(); connection.Open(); using var command = connection.CreateCommand(); command.CommandText = &quot;SELECT IIF(@@OPTIONS&amp;2 = 0, &#39;Implicit Transaction Off&#39;, &#39;Implicit Transaction On&#39;) AS TranMode&quot;; var tranMode = command.ExecuteScalar() as string; 6. Saving Entity Framework Core (EF Core) supports two approaches for persisting data to the database: change tracking with SaveChanges() and direct execution with ExecuteUpdate and ExecuteDelete. 6.1. SaveChanges, ExecuteUpdate and ExecuteDelete EF Core tracks changes maked to data (adding, updating, or deleting) and SaveChanges() turns those changes into the SQL commands needed to update the database. It is the more common and often preferred method for saving data in EF Core. For large-scale bulk updates, SaveChanges() can be less efficient than direct execution methods. // Add a new entity var newProduct = new Product { Name = &quot;New Widget&quot;, Price = 9.99 }; context.Products.Add(newProduct); // Modify an existing entity var existingProduct = context.Products.Find(1); if (existingProduct != null) { existingProduct.Price = 12.99; } // Remove an entity var productToRemove = context.Products.Find(2); if (productToRemove != null) { context.Products.Remove(productToRemove); } // Save all changes context.SaveChanges(); The ExecuteUpdate and ExecuteDelete offer a direct way, bypassing change tracker, to update or delete data using LINQ queries, which is often more efficient for bulk operations or when needing precise control over the SQL. // Update multiple products context.Products .Where(p =&gt; p.Category == &quot;Electronics&quot;) .ExecuteUpdate(setters =&gt; setters.SetProperty(p =&gt; p.Price, 19.99)); // Delete multiple products context.Products .Where(p =&gt; p.Discontinued) .ExecuteDelete(); 6.2. Transactions By default, if the database provider supports transactions, all changes in a single call to SaveChanges are applied in a transaction. While all relational database providers support transactions, other providers types may throw or no-op when transaction APIs are called. The DbContext.Database API can be used to begin, commit, and rollback transactions. using var context = new BloggingContext(); using var transaction = await context.Database.BeginTransactionAsync(); try { context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/dotnet/&quot; }); await context.SaveChangesAsync(); await transaction.CreateSavepointAsync(&quot;BeforeMoreBlogs&quot;); context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/visualstudio/&quot; }); context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/aspnet/&quot; }); await context.SaveChangesAsync(); await transaction.CommitAsync(); } catch (Exception) { // If a failure occurred, we rollback to the savepoint and can continue the transaction await transaction.RollbackToSavepointAsync(&quot;BeforeMoreBlogs&quot;); // TODO: Handle failure, possibly retry inserting blogs } 6.3. Optimistic concurrency EF Core implements optimistic concurrency, which assumes that concurrency conflicts are relatively rare. In contrast to pessimistic approaches - which lock data up-front and only then proceed to modify it - optimistic concurrency takes no locks, but arranges for the data modification to fail on save if the data has changed since it was queried. Optimistic concurrency failure is reported to the application, which deals with it accordingly, possibly by retrying the entire operation on the new data. In EF Core, optimistic concurrency is implemented by configuring a property as a concurrency token. The concurrency token is loaded and tracked when an entity is queried - just like any other property. Then, when an update or delete operation is performed during SaveChanges(), the value of the concurrency token on the database is compared against the original value read by EF Core. The concurrency token can be managed natively by some databases. The rowversion type shown below is a SQL Server-specific feature; the details on setting up an automatically-updating concurrency token differ across databases, and some databases don&#8217;t support these at all (e.g. SQLite). // Data Annotations public class Person { public int PersonId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } [Timestamp] public byte[] Version { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.Version) .IsRowVersion(); } // UPDATE [People] SET [FirstName] = @p0 // WHERE [PersonId] = @p1 AND [Version] = @p2; using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); var person = await context.People.SingleAsync(b =&gt; string.Equals(b.FirstName, &quot;John&quot;)); person.FirstName = &quot;Paul&quot;; await context.SaveChangesAsync(); The concurrency token can also be managed in application code, rather than have the database manage it. // Data Annotations public class Person { public int PersonId { get; set; } public string FirstName { get; set; } [ConcurrencyCheck] public Guid Version { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.Version) .IsConcurrencyToken(); } // UPDATE [People] SET [FirstName] = @p0, [Version] = @p1 // WHERE [PersonId] = @p2 AND [Version] = @p3; var person = await context.People.SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); person.FirstName = &quot;Paul&quot;; person.Version = Guid.NewGuid(); // assign it in application whenever persisting changes await context.SaveChangesAsync(); 7. Logging, events, and diagnostics Entity Framework Core (EF Core) contains several mechanisms for generating logs, responding to events, and obtaining diagnostics. Entity Framework Core (EF Core) fully integrates with Microsoft.Extensions.Logging. // simple logging protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =&gt; optionsBuilder.LogTo(Console.WriteLine); // logging to console // .LogTo(message =&gt; Debug.WriteLine(message)); // logging to debug window // .LogTo(new StreamWriter(&quot;log.txt&quot;, append: true).WriteLine); // logging to file // .EnableSensitiveDataLogging(); // logging data values // .EnableDetailedErrors(); // logging more detailed errors. 8. Performance diagnosis Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core, which can be broken down into the following broad categories: Premature optimization is the root of all evil - Donald Knuth. Pure database performance. With relational database, EF translates the application&#8217;s LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently. The right index in the right place can make a world of difference in SQL performance, or rewriting the LINQ query may make EF generate a better SQL query. Network data transfer and roundtrips. As with any networking system, it&#8217;s important to limit the amount of data going back and forth on the wire. Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between the application and the database. EF runtime overhead. Finally, EF itself adds some runtime overhead to database operations: compile the queries from LINQ to SQL (although that should normally be done only once) change tracking adds some overhead (but can be disabled), etc. Cache. To maximize performance, especially for scalable apps, minimize database access through caching, as databases are harder to scale than application servers. 8.1. Identifying slow database commands via logging If a certain query is taking too much time (e.g. because an index is missing), this can be seen discovered by inspecting command execution logs and observing how long they actually take. builder.Logging.AddFilter(&quot;Microsoft.EntityFrameworkCore.Database.Command&quot;, LogLevel.Information); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (99ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] (1) SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version] FROM [People] AS [p] WHERE [p].[FirstName] = N&#39;John&#39; 1 The above command took 99 milliseconds. It&#8217;s recommended to only keep logging on for a short interval of time to gather data - while carefully monitoring an application - or to capture logging data on a pre-production system. Databases typically come with their own tracing and performance analysis tools, which usually provide much richer, database-specific information beyond simple execution times; the actual setup, capabilities and usage vary considerably across databases. 8.2. Correlating database commands to LINQ queries One problem with command execution logging is that it&#8217;s sometimes difficult to correlate SQL queries and LINQ queries: the SQL commands executed by EF can look very different from the LINQ queries from which they were generated. var person = await context.People .TagWith(&quot;This is my spatial query!&quot;) (1) .SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (111ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] -- This is my spatial query! (1) SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version] FROM [People] AS [p] WHERE [p].[FirstName] = N&#39;John&#39; 1 It&#8217;s often worth tagging the major queries of an application to make the command execution logs more immediately readable. 8.3. Inspecting query execution plans To optimize slow queries, analyze their execution plans—database-generated blueprints showing the steps and costs involved in query execution. Databases sometimes generate different query plans depending on actual data in the database. For example, if a table contains only a few rows, a database may choose not to use an index on that table, but to perform a full table scan instead. If analyzing query plans on a test database, always make sure it contains data that is similar to the production system. 9. Dapper Dapper is an open-source micro object-relational mapping (ORM) library for .NET applications, which uses the ADO.NET data providers to work with any existing database technology that supports ADO.NET. [6] dotnet add package Dapper Dapper supports a variety of database providers, including the popular Microsoft SQL Server, Oracle, MySQL, MariaDB, PostgreSQL, SQLite, etc. dotnet add package Microsoft.Data.SqlClient # SQL Server dotnet add package System.Data.SQLite.Core # SQLite IDbConnection connection = ... // 1. Scalar Query (Single Value): var blogCount = await connection.ExecuteScalarAsync&lt;int&gt;(&quot;SELECT COUNT(*) FROM Blogs&quot;); // 2. Row Query (Single Row): var firstBlog = await connection.QuerySingleOrDefaultAsync&lt;Blog&gt;(&quot;SELECT * FROM Blogs ORDER BY Id ASC&quot;); // 3. Multi-Result Query (Multiple Rows): var allBlogs = await connection.QueryAsync&lt;Blog&gt;(&quot;SELECT * FROM Blogs&quot;); // 4. Projection (Selecting Specific Columns): var blogNamesAndUrls = await connection.QueryAsync( &quot;SELECT Name, Url FROM Blogs&quot;, (string name, string url) =&gt; new { Name = name, Url = url }); // Mapping to anonymous type //Or use anonymous type directly var blogNamesAndUrls2 = await connection.QueryAsync( &quot;SELECT Name, Url FROM Blogs&quot;, (dynamic item) =&gt; new { Name = item.Name, Url = item.Url }); // Mapping to anonymous type // 5. Parameterized Query (Preventing SQL Injection): var blogsStartingWithB = await connection.QueryAsync&lt;Blog&gt;( &quot;SELECT * FROM Blogs WHERE Name LIKE @NameStart&quot;, new { NameStart = &quot;B%&quot; }); // named parameter // 6. Dynamic Parameter Query: var parameters = new DynamicParameters(); string sql = &quot;SELECT * FROM Blogs WHERE 1=1 &quot;; // Start with a true condition if (!string.IsNullOrEmpty(&quot;Blog&quot;)) // Example condition { sql += &quot;AND Name LIKE @NamePart &quot;; parameters.Add(&quot;@NamePart&quot;, &quot;%&quot; + &quot;Blog&quot; + &quot;%&quot;); } var dynamicBlogs = await connection.QueryAsync&lt;Blog&gt;(sql, parameters); // Using IN clause with Dynamic Parameters var blogIds = new List&lt;int&gt; { 1, 2, 5 }; // Transform the list of IDs into a format suitable for the IN clause var inClauseParams = new DynamicParameters(); for (var i = 0; i &lt; blogIds.Count; i++) { inClauseParams.Add($&quot;@Id{i}&quot;, blogIds[i]); } var inClauseSql = $&quot;SELECT * FROM Blogs WHERE Id IN ({string.Join(&quot;,&quot;, inClauseParams.ParameterNames)})&quot;; var blogsInList = await connection.QueryAsync&lt;Blog&gt;(inClauseSql, inClauseParams); // 7. Insert, Update, Delete (using parameters): var newBlogId = await connection.ExecuteScalarAsync&lt;int&gt;( &quot;INSERT INTO Blogs (Name, Url) VALUES (@Name, @Url); SELECT SCOPE_IDENTITY();&quot;, new { Name = &quot;Another Blog&quot;, Url = &quot;http://another.com&quot; }); var updatedRows = await connection.ExecuteAsync( &quot;UPDATE Blogs SET Url = @NewUrl WHERE Id = @Id&quot;, new { Id = newBlogId, NewUrl = &quot;http://updated.com&quot; }); var deletedRows = await connection.ExecuteAsync(&quot;DELETE FROM Blogs WHERE Id = @Id&quot;, new { Id = newBlogId }); References [1] https://learn.microsoft.com/en-us/ef/core/ [2] https://learn.microsoft.com/en-us/ef/core/get-started/overview/install [3] https://learn.microsoft.com/en-us/ef/core/what-is-new/nuget-packages [4] https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-filtered-indexes [5] https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-indexes-with-included-columns [6] https://www.learndapper.com/" />
<meta property="og:description" content="Entity Framework (EF) Core is a lightweight, extensible, open source and cross-platform version of the popular Entity Framework data access technology, which can serve as an object-relational mapper (O/RM). [1] With EF, data access is performed using a model, which is made up of entity classes and a context object that represents a session to query and save data with the database. EF supports the following model development approaches: Generate a model from an existing database. Hand-code a model to match the database. Once a model is created, use EF Migrations to create a database from the model, which allow evolving the database as the model changes. Instances of the entity classes are retrieved from the database using Language Integrated Query (LINQ). Data is created, deleted, and modified in the database using instances of the entity classes. 1. Installing Entity Framework Core 2. DbContext 2.1. Lifetime, Configuration, and Initialization 2.2. DbContext Pooling 2.3. Connection Pooling 3. Model 3.1. Entity Types 3.2. Entity Properties 3.3. Keys 3.4. Generated Values 3.5. Shadow and Indexer Properties 3.6. Relationships 3.6.1. Foreign and Principal keys 3.6.2. Navigations 3.7. Indexes 3.8. Check Constraints 4. Schemas 4.1. Migrations 4.1.1. Managing Migrations 4.1.2. Applying Migrations 5. Querying 5.1. Tracking vs. no-tracking 5.2. Pagination 5.3. Indexes 5.4. Projections 5.5. SQL queries 6. Saving 6.1. SaveChanges, ExecuteUpdate and ExecuteDelete 6.2. Transactions 6.3. Optimistic concurrency 7. Logging, events, and diagnostics 8. Performance diagnosis 8.1. Identifying slow database commands via logging 8.2. Correlating database commands to LINQ queries 8.3. Inspecting query execution plans 9. Dapper References 1. Installing Entity Framework Core Entity Framework Core (EF Core) is distributed as NuGet packages, with the necessary packages determined by the database system (SQL Server, SQLite, etc.) and required EF Core features. [2][3] Make sure to install the same version of all EF Core packages shipped by Microsoft. For example, if version 5.0.3 of Microsoft.EntityFrameworkCore.SqlServer is installed, then all other Microsoft.EntityFrameworkCore.* packages must also be at 5.0.3. Use of tooling for EF Core migrations and reverse engineering (scaffolding) from an existing database requires installation of the appropriate tooling package: Always use the version of the tools package that matches the major version of the runtime packages. dotnet-ef for cross-platform command line tooling # dotnet ef must be installed as a global or local tool dotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design # dotnet ef can also be used as a local tool dotnet new tool-manifest dotnet tool install dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Microsoft.EntityFrameworkCore.Tasks for MSBuild tasks allowing build-time integration. Microsoft.EntityFrameworkCore.Tools for PowerShell tooling that works in the Visual Studio Package Manager Console 2. DbContext A DbContext is a combination of the Unit Of Work and Repository patterns that represents a session with the database and can be used to query and save instances of entities. A DbContext instance, designed for a single unit-of-work, has a typically short lifespan, beginning with its creation and ending with its disposal. A typical unit-of-work when using Entity Framework Core (EF Core) involves: creating a DbContext instance tracking entities that returned from a query or added or attached to the context making changes to those tracked entities as needed to implement the business rule calling SaveChanges or SaveChangesAsync to persist the changes to the database. disposing the DbContext instance. A DbContext is not thread-safe and doesn&#8217;t support parallel operations. Don&#8217;t share contexts between threads. Make sure to await all async calls before continuing to use the context instance. Use separate DbContext instances for concurrent operations Any code that explicitly executes multiple threads in parallel should ensure that DbContext instances aren&#8217;t ever accessed concurrently. 2.1. Lifetime, Configuration, and Initialization Each DbContext instance must be configured to use one and only one database provider using a specific Use* call. public class ApplicationDbContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { // use the SQL Server database provider optionsBuilder.UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;); } } Other DbContext configuration can be chained either before or after (it makes no difference which) the Use* call. builder.Services.AddDbContext&lt;ApplicationDbContext&gt;( options =&gt; options .EnableSensitiveDataLogging() .UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) ); EF Core can be integrated into applications using dependency injection, typically via the AddDbContext method. The AddDbContext extension method registers DbContext types with a scoped lifetime by default. In many web applications, each HTTP request corresponds to a single unit-of-work. var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;) ?? throw new InvalidOperationException(&quot;Connection string &#39;DefaultConnection&#39; not found.&quot;); builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(connectionString)); // builder.Services.AddDbContext&lt;ApplicationDbContext&gt;( // options =&gt; options.UseSqlServer(connectionString), // contextLifetime: ServiceLifetime.Scoped, // optionsLifetime: ServiceLifetime.Scoped); The ApplicationDbContext class must expose a public constructor with a DbContextOptions&lt;ApplicationDbContext&gt; parameter. public class ApplicationDbContext : DbContext { public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) { } } DbContext can be created with new, configured either by overriding OnConfiguring or by passing options to the constructor. public class ApplicationDbContext : DbContext { private readonly string? _connectionString; public ApplicationDbContext() : this( connectionString: @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) { } public ApplicationDbContext(string connectionString) =&gt; _connectionString = connectionString; public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) { } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { if (_connectionString is not null) optionsBuilder.UseSqlServer(_connectionString); } } using var context = new ApplicationDbContext(); using var context = new ApplicationDbContext( connectionString: @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;); var contextOptions = new DbContextOptionsBuilder&lt;ApplicationDbContext&gt;() .UseSqlServer(@&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) .Options; using var context = new ApplicationDbContext(contextOptions); In applications where dependency injection doesn&#8217;t provide a suitable DbContext lifetime or multiple units-of-work are needed within a scope, AddDbContextFactory can register a factory for creating individual DbContext instances. builder.Services.AddDbContextFactory&lt;ApplicationDbContext&gt;( options =&gt; options.UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;)); public sealed class MyService(IDbContextFactory&lt;ApplicationDbContext&gt; contextFactory) { public async Task DoWorkAsync() { var tasks = Enumerable.Range(1, 10).Select(_ =&gt; { using var context = contextFactory.CreateDbContext(); // ... return Task.CompletedTask; }); await Task.WhenAll(tasks); } } 2.2. DbContext Pooling While generally lightweight, creating and disposing DbContext instances can introduce overhead in high-performance scenarios, which EF Core mitigates through context pooling, reusing instances from an internal pool to minimize setup costs at program startup, rather than continuously. Note that context pooling is orthogonal to database connection pooling, which is managed at a lower level in the database driver. To enable context pooling, simply replace AddDbContext with AddDbContextPool: builder.Services.AddDbContextPool&lt;ApplicationDbContext&gt;( options =&gt; options.UseSqlServer( @&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;), poolSize: 1024); The poolSize parameter of AddDbContextPool sets the maximum number of instances retained by the pool (defaults to 1024). Once poolSize is exceeded, new context instances are not cached and EF falls back to the non-pooling behavior of creating instances on demand. To use context pooling without dependency injection, initialize a PooledDbContextFactory and request context instances from it: var options = new DbContextOptionsBuilder&lt;PooledBloggingContext&gt;() .UseSqlServer(@&quot;Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) .Options; var factory = new PooledDbContextFactory&lt;PooledBloggingContext&gt;(options); using var context = factory.CreateDbContext(); var allPosts = await context.Posts.ToListAsync(); 2.3. Connection Pooling With most databases, a long-lived connection is required for performing database operations, and such connections can be expensive to open and close. EF Core relies on the underlying database driver (e.g., ADO.NET) for connection pooling, a client-side mechanism that reuses database connections to reduce the overhead of opening and closing connections repeatedly. While generally enabled by default and configurable at the driver level (e.g., via connection string), connection pooling is separate from EF Core&#8217;s context pooling, which optimizes DbContext instance reuse. EF Core typically opens and closes connections around each operation, returning them to the pool quickly. 3. Model EF Core uses a metadata model to describe how the application&#8217;s entity types are mapped to the underlying database. EF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API. The model is built using a set of conventions - heuristics that look for common patterns. The model can then be customized to override the configuration performed by conventions using mapping attributes (a.k.a., data annotations) and/or calls to the ModelBuilder methods (a.k.a., fluent API) in OnModelCreating. Fluent API configuration has the highest precedence and will override conventions and data annotations. internal sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Url) .IsRequired(); } } public class Blog { public int BlogId { get; set; } public string? Url { get; set; } } Data annotations will override conventions, but will be overridden by Fluent API configuration. internal sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } } [Table(&quot;Blogs&quot;)] public class Blog { public int BlogId { get; set; } [Required] public string? Url { get; set; } } EF Core model building conventions are classes that contain logic that is triggered based on changes being made to the model as it is being built. EF Core includes many model building conventions that are enabled by default, which can be found in the list of classes that implement the IConvention interface. Applications can remove or replace any of these conventions, as well as add new custom conventions that apply configuration for patterns that are not recognized by EF out of the box. internal sealed class BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : DbContext(options) { protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder) { configurationBuilder.Conventions.Remove(typeof(ForeignKeyIndexConvention)); } } While most configuration is data store-agnostic, providers can offer store-specific configurations and ignore unsupported ones. The model builder debug view can be accessed in the debugger or directly from code. Console.WriteLine(context.Model.ToDebugString()); Model: EntityType: Blog Properties: BlogId (int) Required PK AfterSave:Throw ValueGenerated.OnAdd Url (string) Required Keys: BlogId PK A DbSet included in a DbContext registers its type as an entity in EF Core&#8217;s model, enabling EF Core to read/write instances to/from the database and, for relational databases, create tables via migrations. 3.1. Entity Types A model includes entities through DbSet properties exposed on the context, specified in the OnModelCreating, and any types that are found by recursively exploring the navigation properties of other discovered entity types. internal sealed class MyContext : DbContext { // exposed in a DbSet property public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { // explicitly specified in OnModelCreating modelBuilder.Entity&lt;AuditEntry&gt;(); } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } // discovered via the Blog.Posts navigation property. public List&lt;Post&gt; Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public Blog Blog { get; set; } } public class AuditEntry { public int AuditEntryId { get; set; } public string Username { get; set; } public string Action { get; set; } } To exclude types from the model: // Data Annotations [NotMapped] public class BlogMetadata { public DateTime LoadedFromDatabase { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Ignore&lt;BlogMetadata&gt;(); } To exclude from migrations: protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;IdentityUser&gt;() .ToTable(&quot;AspNetUsers&quot;, t =&gt; t.ExcludeFromMigrations()); } By convention, each entity type will be set up to map to a database table with the same name as the DbSet property that exposes the entity. If no DbSet exists for the given entity, the class name is used. // Data Annotations [Table(&quot;blogs&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .ToTable(&quot;blogs&quot;); } When using a relational database, tables are by convention created in the database&#8217;s default schema. // Data Annotations [Table(&quot;blogs&quot;, Schema = &quot;blogging&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .ToTable(&quot;blogs&quot;, schema: &quot;blogging&quot;); } // define the default schema at the model level protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.HasDefaultSchema(&quot;blogging&quot;); } Entity types can be mapped to database views using the Fluent API. modelBuilder.Entity&lt;Blog&gt;() .ToView(&quot;blogsView&quot;, schema: &quot;blogging&quot;); It&#8217;s possible to map an entity type to a parameterless table-valued function (TVF) instead of a table in the database. modelBuilder.Entity&lt;BlogWithMultiplePosts&gt;().HasNoKey().ToFunction(&quot;BlogsWithMultiplePosts&quot;); An arbitrary text comment can be set on the database table to document the schema in the database. // Data Annotations [Comment(&quot;Blogs managed on the website&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;().ToTable( tableBuilder =&gt; tableBuilder.HasComment(&quot;Blogs managed on the website&quot;)); } Shared-type entity types (those using the same CLR type) require a unique name for configuration and usage, necessitating a Set call for the corresponding DbSet property. internal class MyContext : DbContext { public DbSet&lt;Dictionary&lt;string, object&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;string, object&gt;&gt;(&quot;Blog&quot;); protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.SharedTypeEntity&lt;Dictionary&lt;string, object&gt;&gt;( &quot;Blog&quot;, bb =&gt; { bb.Property&lt;int&gt;(&quot;BlogId&quot;); bb.Property&lt;string&gt;(&quot;Url&quot;); bb.Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); }); } } 3.2. Entity Properties Each entity type in a model has properties that EF Core reads and writes from the database; in relational databases, these properties map to table columns. By convention, all public properties with a getter and a setter will be included in the model. Specific properties can be excluded as follows: // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [NotMapped] public DateTime LoadedFromDatabase { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Ignore(b =&gt; b.LoadedFromDatabase); } By convention, when using a relational database, entity properties are mapped to table columns having the same name as the property. // Data Annotations public class Blog { [Column(&quot;blog_id&quot;)] public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.BlogId) .HasColumnName(&quot;blog_id&quot;); } When using a relational database, the database provider selects a data type based on the .NET type of the property. // Data Annotations public class Blog { public int BlogId { get; set; } [Column(TypeName = &quot;varchar(200)&quot;)] public string Url { get; set; } [Column(TypeName = &quot;decimal(5, 2)&quot;)] public decimal Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;( eb =&gt; { eb.Property(b =&gt; b.Url).HasColumnType(&quot;varchar(200)&quot;); eb.Property(b =&gt; b.Rating).HasColumnType(&quot;decimal(5, 2)&quot;); }); } Configuring a maximum length provides a hint to the database provider about the appropriate column data type to choose for a given array data type property, such as string and byte[]. // Data Annotations public class Blog { public int BlogId { get; set; } [MaxLength(500)] public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Url) .HasMaxLength(500); } Some relational data types support the precision and scale facets; these control what values can be stored, and how much storage is needed for the column. // Data Annotations public class Blog { public int BlogId { get; set; } [Precision(14, 2)] public decimal Score { get; set; } [Precision(3)] public DateTime LastUpdated { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Score) .HasPrecision(14, 2); modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.LastUpdated) .HasPrecision(3); } Text properties are configured as Unicode by default. // Data Annotations public class Book { public int Id { get; set; } public string Title { get; set; } [Unicode(false)] [MaxLength(22)] public string Isbn { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Book&gt;() .Property(b =&gt; b.Isbn) .IsUnicode(false); } When mapping to a relational database schema, required properties are created as non-nullable columns, and optional properties are created as nullable columns. A property is considered optional if it is valid for it to contain null. If null is not a valid value to be assigned to a property then it is considered to be a required property. By convention, a property whose .NET type can contain null will be configured as optional, whereas properties whose .NET type cannot contain null will be configured as required. If nullable reference types are disabled, all properties with .NET reference types are configured as optional by convention (for example, string). // Without NRT public class CustomerWithoutNullableReferenceTypes { public int Id { get; set; } [Required] // Data annotations needed to configure as required public string FirstName { get; set; } [Required] // Data annotations needed to configure as required public string LastName { get; set; } public string MiddleName { get; set; } // Optional by convention } // Without NRT with Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;CustomerWithoutNullableReferenceTypes&gt;(c =&gt; { c.Property(c =&gt; c.FirstName).IsRequired(); c.Property(c =&gt; c.LastName).IsRequired(); }); } If nullable reference types are enabled, properties will be configured based on the C# nullability of their .NET type: string? will be configured as optional, but string will be configured as required. // With NRT public class Customer { public int Id { get; set; } public string FirstName { get; set; } // Required by convention public string LastName { get; set; } // Required by convention public string? MiddleName { get; set; } // Optional by convention // Note the following use of constructor binding, which avoids compiled warnings // for uninitialized non-nullable properties. public Customer(string firstName, string lastName, string? middleName = null) { FirstName = firstName; LastName = lastName; MiddleName = middleName; } } A collation can be defined on text columns, determining how they are compared and ordered. // column level modelBuilder.Entity&lt;Customer&gt;().Property(c =&gt; c.Name) .UseCollation(&quot;SQL_Latin1_General_CP1_CI_AS&quot;); // database level modelBuilder.UseCollation(&quot;SQL_Latin1_General_CP1_CI_AS&quot;); 3.3. Keys A key (primary key or alternate key) serves as a unique identifier for each entity instance. By convention, a property named Id or &lt;type name&gt;Id will be configured as the primary key of an entity. internal class Car { public string Id { get; set; } public string Make { get; set; } public string Model { get; set; } } internal class Truck { public string TruckId { get; set; } public string Make { get; set; } public string Model { get; set; } } An entity&#8217;s primary key can also be explicitly configured using a single property or a composite key (multiple properties). // Data Annotations internal class Car { [Key] public string LicensePlate { get; set; } public string Make { get; set; } public string Model { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Car&gt;() .HasKey(c =&gt; c.LicensePlate); } // Data Annotations [PrimaryKey(nameof(State), nameof(LicensePlate))] internal class Car { public string State { get; set; } public string LicensePlate { get; set; } public string Make { get; set; } public string Model { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Car&gt;() .HasKey(c =&gt; new { c.State, c.LicensePlate }); } By convention, on relational databases primary keys are created with the name PK_&lt;type name&gt;. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasKey(b =&gt; b.BlogId) .HasName(&quot;PrimaryKey_BlogId&quot;); } An alternate key serves as an alternate unique identifier for each entity instance in addition to the primary key; it can be used as the target of a relationship. When using a relational database this maps to the concept of a unique index/constraint on the alternate key column(s) and one or more foreign key constraints that reference the column(s). For simple uniqueness constraints, use a unique index; alternate keys in EF Core are read-only and can also serve as foreign key targets. Alternate keys are usually created automatically by EF Core when a non-primary key property is used as the target of a relationship, so manual configuration is typically unnecessary. By convention, the index and constraint that are introduced for an alternate key will be named AK_&lt;type name&gt;_&lt;property name&gt; (for composite alternate keys &lt;property name&gt; becomes an underscore separated list of property names). 3.4. Generated Values Database columns can have their values generated in various ways: primary key columns are frequently auto-incrementing integers, other columns have default or computed values, etc. On relational databases, a column can be configured with a default value; if a row is inserted without a value for that column, the default value will be used. // a default value protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Rating) .HasDefaultValue(3); } // a SQL fragment protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Created) .HasDefaultValueSql(&quot;getdate()&quot;); } On most relational databases, a column can be configured to have its value computed in the database, typically with an expression referring to other columns: // a virtual computed column modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.DisplayName) .HasComputedColumnSql(&quot;[LastName] + &#39;, &#39; + [FirstName]&quot;); // // a physical computed column modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.NameLength) .HasComputedColumnSql(&quot;LEN([LastName]) + LEN([FirstName])&quot;, stored: true); By convention, non-composite primary keys of type short, int, long, or Guid are set up to have values generated for inserted entities if a value isn&#8217;t provided by the application. A property can be explicitly configured to have its value generated on add or update: // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public DateTime Inserted { get; set; } } // Fluent API // protected override void OnModelCreating(ModelBuilder modelBuilder) // { // modelBuilder.Entity&lt;Blog&gt;() // .Property(b =&gt; b.Inserted) // .ValueGeneratedOnAdd(); // } // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [DatabaseGenerated(DatabaseGeneratedOption.Computed)] public DateTime LastUpdated { get; set; } } // Fluent API // protected override void OnModelCreating(ModelBuilder modelBuilder) // { // modelBuilder.Entity&lt;Blog&gt;() // .Property(b =&gt; b.LastUpdated) // .ValueGeneratedOnAddOrUpdate(); // } Unlike with default values or computed columns, how the values are to be generated depends on the database provider being used. Database providers may automatically set up value generation for some property types, but others may require to manually set up how the value is generated. For example, on SQL Server, when a GUID property is configured as a primary key, the provider automatically performs value generation client-side, using an algorithm to generate optimal sequential GUID values. Similarly, byte[] properties that are configured as generated on add or update and marked as concurrency tokens are set up with the rowversion data type, so that values are automatically generated in the database. A common request is to have a database column which contains the date/time for when the row was first inserted (value generated on add), or for when it was last updated (value generated on add or update). Configuring a date/time column to have the creation timestamp of the row is usually a matter of configuring a default value with the appropriate SQL function. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Created) .HasDefaultValueSql(&quot;getdate()&quot;); } Although stored computed columns seem like a good solution for managing last-updated timestamps, databases usually don&#8217;t allow specifying functions such as GETDATE() in a computed column. As an alternative, set up a database trigger to achieve the same effect: CREATE TRIGGER [dbo].[Blogs_UPDATE] ON [dbo].[Blogs] AFTER UPDATE AS BEGIN SET NOCOUNT ON; IF ((SELECT TRIGGER_NESTLEVEL()) &gt; 1) RETURN; UPDATE B SET LastUpdated = GETDATE() FROM dbo.Blogs AS B INNER JOIN INSERTED AS I ON B.BlogId = I.BlogId END To override value generation with an explicit value, simply set the property to any value that is not the CLR default value for that property&#8217;s type (null for string, 0 for int, Guid.Empty for Guid, etc.). var product = new Product { // To override the auto-generated CreatedDate, set it to something other than DateTime.MinValue: CreatedDate = DateTime.Now.AddYears(-10) }; await context.AddAsync(product); await context.SaveChangesAsync(); public class Product { public Guid Id { get; set; } // Will be auto-generated by default (often) public string? Name { get; set; } // modelBuilder.Entity&lt;Product&gt;().Property(p =&gt; p.CreatedDate).HasDefaultValueSql(&quot;getdate()&quot;); public DateTime CreatedDate { get; set; } // Will be auto-generated (often) } To disable value generation that has been set up by convention. // Data Annotations public class Blog { [DatabaseGenerated(DatabaseGeneratedOption.None)] public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.BlogId) .ValueGeneratedNever(); } 3.5. Shadow and Indexer Properties Shadow properties are properties that aren&#8217;t defined in .NET entity class but are defined for that entity type in the EF Core model, which are maintained purely in the Change Tracker and are useful when there&#8217;s data in the database that shouldn&#8217;t be exposed on the mapped entity types. Indexer properties are entity type properties, which are backed by an indexer in .NET entity class to add additional properties to the entity type without changing the CLR class. Shadow properties are most often used for foreign key properties, where they are added to the model by convention when no foreign key property has been found by convention or configured explicitly. The relationship is represented by navigation properties, but in the database it is enforced by a foreign key constraint, and the value for the foreign key column is stored in the corresponding shadow property. The property will be named &lt;navigation property name&gt;&lt;principal key property name&gt; (the navigation on the dependent entity, which points to the principal entity, is used for the naming). If the principal key property name starts with the name of the navigation property, then the name will just be &lt;principal key property name&gt;. If there is no navigation property on the dependent entity, then the principal type name concatenated with the primary or alternate key property name is used in its place &lt;principal type name&gt;&lt;principal key property name&gt;. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public DbSet&lt;Post&gt; Posts { get; set; } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List&lt;Post&gt; Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } // Since there is no CLR property which holds the foreign // key for this relationship, a shadow property is created. public Blog Blog { get; set; } } var post = new Post { Blog = new() }; await context.AddAsync(post); await context.SaveChangesAsync(); var blogId = (int)context.Entry(post).Property(nameof(Blog.BlogId)).CurrentValue!; Debug.Assert(post.Blog.BlogId == blogId); Shadow properties can be configured using the Fluent API to call the string overload of Property&lt;TProperty&gt;(String) to chain any of the configuration calls for other properties. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } } Shadow property values can be referenced in LINQ queries via the EF.Property static method or obtained and changed through the ChangeTracker API. var blogs = context.Blogs .OrderBy(b =&gt; EF.Property&lt;DateTime&gt;(b, &quot;LastUpdated&quot;)); context.Entry(myBlog).Property(&quot;LastUpdated&quot;).CurrentValue = DateTime.Now; Indexer properties can be configured using the Fluent API to call the method IndexerProperty to chain any of the configuration calls for other properties. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;().IndexerProperty&lt;DateTime&gt;(&quot;LastUpdated&quot;); } } public class Blog { private readonly Dictionary&lt;string, object&gt; _data = new Dictionary&lt;string, object&gt;(); public int BlogId { get; set; } public object this[string key] { get =&gt; _data[key]; set =&gt; _data[key] = value; } } Indexer properties can be referenced in LINQ queries via the EF.Property static method or by using the CLR indexer property. var blog = new Blog(); blog[&quot;LastUpdated&quot;] = DateTime.Now; await context.AddAsync(blog); await context.SaveChangesAsync(); var lastUpdated = await context.Blogs .Select(b =&gt; EF.Property&lt;DateTime&gt;(b, &quot;LastUpdated&quot;)) .FirstAsync(); Console.WriteLine(lastUpdated); Entity types that contain only indexer properties are known as property bag entity types. internal class MyContext : DbContext { public DbSet&lt;Dictionary&lt;string, object&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;string, object&gt;&gt;(&quot;Blog&quot;); protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.SharedTypeEntity&lt;Dictionary&lt;string, object&gt;&gt;( &quot;Blog&quot;, bb =&gt; { bb.Property&lt;int&gt;(&quot;BlogId&quot;); bb.Property&lt;string&gt;(&quot;Url&quot;); bb.Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); }); } } 3.6. Relationships A relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model. A one-to-many relationship is used when a single entity is associated with any number of other entities. CREATE TABLE [Blogs] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Blogs] PRIMARY KEY ([Id]) ); CREATE TABLE [Posts] ( [Id] int NOT NULL IDENTITY, [BlogId] int NOT NULL, CONSTRAINT [PK_Posts] PRIMARY KEY ([Id]), CONSTRAINT [FK_Posts_Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [Blogs] ([Id]) ON DELETE CASCADE ); CREATE INDEX [IX_Posts_BlogId] ON [Posts] ([BlogId]); // Principal (parent) public class Blog { public int Id { get; set; } (1) public ICollection&lt;Post&gt; Posts { get; } = []; // Collection navigation containing dependents (3) } // Dependent (child) public class Post { public int Id { get; set; } public int BlogId { get; set; } // Required foreign key property (2) public Blog Blog { get; set; } = null!; // Required reference navigation to principal (4) // public int? BlogId { get; set; } // Optional foreign key property // public Blog? Blog { get; set; } // Optional reference navigation to principal } A one-to-many relationship is made up from: 1 One or more primary or alternate key properties on the principal entity; that is the &quot;one&quot; end of the relationship. 2 One or more foreign key properties on the dependent entity; that is the &quot;many&quot; end of the relationship. 3 Optionally, a collection navigation on the principal entity referencing the dependent entities. 4 Optionally, a reference navigation on the dependent entity referencing the principal entity. For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasForeignKey(e =&gt; e.BlogId) .IsRequired(); // .IsRequired(false); } As with all relationships, it is exactly equivalent to start with dependent entity type (Post) and use HasOne followed by WithMany. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasOne(e =&gt; e.Blog) .WithMany(e =&gt; e.Posts) .HasForeignKey(e =&gt; e.BlogId) .IsRequired(); // .IsRequired(false); } A one-to-one relationship is used when one entity is associated with at most one other entity. CREATE TABLE [Blogs] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Blogs] PRIMARY KEY ([Id]) ); CREATE TABLE [BlogHeader] ( [Id] int NOT NULL IDENTITY, [BlogId] int NOT NULL, CONSTRAINT [PK_BlogHeader] PRIMARY KEY ([Id]), CONSTRAINT [FK_BlogHeader_Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [Blogs] ([Id]) ON DELETE CASCADE ); CREATE UNIQUE INDEX [IX_BlogHeader_BlogId] ON [BlogHeader] ([BlogId]); -- UNIQUE INDEX // Principal (parent) public class Blog { public int Id { get; set; } (1) public BlogHeader? Header { get; set; } // Reference navigation to dependent (3) } // Dependent (child) public class BlogHeader { public int Id { get; set; } public int BlogId { get; set; } // Required foreign key property (2) public Blog Blog { get; set; } = null!; // Required reference navigation to principal (4) // public int? BlogId { get; set; } // Optional foreign key property // public Blog? Blog { get; set; } // Optional reference navigation to principal } A one-to-many relationship is made up from: 1 One or more primary or alternate key properties on the principal entity; that is the &quot;one&quot; end of the relationship. 2 One or more foreign key properties on the dependent entity; that is the &quot;many&quot; end of the relationship. 3 Optionally, a reference navigation on the principal entity referencing the dependent entities. 4 Optionally, a reference navigation on the dependent entity referencing the principal entity. For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasOne(e =&gt; e.Header) .WithOne(e =&gt; e.Blog) .HasForeignKey&lt;BlogHeader&gt;(e =&gt; e.BlogId) .IsRequired(); } As with all relationships, it is exactly equivalent to start with dependent entity type (BlogHeader) instead. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;BlogHeader&gt;() .HasOne(e =&gt; e.Blog) .WithOne(e =&gt; e.Header) .HasForeignKey&lt;BlogHeader&gt;(e =&gt; e.BlogId) .IsRequired(); } A many-to-many relationship is used when any number entities of one entity type is associated with any number of entities of the same or another entity type. A many-to-many relationship requires a join entity (and table) to link the two sides, as a single foreign key is insufficient. CREATE TABLE [Posts] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Posts] PRIMARY KEY ([Id]) ); CREATE TABLE [Tag] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Tag] PRIMARY KEY ([Id]) ); CREATE TABLE [PostTag] ( [PostsId] int NOT NULL, [TagsId] int NOT NULL, CONSTRAINT [PK_PostTag] PRIMARY KEY ([PostsId], [TagsId]), CONSTRAINT [FK_PostTag_Posts_PostsId] FOREIGN KEY ([PostsId]) REFERENCES [Posts] ([Id]) ON DELETE CASCADE, CONSTRAINT [FK_PostTag_Tag_TagsId] FOREIGN KEY ([TagsId]) REFERENCES [Tag] ([Id]) ON DELETE CASCADE ); CREATE INDEX [IX_PostTag_TagsId] ON [PostTag] ([TagsId]); EF Core can hide the join entity type and manage it behind the scenes that allows the navigations of a many-to-many relationship to be used in a natural manner, adding or removing entities from each side as needed. public class Post { public int Id { get; set; } public List&lt;Tag&gt; Tags { get; } = []; } public class Tag { public int Id { get; set; } public List&lt;Post&gt; Posts { get; } = []; } 3.6.1. Foreign and Principal keys One-to-one and one-to-many relationships are defined by a foreign key on the dependent entity referencing the principal key (primary or alternate) of the principal entity. Many-to-many relationships are formed by two one-to-many relationships, each with its own foreign key referencing a principal key. The property or properties that make up foreign key are often discovered by convention, and can also be configured explicitly using either mapping attributes or with HasForeignKey in the model building API. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasForeignKey(e =&gt; e.ContainingBlogId); // lambda expression. // .HasForeignKey(&quot;ContainingBlogId&quot;); // property name // composite foreign key // .HasForeignKey(e =&gt; new { e.ContainingBlogId1, e.ContainingBlogId2 }); // .HasForeignKey(&quot;ContainingBlogId1&quot;, &quot;ContainingBlogId2&quot;); } By convention, foreign keys are constrained to the primary key at the principal end of the relationship. However, an alternate key can be used instead using HasPrincipalKey on the model building API. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasPrincipalKey(e =&gt; e.AlternateId); // lambda expression. // .HasPrincipalKey(&quot;AlternateId&quot;); // property name // composite key // .HasPrincipalKey(e =&gt; new { e.AlternateId1, e.AlternateId2 }); // .HasPrincipalKey(&quot;AlternateId1&quot;, &quot;AlternateId2&quot;); } The order of the properties in the principal and foreign key must match, which is also the order in which the key is defined in the database schema. There is no need to call HasAlternateKey to define the alternate key on the principal entity when HasPrincipalKey is used with properties that are not the primary key properties. In many-to-many relationships, the foreign keys are defined on the join entity type and mapped to foreign key constraints in the join table. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasMany(e =&gt; e.Tags) .WithMany(e =&gt; e.Posts) .UsingEntity( l =&gt; l.HasOne(typeof(Tag)).WithMany().HasConstraintName(&quot;TagForeignKey_Constraint&quot;), r =&gt; r.HasOne(typeof(Post)).WithMany().HasConstraintName(&quot;PostForeignKey_Constraint&quot;)); } 3.6.2. Navigations EF Core relationships are defined by foreign keys. Navigations are layered over foreign keys to provide a natural, object-oriented view for reading and manipulating relationships. By using navigations, applications can work with graphs of entities without being concerned with what is happening to the foreign key values. A navigation from dependent to principal is required if the relationship is required, which in turn means that the foreign key property is non-nullable. Conversely, the navigation is optional if the foreign key is nullable, and the relationship is therefore optional. Reference navigations are simple object references to another entity, which represent the &quot;one&quot; side(s) of one-to-many and one-to-one relationships. Reference navigations must have a setter, although it does not need to be public. Reference navigations should not be automatically initialized to a non-null default value; doing so is equivalent to asserting that an entity exists when it does not. When using C# nullable reference types, reference navigations must be nullable for optional relationships: Reference navigations for required relationships can be nullable or non-nullable. public Blog? TheBlog { get; set; } Collection navigations are instances of a .NET collection type; that is, any type implementing ICollection&lt;T&gt;, which represent the &quot;many&quot; side(s) of one-to-many and many-to-many relationships. Collection navigations do not need to have a setter. It is common to initialize the collection inline, thereby removing the need to ever check if the property is null. public ICollection&lt;Post&gt; ThePosts { get; } = []; Don&#8217;t accidentally create an expression bodied property, such as public ICollection&lt;Post&gt; ThePosts =&gt; [];, which will create a new, empty collection instance each time the property is accessed, and will therefore be useless as a navigation. 3.7. Indexes Indexes are a common concept across many data store to make lookups based on a column (or set of columns) more efficient. // Data Annotations [Index(nameof(Url))] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url); } By convention, an index is created in each property (or set of properties) that are used as a foreign key. A composite index, spanning more than one column, speeds up queries which filter on index&#8217;s columns, but also queries which only filter on the first columns covered by the index. // Data Annotations [Index(nameof(FirstName), nameof(LastName))] public class Person { public int PersonId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }); } By default, indexes aren&#8217;t unique: multiple rows are allowed to have the same value(s) for the index&#8217;s column set. // Data Annotations [Index(nameof(Url), IsUnique = true)] // UNIQUE INDEX public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url) .IsUnique(); // UNIQUE INDEX } In most databases, each column covered by an index can be either ascending or descending. For indexes covering only one column, this typically does not matter: the database can traverse the index in reverse order as needed. However, for composite indexes, the ordering can be crucial for good performance, and can mean the difference between an index getting used by a query or not. In general, the index columns&#39; sort orders should correspond to those specified in the ORDER BY clause of a query. The index sort order is ascending by default. // Data Annotations [Index(nameof(Url), nameof(Rating), AllDescending = true)] // make all columns as descending order public class Blog { public int BlogId { get; set; } public string Url { get; set; } public int Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; new { b.Url, b.Rating }) .IsDescending(); // make all columns as descending order } The index may also be specified the sort order on a column-by-column basis. // Data Annotations [Index(nameof(Url), nameof(Rating), IsDescending = new[] { false, true })] public class Blog { public int BlogId { get; set; } public string Url { get; set; } public int Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; new { b.Url, b.Rating }) .IsDescending(false, true); } To create multiple indexes over the same set of properties, pass a name to the HasIndex, which will be used to identify the index in the EF model, and to distinguish it from other indexes over the same properties. // Fluent API modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }, &quot;IX_Names_Ascending&quot;); modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }, &quot;IX_Names_Descending&quot;) .IsDescending(); // Data Annotations [Index(nameof(FirstName), nameof(LastName), Name = &quot;IX_Names_Ascending&quot;)] [Index(nameof(FirstName), nameof(LastName), Name = &quot;IX_Names_Descending&quot;, AllDescending = true)] public class Person { public int PersonId { get; set; } public string? FirstName { get; set; } public string? LastName { get; set; } } A filtered index is an index that includes a WHERE clause, effectively indexing only a subset of the rows in a table to index only a subset of a column&#8217;s values, reducing the index&#8217;s size and improving both performance and disk space usage. [4] Filtered indexes are not supported by all RDBMS. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url) .HasFilter(&quot;[Url] IS NOT NULL&quot;); } An index with nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns. [5] protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasIndex(p =&gt; p.Url) .IncludeProperties( p =&gt; new { p.Title, p.PublishedOn }); } Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data isn&#8217;t accessed resulting in fewer disk I/O operations. 3.8. Check Constraints Check constraints are a standard database feature that enforces a condition on all table rows; inserts or updates violating the condition will fail. Check constraints are similar to non-null and unique constraints but allow for arbitrary SQL expressions. modelBuilder.Entity&lt;Product&gt;() .ToTable(b =&gt; { b.HasCheckConstraint(&quot;CK_Prices&quot;, &quot;[Price] &gt; [DiscountedPrice]&quot;); b.HasCheckConstraint(&quot;CK_PositivePrice&quot;, &quot;[Price] &gt; 0&quot;); b.HasCheckConstraint(&quot;CK_PositiveDiscountedPrice&quot;, &quot;[DiscountedPrice] &gt;= 0&quot;); }); 4. Schemas EF Core offers two ways to synchronize a model and database schema: Migrations (model as the source of truth, incrementally applying schema changes) and Reverse Engineering (database as the source of truth, scaffolding a model from the existing schema). 4.1. Migrations The migrations feature in EF Core provides a way to incrementally update the database schema to keep it in sync with the application&#8217;s data model while preserving existing data in the database. When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration describing the updates necessary to keep the database schema in sync. EF Core compares the current model against a snapshot of the old model to determine the differences, and generates migration source files; the files can be tracked in the project&#8217;s source control like any other source file. Once a new migration has been generated, it can be applied to a database in various ways. EF Core records all applied migrations in a special history table, allowing it to know which migrations have been applied and which haven&#8217;t. Create and Drop APIs The EnsureCreatedAsync and EnsureDeletedAsync methods provide a lightweight alternative to Migrations for managing the database schema, which are useful in scenarios when the data is transient and can be dropped when the schema changes, such as during development. EnsureCreatedAsync and Migrations don&#8217;t work well together. // Drop the database if it exists await dbContext.Database.EnsureDeletedAsync(); // Create the database if it doesn&#39;t exist dbContext.Database.EnsureCreatedAsync(); // Get the SQL used by EnsureCreatedAsync var sql = dbContext.Database.GenerateCreateScript(); Install the EF Core command-line tools. # globally dotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design # locally dotnet new tool-manifest dotnet tool install dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Set up a .NET generic host for app startup and lifetime management. # create a new project dotnet new console -o getting-started &amp;&amp; cd getting-started/ # install SQLite provider dotnet add package Microsoft.EntityFrameworkCore.Sqlite # install generic host package dotnet add package Microsoft.Extensions.Hosting // Program.cs var builder = Host.CreateApplicationBuilder(args); builder.Services.AddDbContext&lt;BloggingContext&gt;(options =&gt; options.UseSqlite(&quot;Data Source=:memory:&quot;)); // &quot;:memory:&quot; creates in-memory DB var app = builder.Build(); // Create and Drop APIs // using (var scope = app.Services.CreateScope()) // { // using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); // await context.Database.EnsureDeletedAsync(); // await context.Database.EnsureCreatedAsync(); // } sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } } public class Blog { public int Id { get; set; } public string? Name { get; set; } } 4.1.1. Managing Migrations As the model changes, migrations are added and removed as part of normal development, and the migration files are checked into the project&#8217;s source control. dotnet ef migrations add // add a migration dotnet ef migrations add InitialCreate EF Core will create a directory called Migrations in the project, and generate some files. $ tree ./Migrations/ ./Migrations/ ├── 20250213080400_InitialCreate.cs (1) ├── 20250213080400_InitialCreate.Designer.cs (2) └── BloggingContextModelSnapshot.cs (3) 1 The main migrations file that contains the operations necessary to apply the migration (in Up) and to revert it (in Down). 2 The migrations metadata file that contains information used by EF. 3 A snapshot of the current model used to determine what changed when adding the next migration. It&#8217;s a good idea to inspect what exactly EF Core generated - and possibly amend it. dotnet ef migrations list $ dotnet ef migrations list Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (9ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT COUNT(*) FROM &quot;sqlite_master&quot; WHERE &quot;name&quot; = &#39;__EFMigrationsHistory&#39; AND &quot;type&quot; = &#39;table&#39;; 20250213080400_InitialCreate (Pending) dotnet ef migrations remove Avoid removing any migrations which have already been applied to production databases. $ dotnet ef migrations remove Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (10ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT COUNT(*) FROM &quot;sqlite_master&quot; WHERE &quot;name&quot; = &#39;__EFMigrationsHistory&#39; AND &quot;type&quot; = &#39;table&#39;; Removing migration &#39;20250213080400_InitialCreate&#39;. Removing model snapshot. Done. 4.1.2. Applying Migrations The recommended way to deploy migrations to a production database is by generating SQL scripts. SQL scripts can be reviewed for accuracy; this is important since applying schema changes to production databases is a potentially dangerous operation that could involve data loss. In some cases, the scripts can be tuned to fit the specific needs of a production database. SQL scripts can be used in conjunction with a deployment technology, and can even be generated as part of a CI process. SQL scripts can be provided to a DBA, and can be managed and archived separately. # generate a SQL script from a blank database to the latest migration dotnet ef migrations script # generate a SQL script from the given migration to the latest migration. dotnet ef migrations script AddNewTables # generate a SQL script from the specified from migration to the specified to migration dotnet ef migrations script AddNewTables AddAuditTable # generate idempotent migrations dotnet ef migrations script --idempotent The EF command-line tools can be productively used to apply migrations during local development and testing, but are not ideal for managing production databases. The SQL commands are applied directly by the tool, without giving the developer a chance to inspect or modify them, which can be dangerous in a production environment. The .NET SDK and the EF tool must be installed on production servers and requires the project&#8217;s source code. # update database to the latest migration dotnet ef database update # update or roll back database to a given migration dotnet ef database update AddNewTables Migration bundles are single-file executables that can be used to apply migrations to a databaseto ddress some of the shortcomings of the SQL script and command-line tools. Executing SQL scripts requires additional tools. The transaction handling and continue-on-error behavior of these tools are inconsistent and sometimes unexpected, which can leave the database in an undefined state if a failure occurs when applying migrations. Bundles can be generated as part of a CI process and easily executed later as part of the deployment process. Bundles are executable without the .NET SDK, EF Tool, or even the .NET Runtime (if self-contained), and they don&#8217;t require source code. # generate a bundle dotnet ef migrations bundle # generate a self-contained bundle for Linux dotnet ef migrations bundle --self-contained -r linux-x64 The resulting executable is named efbundle by default, which can be used to update the database to the latest migration. $ ./efbundle --help Entity Framework Core Migrations Bundle 9.0.2 Usage: efbundle [arguments] [options] [[--] &lt;arg&gt;...]] Arguments: &lt;MIGRATION&gt; The target migration. If &#39;0&#39;, all migrations will be reverted. Defaults to the last migration. Options: --connection &lt;CONNECTION&gt; The connection string to the database. Defaults to the one specified in AddDbContext or OnConfiguring. --version Show version information -h|--help Show help information -v|--verbose Show verbose output. --no-color Don&#39;t colorize output. --prefix-output Prefix output with level. The migrations can be programmatically applied by calling context.Database.MigrateAsync() for local development and testing. var builder = Host.CreateApplicationBuilder(args); // . . . var app = builder.Build(); using (var scope = app.Services.CreateScope()) { using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); await context.Database.MigrateAsync(); } 5. Querying Entity Framework Core uses Language-Integrated Query (LINQ) to query data from the database. EF Core passes a representation of the LINQ query to the database provider. Database providers in turn translate it to database-specific query language (for example, SQL for a relational database). Queries are always executed against the database even if the entities returned in the result already exist in the context. // SELECT [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] var blogs = await context.Blogs.ToListAsync(); // SELECT TOP(1) [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] // WHERE [b].[Id] = 1 var blog = await context.Blogs.SingleOrDefaultAsync(b =&gt; b.Id == 1); // SELECT [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] // WHERE [b].[Url] IS NOT NULL AND [b].[Url] LIKE N&#39;%dotnet%&#39; var filteredBlogs = await context.Blogs .Where(b =&gt; b.Url != null &amp;&amp; b.Url.Contains(&quot;dotnet&quot;)).ToListAsync(); Tracking behavior controls if Entity Framework Core keeps information about an entity instance in its change tracker. If an entity is tracked, any changes detected in the entity are persisted to the database during SaveChanges. EF Core also fixes up navigation properties between the entities in a tracking query result and the entities that are in the change tracker. By default, queries that return entity types are tracking. If EF Core finds an existing entity, then the same instance is returned, which can potentially use less memory and be faster than a no-tracking query. EF Core doesn&#8217;t overwrite current and original values of the entity&#8217;s properties in the entry with the database values. If the entity isn&#8217;t found in the context, EF Core creates a new entity instance and attaches it to the context. Query results don&#8217;t contain any entity which is added to the context but not yet saved to the database. var blog = await context.Blogs.SingleOrDefaultAsync(b =&gt; b.BlogId == 1); blog.Rating = 5; await context.SaveChangesAsync(); 5.1. Tracking vs. no-tracking No-tracking queries are useful when the results are used in a read-only scenario, which are generally quicker to execute because there&#8217;s no need to set up the change tracking information. If the entities retrieved from the database don&#8217;t need to be updated, then a no-tracking query should be used. An individual query can be set to be no-tracking. var blogs = await context.Blogs .AsNoTracking() .ToListAsync(); A no-tracking query also give results based on what&#8217;s in the database disregarding any local changes or added entities. The default tracking behavior can be changed at the context instance level. context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; var blogs = await context.Blogs.ToListAsync(); To make all the queries no-tracking by default. protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder .UseSqlServer(@&quot;Server=(localdb)\mssqllocaldb;Database=EFQuerying.Tracking&quot;) .UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking); } // You can still add AsTracking to make specific queries tracking. var blogs = await context.Blogs.AsNoTracking().ToListAsync(); 5.2. Pagination Keyset pagination is appropriate for pagination interfaces where the user navigates forwards and backwards, but does not support random access, where the user can jump to any specific page. A common way to implement pagination with databases is to use the Skip and Take LINQ operators (OFFSET and LIMIT in SQL). var posts = await context.Blogs .OrderBy(b =&gt; b.Id) .Skip(20) // page index .Take(10) // page size .ToListAsync(); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (14ms) [Parameters=[@__p_0=&#39;20&#39;, @__p_1=&#39;10&#39;], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT [b].[Id], [b].[Name], [b].[Url] FROM [Blogs] AS [b] ORDER BY [b].[Id] OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY The recommended alternative to offset-based pagination - sometimes called keyset pagination or seek-based pagination - is to simply use a WHERE clause to skip rows, instead of an offset. int lastId = 55; var posts = await context.Blogs .OrderBy(b =&gt; b.Id) .Where(b =&gt; b.Id &gt; lastId) .Take(10) .ToListAsync(); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (136ms) [Parameters=[@__p_1=&#39;10&#39;, @__lastId_0=&#39;55&#39;], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT TOP(@__p_1) [b].[Id], [b].[Name], [b].[Url] FROM [Blogs] AS [b] WHERE [b].[Id] &gt; @__lastId_0 ORDER BY [b].[Id] 5.3. Indexes A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via a database&#8217;s favorite tool. While indexes speed up queries, they also slow down updates since they need to be kept up-to-date. Avoid defining indexes which aren&#8217;t needed, and consider using index filters to limit the index to a subset of the rows. Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don&#8217;t filter on all the index&#8217;s columns - depending on ordering. For example, an index on columns A and B speeds up queries filtering by A and B as well as queries filtering only by A, but it does not speed up queries only filtering over B. If a query filters by an expression over a column (e.g. price / 2), a simple index cannot be used. However, a stored persisted column can be defined for the expression, and create an index over that. Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression. 5.4. Projections For read-only queries with multiple columns, project into anonymous types, but be aware that updates become more complex since EF Core change tracking relies on entities, though partial updates are possible with advanced techniques. // SELECT TOP(2) [p].[FirstName], [p].[LastName] // FROM [People] AS [p] // WHERE [p].[FirstName] = N&#39;John&#39; var p = await context.People .Select(p =&gt; new { p.FirstName, p.LastName }) // projection .SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); 5.5. SQL queries Entity Framework Core allows dropping down to SQL queries when working with a relational database, which are useful if the query can&#8217;t be expressed using LINQ, or if a LINQ query causes EF to generate inefficient SQL. Basic SQL queries // a LINQ query based on a SQL query var blogs = await context.Blogs .FromSql($&quot;SELECT * FROM dbo.Blogs&quot;) .ToListAsync(); // execute a stored procedure var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogs&quot;) .ToListAsync(); // string interpolation var user = &quot;johndoe&quot;; var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogsForUser {user}&quot;) .ToListAsync(); // named parameters var user = new SqlParameter(&quot;user&quot;, &quot;johndoe&quot;); var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogsForUser @filterByUser={user}&quot;) .ToListAsync(); // executing non-querying SQL var rowsModified = context.Database.ExecuteSql($&quot;UPDATE [Blogs] SET [Url] = NULL&quot;); // executing non-querying SQL var tranMode = context.Database.SqlQueryRaw&lt;string&gt;( &quot;SELECT IIF(@@OPTIONS&amp;2 = 0, &#39;Implicit Transaction Off&#39;, &#39;Implicit Transaction On&#39;) AS TranMode&quot;) .ToList() .FirstOrDefault(); // use the underlying ADO.NET connection directly using var connection = context.Database.GetDbConnection(); connection.Open(); using var command = connection.CreateCommand(); command.CommandText = &quot;SELECT IIF(@@OPTIONS&amp;2 = 0, &#39;Implicit Transaction Off&#39;, &#39;Implicit Transaction On&#39;) AS TranMode&quot;; var tranMode = command.ExecuteScalar() as string; 6. Saving Entity Framework Core (EF Core) supports two approaches for persisting data to the database: change tracking with SaveChanges() and direct execution with ExecuteUpdate and ExecuteDelete. 6.1. SaveChanges, ExecuteUpdate and ExecuteDelete EF Core tracks changes maked to data (adding, updating, or deleting) and SaveChanges() turns those changes into the SQL commands needed to update the database. It is the more common and often preferred method for saving data in EF Core. For large-scale bulk updates, SaveChanges() can be less efficient than direct execution methods. // Add a new entity var newProduct = new Product { Name = &quot;New Widget&quot;, Price = 9.99 }; context.Products.Add(newProduct); // Modify an existing entity var existingProduct = context.Products.Find(1); if (existingProduct != null) { existingProduct.Price = 12.99; } // Remove an entity var productToRemove = context.Products.Find(2); if (productToRemove != null) { context.Products.Remove(productToRemove); } // Save all changes context.SaveChanges(); The ExecuteUpdate and ExecuteDelete offer a direct way, bypassing change tracker, to update or delete data using LINQ queries, which is often more efficient for bulk operations or when needing precise control over the SQL. // Update multiple products context.Products .Where(p =&gt; p.Category == &quot;Electronics&quot;) .ExecuteUpdate(setters =&gt; setters.SetProperty(p =&gt; p.Price, 19.99)); // Delete multiple products context.Products .Where(p =&gt; p.Discontinued) .ExecuteDelete(); 6.2. Transactions By default, if the database provider supports transactions, all changes in a single call to SaveChanges are applied in a transaction. While all relational database providers support transactions, other providers types may throw or no-op when transaction APIs are called. The DbContext.Database API can be used to begin, commit, and rollback transactions. using var context = new BloggingContext(); using var transaction = await context.Database.BeginTransactionAsync(); try { context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/dotnet/&quot; }); await context.SaveChangesAsync(); await transaction.CreateSavepointAsync(&quot;BeforeMoreBlogs&quot;); context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/visualstudio/&quot; }); context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/aspnet/&quot; }); await context.SaveChangesAsync(); await transaction.CommitAsync(); } catch (Exception) { // If a failure occurred, we rollback to the savepoint and can continue the transaction await transaction.RollbackToSavepointAsync(&quot;BeforeMoreBlogs&quot;); // TODO: Handle failure, possibly retry inserting blogs } 6.3. Optimistic concurrency EF Core implements optimistic concurrency, which assumes that concurrency conflicts are relatively rare. In contrast to pessimistic approaches - which lock data up-front and only then proceed to modify it - optimistic concurrency takes no locks, but arranges for the data modification to fail on save if the data has changed since it was queried. Optimistic concurrency failure is reported to the application, which deals with it accordingly, possibly by retrying the entire operation on the new data. In EF Core, optimistic concurrency is implemented by configuring a property as a concurrency token. The concurrency token is loaded and tracked when an entity is queried - just like any other property. Then, when an update or delete operation is performed during SaveChanges(), the value of the concurrency token on the database is compared against the original value read by EF Core. The concurrency token can be managed natively by some databases. The rowversion type shown below is a SQL Server-specific feature; the details on setting up an automatically-updating concurrency token differ across databases, and some databases don&#8217;t support these at all (e.g. SQLite). // Data Annotations public class Person { public int PersonId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } [Timestamp] public byte[] Version { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.Version) .IsRowVersion(); } // UPDATE [People] SET [FirstName] = @p0 // WHERE [PersonId] = @p1 AND [Version] = @p2; using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); var person = await context.People.SingleAsync(b =&gt; string.Equals(b.FirstName, &quot;John&quot;)); person.FirstName = &quot;Paul&quot;; await context.SaveChangesAsync(); The concurrency token can also be managed in application code, rather than have the database manage it. // Data Annotations public class Person { public int PersonId { get; set; } public string FirstName { get; set; } [ConcurrencyCheck] public Guid Version { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.Version) .IsConcurrencyToken(); } // UPDATE [People] SET [FirstName] = @p0, [Version] = @p1 // WHERE [PersonId] = @p2 AND [Version] = @p3; var person = await context.People.SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); person.FirstName = &quot;Paul&quot;; person.Version = Guid.NewGuid(); // assign it in application whenever persisting changes await context.SaveChangesAsync(); 7. Logging, events, and diagnostics Entity Framework Core (EF Core) contains several mechanisms for generating logs, responding to events, and obtaining diagnostics. Entity Framework Core (EF Core) fully integrates with Microsoft.Extensions.Logging. // simple logging protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =&gt; optionsBuilder.LogTo(Console.WriteLine); // logging to console // .LogTo(message =&gt; Debug.WriteLine(message)); // logging to debug window // .LogTo(new StreamWriter(&quot;log.txt&quot;, append: true).WriteLine); // logging to file // .EnableSensitiveDataLogging(); // logging data values // .EnableDetailedErrors(); // logging more detailed errors. 8. Performance diagnosis Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core, which can be broken down into the following broad categories: Premature optimization is the root of all evil - Donald Knuth. Pure database performance. With relational database, EF translates the application&#8217;s LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently. The right index in the right place can make a world of difference in SQL performance, or rewriting the LINQ query may make EF generate a better SQL query. Network data transfer and roundtrips. As with any networking system, it&#8217;s important to limit the amount of data going back and forth on the wire. Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between the application and the database. EF runtime overhead. Finally, EF itself adds some runtime overhead to database operations: compile the queries from LINQ to SQL (although that should normally be done only once) change tracking adds some overhead (but can be disabled), etc. Cache. To maximize performance, especially for scalable apps, minimize database access through caching, as databases are harder to scale than application servers. 8.1. Identifying slow database commands via logging If a certain query is taking too much time (e.g. because an index is missing), this can be seen discovered by inspecting command execution logs and observing how long they actually take. builder.Logging.AddFilter(&quot;Microsoft.EntityFrameworkCore.Database.Command&quot;, LogLevel.Information); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (99ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] (1) SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version] FROM [People] AS [p] WHERE [p].[FirstName] = N&#39;John&#39; 1 The above command took 99 milliseconds. It&#8217;s recommended to only keep logging on for a short interval of time to gather data - while carefully monitoring an application - or to capture logging data on a pre-production system. Databases typically come with their own tracing and performance analysis tools, which usually provide much richer, database-specific information beyond simple execution times; the actual setup, capabilities and usage vary considerably across databases. 8.2. Correlating database commands to LINQ queries One problem with command execution logging is that it&#8217;s sometimes difficult to correlate SQL queries and LINQ queries: the SQL commands executed by EF can look very different from the LINQ queries from which they were generated. var person = await context.People .TagWith(&quot;This is my spatial query!&quot;) (1) .SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (111ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] -- This is my spatial query! (1) SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version] FROM [People] AS [p] WHERE [p].[FirstName] = N&#39;John&#39; 1 It&#8217;s often worth tagging the major queries of an application to make the command execution logs more immediately readable. 8.3. Inspecting query execution plans To optimize slow queries, analyze their execution plans—database-generated blueprints showing the steps and costs involved in query execution. Databases sometimes generate different query plans depending on actual data in the database. For example, if a table contains only a few rows, a database may choose not to use an index on that table, but to perform a full table scan instead. If analyzing query plans on a test database, always make sure it contains data that is similar to the production system. 9. Dapper Dapper is an open-source micro object-relational mapping (ORM) library for .NET applications, which uses the ADO.NET data providers to work with any existing database technology that supports ADO.NET. [6] dotnet add package Dapper Dapper supports a variety of database providers, including the popular Microsoft SQL Server, Oracle, MySQL, MariaDB, PostgreSQL, SQLite, etc. dotnet add package Microsoft.Data.SqlClient # SQL Server dotnet add package System.Data.SQLite.Core # SQLite IDbConnection connection = ... // 1. Scalar Query (Single Value): var blogCount = await connection.ExecuteScalarAsync&lt;int&gt;(&quot;SELECT COUNT(*) FROM Blogs&quot;); // 2. Row Query (Single Row): var firstBlog = await connection.QuerySingleOrDefaultAsync&lt;Blog&gt;(&quot;SELECT * FROM Blogs ORDER BY Id ASC&quot;); // 3. Multi-Result Query (Multiple Rows): var allBlogs = await connection.QueryAsync&lt;Blog&gt;(&quot;SELECT * FROM Blogs&quot;); // 4. Projection (Selecting Specific Columns): var blogNamesAndUrls = await connection.QueryAsync( &quot;SELECT Name, Url FROM Blogs&quot;, (string name, string url) =&gt; new { Name = name, Url = url }); // Mapping to anonymous type //Or use anonymous type directly var blogNamesAndUrls2 = await connection.QueryAsync( &quot;SELECT Name, Url FROM Blogs&quot;, (dynamic item) =&gt; new { Name = item.Name, Url = item.Url }); // Mapping to anonymous type // 5. Parameterized Query (Preventing SQL Injection): var blogsStartingWithB = await connection.QueryAsync&lt;Blog&gt;( &quot;SELECT * FROM Blogs WHERE Name LIKE @NameStart&quot;, new { NameStart = &quot;B%&quot; }); // named parameter // 6. Dynamic Parameter Query: var parameters = new DynamicParameters(); string sql = &quot;SELECT * FROM Blogs WHERE 1=1 &quot;; // Start with a true condition if (!string.IsNullOrEmpty(&quot;Blog&quot;)) // Example condition { sql += &quot;AND Name LIKE @NamePart &quot;; parameters.Add(&quot;@NamePart&quot;, &quot;%&quot; + &quot;Blog&quot; + &quot;%&quot;); } var dynamicBlogs = await connection.QueryAsync&lt;Blog&gt;(sql, parameters); // Using IN clause with Dynamic Parameters var blogIds = new List&lt;int&gt; { 1, 2, 5 }; // Transform the list of IDs into a format suitable for the IN clause var inClauseParams = new DynamicParameters(); for (var i = 0; i &lt; blogIds.Count; i++) { inClauseParams.Add($&quot;@Id{i}&quot;, blogIds[i]); } var inClauseSql = $&quot;SELECT * FROM Blogs WHERE Id IN ({string.Join(&quot;,&quot;, inClauseParams.ParameterNames)})&quot;; var blogsInList = await connection.QueryAsync&lt;Blog&gt;(inClauseSql, inClauseParams); // 7. Insert, Update, Delete (using parameters): var newBlogId = await connection.ExecuteScalarAsync&lt;int&gt;( &quot;INSERT INTO Blogs (Name, Url) VALUES (@Name, @Url); SELECT SCOPE_IDENTITY();&quot;, new { Name = &quot;Another Blog&quot;, Url = &quot;http://another.com&quot; }); var updatedRows = await connection.ExecuteAsync( &quot;UPDATE Blogs SET Url = @NewUrl WHERE Id = @Id&quot;, new { Id = newBlogId, NewUrl = &quot;http://updated.com&quot; }); var deletedRows = await connection.ExecuteAsync(&quot;DELETE FROM Blogs WHERE Id = @Id&quot;, new { Id = newBlogId }); References [1] https://learn.microsoft.com/en-us/ef/core/ [2] https://learn.microsoft.com/en-us/ef/core/get-started/overview/install [3] https://learn.microsoft.com/en-us/ef/core/what-is-new/nuget-packages [4] https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-filtered-indexes [5] https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-indexes-with-included-columns [6] https://www.learndapper.com/" />
<link rel="canonical" href="https://blog.codefarm.me/2023/02/10/entity-framework-core-in-net/" />
<meta property="og:url" content="https://blog.codefarm.me/2023/02/10/entity-framework-core-in-net/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-02-10T22:03:22+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Entity Framework in .NET" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-10T22:03:22+08:00","datePublished":"2023-02-10T22:03:22+08:00","description":"Entity Framework (EF) Core is a lightweight, extensible, open source and cross-platform version of the popular Entity Framework data access technology, which can serve as an object-relational mapper (O/RM). [1] With EF, data access is performed using a model, which is made up of entity classes and a context object that represents a session to query and save data with the database. EF supports the following model development approaches: Generate a model from an existing database. Hand-code a model to match the database. Once a model is created, use EF Migrations to create a database from the model, which allow evolving the database as the model changes. Instances of the entity classes are retrieved from the database using Language Integrated Query (LINQ). Data is created, deleted, and modified in the database using instances of the entity classes. 1. Installing Entity Framework Core 2. DbContext 2.1. Lifetime, Configuration, and Initialization 2.2. DbContext Pooling 2.3. Connection Pooling 3. Model 3.1. Entity Types 3.2. Entity Properties 3.3. Keys 3.4. Generated Values 3.5. Shadow and Indexer Properties 3.6. Relationships 3.6.1. Foreign and Principal keys 3.6.2. Navigations 3.7. Indexes 3.8. Check Constraints 4. Schemas 4.1. Migrations 4.1.1. Managing Migrations 4.1.2. Applying Migrations 5. Querying 5.1. Tracking vs. no-tracking 5.2. Pagination 5.3. Indexes 5.4. Projections 5.5. SQL queries 6. Saving 6.1. SaveChanges, ExecuteUpdate and ExecuteDelete 6.2. Transactions 6.3. Optimistic concurrency 7. Logging, events, and diagnostics 8. Performance diagnosis 8.1. Identifying slow database commands via logging 8.2. Correlating database commands to LINQ queries 8.3. Inspecting query execution plans 9. Dapper References 1. Installing Entity Framework Core Entity Framework Core (EF Core) is distributed as NuGet packages, with the necessary packages determined by the database system (SQL Server, SQLite, etc.) and required EF Core features. [2][3] Make sure to install the same version of all EF Core packages shipped by Microsoft. For example, if version 5.0.3 of Microsoft.EntityFrameworkCore.SqlServer is installed, then all other Microsoft.EntityFrameworkCore.* packages must also be at 5.0.3. Use of tooling for EF Core migrations and reverse engineering (scaffolding) from an existing database requires installation of the appropriate tooling package: Always use the version of the tools package that matches the major version of the runtime packages. dotnet-ef for cross-platform command line tooling # dotnet ef must be installed as a global or local tool dotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design # dotnet ef can also be used as a local tool dotnet new tool-manifest dotnet tool install dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Microsoft.EntityFrameworkCore.Tasks for MSBuild tasks allowing build-time integration. Microsoft.EntityFrameworkCore.Tools for PowerShell tooling that works in the Visual Studio Package Manager Console 2. DbContext A DbContext is a combination of the Unit Of Work and Repository patterns that represents a session with the database and can be used to query and save instances of entities. A DbContext instance, designed for a single unit-of-work, has a typically short lifespan, beginning with its creation and ending with its disposal. A typical unit-of-work when using Entity Framework Core (EF Core) involves: creating a DbContext instance tracking entities that returned from a query or added or attached to the context making changes to those tracked entities as needed to implement the business rule calling SaveChanges or SaveChangesAsync to persist the changes to the database. disposing the DbContext instance. A DbContext is not thread-safe and doesn&#8217;t support parallel operations. Don&#8217;t share contexts between threads. Make sure to await all async calls before continuing to use the context instance. Use separate DbContext instances for concurrent operations Any code that explicitly executes multiple threads in parallel should ensure that DbContext instances aren&#8217;t ever accessed concurrently. 2.1. Lifetime, Configuration, and Initialization Each DbContext instance must be configured to use one and only one database provider using a specific Use* call. public class ApplicationDbContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { // use the SQL Server database provider optionsBuilder.UseSqlServer( @&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;); } } Other DbContext configuration can be chained either before or after (it makes no difference which) the Use* call. builder.Services.AddDbContext&lt;ApplicationDbContext&gt;( options =&gt; options .EnableSensitiveDataLogging() .UseSqlServer( @&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) ); EF Core can be integrated into applications using dependency injection, typically via the AddDbContext method. The AddDbContext extension method registers DbContext types with a scoped lifetime by default. In many web applications, each HTTP request corresponds to a single unit-of-work. var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;) ?? throw new InvalidOperationException(&quot;Connection string &#39;DefaultConnection&#39; not found.&quot;); builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(connectionString)); // builder.Services.AddDbContext&lt;ApplicationDbContext&gt;( // options =&gt; options.UseSqlServer(connectionString), // contextLifetime: ServiceLifetime.Scoped, // optionsLifetime: ServiceLifetime.Scoped); The ApplicationDbContext class must expose a public constructor with a DbContextOptions&lt;ApplicationDbContext&gt; parameter. public class ApplicationDbContext : DbContext { public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) { } } DbContext can be created with new, configured either by overriding OnConfiguring or by passing options to the constructor. public class ApplicationDbContext : DbContext { private readonly string? _connectionString; public ApplicationDbContext() : this( connectionString: @&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) { } public ApplicationDbContext(string connectionString) =&gt; _connectionString = connectionString; public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) { } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { if (_connectionString is not null) optionsBuilder.UseSqlServer(_connectionString); } } using var context = new ApplicationDbContext(); using var context = new ApplicationDbContext( connectionString: @&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;); var contextOptions = new DbContextOptionsBuilder&lt;ApplicationDbContext&gt;() .UseSqlServer(@&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) .Options; using var context = new ApplicationDbContext(contextOptions); In applications where dependency injection doesn&#8217;t provide a suitable DbContext lifetime or multiple units-of-work are needed within a scope, AddDbContextFactory can register a factory for creating individual DbContext instances. builder.Services.AddDbContextFactory&lt;ApplicationDbContext&gt;( options =&gt; options.UseSqlServer( @&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;)); public sealed class MyService(IDbContextFactory&lt;ApplicationDbContext&gt; contextFactory) { public async Task DoWorkAsync() { var tasks = Enumerable.Range(1, 10).Select(_ =&gt; { using var context = contextFactory.CreateDbContext(); // ... return Task.CompletedTask; }); await Task.WhenAll(tasks); } } 2.2. DbContext Pooling While generally lightweight, creating and disposing DbContext instances can introduce overhead in high-performance scenarios, which EF Core mitigates through context pooling, reusing instances from an internal pool to minimize setup costs at program startup, rather than continuously. Note that context pooling is orthogonal to database connection pooling, which is managed at a lower level in the database driver. To enable context pooling, simply replace AddDbContext with AddDbContextPool: builder.Services.AddDbContextPool&lt;ApplicationDbContext&gt;( options =&gt; options.UseSqlServer( @&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;), poolSize: 1024); The poolSize parameter of AddDbContextPool sets the maximum number of instances retained by the pool (defaults to 1024). Once poolSize is exceeded, new context instances are not cached and EF falls back to the non-pooling behavior of creating instances on demand. To use context pooling without dependency injection, initialize a PooledDbContextFactory and request context instances from it: var options = new DbContextOptionsBuilder&lt;PooledBloggingContext&gt;() .UseSqlServer(@&quot;Server=(localdb)\\mssqllocaldb;Database=Test;ConnectRetryCount=0&quot;) .Options; var factory = new PooledDbContextFactory&lt;PooledBloggingContext&gt;(options); using var context = factory.CreateDbContext(); var allPosts = await context.Posts.ToListAsync(); 2.3. Connection Pooling With most databases, a long-lived connection is required for performing database operations, and such connections can be expensive to open and close. EF Core relies on the underlying database driver (e.g., ADO.NET) for connection pooling, a client-side mechanism that reuses database connections to reduce the overhead of opening and closing connections repeatedly. While generally enabled by default and configurable at the driver level (e.g., via connection string), connection pooling is separate from EF Core&#8217;s context pooling, which optimizes DbContext instance reuse. EF Core typically opens and closes connections around each operation, returning them to the pool quickly. 3. Model EF Core uses a metadata model to describe how the application&#8217;s entity types are mapped to the underlying database. EF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API. The model is built using a set of conventions - heuristics that look for common patterns. The model can then be customized to override the configuration performed by conventions using mapping attributes (a.k.a., data annotations) and/or calls to the ModelBuilder methods (a.k.a., fluent API) in OnModelCreating. Fluent API configuration has the highest precedence and will override conventions and data annotations. internal sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Url) .IsRequired(); } } public class Blog { public int BlogId { get; set; } public string? Url { get; set; } } Data annotations will override conventions, but will be overridden by Fluent API configuration. internal sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } } [Table(&quot;Blogs&quot;)] public class Blog { public int BlogId { get; set; } [Required] public string? Url { get; set; } } EF Core model building conventions are classes that contain logic that is triggered based on changes being made to the model as it is being built. EF Core includes many model building conventions that are enabled by default, which can be found in the list of classes that implement the IConvention interface. Applications can remove or replace any of these conventions, as well as add new custom conventions that apply configuration for patterns that are not recognized by EF out of the box. internal sealed class BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : DbContext(options) { protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder) { configurationBuilder.Conventions.Remove(typeof(ForeignKeyIndexConvention)); } } While most configuration is data store-agnostic, providers can offer store-specific configurations and ignore unsupported ones. The model builder debug view can be accessed in the debugger or directly from code. Console.WriteLine(context.Model.ToDebugString()); Model: EntityType: Blog Properties: BlogId (int) Required PK AfterSave:Throw ValueGenerated.OnAdd Url (string) Required Keys: BlogId PK A DbSet included in a DbContext registers its type as an entity in EF Core&#8217;s model, enabling EF Core to read/write instances to/from the database and, for relational databases, create tables via migrations. 3.1. Entity Types A model includes entities through DbSet properties exposed on the context, specified in the OnModelCreating, and any types that are found by recursively exploring the navigation properties of other discovered entity types. internal sealed class MyContext : DbContext { // exposed in a DbSet property public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { // explicitly specified in OnModelCreating modelBuilder.Entity&lt;AuditEntry&gt;(); } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } // discovered via the Blog.Posts navigation property. public List&lt;Post&gt; Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public Blog Blog { get; set; } } public class AuditEntry { public int AuditEntryId { get; set; } public string Username { get; set; } public string Action { get; set; } } To exclude types from the model: // Data Annotations [NotMapped] public class BlogMetadata { public DateTime LoadedFromDatabase { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Ignore&lt;BlogMetadata&gt;(); } To exclude from migrations: protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;IdentityUser&gt;() .ToTable(&quot;AspNetUsers&quot;, t =&gt; t.ExcludeFromMigrations()); } By convention, each entity type will be set up to map to a database table with the same name as the DbSet property that exposes the entity. If no DbSet exists for the given entity, the class name is used. // Data Annotations [Table(&quot;blogs&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .ToTable(&quot;blogs&quot;); } When using a relational database, tables are by convention created in the database&#8217;s default schema. // Data Annotations [Table(&quot;blogs&quot;, Schema = &quot;blogging&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .ToTable(&quot;blogs&quot;, schema: &quot;blogging&quot;); } // define the default schema at the model level protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.HasDefaultSchema(&quot;blogging&quot;); } Entity types can be mapped to database views using the Fluent API. modelBuilder.Entity&lt;Blog&gt;() .ToView(&quot;blogsView&quot;, schema: &quot;blogging&quot;); It&#8217;s possible to map an entity type to a parameterless table-valued function (TVF) instead of a table in the database. modelBuilder.Entity&lt;BlogWithMultiplePosts&gt;().HasNoKey().ToFunction(&quot;BlogsWithMultiplePosts&quot;); An arbitrary text comment can be set on the database table to document the schema in the database. // Data Annotations [Comment(&quot;Blogs managed on the website&quot;)] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;().ToTable( tableBuilder =&gt; tableBuilder.HasComment(&quot;Blogs managed on the website&quot;)); } Shared-type entity types (those using the same CLR type) require a unique name for configuration and usage, necessitating a Set call for the corresponding DbSet property. internal class MyContext : DbContext { public DbSet&lt;Dictionary&lt;string, object&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;string, object&gt;&gt;(&quot;Blog&quot;); protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.SharedTypeEntity&lt;Dictionary&lt;string, object&gt;&gt;( &quot;Blog&quot;, bb =&gt; { bb.Property&lt;int&gt;(&quot;BlogId&quot;); bb.Property&lt;string&gt;(&quot;Url&quot;); bb.Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); }); } } 3.2. Entity Properties Each entity type in a model has properties that EF Core reads and writes from the database; in relational databases, these properties map to table columns. By convention, all public properties with a getter and a setter will be included in the model. Specific properties can be excluded as follows: // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [NotMapped] public DateTime LoadedFromDatabase { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Ignore(b =&gt; b.LoadedFromDatabase); } By convention, when using a relational database, entity properties are mapped to table columns having the same name as the property. // Data Annotations public class Blog { [Column(&quot;blog_id&quot;)] public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.BlogId) .HasColumnName(&quot;blog_id&quot;); } When using a relational database, the database provider selects a data type based on the .NET type of the property. // Data Annotations public class Blog { public int BlogId { get; set; } [Column(TypeName = &quot;varchar(200)&quot;)] public string Url { get; set; } [Column(TypeName = &quot;decimal(5, 2)&quot;)] public decimal Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;( eb =&gt; { eb.Property(b =&gt; b.Url).HasColumnType(&quot;varchar(200)&quot;); eb.Property(b =&gt; b.Rating).HasColumnType(&quot;decimal(5, 2)&quot;); }); } Configuring a maximum length provides a hint to the database provider about the appropriate column data type to choose for a given array data type property, such as string and byte[]. // Data Annotations public class Blog { public int BlogId { get; set; } [MaxLength(500)] public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Url) .HasMaxLength(500); } Some relational data types support the precision and scale facets; these control what values can be stored, and how much storage is needed for the column. // Data Annotations public class Blog { public int BlogId { get; set; } [Precision(14, 2)] public decimal Score { get; set; } [Precision(3)] public DateTime LastUpdated { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Score) .HasPrecision(14, 2); modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.LastUpdated) .HasPrecision(3); } Text properties are configured as Unicode by default. // Data Annotations public class Book { public int Id { get; set; } public string Title { get; set; } [Unicode(false)] [MaxLength(22)] public string Isbn { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Book&gt;() .Property(b =&gt; b.Isbn) .IsUnicode(false); } When mapping to a relational database schema, required properties are created as non-nullable columns, and optional properties are created as nullable columns. A property is considered optional if it is valid for it to contain null. If null is not a valid value to be assigned to a property then it is considered to be a required property. By convention, a property whose .NET type can contain null will be configured as optional, whereas properties whose .NET type cannot contain null will be configured as required. If nullable reference types are disabled, all properties with .NET reference types are configured as optional by convention (for example, string). // Without NRT public class CustomerWithoutNullableReferenceTypes { public int Id { get; set; } [Required] // Data annotations needed to configure as required public string FirstName { get; set; } [Required] // Data annotations needed to configure as required public string LastName { get; set; } public string MiddleName { get; set; } // Optional by convention } // Without NRT with Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;CustomerWithoutNullableReferenceTypes&gt;(c =&gt; { c.Property(c =&gt; c.FirstName).IsRequired(); c.Property(c =&gt; c.LastName).IsRequired(); }); } If nullable reference types are enabled, properties will be configured based on the C# nullability of their .NET type: string? will be configured as optional, but string will be configured as required. // With NRT public class Customer { public int Id { get; set; } public string FirstName { get; set; } // Required by convention public string LastName { get; set; } // Required by convention public string? MiddleName { get; set; } // Optional by convention // Note the following use of constructor binding, which avoids compiled warnings // for uninitialized non-nullable properties. public Customer(string firstName, string lastName, string? middleName = null) { FirstName = firstName; LastName = lastName; MiddleName = middleName; } } A collation can be defined on text columns, determining how they are compared and ordered. // column level modelBuilder.Entity&lt;Customer&gt;().Property(c =&gt; c.Name) .UseCollation(&quot;SQL_Latin1_General_CP1_CI_AS&quot;); // database level modelBuilder.UseCollation(&quot;SQL_Latin1_General_CP1_CI_AS&quot;); 3.3. Keys A key (primary key or alternate key) serves as a unique identifier for each entity instance. By convention, a property named Id or &lt;type name&gt;Id will be configured as the primary key of an entity. internal class Car { public string Id { get; set; } public string Make { get; set; } public string Model { get; set; } } internal class Truck { public string TruckId { get; set; } public string Make { get; set; } public string Model { get; set; } } An entity&#8217;s primary key can also be explicitly configured using a single property or a composite key (multiple properties). // Data Annotations internal class Car { [Key] public string LicensePlate { get; set; } public string Make { get; set; } public string Model { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Car&gt;() .HasKey(c =&gt; c.LicensePlate); } // Data Annotations [PrimaryKey(nameof(State), nameof(LicensePlate))] internal class Car { public string State { get; set; } public string LicensePlate { get; set; } public string Make { get; set; } public string Model { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Car&gt;() .HasKey(c =&gt; new { c.State, c.LicensePlate }); } By convention, on relational databases primary keys are created with the name PK_&lt;type name&gt;. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasKey(b =&gt; b.BlogId) .HasName(&quot;PrimaryKey_BlogId&quot;); } An alternate key serves as an alternate unique identifier for each entity instance in addition to the primary key; it can be used as the target of a relationship. When using a relational database this maps to the concept of a unique index/constraint on the alternate key column(s) and one or more foreign key constraints that reference the column(s). For simple uniqueness constraints, use a unique index; alternate keys in EF Core are read-only and can also serve as foreign key targets. Alternate keys are usually created automatically by EF Core when a non-primary key property is used as the target of a relationship, so manual configuration is typically unnecessary. By convention, the index and constraint that are introduced for an alternate key will be named AK_&lt;type name&gt;_&lt;property name&gt; (for composite alternate keys &lt;property name&gt; becomes an underscore separated list of property names). 3.4. Generated Values Database columns can have their values generated in various ways: primary key columns are frequently auto-incrementing integers, other columns have default or computed values, etc. On relational databases, a column can be configured with a default value; if a row is inserted without a value for that column, the default value will be used. // a default value protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Rating) .HasDefaultValue(3); } // a SQL fragment protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Created) .HasDefaultValueSql(&quot;getdate()&quot;); } On most relational databases, a column can be configured to have its value computed in the database, typically with an expression referring to other columns: // a virtual computed column modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.DisplayName) .HasComputedColumnSql(&quot;[LastName] + &#39;, &#39; + [FirstName]&quot;); // // a physical computed column modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.NameLength) .HasComputedColumnSql(&quot;LEN([LastName]) + LEN([FirstName])&quot;, stored: true); By convention, non-composite primary keys of type short, int, long, or Guid are set up to have values generated for inserted entities if a value isn&#8217;t provided by the application. A property can be explicitly configured to have its value generated on add or update: // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public DateTime Inserted { get; set; } } // Fluent API // protected override void OnModelCreating(ModelBuilder modelBuilder) // { // modelBuilder.Entity&lt;Blog&gt;() // .Property(b =&gt; b.Inserted) // .ValueGeneratedOnAdd(); // } // Data Annotations public class Blog { public int BlogId { get; set; } public string Url { get; set; } [DatabaseGenerated(DatabaseGeneratedOption.Computed)] public DateTime LastUpdated { get; set; } } // Fluent API // protected override void OnModelCreating(ModelBuilder modelBuilder) // { // modelBuilder.Entity&lt;Blog&gt;() // .Property(b =&gt; b.LastUpdated) // .ValueGeneratedOnAddOrUpdate(); // } Unlike with default values or computed columns, how the values are to be generated depends on the database provider being used. Database providers may automatically set up value generation for some property types, but others may require to manually set up how the value is generated. For example, on SQL Server, when a GUID property is configured as a primary key, the provider automatically performs value generation client-side, using an algorithm to generate optimal sequential GUID values. Similarly, byte[] properties that are configured as generated on add or update and marked as concurrency tokens are set up with the rowversion data type, so that values are automatically generated in the database. A common request is to have a database column which contains the date/time for when the row was first inserted (value generated on add), or for when it was last updated (value generated on add or update). Configuring a date/time column to have the creation timestamp of the row is usually a matter of configuring a default value with the appropriate SQL function. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.Created) .HasDefaultValueSql(&quot;getdate()&quot;); } Although stored computed columns seem like a good solution for managing last-updated timestamps, databases usually don&#8217;t allow specifying functions such as GETDATE() in a computed column. As an alternative, set up a database trigger to achieve the same effect: CREATE TRIGGER [dbo].[Blogs_UPDATE] ON [dbo].[Blogs] AFTER UPDATE AS BEGIN SET NOCOUNT ON; IF ((SELECT TRIGGER_NESTLEVEL()) &gt; 1) RETURN; UPDATE B SET LastUpdated = GETDATE() FROM dbo.Blogs AS B INNER JOIN INSERTED AS I ON B.BlogId = I.BlogId END To override value generation with an explicit value, simply set the property to any value that is not the CLR default value for that property&#8217;s type (null for string, 0 for int, Guid.Empty for Guid, etc.). var product = new Product { // To override the auto-generated CreatedDate, set it to something other than DateTime.MinValue: CreatedDate = DateTime.Now.AddYears(-10) }; await context.AddAsync(product); await context.SaveChangesAsync(); public class Product { public Guid Id { get; set; } // Will be auto-generated by default (often) public string? Name { get; set; } // modelBuilder.Entity&lt;Product&gt;().Property(p =&gt; p.CreatedDate).HasDefaultValueSql(&quot;getdate()&quot;); public DateTime CreatedDate { get; set; } // Will be auto-generated (often) } To disable value generation that has been set up by convention. // Data Annotations public class Blog { [DatabaseGenerated(DatabaseGeneratedOption.None)] public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property(b =&gt; b.BlogId) .ValueGeneratedNever(); } 3.5. Shadow and Indexer Properties Shadow properties are properties that aren&#8217;t defined in .NET entity class but are defined for that entity type in the EF Core model, which are maintained purely in the Change Tracker and are useful when there&#8217;s data in the database that shouldn&#8217;t be exposed on the mapped entity types. Indexer properties are entity type properties, which are backed by an indexer in .NET entity class to add additional properties to the entity type without changing the CLR class. Shadow properties are most often used for foreign key properties, where they are added to the model by convention when no foreign key property has been found by convention or configured explicitly. The relationship is represented by navigation properties, but in the database it is enforced by a foreign key constraint, and the value for the foreign key column is stored in the corresponding shadow property. The property will be named &lt;navigation property name&gt;&lt;principal key property name&gt; (the navigation on the dependent entity, which points to the principal entity, is used for the naming). If the principal key property name starts with the name of the navigation property, then the name will just be &lt;principal key property name&gt;. If there is no navigation property on the dependent entity, then the principal type name concatenated with the primary or alternate key property name is used in its place &lt;principal type name&gt;&lt;principal key property name&gt;. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public DbSet&lt;Post&gt; Posts { get; set; } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List&lt;Post&gt; Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } // Since there is no CLR property which holds the foreign // key for this relationship, a shadow property is created. public Blog Blog { get; set; } } var post = new Post { Blog = new() }; await context.AddAsync(post); await context.SaveChangesAsync(); var blogId = (int)context.Entry(post).Property(nameof(Blog.BlogId)).CurrentValue!; Debug.Assert(post.Blog.BlogId == blogId); Shadow properties can be configured using the Fluent API to call the string overload of Property&lt;TProperty&gt;(String) to chain any of the configuration calls for other properties. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } } Shadow property values can be referenced in LINQ queries via the EF.Property static method or obtained and changed through the ChangeTracker API. var blogs = context.Blogs .OrderBy(b =&gt; EF.Property&lt;DateTime&gt;(b, &quot;LastUpdated&quot;)); context.Entry(myBlog).Property(&quot;LastUpdated&quot;).CurrentValue = DateTime.Now; Indexer properties can be configured using the Fluent API to call the method IndexerProperty to chain any of the configuration calls for other properties. internal class MyContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;().IndexerProperty&lt;DateTime&gt;(&quot;LastUpdated&quot;); } } public class Blog { private readonly Dictionary&lt;string, object&gt; _data = new Dictionary&lt;string, object&gt;(); public int BlogId { get; set; } public object this[string key] { get =&gt; _data[key]; set =&gt; _data[key] = value; } } Indexer properties can be referenced in LINQ queries via the EF.Property static method or by using the CLR indexer property. var blog = new Blog(); blog[&quot;LastUpdated&quot;] = DateTime.Now; await context.AddAsync(blog); await context.SaveChangesAsync(); var lastUpdated = await context.Blogs .Select(b =&gt; EF.Property&lt;DateTime&gt;(b, &quot;LastUpdated&quot;)) .FirstAsync(); Console.WriteLine(lastUpdated); Entity types that contain only indexer properties are known as property bag entity types. internal class MyContext : DbContext { public DbSet&lt;Dictionary&lt;string, object&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;string, object&gt;&gt;(&quot;Blog&quot;); protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.SharedTypeEntity&lt;Dictionary&lt;string, object&gt;&gt;( &quot;Blog&quot;, bb =&gt; { bb.Property&lt;int&gt;(&quot;BlogId&quot;); bb.Property&lt;string&gt;(&quot;Url&quot;); bb.Property&lt;DateTime&gt;(&quot;LastUpdated&quot;); }); } } 3.6. Relationships A relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model. A one-to-many relationship is used when a single entity is associated with any number of other entities. CREATE TABLE [Blogs] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Blogs] PRIMARY KEY ([Id]) ); CREATE TABLE [Posts] ( [Id] int NOT NULL IDENTITY, [BlogId] int NOT NULL, CONSTRAINT [PK_Posts] PRIMARY KEY ([Id]), CONSTRAINT [FK_Posts_Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [Blogs] ([Id]) ON DELETE CASCADE ); CREATE INDEX [IX_Posts_BlogId] ON [Posts] ([BlogId]); // Principal (parent) public class Blog { public int Id { get; set; } (1) public ICollection&lt;Post&gt; Posts { get; } = []; // Collection navigation containing dependents (3) } // Dependent (child) public class Post { public int Id { get; set; } public int BlogId { get; set; } // Required foreign key property (2) public Blog Blog { get; set; } = null!; // Required reference navigation to principal (4) // public int? BlogId { get; set; } // Optional foreign key property // public Blog? Blog { get; set; } // Optional reference navigation to principal } A one-to-many relationship is made up from: 1 One or more primary or alternate key properties on the principal entity; that is the &quot;one&quot; end of the relationship. 2 One or more foreign key properties on the dependent entity; that is the &quot;many&quot; end of the relationship. 3 Optionally, a collection navigation on the principal entity referencing the dependent entities. 4 Optionally, a reference navigation on the dependent entity referencing the principal entity. For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasForeignKey(e =&gt; e.BlogId) .IsRequired(); // .IsRequired(false); } As with all relationships, it is exactly equivalent to start with dependent entity type (Post) and use HasOne followed by WithMany. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasOne(e =&gt; e.Blog) .WithMany(e =&gt; e.Posts) .HasForeignKey(e =&gt; e.BlogId) .IsRequired(); // .IsRequired(false); } A one-to-one relationship is used when one entity is associated with at most one other entity. CREATE TABLE [Blogs] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Blogs] PRIMARY KEY ([Id]) ); CREATE TABLE [BlogHeader] ( [Id] int NOT NULL IDENTITY, [BlogId] int NOT NULL, CONSTRAINT [PK_BlogHeader] PRIMARY KEY ([Id]), CONSTRAINT [FK_BlogHeader_Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [Blogs] ([Id]) ON DELETE CASCADE ); CREATE UNIQUE INDEX [IX_BlogHeader_BlogId] ON [BlogHeader] ([BlogId]); -- UNIQUE INDEX // Principal (parent) public class Blog { public int Id { get; set; } (1) public BlogHeader? Header { get; set; } // Reference navigation to dependent (3) } // Dependent (child) public class BlogHeader { public int Id { get; set; } public int BlogId { get; set; } // Required foreign key property (2) public Blog Blog { get; set; } = null!; // Required reference navigation to principal (4) // public int? BlogId { get; set; } // Optional foreign key property // public Blog? Blog { get; set; } // Optional reference navigation to principal } A one-to-many relationship is made up from: 1 One or more primary or alternate key properties on the principal entity; that is the &quot;one&quot; end of the relationship. 2 One or more foreign key properties on the dependent entity; that is the &quot;many&quot; end of the relationship. 3 Optionally, a reference navigation on the principal entity referencing the dependent entities. 4 Optionally, a reference navigation on the dependent entity referencing the principal entity. For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasOne(e =&gt; e.Header) .WithOne(e =&gt; e.Blog) .HasForeignKey&lt;BlogHeader&gt;(e =&gt; e.BlogId) .IsRequired(); } As with all relationships, it is exactly equivalent to start with dependent entity type (BlogHeader) instead. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;BlogHeader&gt;() .HasOne(e =&gt; e.Blog) .WithOne(e =&gt; e.Header) .HasForeignKey&lt;BlogHeader&gt;(e =&gt; e.BlogId) .IsRequired(); } A many-to-many relationship is used when any number entities of one entity type is associated with any number of entities of the same or another entity type. A many-to-many relationship requires a join entity (and table) to link the two sides, as a single foreign key is insufficient. CREATE TABLE [Posts] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Posts] PRIMARY KEY ([Id]) ); CREATE TABLE [Tag] ( [Id] int NOT NULL IDENTITY, CONSTRAINT [PK_Tag] PRIMARY KEY ([Id]) ); CREATE TABLE [PostTag] ( [PostsId] int NOT NULL, [TagsId] int NOT NULL, CONSTRAINT [PK_PostTag] PRIMARY KEY ([PostsId], [TagsId]), CONSTRAINT [FK_PostTag_Posts_PostsId] FOREIGN KEY ([PostsId]) REFERENCES [Posts] ([Id]) ON DELETE CASCADE, CONSTRAINT [FK_PostTag_Tag_TagsId] FOREIGN KEY ([TagsId]) REFERENCES [Tag] ([Id]) ON DELETE CASCADE ); CREATE INDEX [IX_PostTag_TagsId] ON [PostTag] ([TagsId]); EF Core can hide the join entity type and manage it behind the scenes that allows the navigations of a many-to-many relationship to be used in a natural manner, adding or removing entities from each side as needed. public class Post { public int Id { get; set; } public List&lt;Tag&gt; Tags { get; } = []; } public class Tag { public int Id { get; set; } public List&lt;Post&gt; Posts { get; } = []; } 3.6.1. Foreign and Principal keys One-to-one and one-to-many relationships are defined by a foreign key on the dependent entity referencing the principal key (primary or alternate) of the principal entity. Many-to-many relationships are formed by two one-to-many relationships, each with its own foreign key referencing a principal key. The property or properties that make up foreign key are often discovered by convention, and can also be configured explicitly using either mapping attributes or with HasForeignKey in the model building API. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasForeignKey(e =&gt; e.ContainingBlogId); // lambda expression. // .HasForeignKey(&quot;ContainingBlogId&quot;); // property name // composite foreign key // .HasForeignKey(e =&gt; new { e.ContainingBlogId1, e.ContainingBlogId2 }); // .HasForeignKey(&quot;ContainingBlogId1&quot;, &quot;ContainingBlogId2&quot;); } By convention, foreign keys are constrained to the primary key at the principal end of the relationship. However, an alternate key can be used instead using HasPrincipalKey on the model building API. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasMany(e =&gt; e.Posts) .WithOne(e =&gt; e.Blog) .HasPrincipalKey(e =&gt; e.AlternateId); // lambda expression. // .HasPrincipalKey(&quot;AlternateId&quot;); // property name // composite key // .HasPrincipalKey(e =&gt; new { e.AlternateId1, e.AlternateId2 }); // .HasPrincipalKey(&quot;AlternateId1&quot;, &quot;AlternateId2&quot;); } The order of the properties in the principal and foreign key must match, which is also the order in which the key is defined in the database schema. There is no need to call HasAlternateKey to define the alternate key on the principal entity when HasPrincipalKey is used with properties that are not the primary key properties. In many-to-many relationships, the foreign keys are defined on the join entity type and mapped to foreign key constraints in the join table. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasMany(e =&gt; e.Tags) .WithMany(e =&gt; e.Posts) .UsingEntity( l =&gt; l.HasOne(typeof(Tag)).WithMany().HasConstraintName(&quot;TagForeignKey_Constraint&quot;), r =&gt; r.HasOne(typeof(Post)).WithMany().HasConstraintName(&quot;PostForeignKey_Constraint&quot;)); } 3.6.2. Navigations EF Core relationships are defined by foreign keys. Navigations are layered over foreign keys to provide a natural, object-oriented view for reading and manipulating relationships. By using navigations, applications can work with graphs of entities without being concerned with what is happening to the foreign key values. A navigation from dependent to principal is required if the relationship is required, which in turn means that the foreign key property is non-nullable. Conversely, the navigation is optional if the foreign key is nullable, and the relationship is therefore optional. Reference navigations are simple object references to another entity, which represent the &quot;one&quot; side(s) of one-to-many and one-to-one relationships. Reference navigations must have a setter, although it does not need to be public. Reference navigations should not be automatically initialized to a non-null default value; doing so is equivalent to asserting that an entity exists when it does not. When using C# nullable reference types, reference navigations must be nullable for optional relationships: Reference navigations for required relationships can be nullable or non-nullable. public Blog? TheBlog { get; set; } Collection navigations are instances of a .NET collection type; that is, any type implementing ICollection&lt;T&gt;, which represent the &quot;many&quot; side(s) of one-to-many and many-to-many relationships. Collection navigations do not need to have a setter. It is common to initialize the collection inline, thereby removing the need to ever check if the property is null. public ICollection&lt;Post&gt; ThePosts { get; } = []; Don&#8217;t accidentally create an expression bodied property, such as public ICollection&lt;Post&gt; ThePosts =&gt; [];, which will create a new, empty collection instance each time the property is accessed, and will therefore be useless as a navigation. 3.7. Indexes Indexes are a common concept across many data store to make lookups based on a column (or set of columns) more efficient. // Data Annotations [Index(nameof(Url))] public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url); } By convention, an index is created in each property (or set of properties) that are used as a foreign key. A composite index, spanning more than one column, speeds up queries which filter on index&#8217;s columns, but also queries which only filter on the first columns covered by the index. // Data Annotations [Index(nameof(FirstName), nameof(LastName))] public class Person { public int PersonId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }); } By default, indexes aren&#8217;t unique: multiple rows are allowed to have the same value(s) for the index&#8217;s column set. // Data Annotations [Index(nameof(Url), IsUnique = true)] // UNIQUE INDEX public class Blog { public int BlogId { get; set; } public string Url { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url) .IsUnique(); // UNIQUE INDEX } In most databases, each column covered by an index can be either ascending or descending. For indexes covering only one column, this typically does not matter: the database can traverse the index in reverse order as needed. However, for composite indexes, the ordering can be crucial for good performance, and can mean the difference between an index getting used by a query or not. In general, the index columns&#39; sort orders should correspond to those specified in the ORDER BY clause of a query. The index sort order is ascending by default. // Data Annotations [Index(nameof(Url), nameof(Rating), AllDescending = true)] // make all columns as descending order public class Blog { public int BlogId { get; set; } public string Url { get; set; } public int Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; new { b.Url, b.Rating }) .IsDescending(); // make all columns as descending order } The index may also be specified the sort order on a column-by-column basis. // Data Annotations [Index(nameof(Url), nameof(Rating), IsDescending = new[] { false, true })] public class Blog { public int BlogId { get; set; } public string Url { get; set; } public int Rating { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; new { b.Url, b.Rating }) .IsDescending(false, true); } To create multiple indexes over the same set of properties, pass a name to the HasIndex, which will be used to identify the index in the EF model, and to distinguish it from other indexes over the same properties. // Fluent API modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }, &quot;IX_Names_Ascending&quot;); modelBuilder.Entity&lt;Person&gt;() .HasIndex(p =&gt; new { p.FirstName, p.LastName }, &quot;IX_Names_Descending&quot;) .IsDescending(); // Data Annotations [Index(nameof(FirstName), nameof(LastName), Name = &quot;IX_Names_Ascending&quot;)] [Index(nameof(FirstName), nameof(LastName), Name = &quot;IX_Names_Descending&quot;, AllDescending = true)] public class Person { public int PersonId { get; set; } public string? FirstName { get; set; } public string? LastName { get; set; } } A filtered index is an index that includes a WHERE clause, effectively indexing only a subset of the rows in a table to index only a subset of a column&#8217;s values, reducing the index&#8217;s size and improving both performance and disk space usage. [4] Filtered indexes are not supported by all RDBMS. protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Blog&gt;() .HasIndex(b =&gt; b.Url) .HasFilter(&quot;[Url] IS NOT NULL&quot;); } An index with nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns. [5] protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Post&gt;() .HasIndex(p =&gt; p.Url) .IncludeProperties( p =&gt; new { p.Title, p.PublishedOn }); } Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data isn&#8217;t accessed resulting in fewer disk I/O operations. 3.8. Check Constraints Check constraints are a standard database feature that enforces a condition on all table rows; inserts or updates violating the condition will fail. Check constraints are similar to non-null and unique constraints but allow for arbitrary SQL expressions. modelBuilder.Entity&lt;Product&gt;() .ToTable(b =&gt; { b.HasCheckConstraint(&quot;CK_Prices&quot;, &quot;[Price] &gt; [DiscountedPrice]&quot;); b.HasCheckConstraint(&quot;CK_PositivePrice&quot;, &quot;[Price] &gt; 0&quot;); b.HasCheckConstraint(&quot;CK_PositiveDiscountedPrice&quot;, &quot;[DiscountedPrice] &gt;= 0&quot;); }); 4. Schemas EF Core offers two ways to synchronize a model and database schema: Migrations (model as the source of truth, incrementally applying schema changes) and Reverse Engineering (database as the source of truth, scaffolding a model from the existing schema). 4.1. Migrations The migrations feature in EF Core provides a way to incrementally update the database schema to keep it in sync with the application&#8217;s data model while preserving existing data in the database. When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration describing the updates necessary to keep the database schema in sync. EF Core compares the current model against a snapshot of the old model to determine the differences, and generates migration source files; the files can be tracked in the project&#8217;s source control like any other source file. Once a new migration has been generated, it can be applied to a database in various ways. EF Core records all applied migrations in a special history table, allowing it to know which migrations have been applied and which haven&#8217;t. Create and Drop APIs The EnsureCreatedAsync and EnsureDeletedAsync methods provide a lightweight alternative to Migrations for managing the database schema, which are useful in scenarios when the data is transient and can be dropped when the schema changes, such as during development. EnsureCreatedAsync and Migrations don&#8217;t work well together. // Drop the database if it exists await dbContext.Database.EnsureDeletedAsync(); // Create the database if it doesn&#39;t exist dbContext.Database.EnsureCreatedAsync(); // Get the SQL used by EnsureCreatedAsync var sql = dbContext.Database.GenerateCreateScript(); Install the EF Core command-line tools. # globally dotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design # locally dotnet new tool-manifest dotnet tool install dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Set up a .NET generic host for app startup and lifetime management. # create a new project dotnet new console -o getting-started &amp;&amp; cd getting-started/ # install SQLite provider dotnet add package Microsoft.EntityFrameworkCore.Sqlite # install generic host package dotnet add package Microsoft.Extensions.Hosting // Program.cs var builder = Host.CreateApplicationBuilder(args); builder.Services.AddDbContext&lt;BloggingContext&gt;(options =&gt; options.UseSqlite(&quot;Data Source=:memory:&quot;)); // &quot;:memory:&quot; creates in-memory DB var app = builder.Build(); // Create and Drop APIs // using (var scope = app.Services.CreateScope()) // { // using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); // await context.Database.EnsureDeletedAsync(); // await context.Database.EnsureCreatedAsync(); // } sealed class BloggingContext : DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) { } } public class Blog { public int Id { get; set; } public string? Name { get; set; } } 4.1.1. Managing Migrations As the model changes, migrations are added and removed as part of normal development, and the migration files are checked into the project&#8217;s source control. dotnet ef migrations add // add a migration dotnet ef migrations add InitialCreate EF Core will create a directory called Migrations in the project, and generate some files. $ tree ./Migrations/ ./Migrations/ ├── 20250213080400_InitialCreate.cs (1) ├── 20250213080400_InitialCreate.Designer.cs (2) └── BloggingContextModelSnapshot.cs (3) 1 The main migrations file that contains the operations necessary to apply the migration (in Up) and to revert it (in Down). 2 The migrations metadata file that contains information used by EF. 3 A snapshot of the current model used to determine what changed when adding the next migration. It&#8217;s a good idea to inspect what exactly EF Core generated - and possibly amend it. dotnet ef migrations list $ dotnet ef migrations list Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (9ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT COUNT(*) FROM &quot;sqlite_master&quot; WHERE &quot;name&quot; = &#39;__EFMigrationsHistory&#39; AND &quot;type&quot; = &#39;table&#39;; 20250213080400_InitialCreate (Pending) dotnet ef migrations remove Avoid removing any migrations which have already been applied to production databases. $ dotnet ef migrations remove Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (10ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT COUNT(*) FROM &quot;sqlite_master&quot; WHERE &quot;name&quot; = &#39;__EFMigrationsHistory&#39; AND &quot;type&quot; = &#39;table&#39;; Removing migration &#39;20250213080400_InitialCreate&#39;. Removing model snapshot. Done. 4.1.2. Applying Migrations The recommended way to deploy migrations to a production database is by generating SQL scripts. SQL scripts can be reviewed for accuracy; this is important since applying schema changes to production databases is a potentially dangerous operation that could involve data loss. In some cases, the scripts can be tuned to fit the specific needs of a production database. SQL scripts can be used in conjunction with a deployment technology, and can even be generated as part of a CI process. SQL scripts can be provided to a DBA, and can be managed and archived separately. # generate a SQL script from a blank database to the latest migration dotnet ef migrations script # generate a SQL script from the given migration to the latest migration. dotnet ef migrations script AddNewTables # generate a SQL script from the specified from migration to the specified to migration dotnet ef migrations script AddNewTables AddAuditTable # generate idempotent migrations dotnet ef migrations script --idempotent The EF command-line tools can be productively used to apply migrations during local development and testing, but are not ideal for managing production databases. The SQL commands are applied directly by the tool, without giving the developer a chance to inspect or modify them, which can be dangerous in a production environment. The .NET SDK and the EF tool must be installed on production servers and requires the project&#8217;s source code. # update database to the latest migration dotnet ef database update # update or roll back database to a given migration dotnet ef database update AddNewTables Migration bundles are single-file executables that can be used to apply migrations to a databaseto ddress some of the shortcomings of the SQL script and command-line tools. Executing SQL scripts requires additional tools. The transaction handling and continue-on-error behavior of these tools are inconsistent and sometimes unexpected, which can leave the database in an undefined state if a failure occurs when applying migrations. Bundles can be generated as part of a CI process and easily executed later as part of the deployment process. Bundles are executable without the .NET SDK, EF Tool, or even the .NET Runtime (if self-contained), and they don&#8217;t require source code. # generate a bundle dotnet ef migrations bundle # generate a self-contained bundle for Linux dotnet ef migrations bundle --self-contained -r linux-x64 The resulting executable is named efbundle by default, which can be used to update the database to the latest migration. $ ./efbundle --help Entity Framework Core Migrations Bundle 9.0.2 Usage: efbundle [arguments] [options] [[--] &lt;arg&gt;...]] Arguments: &lt;MIGRATION&gt; The target migration. If &#39;0&#39;, all migrations will be reverted. Defaults to the last migration. Options: --connection &lt;CONNECTION&gt; The connection string to the database. Defaults to the one specified in AddDbContext or OnConfiguring. --version Show version information -h|--help Show help information -v|--verbose Show verbose output. --no-color Don&#39;t colorize output. --prefix-output Prefix output with level. The migrations can be programmatically applied by calling context.Database.MigrateAsync() for local development and testing. var builder = Host.CreateApplicationBuilder(args); // . . . var app = builder.Build(); using (var scope = app.Services.CreateScope()) { using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); await context.Database.MigrateAsync(); } 5. Querying Entity Framework Core uses Language-Integrated Query (LINQ) to query data from the database. EF Core passes a representation of the LINQ query to the database provider. Database providers in turn translate it to database-specific query language (for example, SQL for a relational database). Queries are always executed against the database even if the entities returned in the result already exist in the context. // SELECT [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] var blogs = await context.Blogs.ToListAsync(); // SELECT TOP(1) [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] // WHERE [b].[Id] = 1 var blog = await context.Blogs.SingleOrDefaultAsync(b =&gt; b.Id == 1); // SELECT [b].[Id], [b].[Name], [b].[Url] // FROM [Blogs] AS [b] // WHERE [b].[Url] IS NOT NULL AND [b].[Url] LIKE N&#39;%dotnet%&#39; var filteredBlogs = await context.Blogs .Where(b =&gt; b.Url != null &amp;&amp; b.Url.Contains(&quot;dotnet&quot;)).ToListAsync(); Tracking behavior controls if Entity Framework Core keeps information about an entity instance in its change tracker. If an entity is tracked, any changes detected in the entity are persisted to the database during SaveChanges. EF Core also fixes up navigation properties between the entities in a tracking query result and the entities that are in the change tracker. By default, queries that return entity types are tracking. If EF Core finds an existing entity, then the same instance is returned, which can potentially use less memory and be faster than a no-tracking query. EF Core doesn&#8217;t overwrite current and original values of the entity&#8217;s properties in the entry with the database values. If the entity isn&#8217;t found in the context, EF Core creates a new entity instance and attaches it to the context. Query results don&#8217;t contain any entity which is added to the context but not yet saved to the database. var blog = await context.Blogs.SingleOrDefaultAsync(b =&gt; b.BlogId == 1); blog.Rating = 5; await context.SaveChangesAsync(); 5.1. Tracking vs. no-tracking No-tracking queries are useful when the results are used in a read-only scenario, which are generally quicker to execute because there&#8217;s no need to set up the change tracking information. If the entities retrieved from the database don&#8217;t need to be updated, then a no-tracking query should be used. An individual query can be set to be no-tracking. var blogs = await context.Blogs .AsNoTracking() .ToListAsync(); A no-tracking query also give results based on what&#8217;s in the database disregarding any local changes or added entities. The default tracking behavior can be changed at the context instance level. context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; var blogs = await context.Blogs.ToListAsync(); To make all the queries no-tracking by default. protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder .UseSqlServer(@&quot;Server=(localdb)\\mssqllocaldb;Database=EFQuerying.Tracking&quot;) .UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking); } // You can still add AsTracking to make specific queries tracking. var blogs = await context.Blogs.AsNoTracking().ToListAsync(); 5.2. Pagination Keyset pagination is appropriate for pagination interfaces where the user navigates forwards and backwards, but does not support random access, where the user can jump to any specific page. A common way to implement pagination with databases is to use the Skip and Take LINQ operators (OFFSET and LIMIT in SQL). var posts = await context.Blogs .OrderBy(b =&gt; b.Id) .Skip(20) // page index .Take(10) // page size .ToListAsync(); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (14ms) [Parameters=[@__p_0=&#39;20&#39;, @__p_1=&#39;10&#39;], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT [b].[Id], [b].[Name], [b].[Url] FROM [Blogs] AS [b] ORDER BY [b].[Id] OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY The recommended alternative to offset-based pagination - sometimes called keyset pagination or seek-based pagination - is to simply use a WHERE clause to skip rows, instead of an offset. int lastId = 55; var posts = await context.Blogs .OrderBy(b =&gt; b.Id) .Where(b =&gt; b.Id &gt; lastId) .Take(10) .ToListAsync(); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (136ms) [Parameters=[@__p_1=&#39;10&#39;, @__lastId_0=&#39;55&#39;], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] SELECT TOP(@__p_1) [b].[Id], [b].[Name], [b].[Url] FROM [Blogs] AS [b] WHERE [b].[Id] &gt; @__lastId_0 ORDER BY [b].[Id] 5.3. Indexes A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via a database&#8217;s favorite tool. While indexes speed up queries, they also slow down updates since they need to be kept up-to-date. Avoid defining indexes which aren&#8217;t needed, and consider using index filters to limit the index to a subset of the rows. Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don&#8217;t filter on all the index&#8217;s columns - depending on ordering. For example, an index on columns A and B speeds up queries filtering by A and B as well as queries filtering only by A, but it does not speed up queries only filtering over B. If a query filters by an expression over a column (e.g. price / 2), a simple index cannot be used. However, a stored persisted column can be defined for the expression, and create an index over that. Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression. 5.4. Projections For read-only queries with multiple columns, project into anonymous types, but be aware that updates become more complex since EF Core change tracking relies on entities, though partial updates are possible with advanced techniques. // SELECT TOP(2) [p].[FirstName], [p].[LastName] // FROM [People] AS [p] // WHERE [p].[FirstName] = N&#39;John&#39; var p = await context.People .Select(p =&gt; new { p.FirstName, p.LastName }) // projection .SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); 5.5. SQL queries Entity Framework Core allows dropping down to SQL queries when working with a relational database, which are useful if the query can&#8217;t be expressed using LINQ, or if a LINQ query causes EF to generate inefficient SQL. Basic SQL queries // a LINQ query based on a SQL query var blogs = await context.Blogs .FromSql($&quot;SELECT * FROM dbo.Blogs&quot;) .ToListAsync(); // execute a stored procedure var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogs&quot;) .ToListAsync(); // string interpolation var user = &quot;johndoe&quot;; var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogsForUser {user}&quot;) .ToListAsync(); // named parameters var user = new SqlParameter(&quot;user&quot;, &quot;johndoe&quot;); var blogs = await context.Blogs .FromSql($&quot;EXECUTE dbo.GetMostPopularBlogsForUser @filterByUser={user}&quot;) .ToListAsync(); // executing non-querying SQL var rowsModified = context.Database.ExecuteSql($&quot;UPDATE [Blogs] SET [Url] = NULL&quot;); // executing non-querying SQL var tranMode = context.Database.SqlQueryRaw&lt;string&gt;( &quot;SELECT IIF(@@OPTIONS&amp;2 = 0, &#39;Implicit Transaction Off&#39;, &#39;Implicit Transaction On&#39;) AS TranMode&quot;) .ToList() .FirstOrDefault(); // use the underlying ADO.NET connection directly using var connection = context.Database.GetDbConnection(); connection.Open(); using var command = connection.CreateCommand(); command.CommandText = &quot;SELECT IIF(@@OPTIONS&amp;2 = 0, &#39;Implicit Transaction Off&#39;, &#39;Implicit Transaction On&#39;) AS TranMode&quot;; var tranMode = command.ExecuteScalar() as string; 6. Saving Entity Framework Core (EF Core) supports two approaches for persisting data to the database: change tracking with SaveChanges() and direct execution with ExecuteUpdate and ExecuteDelete. 6.1. SaveChanges, ExecuteUpdate and ExecuteDelete EF Core tracks changes maked to data (adding, updating, or deleting) and SaveChanges() turns those changes into the SQL commands needed to update the database. It is the more common and often preferred method for saving data in EF Core. For large-scale bulk updates, SaveChanges() can be less efficient than direct execution methods. // Add a new entity var newProduct = new Product { Name = &quot;New Widget&quot;, Price = 9.99 }; context.Products.Add(newProduct); // Modify an existing entity var existingProduct = context.Products.Find(1); if (existingProduct != null) { existingProduct.Price = 12.99; } // Remove an entity var productToRemove = context.Products.Find(2); if (productToRemove != null) { context.Products.Remove(productToRemove); } // Save all changes context.SaveChanges(); The ExecuteUpdate and ExecuteDelete offer a direct way, bypassing change tracker, to update or delete data using LINQ queries, which is often more efficient for bulk operations or when needing precise control over the SQL. // Update multiple products context.Products .Where(p =&gt; p.Category == &quot;Electronics&quot;) .ExecuteUpdate(setters =&gt; setters.SetProperty(p =&gt; p.Price, 19.99)); // Delete multiple products context.Products .Where(p =&gt; p.Discontinued) .ExecuteDelete(); 6.2. Transactions By default, if the database provider supports transactions, all changes in a single call to SaveChanges are applied in a transaction. While all relational database providers support transactions, other providers types may throw or no-op when transaction APIs are called. The DbContext.Database API can be used to begin, commit, and rollback transactions. using var context = new BloggingContext(); using var transaction = await context.Database.BeginTransactionAsync(); try { context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/dotnet/&quot; }); await context.SaveChangesAsync(); await transaction.CreateSavepointAsync(&quot;BeforeMoreBlogs&quot;); context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/visualstudio/&quot; }); context.Blogs.Add(new Blog { Url = &quot;https://devblogs.microsoft.com/aspnet/&quot; }); await context.SaveChangesAsync(); await transaction.CommitAsync(); } catch (Exception) { // If a failure occurred, we rollback to the savepoint and can continue the transaction await transaction.RollbackToSavepointAsync(&quot;BeforeMoreBlogs&quot;); // TODO: Handle failure, possibly retry inserting blogs } 6.3. Optimistic concurrency EF Core implements optimistic concurrency, which assumes that concurrency conflicts are relatively rare. In contrast to pessimistic approaches - which lock data up-front and only then proceed to modify it - optimistic concurrency takes no locks, but arranges for the data modification to fail on save if the data has changed since it was queried. Optimistic concurrency failure is reported to the application, which deals with it accordingly, possibly by retrying the entire operation on the new data. In EF Core, optimistic concurrency is implemented by configuring a property as a concurrency token. The concurrency token is loaded and tracked when an entity is queried - just like any other property. Then, when an update or delete operation is performed during SaveChanges(), the value of the concurrency token on the database is compared against the original value read by EF Core. The concurrency token can be managed natively by some databases. The rowversion type shown below is a SQL Server-specific feature; the details on setting up an automatically-updating concurrency token differ across databases, and some databases don&#8217;t support these at all (e.g. SQLite). // Data Annotations public class Person { public int PersonId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } [Timestamp] public byte[] Version { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.Version) .IsRowVersion(); } // UPDATE [People] SET [FirstName] = @p0 // WHERE [PersonId] = @p1 AND [Version] = @p2; using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;(); var person = await context.People.SingleAsync(b =&gt; string.Equals(b.FirstName, &quot;John&quot;)); person.FirstName = &quot;Paul&quot;; await context.SaveChangesAsync(); The concurrency token can also be managed in application code, rather than have the database manage it. // Data Annotations public class Person { public int PersonId { get; set; } public string FirstName { get; set; } [ConcurrencyCheck] public Guid Version { get; set; } } // Fluent API protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;Person&gt;() .Property(p =&gt; p.Version) .IsConcurrencyToken(); } // UPDATE [People] SET [FirstName] = @p0, [Version] = @p1 // WHERE [PersonId] = @p2 AND [Version] = @p3; var person = await context.People.SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); person.FirstName = &quot;Paul&quot;; person.Version = Guid.NewGuid(); // assign it in application whenever persisting changes await context.SaveChangesAsync(); 7. Logging, events, and diagnostics Entity Framework Core (EF Core) contains several mechanisms for generating logs, responding to events, and obtaining diagnostics. Entity Framework Core (EF Core) fully integrates with Microsoft.Extensions.Logging. // simple logging protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =&gt; optionsBuilder.LogTo(Console.WriteLine); // logging to console // .LogTo(message =&gt; Debug.WriteLine(message)); // logging to debug window // .LogTo(new StreamWriter(&quot;log.txt&quot;, append: true).WriteLine); // logging to file // .EnableSensitiveDataLogging(); // logging data values // .EnableDetailedErrors(); // logging more detailed errors. 8. Performance diagnosis Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core, which can be broken down into the following broad categories: Premature optimization is the root of all evil - Donald Knuth. Pure database performance. With relational database, EF translates the application&#8217;s LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently. The right index in the right place can make a world of difference in SQL performance, or rewriting the LINQ query may make EF generate a better SQL query. Network data transfer and roundtrips. As with any networking system, it&#8217;s important to limit the amount of data going back and forth on the wire. Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between the application and the database. EF runtime overhead. Finally, EF itself adds some runtime overhead to database operations: compile the queries from LINQ to SQL (although that should normally be done only once) change tracking adds some overhead (but can be disabled), etc. Cache. To maximize performance, especially for scalable apps, minimize database access through caching, as databases are harder to scale than application servers. 8.1. Identifying slow database commands via logging If a certain query is taking too much time (e.g. because an index is missing), this can be seen discovered by inspecting command execution logs and observing how long they actually take. builder.Logging.AddFilter(&quot;Microsoft.EntityFrameworkCore.Database.Command&quot;, LogLevel.Information); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (99ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] (1) SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version] FROM [People] AS [p] WHERE [p].[FirstName] = N&#39;John&#39; 1 The above command took 99 milliseconds. It&#8217;s recommended to only keep logging on for a short interval of time to gather data - while carefully monitoring an application - or to capture logging data on a pre-production system. Databases typically come with their own tracing and performance analysis tools, which usually provide much richer, database-specific information beyond simple execution times; the actual setup, capabilities and usage vary considerably across databases. 8.2. Correlating database commands to LINQ queries One problem with command execution logging is that it&#8217;s sometimes difficult to correlate SQL queries and LINQ queries: the SQL commands executed by EF can look very different from the LINQ queries from which they were generated. var person = await context.People .TagWith(&quot;This is my spatial query!&quot;) (1) .SingleAsync(b =&gt; b.FirstName == &quot;John&quot;); info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (111ms) [Parameters=[], CommandType=&#39;Text&#39;, CommandTimeout=&#39;30&#39;] -- This is my spatial query! (1) SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version] FROM [People] AS [p] WHERE [p].[FirstName] = N&#39;John&#39; 1 It&#8217;s often worth tagging the major queries of an application to make the command execution logs more immediately readable. 8.3. Inspecting query execution plans To optimize slow queries, analyze their execution plans—database-generated blueprints showing the steps and costs involved in query execution. Databases sometimes generate different query plans depending on actual data in the database. For example, if a table contains only a few rows, a database may choose not to use an index on that table, but to perform a full table scan instead. If analyzing query plans on a test database, always make sure it contains data that is similar to the production system. 9. Dapper Dapper is an open-source micro object-relational mapping (ORM) library for .NET applications, which uses the ADO.NET data providers to work with any existing database technology that supports ADO.NET. [6] dotnet add package Dapper Dapper supports a variety of database providers, including the popular Microsoft SQL Server, Oracle, MySQL, MariaDB, PostgreSQL, SQLite, etc. dotnet add package Microsoft.Data.SqlClient # SQL Server dotnet add package System.Data.SQLite.Core # SQLite IDbConnection connection = ... // 1. Scalar Query (Single Value): var blogCount = await connection.ExecuteScalarAsync&lt;int&gt;(&quot;SELECT COUNT(*) FROM Blogs&quot;); // 2. Row Query (Single Row): var firstBlog = await connection.QuerySingleOrDefaultAsync&lt;Blog&gt;(&quot;SELECT * FROM Blogs ORDER BY Id ASC&quot;); // 3. Multi-Result Query (Multiple Rows): var allBlogs = await connection.QueryAsync&lt;Blog&gt;(&quot;SELECT * FROM Blogs&quot;); // 4. Projection (Selecting Specific Columns): var blogNamesAndUrls = await connection.QueryAsync( &quot;SELECT Name, Url FROM Blogs&quot;, (string name, string url) =&gt; new { Name = name, Url = url }); // Mapping to anonymous type //Or use anonymous type directly var blogNamesAndUrls2 = await connection.QueryAsync( &quot;SELECT Name, Url FROM Blogs&quot;, (dynamic item) =&gt; new { Name = item.Name, Url = item.Url }); // Mapping to anonymous type // 5. Parameterized Query (Preventing SQL Injection): var blogsStartingWithB = await connection.QueryAsync&lt;Blog&gt;( &quot;SELECT * FROM Blogs WHERE Name LIKE @NameStart&quot;, new { NameStart = &quot;B%&quot; }); // named parameter // 6. Dynamic Parameter Query: var parameters = new DynamicParameters(); string sql = &quot;SELECT * FROM Blogs WHERE 1=1 &quot;; // Start with a true condition if (!string.IsNullOrEmpty(&quot;Blog&quot;)) // Example condition { sql += &quot;AND Name LIKE @NamePart &quot;; parameters.Add(&quot;@NamePart&quot;, &quot;%&quot; + &quot;Blog&quot; + &quot;%&quot;); } var dynamicBlogs = await connection.QueryAsync&lt;Blog&gt;(sql, parameters); // Using IN clause with Dynamic Parameters var blogIds = new List&lt;int&gt; { 1, 2, 5 }; // Transform the list of IDs into a format suitable for the IN clause var inClauseParams = new DynamicParameters(); for (var i = 0; i &lt; blogIds.Count; i++) { inClauseParams.Add($&quot;@Id{i}&quot;, blogIds[i]); } var inClauseSql = $&quot;SELECT * FROM Blogs WHERE Id IN ({string.Join(&quot;,&quot;, inClauseParams.ParameterNames)})&quot;; var blogsInList = await connection.QueryAsync&lt;Blog&gt;(inClauseSql, inClauseParams); // 7. Insert, Update, Delete (using parameters): var newBlogId = await connection.ExecuteScalarAsync&lt;int&gt;( &quot;INSERT INTO Blogs (Name, Url) VALUES (@Name, @Url); SELECT SCOPE_IDENTITY();&quot;, new { Name = &quot;Another Blog&quot;, Url = &quot;http://another.com&quot; }); var updatedRows = await connection.ExecuteAsync( &quot;UPDATE Blogs SET Url = @NewUrl WHERE Id = @Id&quot;, new { Id = newBlogId, NewUrl = &quot;http://updated.com&quot; }); var deletedRows = await connection.ExecuteAsync(&quot;DELETE FROM Blogs WHERE Id = @Id&quot;, new { Id = newBlogId }); References [1] https://learn.microsoft.com/en-us/ef/core/ [2] https://learn.microsoft.com/en-us/ef/core/get-started/overview/install [3] https://learn.microsoft.com/en-us/ef/core/what-is-new/nuget-packages [4] https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-filtered-indexes [5] https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-indexes-with-included-columns [6] https://www.learndapper.com/","headline":"Entity Framework in .NET","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2023/02/10/entity-framework-core-in-net/"},"url":"https://blog.codefarm.me/2023/02/10/entity-framework-core-in-net/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Entity Framework in .NET</h1><p class="c-post-meta">10 Feb 2025</p>
  </header>

  <div class="c-post-content">
    <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/ef/core">Entity Framework (EF) Core</a> is a lightweight, extensible, <a href="https://github.com/dotnet/efcore">open source</a> and cross-platform version of the popular Entity Framework data access technology, which can serve as an object-relational mapper (O/RM). <a href="#learn-ef-core">[1]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>With EF, data access is performed using a <a href="https://learn.microsoft.com/en-us/ef/core/modeling/"><em>model</em></a>, which is made up of <em>entity</em> classes and a <a href="https://learn.microsoft.com/en-us/ef/core/dbcontext-configuration/"><em>context</em></a> object that represents a <em>session</em> to query and save data with the database. EF supports the following model development approaches:</p>
<div class="ulist">
<ul>
<li>
<p>Generate a model from an existing database.</p>
</li>
<li>
<p>Hand-code a model to match the database.</p>
<div class="paragraph">
<p>Once a model is created, use <a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/">EF Migrations</a> to create a database from the model, which allow evolving the database as the model changes.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Instances of the entity classes are retrieved from the database using <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/">Language Integrated Query (LINQ)</a>.</p>
</li>
<li>
<p>Data is created, deleted, and modified in the database using instances of the entity classes.</p>
</li>
</ul>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#installing-entity-framework-core">1. Installing Entity Framework Core</a></li>
<li><a href="#dbcontext">2. DbContext</a>
<ul class="sectlevel2">
<li><a href="#lifetime-configuration-and-initialization">2.1. Lifetime, Configuration, and Initialization</a></li>
<li><a href="#dbcontext-pooling">2.2. DbContext Pooling</a></li>
<li><a href="#connection-pooling">2.3. Connection Pooling</a></li>
</ul>
</li>
<li><a href="#model">3. Model</a>
<ul class="sectlevel2">
<li><a href="#entity-types">3.1. Entity Types</a></li>
<li><a href="#entity-properties">3.2. Entity Properties</a></li>
<li><a href="#keys">3.3. Keys</a></li>
<li><a href="#generated-values">3.4. Generated Values</a></li>
<li><a href="#shadow-and-indexer-properties">3.5. Shadow and Indexer Properties</a></li>
<li><a href="#relationships">3.6. Relationships</a>
<ul class="sectlevel3">
<li><a href="#foreign-and-principal-keys">3.6.1. Foreign and Principal keys</a></li>
<li><a href="#navigations">3.6.2. Navigations</a></li>
</ul>
</li>
<li><a href="#indexes">3.7. Indexes</a></li>
<li><a href="#check-constraints">3.8. Check Constraints</a></li>
</ul>
</li>
<li><a href="#schemas">4. Schemas</a>
<ul class="sectlevel2">
<li><a href="#migrations">4.1. Migrations</a>
<ul class="sectlevel3">
<li><a href="#managing-migrations">4.1.1. Managing Migrations</a></li>
<li><a href="#applying-migrations">4.1.2. Applying Migrations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#querying">5. Querying</a>
<ul class="sectlevel2">
<li><a href="#tracking-vs-no-tracking">5.1. Tracking vs. no-tracking</a></li>
<li><a href="#pagination">5.2. Pagination</a></li>
<li><a href="#indexes-2">5.3. Indexes</a></li>
<li><a href="#projections">5.4. Projections</a></li>
<li><a href="#sql-queries">5.5. SQL queries</a></li>
</ul>
</li>
<li><a href="#saving">6. Saving</a>
<ul class="sectlevel2">
<li><a href="#savechanges-executeupdate-and-executedelete">6.1. SaveChanges, ExecuteUpdate and ExecuteDelete</a></li>
<li><a href="#transactions">6.2. Transactions</a></li>
<li><a href="#optimistic-concurrency">6.3. Optimistic concurrency</a></li>
</ul>
</li>
<li><a href="#logging-events-and-diagnostics">7. Logging, events, and diagnostics</a></li>
<li><a href="#performance-diagnosis">8. Performance diagnosis</a>
<ul class="sectlevel2">
<li><a href="#identifying-slow-database-commands-via-logging">8.1. Identifying slow database commands via logging</a></li>
<li><a href="#correlating-database-commands-to-linq-queries">8.2. Correlating database commands to LINQ queries</a></li>
<li><a href="#inspecting-query-execution-plans">8.3. Inspecting query execution plans</a></li>
</ul>
</li>
<li><a href="#dapper">9. Dapper</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="installing-entity-framework-core">1. Installing Entity Framework Core</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity Framework Core (EF Core) is distributed as <a href="https://www.nuget.org/profiles/EntityFramework">NuGet packages</a>, with the necessary packages determined by the <a href="https://learn.microsoft.com/en-us/ef/core/providers">database system</a> (SQL Server, SQLite, etc.) and required EF Core features. <a href="#learn-ef-core-gs-install">[2]</a><a href="#learn-ef-core-nupkg">[3]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure to install the same version of all EF Core packages shipped by Microsoft.</p>
<div class="ulist">
<ul>
<li>
<p>For example, if version <code>5.0.3</code> of <code>Microsoft.EntityFrameworkCore.SqlServer</code> is installed, then all other <code>Microsoft.EntityFrameworkCore.*</code> packages must also be at <code>5.0.3</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Use of tooling for <a href="https://learn.microsoft.com/en-us/ef/core/migrations/">EF Core migrations</a> and <a href="https://learn.microsoft.com/en-us/ef/core/scaffolding/">reverse engineering (scaffolding) from an existing database</a> requires installation of the appropriate <a href="https://learn.microsoft.com/en-us/ef/core/cli/">tooling</a> package:</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Always use the version of the tools package that matches the major version of the runtime packages.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.nuget.org/packages/dotnet-ef/">dotnet-ef</a> for cross-platform command line tooling</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># dotnet ef must be installed as a global or local tool</span>
dotnet tool <span class="nb">install</span> <span class="nt">--global</span> dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore.Design</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># dotnet ef can also be used as a local tool</span>
dotnet new tool-manifest
dotnet tool <span class="nb">install </span>dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore.Design</code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Tools/">Microsoft.EntityFrameworkCore.Tasks</a> for MSBuild tasks allowing build-time integration.</p>
</li>
<li>
<p><a href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Tools/">Microsoft.EntityFrameworkCore.Tools</a> for PowerShell tooling that works in the Visual Studio Package Manager Console</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dbcontext">2. DbContext</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext">DbContext</a> is a combination of the <a href="https://www.martinfowler.com/eaaCatalog/unitOfWork.html">Unit Of Work</a> and <a href="https://martinfowler.com/eaaCatalog/repository.html">Repository patterns</a> that represents a session with the database and can be used to query and save instances of entities.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>DbContext</code> instance, designed for a single unit-of-work, has a typically short lifespan, beginning with its creation and ending with its disposal.</p>
</li>
<li>
<p>A typical unit-of-work when using Entity Framework Core (EF Core) involves:</p>
<div class="ulist">
<ul>
<li>
<p>creating a <code>DbContext</code> instance</p>
</li>
<li>
<p>tracking entities that <a href="https://learn.microsoft.com/en-us/ef/core/querying/tracking">returned from a query</a> or <a href="https://learn.microsoft.com/en-us/ef/core/saving/disconnected-entities">added or attached to the context</a></p>
</li>
<li>
<p>making changes to those tracked entities as needed to implement the business rule</p>
</li>
<li>
<p>calling <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechanges">SaveChanges</a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechangesasync">SaveChangesAsync</a> to persist the changes to the database.</p>
</li>
<li>
<p>disposing the <code>DbContext</code> instance.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A <code>DbContext</code> is not thread-safe and doesn&#8217;t support parallel operations.</p>
<div class="ulist">
<ul>
<li>
<p>Don&#8217;t share contexts between threads.</p>
</li>
<li>
<p>Make sure to <code>await</code> all <code>async</code> calls before continuing to use the context instance.</p>
</li>
<li>
<p>Use separate <code>DbContext</code> instances for concurrent operations</p>
</li>
<li>
<p>Any code that explicitly executes multiple threads in parallel should ensure that <code>DbContext</code> instances aren&#8217;t ever accessed concurrently.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="lifetime-configuration-and-initialization">2.1. Lifetime, Configuration, and Initialization</h3>
<div class="ulist">
<ul>
<li>
<p>Each <code>DbContext</code> instance must be configured to use one and only one database provider using a specific <code>Use*</code> call.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">ApplicationDbContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnConfiguring</span><span class="p">(</span><span class="n">DbContextOptionsBuilder</span> <span class="n">optionsBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// use the SQL Server database provider</span>
        <span class="n">optionsBuilder</span><span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span>
            <span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Other <code>DbContext</code> configuration can be chained either before or after (it makes no difference which) the <code>Use*</code> call.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddDbContext</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;(</span>
    <span class="n">options</span> <span class="p">=&gt;</span> <span class="n">options</span>
        <span class="p">.</span><span class="nf">EnableSensitiveDataLogging</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span>
            <span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">)</span>
        <span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>EF Core can be integrated into applications using dependency injection, typically via the <code>AddDbContext</code> method.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>AddDbContext</code> extension method registers <code>DbContext</code> types with a <em>scoped lifetime</em> by default.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In many web applications, each HTTP request corresponds to a single unit-of-work.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">connectionString</span> <span class="p">=</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">Configuration</span><span class="p">.</span><span class="nf">GetConnectionString</span><span class="p">(</span><span class="s">"DefaultConnection"</span><span class="p">)</span>
        <span class="p">??</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"Connection string 'DefaultConnection' not found."</span><span class="p">);</span>

<span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddDbContext</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;(</span><span class="n">options</span> <span class="p">=&gt;</span>
     <span class="n">options</span><span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span><span class="n">connectionString</span><span class="p">));</span>
<span class="c1">// builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(</span>
<span class="c1">//     options =&gt; options.UseSqlServer(connectionString),</span>
<span class="c1">//     contextLifetime: ServiceLifetime.Scoped,</span>
<span class="c1">//     optionsLifetime: ServiceLifetime.Scoped);</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>ApplicationDbContext</code> class must expose a public constructor with a <code>DbContextOptions&lt;ApplicationDbContext&gt;</code> parameter.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">ApplicationDbContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">ApplicationDbContext</span><span class="p">(</span><span class="n">DbContextOptions</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;</span> <span class="n">options</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>DbContext</code> can be created with <code>new</code>, configured either by overriding <code>OnConfiguring</code> or by passing options to the constructor.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">ApplicationDbContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span><span class="p">?</span> <span class="n">_connectionString</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">ApplicationDbContext</span><span class="p">()</span> <span class="p">:</span> <span class="k">this</span><span class="p">(</span>
        <span class="n">connectionString</span><span class="p">:</span> <span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">ApplicationDbContext</span><span class="p">(</span><span class="kt">string</span> <span class="n">connectionString</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_connectionString</span> <span class="p">=</span> <span class="n">connectionString</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">ApplicationDbContext</span><span class="p">(</span><span class="n">DbContextOptions</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;</span> <span class="n">options</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnConfiguring</span><span class="p">(</span><span class="n">DbContextOptionsBuilder</span> <span class="n">optionsBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_connectionString</span> <span class="k">is</span> <span class="n">not</span> <span class="k">null</span><span class="p">)</span> <span class="n">optionsBuilder</span><span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span><span class="n">_connectionString</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ApplicationDbContext</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ApplicationDbContext</span><span class="p">(</span>
    <span class="n">connectionString</span><span class="p">:</span> <span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">contextOptions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DbContextOptionsBuilder</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span><span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Options</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ApplicationDbContext</span><span class="p">(</span><span class="n">contextOptions</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>In applications where dependency injection doesn&#8217;t provide a suitable <code>DbContext</code> lifetime or multiple units-of-work are needed within a scope, <code>AddDbContextFactory</code> can register a factory for creating individual <code>DbContext</code> instances.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddDbContextFactory</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;(</span>
    <span class="n">options</span> <span class="p">=&gt;</span> <span class="n">options</span><span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span>
        <span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MyService</span><span class="p">(</span><span class="n">IDbContextFactory</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;</span> <span class="n">contextFactory</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoWorkAsync</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">).</span><span class="nf">Select</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="n">contextFactory</span><span class="p">.</span><span class="nf">CreateDbContext</span><span class="p">();</span>
            <span class="c1">// ...</span>
            <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="dbcontext-pooling">2.2. DbContext Pooling</h3>
<div class="paragraph">
<p>While generally lightweight, creating and disposing <code>DbContext</code> instances can introduce overhead in high-performance scenarios, which EF Core mitigates through context pooling, reusing instances from an internal pool to minimize setup costs at program startup, rather than continuously.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Note that context pooling is orthogonal to database connection pooling, which is managed at a lower level in the database driver.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>To enable context pooling, simply replace <code>AddDbContext</code> with <code>AddDbContextPool</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddDbContextPool</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;(</span>
    <span class="n">options</span> <span class="p">=&gt;</span> <span class="n">options</span><span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span>
        <span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">),</span>
    <span class="n">poolSize</span><span class="p">:</span> <span class="m">1024</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>poolSize</code> parameter of <code>AddDbContextPool</code> sets the maximum number of instances retained by the pool (defaults to <code>1024</code>).</p>
</li>
<li>
<p>Once <code>poolSize</code> is exceeded, new context instances are not cached and EF falls back to the non-pooling behavior of creating instances on demand.</p>
</li>
</ul>
</div>
</li>
<li>
<p>To use context pooling without dependency injection, initialize a <code>PooledDbContextFactory</code> and request context instances from it:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">options</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DbContextOptionsBuilder</span><span class="p">&lt;</span><span class="n">PooledBloggingContext</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span><span class="s">@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0"</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Options</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">factory</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PooledDbContextFactory</span><span class="p">&lt;</span><span class="n">PooledBloggingContext</span><span class="p">&gt;(</span><span class="n">options</span><span class="p">);</span>

<span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="n">factory</span><span class="p">.</span><span class="nf">CreateDbContext</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">allPosts</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Posts</span><span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="connection-pooling">2.3. Connection Pooling</h3>
<div class="paragraph">
<p>With most databases, a long-lived connection is required for performing database operations, and such connections can be expensive to open and close.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>EF Core relies on the underlying database driver (e.g., ADO.NET) for <em>connection pooling</em>, a client-side mechanism that reuses database connections to reduce the overhead of opening and closing connections repeatedly.</p>
</li>
<li>
<p>While generally enabled by default and configurable at the driver level (e.g., via connection string), connection pooling is separate from EF Core&#8217;s context pooling, which optimizes <code>DbContext</code> instance reuse.</p>
</li>
<li>
<p>EF Core typically opens and closes connections around each operation, returning them to the pool quickly.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="model">3. Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>EF Core uses a metadata <em>model</em> to describe how the application&#8217;s entity types are mapped to the underlying database.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
EF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>The model is built using a set of <em>conventions</em> - heuristics that look for common patterns.</p>
</li>
<li>
<p>The model can then be customized to override the configuration performed by conventions using <em>mapping attributes</em> (a.k.a., <em>data annotations</em>) and/or calls to the <code>ModelBuilder</code> methods (a.k.a., <em>fluent API</em>) in <code>OnModelCreating</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Fluent API configuration has the highest precedence and will override conventions and data annotations.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">BloggingContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;</span> <span class="n">Blogs</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">BloggingContext</span><span class="p">(</span><span class="n">DbContextOptions</span><span class="p">&lt;</span><span class="n">BloggingContext</span><span class="p">&gt;</span> <span class="n">options</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">)</span>
           <span class="p">.</span><span class="nf">IsRequired</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Data annotations will override conventions, but will be overridden by Fluent API configuration.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">BloggingContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;</span> <span class="n">Blogs</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">BloggingContext</span><span class="p">(</span><span class="n">DbContextOptions</span><span class="p">&lt;</span><span class="n">BloggingContext</span><span class="p">&gt;</span> <span class="n">options</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">[</span><span class="nf">Table</span><span class="p">(</span><span class="s">"Blogs"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="n">Required</span><span class="p">]</span>
    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>EF Core model building conventions are classes that contain logic that is triggered based on changes being made to the model as it is being built.</p>
<div class="ulist">
<ul>
<li>
<p>EF Core includes many model building conventions that are enabled by default, which can be found in the list of classes that implement the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.conventions.iconvention">IConvention</a> interface.</p>
</li>
<li>
<p>Applications can remove or replace any of these conventions, as well as add new custom conventions that apply configuration for patterns that are not recognized by EF out of the box.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">BloggingContext</span><span class="p">(</span><span class="n">DbContextOptions</span><span class="p">&lt;</span><span class="n">BloggingContext</span><span class="p">&gt;</span> <span class="n">options</span><span class="p">)</span> <span class="p">:</span> <span class="nf">DbContext</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">ConfigureConventions</span><span class="p">(</span><span class="n">ModelConfigurationBuilder</span> <span class="n">configurationBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">configurationBuilder</span><span class="p">.</span><span class="n">Conventions</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ForeignKeyIndexConvention</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>While most configuration is data store-agnostic, providers can offer store-specific configurations and ignore unsupported ones.</p>
</li>
<li>
<p>The model builder debug view can be accessed in the debugger or directly from code.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Model</span><span class="p">.</span><span class="nf">ToDebugString</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">Model:
  EntityType: Blog
    Properties:
      BlogId (int) Required PK AfterSave:Throw ValueGenerated.OnAdd
      Url (string) Required
    Keys:
      BlogId PK</span></code></pre>
</div>
</div>
</li>
<li>
<p>A <code>DbSet</code> included in a <code>DbContext</code> registers its type as an <em>entity</em> in EF Core&#8217;s model, enabling EF Core to read/write instances to/from the database and, for relational databases, create tables via migrations.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="entity-types">3.1. Entity Types</h3>
<div class="ulist">
<ul>
<li>
<p>A model includes entities through <code>DbSet</code> properties exposed on the context, specified in the <code>OnModelCreating</code>, and any types that are found by recursively exploring the navigation properties of other discovered entity types.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MyContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="c1">// exposed in a DbSet property</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;</span> <span class="n">Blogs</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// explicitly specified in OnModelCreating</span>
        <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">AuditEntry</span><span class="p">&gt;();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// discovered via the Blog.Posts navigation property.</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;</span> <span class="n">Posts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Post</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PostId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Content</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">Blog</span> <span class="n">Blog</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">AuditEntry</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">AuditEntryId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Username</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Action</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>To exclude types from the model:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="n">NotMapped</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">BlogMetadata</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">LoadedFromDatabase</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Ignore</span><span class="p">&lt;</span><span class="n">BlogMetadata</span><span class="p">&gt;();</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>To exclude from migrations:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">IdentityUser</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">ToTable</span><span class="p">(</span><span class="s">"AspNetUsers"</span><span class="p">,</span> <span class="n">t</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="nf">ExcludeFromMigrations</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>By convention, each entity type will be set up to map to a database table with the same name as the <code>DbSet</code> property that exposes the entity. If no <code>DbSet</code> exists for the given entity, the class name is used.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Table</span><span class="p">(</span><span class="s">"blogs"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">ToTable</span><span class="p">(</span><span class="s">"blogs"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>When using a relational database, tables are by convention created in the database&#8217;s default schema.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Table</span><span class="p">(</span><span class="s">"blogs"</span><span class="p">,</span> <span class="n">Schema</span> <span class="p">=</span> <span class="s">"blogging"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">ToTable</span><span class="p">(</span><span class="s">"blogs"</span><span class="p">,</span> <span class="n">schema</span><span class="p">:</span> <span class="s">"blogging"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// define the default schema at the model level</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="nf">HasDefaultSchema</span><span class="p">(</span><span class="s">"blogging"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Entity types can be mapped to database views using the Fluent API.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">ToView</span><span class="p">(</span><span class="s">"blogsView"</span><span class="p">,</span> <span class="n">schema</span><span class="p">:</span> <span class="s">"blogging"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>It&#8217;s possible to map an entity type to a parameterless table-valued function (TVF) instead of a table in the database.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">BlogWithMultiplePosts</span><span class="p">&gt;().</span><span class="nf">HasNoKey</span><span class="p">().</span><span class="nf">ToFunction</span><span class="p">(</span><span class="s">"BlogsWithMultiplePosts"</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>An arbitrary text comment can be set on the database table to document the schema in the database.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Comment</span><span class="p">(</span><span class="s">"Blogs managed on the website"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;().</span><span class="nf">ToTable</span><span class="p">(</span>
        <span class="n">tableBuilder</span> <span class="p">=&gt;</span> <span class="n">tableBuilder</span><span class="p">.</span><span class="nf">HasComment</span><span class="p">(</span><span class="s">"Blogs managed on the website"</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Shared-type entity types (those using the same CLR type) require a unique name for configuration and usage, necessitating a <code>Set</code> call for the corresponding <code>DbSet</code> property.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">class</span> <span class="nc">MyContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">Blogs</span> <span class="p">=&gt;</span> <span class="n">Set</span><span class="p">&lt;</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;(</span><span class="s">"Blog"</span><span class="p">);</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">modelBuilder</span><span class="p">.</span><span class="n">SharedTypeEntity</span><span class="p">&lt;</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;(</span>
            <span class="s">"Blog"</span><span class="p">,</span> <span class="n">bb</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">bb</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="s">"BlogId"</span><span class="p">);</span>
                <span class="n">bb</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">"Url"</span><span class="p">);</span>
                <span class="n">bb</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="n">DateTime</span><span class="p">&gt;(</span><span class="s">"LastUpdated"</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="entity-properties">3.2. Entity Properties</h3>
<div class="paragraph">
<p>Each entity type in a model has properties that EF Core reads and writes from the database; in relational databases, these properties map to table columns.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By convention, all public properties with a getter and a setter will be included in the model.</p>
<div class="paragraph">
<p>Specific properties can be excluded as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="n">NotMapped</span><span class="p">]</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">LoadedFromDatabase</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Ignore</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">LoadedFromDatabase</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>By convention, when using a relational database, entity properties are mapped to table columns having the same name as the property.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">Column</span><span class="p">(</span><span class="s">"blog_id"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasColumnName</span><span class="p">(</span><span class="s">"blog_id"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>When using a relational database, the database provider selects a data type based on the .NET type of the property.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="nf">Column</span><span class="p">(</span><span class="n">TypeName</span> <span class="p">=</span> <span class="s">"varchar(200)"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="nf">Column</span><span class="p">(</span><span class="n">TypeName</span> <span class="p">=</span> <span class="s">"decimal(5, 2)"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Rating</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;(</span>
        <span class="n">eb</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">eb</span><span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">).</span><span class="nf">HasColumnType</span><span class="p">(</span><span class="s">"varchar(200)"</span><span class="p">);</span>
            <span class="n">eb</span><span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Rating</span><span class="p">).</span><span class="nf">HasColumnType</span><span class="p">(</span><span class="s">"decimal(5, 2)"</span><span class="p">);</span>
        <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Configuring a maximum length provides a hint to the database provider about the appropriate column data type to choose for a given array data type property, such as <code>string</code> and <code>byte[]</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="nf">MaxLength</span><span class="p">(</span><span class="m">500</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasMaxLength</span><span class="p">(</span><span class="m">500</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Some relational data types support the precision and scale facets; these control what values can be stored, and how much storage is needed for the column.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">[</span><span class="nf">Precision</span><span class="p">(</span><span class="m">14</span><span class="p">,</span> <span class="m">2</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Score</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">[</span><span class="nf">Precision</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">LastUpdated</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Score</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasPrecision</span><span class="p">(</span><span class="m">14</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>

    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">LastUpdated</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasPrecision</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Text properties are configured as Unicode by default.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Book</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="nf">Unicode</span><span class="p">(</span><span class="k">false</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">MaxLength</span><span class="p">(</span><span class="m">22</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Isbn</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Book</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Isbn</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsUnicode</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>When mapping to a relational database schema, required properties are created as non-nullable columns, and optional properties are created as nullable columns.</p>
<div class="ulist">
<ul>
<li>
<p>A property is considered optional if it is valid for it to contain <code>null</code>.</p>
</li>
<li>
<p>If <code>null</code> is not a valid value to be assigned to a property then it is considered to be a required property.</p>
</li>
<li>
<p>By convention, a property whose .NET type can contain <code>null</code> will be configured as optional, whereas properties whose .NET type cannot contain <code>null</code> will be configured as required.</p>
</li>
<li>
<p>If nullable reference types are disabled, all properties with .NET reference types are configured as optional by convention (for example, <code>string</code>).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Without NRT</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomerWithoutNullableReferenceTypes</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="n">Required</span><span class="p">]</span> <span class="c1">// Data annotations needed to configure as required</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="n">Required</span><span class="p">]</span> <span class="c1">// Data annotations needed to configure as required</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">MiddleName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Optional by convention</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Without NRT with Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">CustomerWithoutNullableReferenceTypes</span><span class="p">&gt;(</span><span class="n">c</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">c</span><span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">FirstName</span><span class="p">).</span><span class="nf">IsRequired</span><span class="p">();</span>
        <span class="n">c</span><span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">LastName</span><span class="p">).</span><span class="nf">IsRequired</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>If nullable reference types are enabled, properties will be configured based on the C# nullability of their .NET type: <code>string?</code> will be configured as optional, but <code>string</code> will be configured as required.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// With NRT</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Customer</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Required by convention</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Required by convention</span>
    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">MiddleName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Optional by convention</span>

    <span class="c1">// Note the following use of constructor binding, which avoids compiled warnings</span>
    <span class="c1">// for uninitialized non-nullable properties.</span>
    <span class="k">public</span> <span class="nf">Customer</span><span class="p">(</span><span class="kt">string</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">,</span> <span class="kt">string</span><span class="p">?</span> <span class="n">middleName</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FirstName</span> <span class="p">=</span> <span class="n">firstName</span><span class="p">;</span>
        <span class="n">LastName</span> <span class="p">=</span> <span class="n">lastName</span><span class="p">;</span>
        <span class="n">MiddleName</span> <span class="p">=</span> <span class="n">middleName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A collation can be defined on text columns, determining how they are compared and ordered.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// column level</span>
<span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Customer</span><span class="p">&gt;().</span><span class="nf">Property</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Name</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">UseCollation</span><span class="p">(</span><span class="s">"SQL_Latin1_General_CP1_CI_AS"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// database level</span>
<span class="n">modelBuilder</span><span class="p">.</span><span class="nf">UseCollation</span><span class="p">(</span><span class="s">"SQL_Latin1_General_CP1_CI_AS"</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="keys">3.3. Keys</h3>
<div class="paragraph">
<p>A key (primary key or alternate key) serves as a unique identifier for each entity instance.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By convention, a property named <code>Id</code> or <code>&lt;type name&gt;Id</code> will be configured as the primary key of an entity.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="hll">    <span class="k">public</span> <span class="kt">string</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Make</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Model</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">internal</span> <span class="k">class</span> <span class="nc">Truck</span>
<span class="p">{</span>
<span class="hll">    <span class="k">public</span> <span class="kt">string</span> <span class="n">TruckId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Make</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Model</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>An entity&#8217;s primary key can also be explicitly configured using a single property or a composite key (multiple properties).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">internal</span> <span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Key</span><span class="p">]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LicensePlate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Make</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Model</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Car</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasKey</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">LicensePlate</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">PrimaryKey</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">State</span><span class="p">),</span> <span class="k">nameof</span><span class="p">(</span><span class="n">LicensePlate</span><span class="p">))]</span>
<span class="k">internal</span> <span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">State</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LicensePlate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Make</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Model</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Car</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasKey</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">State</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">LicensePlate</span> <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>By convention, on relational databases primary keys are created with the name <code>PK_&lt;type name&gt;</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasKey</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasName</span><span class="p">(</span><span class="s">"PrimaryKey_BlogId"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>An alternate key serves as an alternate unique identifier for each entity instance in addition to the primary key; it can be used as the target of a relationship.</p>
<div class="ulist">
<ul>
<li>
<p>When using a relational database this maps to the concept of a unique index/constraint on the alternate key column(s) and one or more foreign key constraints that reference the column(s).</p>
</li>
<li>
<p>For simple uniqueness constraints, use a unique index; alternate keys in EF Core are read-only and can also serve as foreign key targets.</p>
</li>
<li>
<p>Alternate keys are usually created automatically by EF Core when a non-primary key property is used as the target of a relationship, so manual configuration is typically unnecessary.</p>
</li>
<li>
<p>By convention, the index and constraint that are introduced for an alternate key will be named <code>AK_&lt;type name&gt;_&lt;property name&gt;</code> (for composite alternate keys <code>&lt;property name&gt;</code> becomes an underscore separated list of property names).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="generated-values">3.4. Generated Values</h3>
<div class="paragraph">
<p>Database columns can have their values generated in various ways: primary key columns are frequently auto-incrementing integers, other columns have default or computed values, etc.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On relational databases, a column can be configured with a default value; if a row is inserted without a value for that column, the default value will be used.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// a default value</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Rating</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasDefaultValue</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// a SQL fragment</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Created</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasDefaultValueSql</span><span class="p">(</span><span class="s">"getdate()"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>On most relational databases, a column can be configured to have its value computed in the database, typically with an expression referring to other columns:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// a virtual computed column</span>
<span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">DisplayName</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">HasComputedColumnSql</span><span class="p">(</span><span class="s">"[LastName] + ', ' + [FirstName]"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// // a physical computed column</span>
<span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">NameLength</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">HasComputedColumnSql</span><span class="p">(</span><span class="s">"LEN([LastName]) + LEN([FirstName])"</span><span class="p">,</span> <span class="n">stored</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>By convention, non-composite primary keys of type short, int, long, or Guid are set up to have values generated for inserted entities if a value isn&#8217;t provided by the application.</p>
</li>
<li>
<p>A property can be explicitly configured to have its value generated on add or update:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="nf">DatabaseGenerated</span><span class="p">(</span><span class="n">DatabaseGeneratedOption</span><span class="p">.</span><span class="n">Identity</span><span class="p">)]</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">Inserted</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Fluent API</span>
<span class="c1">// protected override void OnModelCreating(ModelBuilder modelBuilder)</span>
<span class="c1">// {</span>
<span class="c1">//     modelBuilder.Entity&lt;Blog&gt;()</span>
<span class="c1">//         .Property(b =&gt; b.Inserted)</span>
<span class="c1">//         .ValueGeneratedOnAdd();</span>
<span class="c1">// }</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="nf">DatabaseGenerated</span><span class="p">(</span><span class="n">DatabaseGeneratedOption</span><span class="p">.</span><span class="n">Computed</span><span class="p">)]</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">LastUpdated</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Fluent API</span>
<span class="c1">// protected override void OnModelCreating(ModelBuilder modelBuilder)</span>
<span class="c1">// {</span>
<span class="c1">//     modelBuilder.Entity&lt;Blog&gt;()</span>
<span class="c1">//         .Property(b =&gt; b.LastUpdated)</span>
<span class="c1">//         .ValueGeneratedOnAddOrUpdate();</span>
<span class="c1">// }</span></code></pre>
</div>
</div>
</li>
<li>
<p>Unlike with default values or computed columns, how the values are to be generated depends on the database provider being used.</p>
<div class="ulist">
<ul>
<li>
<p>Database providers may automatically set up value generation for some property types, but others may require to manually set up how the value is generated.</p>
</li>
<li>
<p>For example, on SQL Server, when a <code>GUID</code> property is configured as a primary key, the provider automatically performs value generation client-side, using an algorithm to generate optimal sequential <code>GUID</code> values.</p>
</li>
<li>
<p>Similarly, <code>byte[]</code> properties that are configured as generated on add or update and marked as concurrency tokens are set up with the rowversion data type, so that values are automatically generated in the database.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A common request is to have a database column which contains the date/time for when the row was first inserted (value generated on add), or for when it was last updated (value generated on add or update).</p>
<div class="ulist">
<ul>
<li>
<p>Configuring a date/time column to have the <em>creation timestamp</em> of the row is usually a matter of configuring a default value with the appropriate SQL function.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Created</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasDefaultValueSql</span><span class="p">(</span><span class="s">"getdate()"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Although stored computed columns seem like a good solution for managing last-updated timestamps, databases usually don&#8217;t allow specifying functions such as <code>GETDATE()</code> in a computed column. As an alternative, set up a database trigger to achieve the same effect:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">CREATE</span> <span class="n">TRIGGER</span> <span class="p">[</span><span class="n">dbo</span><span class="p">].[</span><span class="n">Blogs_UPDATE</span><span class="p">]</span> <span class="n">ON</span> <span class="p">[</span><span class="n">dbo</span><span class="p">].[</span><span class="n">Blogs</span><span class="p">]</span>
    <span class="n">AFTER</span> <span class="n">UPDATE</span>
<span class="n">AS</span>
<span class="n">BEGIN</span>
    <span class="n">SET</span> <span class="n">NOCOUNT</span> <span class="n">ON</span><span class="p">;</span>

    <span class="nf">IF</span> <span class="p">((</span><span class="n">SELECT</span> <span class="nf">TRIGGER_NESTLEVEL</span><span class="p">())</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">)</span> <span class="n">RETURN</span><span class="p">;</span>

    <span class="n">UPDATE</span> <span class="n">B</span>
    <span class="n">SET</span> <span class="n">LastUpdated</span> <span class="p">=</span> <span class="nf">GETDATE</span><span class="p">()</span>
    <span class="n">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Blogs</span> <span class="n">AS</span> <span class="n">B</span>
    <span class="n">INNER</span> <span class="n">JOIN</span> <span class="n">INSERTED</span> <span class="n">AS</span> <span class="n">I</span>
        <span class="n">ON</span> <span class="n">B</span><span class="p">.</span><span class="n">BlogId</span> <span class="p">=</span> <span class="n">I</span><span class="p">.</span><span class="n">BlogId</span>
<span class="n">END</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>To override value generation with an explicit value, simply set the property to any value that is not the CLR default value for that property&#8217;s type (<code>null</code> for string, <code>0</code> for int, <code>Guid.Empty</code> for <code>Guid</code>, etc.).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">product</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Product</span>
<span class="p">{</span>
    <span class="c1">// To override the auto-generated CreatedDate, set it to something other than DateTime.MinValue:</span>
    <span class="n">CreatedDate</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="nf">AddYears</span><span class="p">(-</span><span class="m">10</span><span class="p">)</span>
<span class="p">};</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">AddAsync</span><span class="p">(</span><span class="n">product</span><span class="p">);</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Guid</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Will be auto-generated by default (often)</span>
    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// modelBuilder.Entity&lt;Product&gt;().Property(p =&gt; p.CreatedDate).HasDefaultValueSql("getdate()");</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">CreatedDate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Will be auto-generated (often)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>To disable value generation that has been set up by convention.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">DatabaseGenerated</span><span class="p">(</span><span class="n">DatabaseGeneratedOption</span><span class="p">.</span><span class="n">None</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">ValueGeneratedNever</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="shadow-and-indexer-properties">3.5. Shadow and Indexer Properties</h3>
<div class="paragraph">
<p>Shadow properties are properties that aren&#8217;t defined in .NET entity class but are defined for that entity type in the EF Core model, which are maintained purely in the Change Tracker and are useful when there&#8217;s data in the database that shouldn&#8217;t be exposed on the mapped entity types.</p>
</div>
<div class="paragraph">
<p>Indexer properties are entity type properties, which are backed by an indexer in .NET entity class to add additional properties to the entity type without changing the CLR class.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Shadow properties are most often used for foreign key properties, where they are added to the model by convention when no foreign key property has been found by convention or configured explicitly.</p>
<div class="ulist">
<ul>
<li>
<p>The relationship is represented by navigation properties, but in the database it is enforced by a foreign key constraint, and the value for the foreign key column is stored in the corresponding shadow property.</p>
</li>
<li>
<p>The property will be named <code>&lt;navigation property name&gt;&lt;principal key property name&gt;</code> (the navigation on the dependent entity, which points to the principal entity, is used for the naming).</p>
</li>
<li>
<p>If the principal key property name starts with the name of the navigation property, then the name will just be <code>&lt;principal key property name&gt;</code>.</p>
</li>
<li>
<p>If there is no navigation property on the dependent entity, then the principal type name concatenated with the primary or alternate key property name is used in its place <code>&lt;principal type name&gt;&lt;principal key property name&gt;</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">class</span> <span class="nc">MyContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;</span> <span class="n">Blogs</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;</span> <span class="n">Posts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;</span> <span class="n">Posts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Post</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PostId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Content</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Since there is no CLR property which holds the foreign</span>
    <span class="c1">// key for this relationship, a shadow property is created.</span>
    <span class="k">public</span> <span class="n">Blog</span> <span class="n">Blog</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">post</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Post</span> <span class="p">{</span> <span class="n">Blog</span> <span class="p">=</span> <span class="k">new</span><span class="p">()</span> <span class="p">};</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">AddAsync</span><span class="p">(</span><span class="n">post</span><span class="p">);</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">blogId</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">context</span><span class="p">.</span><span class="nf">Entry</span><span class="p">(</span><span class="n">post</span><span class="p">).</span><span class="nf">Property</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">Blog</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)).</span><span class="n">CurrentValue</span><span class="p">!;</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">Blog</span><span class="p">.</span><span class="n">BlogId</span> <span class="p">==</span> <span class="n">blogId</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Shadow properties can be configured using the Fluent API to call the string overload of <code>Property&lt;TProperty&gt;(String)</code> to chain any of the configuration calls for other properties.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">class</span> <span class="nc">MyContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;</span> <span class="n">Blogs</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
            <span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="n">DateTime</span><span class="p">&gt;(</span><span class="s">"LastUpdated"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Shadow property values can be referenced in LINQ queries via the <code>EF.Property</code> static method or obtained and changed through the <code>ChangeTracker</code> API.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">OrderBy</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">EF</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="n">DateTime</span><span class="p">&gt;(</span><span class="n">b</span><span class="p">,</span> <span class="s">"LastUpdated"</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">context</span><span class="p">.</span><span class="nf">Entry</span><span class="p">(</span><span class="n">myBlog</span><span class="p">).</span><span class="nf">Property</span><span class="p">(</span><span class="s">"LastUpdated"</span><span class="p">).</span><span class="n">CurrentValue</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Indexer properties can be configured using the Fluent API to call the method <code>IndexerProperty</code> to chain any of the configuration calls for other properties.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">class</span> <span class="nc">MyContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;</span> <span class="n">Blogs</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;().</span><span class="n">IndexerProperty</span><span class="p">&lt;</span><span class="n">DateTime</span><span class="p">&gt;(</span><span class="s">"LastUpdated"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="n">_data</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;();</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="k">this</span><span class="p">[</span><span class="kt">string</span> <span class="n">key</span><span class="p">]</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Indexer properties can be referenced in LINQ queries via <code>the EF.Property</code> static method or by using the CLR indexer property.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">blog</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Blog</span><span class="p">();</span>
<span class="n">blog</span><span class="p">[</span><span class="s">"LastUpdated"</span><span class="p">]</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">AddAsync</span><span class="p">(</span><span class="n">blog</span><span class="p">);</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">lastUpdated</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">EF</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="n">DateTime</span><span class="p">&gt;(</span><span class="n">b</span><span class="p">,</span> <span class="s">"LastUpdated"</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">FirstAsync</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">lastUpdated</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Entity types that contain only indexer properties are known as property bag entity types.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">internal</span> <span class="k">class</span> <span class="nc">MyContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">Blogs</span> <span class="p">=&gt;</span> <span class="n">Set</span><span class="p">&lt;</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;(</span><span class="s">"Blog"</span><span class="p">);</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">modelBuilder</span><span class="p">.</span><span class="n">SharedTypeEntity</span><span class="p">&lt;</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;(</span>
            <span class="s">"Blog"</span><span class="p">,</span> <span class="n">bb</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">bb</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="s">"BlogId"</span><span class="p">);</span>
                <span class="n">bb</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">"Url"</span><span class="p">);</span>
                <span class="n">bb</span><span class="p">.</span><span class="n">Property</span><span class="p">&lt;</span><span class="n">DateTime</span><span class="p">&gt;(</span><span class="s">"LastUpdated"</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="relationships">3.6. Relationships</h3>
<div class="ulist">
<ul>
<li>
<p>A relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model.</p>
</li>
<li>
<p>A <em>one-to-many relationship</em> is used when a single entity is associated with any number of other entities.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">Blogs</span><span class="p">]</span> <span class="p">(</span>
    <span class="p">[</span><span class="n">Id</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_Blogs</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">Posts</span><span class="p">]</span> <span class="p">(</span>
    <span class="p">[</span><span class="n">Id</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">,</span>
    <span class="p">[</span><span class="n">BlogId</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_Posts</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">Id</span><span class="p">]),</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">FK_Posts_Blogs_BlogId</span><span class="p">]</span>
        <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">BlogId</span><span class="p">])</span> <span class="k">REFERENCES</span> <span class="p">[</span><span class="n">Blogs</span><span class="p">]</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="p">[</span><span class="n">IX_Posts_BlogId</span><span class="p">]</span> <span class="k">ON</span> <span class="p">[</span><span class="n">Posts</span><span class="p">]</span> <span class="p">([</span><span class="n">BlogId</span><span class="p">]);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Principal (parent)</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">public</span> <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;</span> <span class="n">Posts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="p">[];</span> <span class="c1">// Collection navigation containing dependents </span><i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span>

<span class="c1">// Dependent (child)</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Post</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Required foreign key property </span><i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">public</span> <span class="n">Blog</span> <span class="n">Blog</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">null</span><span class="p">!;</span> <span class="c1">// Required reference navigation to principal </span><i class="conum" data-value="4"></i><b>(4)</b>
    <span class="c1">// public int? BlogId { get; set; } // Optional foreign key property</span>
    <span class="c1">// public Blog? Blog { get; set; } // Optional reference navigation to principal</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A one-to-many relationship is made up from:</p>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>One or more <em>primary or alternate key</em> properties on the principal entity; that is the "one" end of the relationship.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>One or more <em>foreign key</em> properties on the dependent entity; that is the "many" end of the relationship.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Optionally, a <em>collection navigation</em> on the principal entity referencing the dependent entities.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Optionally, a <em>reference navigation</em> on the dependent entity referencing the principal entity.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasMany</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Posts</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">WithOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Blog</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasForeignKey</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsRequired</span><span class="p">();</span>
        <span class="c1">// .IsRequired(false);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>As with all relationships, it is exactly equivalent to start with dependent entity type (<code>Post</code>) and use <code>HasOne</code> followed by <code>WithMany</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Blog</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">WithMany</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Posts</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasForeignKey</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsRequired</span><span class="p">();</span>
        <span class="c1">// .IsRequired(false);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A <em>one-to-one relationship</em> is used when one entity is associated with at most one other entity.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">Blogs</span><span class="p">]</span> <span class="p">(</span>
    <span class="p">[</span><span class="n">Id</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_Blogs</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">BlogHeader</span><span class="p">]</span> <span class="p">(</span>
    <span class="p">[</span><span class="n">Id</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">,</span>
    <span class="p">[</span><span class="n">BlogId</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_BlogHeader</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">Id</span><span class="p">]),</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">FK_BlogHeader_Blogs_BlogId</span><span class="p">]</span>
        <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">BlogId</span><span class="p">])</span> <span class="k">REFERENCES</span> <span class="p">[</span><span class="n">Blogs</span><span class="p">]</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">UNIQUE</span> <span class="k">INDEX</span> <span class="p">[</span><span class="n">IX_BlogHeader_BlogId</span><span class="p">]</span> <span class="k">ON</span> <span class="p">[</span><span class="n">BlogHeader</span><span class="p">]</span> <span class="p">([</span><span class="n">BlogId</span><span class="p">]);</span> <span class="c1">-- UNIQUE INDEX</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Principal (parent)</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">public</span> <span class="n">BlogHeader</span><span class="p">?</span> <span class="n">Header</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Reference navigation to dependent </span><i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span>

<span class="c1">// Dependent (child)</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">BlogHeader</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Required foreign key property </span><i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">public</span> <span class="n">Blog</span> <span class="n">Blog</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">null</span><span class="p">!;</span> <span class="c1">// Required reference navigation to principal </span><i class="conum" data-value="4"></i><b>(4)</b>
    <span class="c1">// public int? BlogId { get; set; } // Optional foreign key property</span>
    <span class="c1">// public Blog? Blog { get; set; } // Optional reference navigation to principal</span>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A one-to-many relationship is made up from:</p>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>One or more <em>primary or alternate key</em> properties on the principal entity; that is the "one" end of the relationship.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>One or more <em>foreign key</em> properties on the dependent entity; that is the "many" end of the relationship.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Optionally, a <em>reference navigation</em> on the principal entity referencing the dependent entities.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Optionally, a <em>reference navigation</em> on the dependent entity referencing the principal entity.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>For cases where the navigations, foreign key, or required/optional nature of the relationship are not discovered by convention, these things can be configured explicitly.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Header</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">WithOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Blog</span><span class="p">)</span>
        <span class="p">.</span><span class="n">HasForeignKey</span><span class="p">&lt;</span><span class="n">BlogHeader</span><span class="p">&gt;(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsRequired</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>As with all relationships, it is exactly equivalent to start with dependent entity type (<code>BlogHeader</code>) instead.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">BlogHeader</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Blog</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">WithOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Header</span><span class="p">)</span>
        <span class="p">.</span><span class="n">HasForeignKey</span><span class="p">&lt;</span><span class="n">BlogHeader</span><span class="p">&gt;(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">BlogId</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsRequired</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A <em>many-to-many relationship</em> is used when any number entities of one entity type is associated with any number of entities of the same or another entity type.</p>
<div class="ulist">
<ul>
<li>
<p>A many-to-many relationship requires a <em>join entity</em> (and table) to link the two sides, as a single foreign key is insufficient.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">Posts</span><span class="p">]</span> <span class="p">(</span>
    <span class="p">[</span><span class="n">Id</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_Posts</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">Tag</span><span class="p">]</span> <span class="p">(</span>
    <span class="p">[</span><span class="n">Id</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">IDENTITY</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_Tag</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">PostTag</span><span class="p">]</span> <span class="p">(</span>
    <span class="p">[</span><span class="n">PostsId</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="p">[</span><span class="n">TagsId</span><span class="p">]</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_PostTag</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">PostsId</span><span class="p">],</span> <span class="p">[</span><span class="n">TagsId</span><span class="p">]),</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">FK_PostTag_Posts_PostsId</span><span class="p">]</span>
        <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">PostsId</span><span class="p">])</span> <span class="k">REFERENCES</span> <span class="p">[</span><span class="n">Posts</span><span class="p">]</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">FK_PostTag_Tag_TagsId</span><span class="p">]</span>
        <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">([</span><span class="n">TagsId</span><span class="p">])</span> <span class="k">REFERENCES</span> <span class="p">[</span><span class="n">Tag</span><span class="p">]</span> <span class="p">([</span><span class="n">Id</span><span class="p">])</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="p">[</span><span class="n">IX_PostTag_TagsId</span><span class="p">]</span> <span class="k">ON</span> <span class="p">[</span><span class="n">PostTag</span><span class="p">]</span> <span class="p">([</span><span class="n">TagsId</span><span class="p">]);</span></code></pre>
</div>
</div>
</li>
<li>
<p>EF Core can hide the join entity type and manage it behind the scenes that allows the navigations of a many-to-many relationship to be used in a natural manner, adding or removing entities from each side as needed.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">Post</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Tag</span><span class="p">&gt;</span> <span class="n">Tags</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="p">[];</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Tag</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;</span> <span class="n">Posts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="p">[];</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="foreign-and-principal-keys">3.6.1. Foreign and Principal keys</h4>
<div class="paragraph">
<p>One-to-one and one-to-many relationships are defined by a <em>foreign key</em> on the <em>dependent entity</em> referencing the <em>principal key</em> (primary or alternate) of the <em>principal entity</em>. Many-to-many relationships are formed by two one-to-many relationships, each with its own foreign key referencing a principal key.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The property or properties that make up foreign key are often <em>discovered by convention</em>, and can also be configured explicitly using either <em>mapping attributes</em> or with <code>HasForeignKey</code> in the model building API.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasMany</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Posts</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">WithOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Blog</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasForeignKey</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">ContainingBlogId</span><span class="p">);</span> <span class="c1">// lambda expression.</span>
        <span class="c1">// .HasForeignKey("ContainingBlogId");   // property name</span>

        <span class="c1">// composite foreign key</span>
        <span class="c1">// .HasForeignKey(e =&gt; new { e.ContainingBlogId1, e.ContainingBlogId2 });</span>
        <span class="c1">// .HasForeignKey("ContainingBlogId1", "ContainingBlogId2");</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>By convention, foreign keys are constrained to the primary key at the principal end of the relationship. However, an alternate key can be used instead using <code>HasPrincipalKey</code> on the model building API.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasMany</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Posts</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">WithOne</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Blog</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasPrincipalKey</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">AlternateId</span><span class="p">);</span> <span class="c1">// lambda expression.</span>
        <span class="c1">// .HasPrincipalKey("AlternateId");   // property name</span>

        <span class="c1">// composite key</span>
        <span class="c1">// .HasPrincipalKey(e =&gt; new { e.AlternateId1, e.AlternateId2 });</span>
        <span class="c1">// .HasPrincipalKey("AlternateId1", "AlternateId2");</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The order of the properties in the principal and foreign key must match, which is also the order in which the key is defined in the database schema.</p>
</li>
<li>
<p>There is no need to call <code>HasAlternateKey</code> to define the alternate key on the principal entity when <code>HasPrincipalKey</code> is used with properties that are not the primary key properties.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In many-to-many relationships, the foreign keys are defined on the join entity type and mapped to foreign key constraints in the join table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasMany</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Tags</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">WithMany</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Posts</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">UsingEntity</span><span class="p">(</span>
            <span class="n">l</span> <span class="p">=&gt;</span> <span class="n">l</span><span class="p">.</span><span class="nf">HasOne</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Tag</span><span class="p">)).</span><span class="nf">WithMany</span><span class="p">().</span><span class="nf">HasConstraintName</span><span class="p">(</span><span class="s">"TagForeignKey_Constraint"</span><span class="p">),</span>
            <span class="n">r</span> <span class="p">=&gt;</span> <span class="n">r</span><span class="p">.</span><span class="nf">HasOne</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Post</span><span class="p">)).</span><span class="nf">WithMany</span><span class="p">().</span><span class="nf">HasConstraintName</span><span class="p">(</span><span class="s">"PostForeignKey_Constraint"</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="navigations">3.6.2. Navigations</h4>
<div class="paragraph">
<p>EF Core relationships are defined by foreign keys.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Navigations are layered over foreign keys to provide a natural, object-oriented view for reading and manipulating relationships.</p>
</li>
<li>
<p>By using navigations, applications can work with graphs of entities without being concerned with what is happening to the foreign key values.</p>
</li>
<li>
<p>A navigation from dependent to principal is required if the relationship is required, which in turn means that the foreign key property is non-nullable. Conversely, the navigation is optional if the foreign key is nullable, and the relationship is therefore optional.</p>
</li>
<li>
<p>Reference navigations are simple object references to another entity, which represent the "one" side(s) of one-to-many and one-to-one relationships.</p>
<div class="ulist">
<ul>
<li>
<p>Reference navigations must have a setter, although it does not need to be public.</p>
</li>
<li>
<p>Reference navigations should not be automatically initialized to a non-null default value; doing so is equivalent to asserting that an entity exists when it does not.</p>
</li>
<li>
<p>When using C# nullable reference types, reference navigations must be nullable for optional relationships:</p>
</li>
<li>
<p>Reference navigations for required relationships can be nullable or non-nullable.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="n">Blog</span><span class="p">?</span> <span class="n">TheBlog</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Collection navigations are instances of a .NET collection type; that is, any type implementing <code>ICollection&lt;T&gt;</code>, which represent the "many" side(s) of one-to-many and many-to-many relationships.</p>
<div class="ulist">
<ul>
<li>
<p>Collection navigations do not need to have a setter.</p>
</li>
<li>
<p>It is common to initialize the collection inline, thereby removing the need to ever check if the property is <code>null</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;</span> <span class="n">ThePosts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="p">[];</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don&#8217;t accidentally create an expression bodied property, such as <code>public ICollection&lt;Post&gt; ThePosts => [];</code>, which will create a new, empty collection instance each time the property is accessed, and will therefore be useless as a navigation.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="indexes">3.7. Indexes</h3>
<div class="paragraph">
<p>Indexes are a common concept across many data store to make lookups based on a column (or set of columns) more efficient.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Index</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">Url</span><span class="p">))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
By convention, an index is created in each property (or set of properties) that are used as a foreign key.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>composite index</em>, spanning more than one column, speeds up queries which filter on index&#8217;s columns, but also queries which only filter on the first columns covered by the index.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Index</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">FirstName</span><span class="p">),</span> <span class="k">nameof</span><span class="p">(</span><span class="n">LastName</span><span class="p">))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PersonId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">p</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">LastName</span> <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>By default, indexes aren&#8217;t unique: multiple rows are allowed to have the same value(s) for the index&#8217;s column set.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Index</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">Url</span><span class="p">),</span> <span class="n">IsUnique</span> <span class="p">=</span> <span class="k">true</span><span class="p">)]</span> <span class="c1">// UNIQUE INDEX</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsUnique</span><span class="p">();</span> <span class="c1">// UNIQUE INDEX</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>In most databases, each column covered by an index can be either ascending or descending.</p>
<div class="ulist">
<ul>
<li>
<p>For indexes covering only one column, this typically does not matter: the database can traverse the index in reverse order as needed.</p>
</li>
<li>
<p>However, for composite indexes, the ordering can be crucial for good performance, and can mean the difference between an index getting used by a query or not.</p>
</li>
<li>
<p>In general, the index columns' sort orders should correspond to those specified in the <code>ORDER BY</code> clause of a query.</p>
</li>
<li>
<p>The index sort order is ascending by default.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Index</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">Url</span><span class="p">),</span> <span class="k">nameof</span><span class="p">(</span><span class="n">Rating</span><span class="p">),</span> <span class="n">AllDescending</span> <span class="p">=</span> <span class="k">true</span><span class="p">)]</span> <span class="c1">// make all columns as descending order</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Rating</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">Rating</span> <span class="p">})</span>
        <span class="p">.</span><span class="nf">IsDescending</span><span class="p">();</span> <span class="c1">// make all columns as descending order</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The index may also be specified the sort order on a column-by-column basis.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Index</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">Url</span><span class="p">),</span> <span class="k">nameof</span><span class="p">(</span><span class="n">Rating</span><span class="p">),</span> <span class="n">IsDescending</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span> <span class="p">})]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">BlogId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Rating</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">Rating</span> <span class="p">})</span>
        <span class="p">.</span><span class="nf">IsDescending</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>To create multiple indexes over the same set of properties, pass a name to the <code>HasIndex</code>, which will be used to identify the index in the EF model, and to distinguish it from other indexes over the same properties.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">p</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">LastName</span> <span class="p">},</span> <span class="s">"IX_Names_Ascending"</span><span class="p">);</span>

<span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">p</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">LastName</span> <span class="p">},</span> <span class="s">"IX_Names_Descending"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">IsDescending</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="p">[</span><span class="nf">Index</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">FirstName</span><span class="p">),</span> <span class="k">nameof</span><span class="p">(</span><span class="n">LastName</span><span class="p">),</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">"IX_Names_Ascending"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">Index</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">FirstName</span><span class="p">),</span> <span class="k">nameof</span><span class="p">(</span><span class="n">LastName</span><span class="p">),</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">"IX_Names_Descending"</span><span class="p">,</span> <span class="n">AllDescending</span> <span class="p">=</span> <span class="k">true</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PersonId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>A <em>filtered index</em> is an index that includes a <code>WHERE</code> clause, effectively indexing only a subset of the rows in a table to index only a subset of a column&#8217;s values, reducing the index&#8217;s size and improving both performance and disk space usage. <a href="#mssql-create-filtered-indexes">[4]</a></p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Filtered indexes are not supported by all RDBMS.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">HasFilter</span><span class="p">(</span><span class="s">"[Url] IS NOT NULL"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>An <em>index with nonkey columns</em> can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns. <a href="#mssql-create-indexes-with-included-columns">[5]</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Post</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">HasIndex</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Url</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IncludeProperties</span><span class="p">(</span>
            <span class="n">p</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">p</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">PublishedOn</span> <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data isn&#8217;t accessed resulting in fewer disk I/O operations.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="check-constraints">3.8. Check Constraints</h3>
<div class="ulist">
<ul>
<li>
<p>Check constraints are a standard database feature that enforces a condition on all table rows; inserts or updates violating the condition will fail.</p>
</li>
<li>
<p>Check constraints are similar to non-null and unique constraints but allow for arbitrary SQL expressions.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Product</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">ToTable</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">b</span><span class="p">.</span><span class="nf">HasCheckConstraint</span><span class="p">(</span><span class="s">"CK_Prices"</span><span class="p">,</span> <span class="s">"[Price] &gt; [DiscountedPrice]"</span><span class="p">);</span>
        <span class="n">b</span><span class="p">.</span><span class="nf">HasCheckConstraint</span><span class="p">(</span><span class="s">"CK_PositivePrice"</span><span class="p">,</span> <span class="s">"[Price] &gt; 0"</span><span class="p">);</span>
        <span class="n">b</span><span class="p">.</span><span class="nf">HasCheckConstraint</span><span class="p">(</span><span class="s">"CK_PositiveDiscountedPrice"</span><span class="p">,</span> <span class="s">"[DiscountedPrice] &gt;= 0"</span><span class="p">);</span>
    <span class="p">});</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="schemas">4. Schemas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>EF Core offers two ways to synchronize a model and database schema: <em>Migrations</em> (model as the source of truth, incrementally applying schema changes) and <em>Reverse Engineering</em> (database as the source of truth, scaffolding a model from the existing schema).</p>
</div>
<div class="sect2">
<h3 id="migrations">4.1. Migrations</h3>
<div class="paragraph">
<p>The migrations feature in EF Core provides a way to incrementally update the database schema to keep it in sync with the application&#8217;s data model while preserving existing data in the database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration describing the updates necessary to keep the database schema in sync.</p>
</li>
<li>
<p>EF Core compares the current model against a snapshot of the old model to determine the differences, and generates migration source files; the files can be tracked in the project&#8217;s source control like any other source file.</p>
</li>
<li>
<p>Once a new migration has been generated, it can be applied to a database in various ways.</p>
</li>
<li>
<p>EF Core records all applied migrations in a special history table, allowing it to know which migrations have been applied and which haven&#8217;t.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Create and Drop APIs</div>
<div class="paragraph">
<p>The <code>EnsureCreatedAsync</code> and <code>EnsureDeletedAsync</code> methods provide a lightweight alternative to <em>Migrations</em> for managing the database schema, which are useful in scenarios when the data is transient and can be dropped when the schema changes, such as during development.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>EnsureCreatedAsync</code> and Migrations don&#8217;t work well together.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Drop the database if it exists</span>
<span class="k">await</span> <span class="n">dbContext</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="nf">EnsureDeletedAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Create the database if it doesn't exist</span>
<span class="n">dbContext</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="nf">EnsureCreatedAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Get the SQL used by EnsureCreatedAsync</span>
<span class="kt">var</span> <span class="n">sql</span> <span class="p">=</span> <span class="n">dbContext</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="nf">GenerateCreateScript</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Install the EF Core command-line tools.</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># globally</span>
dotnet tool <span class="nb">install</span> <span class="nt">--global</span> dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore.Design</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># locally</span>
dotnet new tool-manifest
dotnet tool <span class="nb">install </span>dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore.Design</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Set up a .NET generic host for app startup and lifetime management.</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># create a new project</span>
dotnet new console <span class="nt">-o</span> getting-started <span class="o">&amp;&amp;</span> <span class="nb">cd </span>getting-started/

<span class="c"># install SQLite provider</span>
dotnet add package Microsoft.EntityFrameworkCore.Sqlite

<span class="c"># install generic host package</span>
dotnet add package Microsoft.Extensions.Hosting</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Program.cs</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">Host</span><span class="p">.</span><span class="nf">CreateApplicationBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

<span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddDbContext</span><span class="p">&lt;</span><span class="n">BloggingContext</span><span class="p">&gt;(</span><span class="n">options</span> <span class="p">=&gt;</span>
    <span class="n">options</span><span class="p">.</span><span class="nf">UseSqlite</span><span class="p">(</span><span class="s">"Data Source=:memory:"</span><span class="p">));</span> <span class="c1">// ":memory:" creates in-memory DB</span>

<span class="kt">var</span> <span class="n">app</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">Build</span><span class="p">();</span>

<span class="c1">// Create and Drop APIs</span>
<span class="c1">// using (var scope = app.Services.CreateScope())</span>
<span class="c1">// {</span>
<span class="c1">//     using var context = scope.ServiceProvider.GetRequiredService&lt;BloggingContext&gt;();</span>
<span class="c1">//     await context.Database.EnsureDeletedAsync();</span>
<span class="c1">//     await context.Database.EnsureCreatedAsync();</span>
<span class="c1">// }</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">BloggingContext</span> <span class="p">:</span> <span class="n">DbContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DbSet</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;</span> <span class="n">Blogs</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">BloggingContext</span><span class="p">(</span><span class="n">DbContextOptions</span><span class="p">&lt;</span><span class="n">BloggingContext</span><span class="p">&gt;</span> <span class="n">options</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Blog</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="managing-migrations">4.1.1. Managing Migrations</h4>
<div class="paragraph">
<p>As the model changes, migrations are added and removed as part of normal development, and the migration files are checked into the project&#8217;s source control.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dotnet ef migrations add</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">// add a migration
dotnet ef migrations add InitialCreate</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>EF Core will create a directory called <code>Migrations</code> in the project, and generate some files.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>tree ./Migrations/
<span class="go">./Migrations/
├── 20250213080400_InitialCreate.cs <i class="conum" data-value="1"></i><b>(1)</b>
├── 20250213080400_InitialCreate.Designer.cs <i class="conum" data-value="2"></i><b>(2)</b>
└── BloggingContextModelSnapshot.cs <i class="conum" data-value="3"></i><b>(3)</b>
</span></code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The main migrations file that contains the operations necessary to apply the migration (in <code>Up</code>) and to revert it (in <code>Down</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The migrations metadata file that contains information used by EF.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A snapshot of the current model used to determine what changed when adding the next migration.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>It&#8217;s a good idea to inspect what exactly EF Core generated - and possibly amend it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>dotnet ef migrations list</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>dotnet ef migrations list
<span class="go">Build started...
Build succeeded.
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (9ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
</span><span class="gp">      SELECT COUNT(*) FROM "sqlite_master" WHERE "name" = '__EFMigrationsHistory' AND "type" = 'table';</span><span class="w">
</span><span class="go">20250213080400_InitialCreate (Pending)</span></code></pre>
</div>
</div>
</li>
<li>
<p><code>dotnet ef migrations remove</code></p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Avoid removing any migrations which have already been applied to production databases.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>dotnet ef migrations remove
<span class="go">Build started...
Build succeeded.
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (10ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
</span><span class="gp">      SELECT COUNT(*) FROM "sqlite_master" WHERE "name" = '__EFMigrationsHistory' AND "type" = 'table';</span><span class="w">
</span><span class="go">Removing migration '20250213080400_InitialCreate'.
Removing model snapshot.
Done.</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="applying-migrations">4.1.2. Applying Migrations</h4>
<div class="ulist">
<ul>
<li>
<p>The recommended way to deploy migrations to a production database is by generating <strong>SQL scripts</strong>.</p>
<div class="ulist">
<ul>
<li>
<p>SQL scripts can be reviewed for accuracy; this is important since applying schema changes to production databases is a potentially dangerous operation that could involve data loss.</p>
</li>
<li>
<p>In some cases, the scripts can be tuned to fit the specific needs of a production database.</p>
</li>
<li>
<p>SQL scripts can be used in conjunction with a deployment technology, and can even be generated as part of a CI process.</p>
</li>
<li>
<p>SQL scripts can be provided to a DBA, and can be managed and archived separately.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># generate a SQL script from a blank database to the latest migration</span>
dotnet ef migrations script
<span class="c"># generate a SQL script from the given migration to the latest migration.</span>
dotnet ef migrations script AddNewTables
<span class="c"># generate a SQL script from the specified from migration to the specified to migration</span>
dotnet ef migrations script AddNewTables AddAuditTable
<span class="c"># generate idempotent migrations</span>
dotnet ef migrations script <span class="nt">--idempotent</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The EF <strong>command-line tools</strong> can be productively used to apply migrations during local development and testing, but are not ideal for managing production databases.</p>
<div class="ulist">
<ul>
<li>
<p>The SQL commands are applied directly by the tool, without giving the developer a chance to inspect or modify them, which can be dangerous in a production environment.</p>
</li>
<li>
<p>The .NET SDK and the EF tool must be installed on production servers and requires the project&#8217;s source code.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># update database to the latest migration</span>
dotnet ef database update
<span class="c"># update or roll back database to a given migration</span>
dotnet ef database update AddNewTables</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Migration <strong>bundles</strong> are single-file executables that can be used to apply migrations to a databaseto ddress some of the shortcomings of the SQL script and command-line tools.</p>
<div class="ulist">
<ul>
<li>
<p>Executing SQL scripts requires additional tools.</p>
</li>
<li>
<p>The transaction handling and continue-on-error behavior of these tools are inconsistent and sometimes unexpected, which can leave the database in an undefined state if a failure occurs when applying migrations.</p>
</li>
<li>
<p>Bundles can be generated as part of a CI process and easily executed later as part of the deployment process.</p>
</li>
<li>
<p>Bundles are executable without the .NET SDK, EF Tool, or even the .NET Runtime (if self-contained), and they don&#8217;t require source code.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="c"># generate a bundle</span>
dotnet ef migrations bundle
<span class="c"># generate a self-contained bundle for Linux</span>
dotnet ef migrations bundle <span class="nt">--self-contained</span> <span class="nt">-r</span> linux-x64</code></pre>
</div>
</div>
</li>
<li>
<p>The resulting executable is named <code>efbundle</code> by default, which can be used to update the database to the latest migration.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>./efbundle <span class="nt">--help</span>
<span class="go">Entity Framework Core Migrations Bundle 9.0.2

</span><span class="gp">Usage: efbundle [arguments] [options] [[--] &lt;arg&gt;</span>...]]
<span class="go">
Arguments:
</span><span class="gp">  &lt;MIGRATION&gt;</span><span class="w">  </span>The target migration. If <span class="s1">'0'</span>, all migrations will be reverted. Defaults to the last migration.
<span class="go">
Options:
</span><span class="gp">  --connection &lt;CONNECTION&gt;</span><span class="w">  </span>The connection string to the database. Defaults to the one specified <span class="k">in </span>AddDbContext or OnConfiguring.
<span class="go">  --version                  Show version information
  -h|--help                  Show help information
  -v|--verbose               Show verbose output.
  --no-color                 Don't colorize output.
  --prefix-output            Prefix output with level.</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The migrations can be programmatically applied by calling <code>context.Database.MigrateAsync()</code> for local development and testing.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">Host</span><span class="p">.</span><span class="nf">CreateApplicationBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="c1">// . . .</span>
<span class="kt">var</span> <span class="n">app</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">Build</span><span class="p">();</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">app</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="nf">CreateScope</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">ServiceProvider</span><span class="p">.</span><span class="n">GetRequiredService</span><span class="p">&lt;</span><span class="n">BloggingContext</span><span class="p">&gt;();</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="nf">MigrateAsync</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="querying">5. Querying</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity Framework Core uses Language-Integrated Query (LINQ) to query data from the database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>EF Core passes a representation of the LINQ query to the database provider.</p>
</li>
<li>
<p>Database providers in turn translate it to database-specific query language (for example, SQL for a relational database).</p>
</li>
<li>
<p>Queries are always executed against the database even if the entities returned in the result already exist in the context.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// SELECT [b].[Id], [b].[Name], [b].[Url]</span>
<span class="c1">// FROM [Blogs] AS [b]</span>
<span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span>

<span class="c1">// SELECT TOP(1) [b].[Id], [b].[Name], [b].[Url]</span>
<span class="c1">// FROM [Blogs] AS [b]</span>
<span class="c1">// WHERE [b].[Id] = 1</span>
<span class="kt">var</span> <span class="n">blog</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">SingleOrDefaultAsync</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span> <span class="p">==</span> <span class="m">1</span><span class="p">);</span>

<span class="c1">// SELECT [b].[Id], [b].[Name], [b].[Url]</span>
<span class="c1">// FROM [Blogs] AS [b]</span>
<span class="c1">// WHERE [b].[Url] IS NOT NULL AND [b].[Url] LIKE N'%dotnet%'</span>
<span class="kt">var</span> <span class="n">filteredBlogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">b</span><span class="p">.</span><span class="n">Url</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">"dotnet"</span><span class="p">)).</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tracking behavior controls if Entity Framework Core keeps information about an entity instance in its change tracker.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If an entity is tracked, any changes detected in the entity are persisted to the database during <code>SaveChanges</code>.</p>
</li>
<li>
<p>EF Core also fixes up navigation properties between the entities in a tracking query result and the entities that are in the change tracker.</p>
</li>
<li>
<p>By default, queries that return entity types are tracking.</p>
<div class="ulist">
<ul>
<li>
<p>If EF Core finds an existing entity, then the same instance is returned, which can potentially use less memory and be faster than a no-tracking query.</p>
</li>
<li>
<p>EF Core doesn&#8217;t overwrite current and original values of the entity&#8217;s properties in the entry with the database values.</p>
</li>
<li>
<p>If the entity isn&#8217;t found in the context, EF Core creates a new entity instance and attaches it to the context.</p>
</li>
<li>
<p>Query results don&#8217;t contain any entity which is added to the context but not yet saved to the database.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">blog</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">SingleOrDefaultAsync</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">BlogId</span> <span class="p">==</span> <span class="m">1</span><span class="p">);</span>
<span class="n">blog</span><span class="p">.</span><span class="n">Rating</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="tracking-vs-no-tracking">5.1. Tracking vs. no-tracking</h3>
<div class="ulist">
<ul>
<li>
<p>No-tracking queries are useful when the results are used in a read-only scenario, which are generally quicker to execute because there&#8217;s no need to set up the change tracking information.</p>
<div class="ulist">
<ul>
<li>
<p>If the entities retrieved from the database don&#8217;t need to be updated, then a no-tracking query should be used.</p>
</li>
<li>
<p>An individual query can be set to be no-tracking.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">AsNoTracking</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
<li>
<p>A no-tracking query also give results based on what&#8217;s in the database disregarding any local changes or added entities.</p>
</li>
<li>
<p>The default tracking behavior can be changed at the context instance level.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">context</span><span class="p">.</span><span class="n">ChangeTracker</span><span class="p">.</span><span class="n">QueryTrackingBehavior</span> <span class="p">=</span> <span class="n">QueryTrackingBehavior</span><span class="p">.</span><span class="n">NoTracking</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
<li>
<p>To make all the queries no-tracking by default.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnConfiguring</span><span class="p">(</span><span class="n">DbContextOptionsBuilder</span> <span class="n">optionsBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">optionsBuilder</span>
        <span class="p">.</span><span class="nf">UseSqlServer</span><span class="p">(</span><span class="s">@"Server=(localdb)\mssqllocaldb;Database=EFQuerying.Tracking"</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">UseQueryTrackingBehavior</span><span class="p">(</span><span class="n">QueryTrackingBehavior</span><span class="p">.</span><span class="n">NoTracking</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// You can still add AsTracking to make specific queries tracking.</span>
<span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">AsNoTracking</span><span class="p">().</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="pagination">5.2. Pagination</h3>
<div class="paragraph">
<p>Keyset pagination is appropriate for pagination interfaces where the user navigates forwards and backwards, but does not support random access, where the user can jump to any specific page.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A common way to implement pagination with databases is to use the <code>Skip</code> and <code>Take</code> LINQ operators (<code>OFFSET</code> and <code>LIMIT</code> in SQL).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">posts</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">OrderBy</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">Skip</span><span class="p">(</span><span class="m">20</span><span class="p">)</span> <span class="c1">// page index</span>
    <span class="p">.</span><span class="nf">Take</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="c1">// page size</span>
    <span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (14ms) [Parameters=[@__p_0='20', @__p_1='10'], CommandType='Text', CommandTimeout='30']
      SELECT [b].[Id], [b].[Name], [b].[Url]
      FROM [Blogs] AS [b]
      ORDER BY [b].[Id]
      OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY</span></code></pre>
</div>
</div>
</li>
<li>
<p>The recommended alternative to offset-based pagination - sometimes called <em>keyset pagination</em> or <em>seek-based pagination</em> - is to simply use a <code>WHERE</code> clause to skip rows, instead of an offset.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">int</span> <span class="n">lastId</span> <span class="p">=</span> <span class="m">55</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">posts</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">OrderBy</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span> <span class="p">&gt;</span> <span class="n">lastId</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">Take</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (136ms) [Parameters=[@__p_1='10', @__lastId_0='55'], CommandType='Text', CommandTimeout='30']
      SELECT TOP(@__p_1) [b].[Id], [b].[Name], [b].[Url]
      FROM [Blogs] AS [b]
</span><span class="gp">      WHERE [b].[Id] &gt;</span><span class="w"> </span>@__lastId_0
<span class="go">      ORDER BY [b].[Id]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="indexes-2">5.3. Indexes</h3>
<div class="ulist">
<ul>
<li>
<p>A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via a database&#8217;s favorite tool.</p>
<div class="ulist">
<ul>
<li>
<p>While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</p>
</li>
<li>
<p>Avoid defining indexes which aren&#8217;t needed, and consider using index filters to limit the index to a subset of the rows.</p>
</li>
<li>
<p>Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don&#8217;t filter on all the index&#8217;s columns - depending on ordering.</p>
<div class="ulist">
<ul>
<li>
<p>For example, an index on columns A and B speeds up queries filtering by A and B as well as queries filtering only by A, but it does not speed up queries only filtering over B.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If a query filters by an expression over a column (e.g. <code>price / 2</code>), a simple index cannot be used.</p>
<div class="ulist">
<ul>
<li>
<p>However, a stored persisted column can be defined for the expression, and create an index over that.</p>
</li>
<li>
<p>Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="projections">5.4. Projections</h3>
<div class="ulist">
<ul>
<li>
<p>For read-only queries with multiple columns, project into anonymous types, but be aware that updates become more complex since EF Core change tracking relies on entities, though partial updates are possible with advanced techniques.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// SELECT TOP(2) [p].[FirstName], [p].[LastName]</span>
<span class="c1">// FROM [People] AS [p]</span>
<span class="c1">// WHERE [p].[FirstName] = N'John'</span>
<span class="kt">var</span> <span class="n">p</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">People</span>
    <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">p</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">LastName</span> <span class="p">})</span> <span class="c1">// projection</span>
    <span class="p">.</span><span class="nf">SingleAsync</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">==</span> <span class="s">"John"</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="sql-queries">5.5. SQL queries</h3>
<div class="paragraph">
<p>Entity Framework Core allows dropping down to SQL queries when working with a relational database, which are useful if the query can&#8217;t be expressed using LINQ, or if a LINQ query causes EF to generate inefficient SQL.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic SQL queries</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// a LINQ query based on a SQL query</span>
<span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">FromSql</span><span class="p">(</span><span class="s">$"SELECT * FROM dbo.Blogs"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// execute a stored procedure</span>
<span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">FromSql</span><span class="p">(</span><span class="s">$"EXECUTE dbo.GetMostPopularBlogs"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">//  string interpolation</span>
<span class="kt">var</span> <span class="n">user</span> <span class="p">=</span> <span class="s">"johndoe"</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">FromSql</span><span class="p">(</span><span class="s">$"EXECUTE dbo.GetMostPopularBlogsForUser </span><span class="p">{</span><span class="n">user</span><span class="p">}</span><span class="s">"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// named parameters</span>
<span class="kt">var</span> <span class="n">user</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SqlParameter</span><span class="p">(</span><span class="s">"user"</span><span class="p">,</span> <span class="s">"johndoe"</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">blogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span>
    <span class="p">.</span><span class="nf">FromSql</span><span class="p">(</span><span class="s">$"EXECUTE dbo.GetMostPopularBlogsForUser @filterByUser=</span><span class="p">{</span><span class="n">user</span><span class="p">}</span><span class="s">"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToListAsync</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// executing non-querying SQL</span>
<span class="kt">var</span> <span class="n">rowsModified</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="nf">ExecuteSql</span><span class="p">(</span><span class="s">$"UPDATE [Blogs] SET [Url] = NULL"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// executing non-querying SQL</span>
<span class="kt">var</span> <span class="n">tranMode</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">SqlQueryRaw</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span>
    <span class="s">"SELECT IIF(@@OPTIONS&amp;2 = 0, 'Implicit Transaction Off', 'Implicit Transaction On') AS TranMode"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ToList</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">FirstOrDefault</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// use the underlying ADO.NET connection directly</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">connection</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="nf">GetDbConnection</span><span class="p">();</span>
<span class="n">connection</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">command</span> <span class="p">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">CreateCommand</span><span class="p">();</span>
<span class="n">command</span><span class="p">.</span><span class="n">CommandText</span> <span class="p">=</span>
    <span class="s">"SELECT IIF(@@OPTIONS&amp;2 = 0, 'Implicit Transaction Off', 'Implicit Transaction On') AS TranMode"</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">tranMode</span> <span class="p">=</span> <span class="n">command</span><span class="p">.</span><span class="nf">ExecuteScalar</span><span class="p">()</span> <span class="k">as</span> <span class="kt">string</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="saving">6. Saving</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity Framework Core (EF Core) supports two approaches for persisting data to the database: change tracking with <code>SaveChanges()</code> and direct execution with <code>ExecuteUpdate</code> and <code>ExecuteDelete</code>.</p>
</div>
<div class="sect2">
<h3 id="savechanges-executeupdate-and-executedelete">6.1. SaveChanges, ExecuteUpdate and ExecuteDelete</h3>
<div class="ulist">
<ul>
<li>
<p>EF Core tracks changes maked to data (adding, updating, or deleting) and <code>SaveChanges()</code> turns those changes into the SQL commands needed to update the database.</p>
<div class="ulist">
<ul>
<li>
<p>It is the more common and often preferred method for saving data in EF Core.</p>
</li>
<li>
<p>For large-scale bulk updates, SaveChanges() can be less efficient than direct execution methods.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Add a new entity</span>
<span class="kt">var</span> <span class="n">newProduct</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Product</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">"New Widget"</span><span class="p">,</span> <span class="n">Price</span> <span class="p">=</span> <span class="m">9.99</span> <span class="p">};</span>
<span class="n">context</span><span class="p">.</span><span class="n">Products</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">newProduct</span><span class="p">);</span>

<span class="c1">// Modify an existing entity</span>
<span class="kt">var</span> <span class="n">existingProduct</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Products</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">existingProduct</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">existingProduct</span><span class="p">.</span><span class="n">Price</span> <span class="p">=</span> <span class="m">12.99</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Remove an entity</span>
<span class="kt">var</span> <span class="n">productToRemove</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Products</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">productToRemove</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">context</span><span class="p">.</span><span class="n">Products</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">productToRemove</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Save all changes</span>
<span class="n">context</span><span class="p">.</span><span class="nf">SaveChanges</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>ExecuteUpdate</code> and <code>ExecuteDelete</code> offer a direct way, bypassing change tracker, to update or delete data using LINQ queries, which is often more efficient for bulk operations or when needing precise control over the SQL.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Update multiple products</span>
<span class="n">context</span><span class="p">.</span><span class="n">Products</span>
    <span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Category</span> <span class="p">==</span> <span class="s">"Electronics"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ExecuteUpdate</span><span class="p">(</span><span class="n">setters</span> <span class="p">=&gt;</span> <span class="n">setters</span><span class="p">.</span><span class="nf">SetProperty</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Price</span><span class="p">,</span> <span class="m">19.99</span><span class="p">));</span>

<span class="c1">// Delete multiple products</span>
<span class="n">context</span><span class="p">.</span><span class="n">Products</span>
    <span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Discontinued</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">ExecuteDelete</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="transactions">6.2. Transactions</h3>
<div class="ulist">
<ul>
<li>
<p>By default, if the database provider supports transactions, all changes in a single call to <code>SaveChanges</code> are applied in a transaction.</p>
</li>
<li>
<p>While all relational database providers support transactions, other providers types may throw or no-op when transaction APIs are called.</p>
</li>
<li>
<p>The <code>DbContext.Database</code> API can be used to begin, commit, and rollback transactions.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BloggingContext</span><span class="p">();</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">transaction</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="nf">BeginTransactionAsync</span><span class="p">();</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Blog</span> <span class="p">{</span> <span class="n">Url</span> <span class="p">=</span> <span class="s">"https://devblogs.microsoft.com/dotnet/"</span> <span class="p">});</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span>

    <span class="k">await</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">CreateSavepointAsync</span><span class="p">(</span><span class="s">"BeforeMoreBlogs"</span><span class="p">);</span>

    <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Blog</span> <span class="p">{</span> <span class="n">Url</span> <span class="p">=</span> <span class="s">"https://devblogs.microsoft.com/visualstudio/"</span> <span class="p">});</span>
    <span class="n">context</span><span class="p">.</span><span class="n">Blogs</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Blog</span> <span class="p">{</span> <span class="n">Url</span> <span class="p">=</span> <span class="s">"https://devblogs.microsoft.com/aspnet/"</span> <span class="p">});</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span>

    <span class="k">await</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">CommitAsync</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If a failure occurred, we rollback to the savepoint and can continue the transaction</span>
    <span class="k">await</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">RollbackToSavepointAsync</span><span class="p">(</span><span class="s">"BeforeMoreBlogs"</span><span class="p">);</span>

    <span class="c1">// TODO: Handle failure, possibly retry inserting blogs</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="optimistic-concurrency">6.3. Optimistic concurrency</h3>
<div class="paragraph">
<p>EF Core implements <strong>optimistic</strong> concurrency, which assumes that concurrency conflicts are relatively rare.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In contrast to <strong>pessimistic</strong> approaches - which lock data up-front and only then proceed to modify it - optimistic concurrency takes no locks, but arranges for the data modification to fail on save if the data has changed since it was queried.</p>
</li>
<li>
<p>Optimistic concurrency failure is reported to the application, which deals with it accordingly, possibly by retrying the entire operation on the new data.</p>
</li>
<li>
<p>In EF Core, optimistic concurrency is implemented by configuring a property as a <strong>concurrency token</strong>.</p>
<div class="ulist">
<ul>
<li>
<p>The concurrency token is loaded and tracked when an entity is queried - just like any other property.</p>
</li>
<li>
<p>Then, when an update or delete operation is performed during <code>SaveChanges()</code>, the value of the concurrency token on the database is compared against the original value read by EF Core.</p>
</li>
<li>
<p>The concurrency token can be managed natively by some databases.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>rowversion</code> type shown below is a SQL Server-specific feature; the details on setting up an automatically-updating concurrency token differ across databases, and some databases don&#8217;t support these at all (e.g. SQLite).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PersonId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="n">Timestamp</span><span class="p">]</span>
    <span class="k">public</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">Version</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Version</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsRowVersion</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// UPDATE [People] SET [FirstName] = @p0</span>
<span class="c1">// WHERE [PersonId] = @p1 AND [Version] = @p2;</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">context</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">ServiceProvider</span><span class="p">.</span><span class="n">GetRequiredService</span><span class="p">&lt;</span><span class="n">BloggingContext</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">person</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">People</span><span class="p">.</span><span class="nf">SingleAsync</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="s">"John"</span><span class="p">));</span>
<span class="n">person</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">=</span> <span class="s">"Paul"</span><span class="p">;</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The concurrency token can also be managed in application code, rather than have the database manage it.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Data Annotations</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PersonId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="n">ConcurrencyCheck</span><span class="p">]</span>
    <span class="k">public</span> <span class="n">Guid</span> <span class="n">Version</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Fluent API</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelCreating</span><span class="p">(</span><span class="n">ModelBuilder</span> <span class="n">modelBuilder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">modelBuilder</span><span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Version</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">IsConcurrencyToken</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// UPDATE [People] SET [FirstName] = @p0, [Version] = @p1</span>
<span class="c1">// WHERE [PersonId] = @p2 AND [Version] = @p3;</span>
<span class="kt">var</span> <span class="n">person</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">People</span><span class="p">.</span><span class="nf">SingleAsync</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">==</span> <span class="s">"John"</span><span class="p">);</span>
<span class="n">person</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">=</span> <span class="s">"Paul"</span><span class="p">;</span>
<span class="n">person</span><span class="p">.</span><span class="n">Version</span> <span class="p">=</span> <span class="n">Guid</span><span class="p">.</span><span class="nf">NewGuid</span><span class="p">();</span> <span class="c1">// assign it in application whenever persisting changes</span>
<span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">SaveChangesAsync</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logging-events-and-diagnostics">7. Logging, events, and diagnostics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity Framework Core (EF Core) contains several mechanisms for generating logs, responding to events, and obtaining diagnostics.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Entity Framework Core (EF Core) fully integrates with <code>Microsoft.Extensions.Logging</code>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// simple logging</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnConfiguring</span><span class="p">(</span><span class="n">DbContextOptionsBuilder</span> <span class="n">optionsBuilder</span><span class="p">)</span>
    <span class="p">=&gt;</span> <span class="n">optionsBuilder</span><span class="p">.</span><span class="nf">LogTo</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">);</span>                     <span class="c1">// logging to console</span>
    <span class="c1">// .LogTo(message =&gt; Debug.WriteLine(message));                 // logging to debug window</span>
    <span class="c1">// .LogTo(new StreamWriter("log.txt", append: true).WriteLine); // logging to file</span>
    <span class="c1">// .EnableSensitiveDataLogging(); // logging data values</span>
    <span class="c1">// .EnableDetailedErrors();       // logging more detailed errors.</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="performance-diagnosis">8. Performance diagnosis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core, which can be broken down into the following broad categories:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Premature optimization is the root of all evil - Donald Knuth.</p>
</div>
</blockquote>
</div>
<div class="ulist">
<ul>
<li>
<p>Pure database performance.</p>
<div class="ulist">
<ul>
<li>
<p>With relational database, EF translates the application&#8217;s LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</p>
</li>
<li>
<p>The right index in the right place can make a world of difference in SQL performance, or rewriting the LINQ query may make EF generate a better SQL query.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Network data transfer and roundtrips.</p>
<div class="ulist">
<ul>
<li>
<p>As with any networking system, it&#8217;s important to limit the amount of data going back and forth on the wire.</p>
</li>
<li>
<p>Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between the application and the database.</p>
</li>
</ul>
</div>
</li>
<li>
<p>EF runtime overhead.</p>
<div class="ulist">
<ul>
<li>
<p>Finally, EF itself adds some runtime overhead to database operations:</p>
<div class="ulist">
<ul>
<li>
<p>compile the queries from LINQ to SQL (although that should normally be done only once)</p>
</li>
<li>
<p>change tracking adds some overhead (but can be disabled), etc.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Cache.</p>
<div class="ulist">
<ul>
<li>
<p>To maximize performance, especially for scalable apps, minimize database access through caching, as databases are harder to scale than application servers.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="identifying-slow-database-commands-via-logging">8.1. Identifying slow database commands via logging</h3>
<div class="ulist">
<ul>
<li>
<p>If a certain query is taking too much time (e.g. because an index is missing), this can be seen discovered by inspecting command execution logs and observing how long they actually take.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">builder</span><span class="p">.</span><span class="n">Logging</span><span class="p">.</span><span class="nf">AddFilter</span><span class="p">(</span><span class="s">"Microsoft.EntityFrameworkCore.Database.Command"</span><span class="p">,</span> <span class="n">LogLevel</span><span class="p">.</span><span class="n">Information</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="log">info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (99ms) [Parameters=[], CommandType='Text', CommandTimeout='30'] <i class="conum" data-value="1"></i><b>(1)</b>
      SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version]
      FROM [People] AS [p]
      WHERE [p].[FirstName] = N'John'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above command took 99 milliseconds.</td>
</tr>
</table>
</div>
</li>
<li>
<p>It&#8217;s recommended to only keep logging on for a short interval of time to gather data - while carefully monitoring an application - or to capture logging data on a pre-production system.</p>
</li>
<li>
<p>Databases typically come with their own tracing and performance analysis tools, which usually provide much richer, database-specific information beyond simple execution times; the actual setup, capabilities and usage vary considerably across databases.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="correlating-database-commands-to-linq-queries">8.2. Correlating database commands to LINQ queries</h3>
<div class="ulist">
<ul>
<li>
<p>One problem with command execution logging is that it&#8217;s sometimes difficult to correlate SQL queries and LINQ queries: the SQL commands executed by EF can look very different from the LINQ queries from which they were generated.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">person</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">People</span>
    <span class="p">.</span><span class="nf">TagWith</span><span class="p">(</span><span class="s">"This is my spatial query!"</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">.</span><span class="nf">SingleAsync</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">==</span> <span class="s">"John"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (111ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      -- This is my spatial query! <i class="conum" data-value="1"></i><b>(1)</b>

      SELECT TOP(2) [p].[PersonId], [p].[FirstName], [p].[LastName], [p].[Version]
      FROM [People] AS [p]
      WHERE [p].[FirstName] = N'John'</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>It&#8217;s often worth tagging the major queries of an application to make the command execution logs more immediately readable.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="inspecting-query-execution-plans">8.3. Inspecting query execution plans</h3>
<div class="ulist">
<ul>
<li>
<p>To optimize slow queries, analyze their execution plans—database-generated blueprints showing the steps and costs involved in query execution.</p>
</li>
<li>
<p>Databases sometimes generate different query plans depending on actual data in the database.</p>
<div class="ulist">
<ul>
<li>
<p>For example, if a table contains only a few rows, a database may choose not to use an index on that table, but to perform a full table scan instead.</p>
</li>
<li>
<p>If analyzing query plans on a test database, always make sure it contains data that is similar to the production system.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dapper">9. Dapper</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/DapperLib/Dapper">Dapper</a> is an open-source micro object-relational mapping (ORM) library for .NET applications, which uses the ADO.NET data providers to work with any existing database technology that supports ADO.NET. <a href="#learndapper">[6]</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">dotnet add package Dapper</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dapper supports a variety of database providers, including the popular Microsoft SQL Server, Oracle, MySQL, MariaDB, PostgreSQL, SQLite, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">dotnet add package Microsoft.Data.SqlClient <span class="c"># SQL Server</span>
dotnet add package System.Data.SQLite.Core  <span class="c"># SQLite</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">IDbConnection</span> <span class="n">connection</span> <span class="p">=</span> <span class="p">...</span>

<span class="c1">// 1. Scalar Query (Single Value):</span>
<span class="kt">var</span> <span class="n">blogCount</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">ExecuteScalarAsync</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="s">"SELECT COUNT(*) FROM Blogs"</span><span class="p">);</span>

<span class="c1">// 2. Row Query (Single Row):</span>
<span class="kt">var</span> <span class="n">firstBlog</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">QuerySingleOrDefaultAsync</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;(</span><span class="s">"SELECT * FROM Blogs ORDER BY Id ASC"</span><span class="p">);</span>

<span class="c1">// 3. Multi-Result Query (Multiple Rows):</span>
<span class="kt">var</span> <span class="n">allBlogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">QueryAsync</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;(</span><span class="s">"SELECT * FROM Blogs"</span><span class="p">);</span>

<span class="c1">// 4. Projection (Selecting Specific Columns):</span>
<span class="kt">var</span> <span class="n">blogNamesAndUrls</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="nf">QueryAsync</span><span class="p">(</span>
    <span class="s">"SELECT Name, Url FROM Blogs"</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span> <span class="n">url</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">,</span> <span class="n">Url</span> <span class="p">=</span> <span class="n">url</span> <span class="p">});</span> <span class="c1">// Mapping to anonymous type</span>

<span class="c1">//Or use anonymous type directly</span>
<span class="kt">var</span> <span class="n">blogNamesAndUrls2</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="nf">QueryAsync</span><span class="p">(</span>
    <span class="s">"SELECT Name, Url FROM Blogs"</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">dynamic</span> <span class="n">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="n">item</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">Url</span> <span class="p">=</span> <span class="n">item</span><span class="p">.</span><span class="n">Url</span> <span class="p">});</span> <span class="c1">// Mapping to anonymous type</span>

<span class="c1">// 5. Parameterized Query (Preventing SQL Injection):</span>
<span class="kt">var</span> <span class="n">blogsStartingWithB</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">QueryAsync</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;(</span>
    <span class="s">"SELECT * FROM Blogs WHERE Name LIKE @NameStart"</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">NameStart</span> <span class="p">=</span> <span class="s">"B%"</span> <span class="p">});</span> <span class="c1">// named parameter</span>

<span class="c1">// 6. Dynamic Parameter Query:</span>
<span class="kt">var</span> <span class="n">parameters</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DynamicParameters</span><span class="p">();</span>

<span class="kt">string</span> <span class="n">sql</span> <span class="p">=</span> <span class="s">"SELECT * FROM Blogs WHERE 1=1 "</span><span class="p">;</span> <span class="c1">// Start with a true condition</span>

<span class="k">if</span> <span class="p">(!</span><span class="kt">string</span><span class="p">.</span><span class="nf">IsNullOrEmpty</span><span class="p">(</span><span class="s">"Blog"</span><span class="p">))</span> <span class="c1">// Example condition</span>
<span class="p">{</span>
    <span class="n">sql</span> <span class="p">+=</span> <span class="s">"AND Name LIKE @NamePart "</span><span class="p">;</span>
    <span class="n">parameters</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"@NamePart"</span><span class="p">,</span> <span class="s">"%"</span> <span class="p">+</span> <span class="s">"Blog"</span> <span class="p">+</span> <span class="s">"%"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">dynamicBlogs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">QueryAsync</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;(</span><span class="n">sql</span><span class="p">,</span> <span class="n">parameters</span><span class="p">);</span>

<span class="c1">// Using IN clause with Dynamic Parameters</span>
<span class="kt">var</span> <span class="n">blogIds</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">5</span> <span class="p">};</span>

<span class="c1">// Transform the list of IDs into a format suitable for the IN clause</span>
<span class="kt">var</span> <span class="n">inClauseParams</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DynamicParameters</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">blogIds</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">inClauseParams</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">$"@Id</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s">"</span><span class="p">,</span> <span class="n">blogIds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">inClauseSql</span> <span class="p">=</span> <span class="s">$"SELECT * FROM Blogs WHERE Id IN (</span><span class="p">{</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">","</span><span class="p">,</span> <span class="n">inClauseParams</span><span class="p">.</span><span class="n">ParameterNames</span><span class="p">)}</span><span class="s">)"</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">blogsInList</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">QueryAsync</span><span class="p">&lt;</span><span class="n">Blog</span><span class="p">&gt;(</span><span class="n">inClauseSql</span><span class="p">,</span> <span class="n">inClauseParams</span><span class="p">);</span>

<span class="c1">// 7. Insert, Update, Delete (using parameters):</span>
<span class="kt">var</span> <span class="n">newBlogId</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">ExecuteScalarAsync</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span>
    <span class="s">"INSERT INTO Blogs (Name, Url) VALUES (@Name, @Url); SELECT SCOPE_IDENTITY();"</span><span class="p">,</span>
    <span class="k">new</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">"Another Blog"</span><span class="p">,</span> <span class="n">Url</span> <span class="p">=</span> <span class="s">"http://another.com"</span> <span class="p">});</span>

<span class="kt">var</span> <span class="n">updatedRows</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="nf">ExecuteAsync</span><span class="p">(</span>
    <span class="s">"UPDATE Blogs SET Url = @NewUrl WHERE Id = @Id"</span><span class="p">,</span>
    <span class="k">new</span> <span class="p">{</span> <span class="n">Id</span> <span class="p">=</span> <span class="n">newBlogId</span><span class="p">,</span> <span class="n">NewUrl</span> <span class="p">=</span> <span class="s">"http://updated.com"</span> <span class="p">});</span>

<span class="kt">var</span> <span class="n">deletedRows</span> <span class="p">=</span> <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="nf">ExecuteAsync</span><span class="p">(</span><span class="s">"DELETE FROM Blogs WHERE Id = @Id"</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">Id</span> <span class="p">=</span> <span class="n">newBlogId</span> <span class="p">});</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="learn-ef-core"></a>[1] <a href="https://learn.microsoft.com/en-us/ef/core/" class="bare">https://learn.microsoft.com/en-us/ef/core/</a></p>
</li>
<li>
<p><a id="learn-ef-core-gs-install"></a>[2] <a href="https://learn.microsoft.com/en-us/ef/core/get-started/overview/install" class="bare">https://learn.microsoft.com/en-us/ef/core/get-started/overview/install</a></p>
</li>
<li>
<p><a id="learn-ef-core-nupkg"></a>[3] <a href="https://learn.microsoft.com/en-us/ef/core/what-is-new/nuget-packages" class="bare">https://learn.microsoft.com/en-us/ef/core/what-is-new/nuget-packages</a></p>
</li>
<li>
<p><a id="mssql-create-filtered-indexes"></a>[4] <a href="https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-filtered-indexes" class="bare">https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-filtered-indexes</a></p>
</li>
<li>
<p><a id="mssql-create-indexes-with-included-columns"></a>[5] <a href="https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-indexes-with-included-columns" class="bare">https://learn.microsoft.com/en-us/sql/relational-databases/indexes/create-indexes-with-included-columns</a></p>
</li>
<li>
<p><a id="learndapper"></a>[6] <a href="https://www.learndapper.com/" class="bare">https://www.learndapper.com/</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
