<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Intro to SQL Server Database | CODE FARM</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Intro to SQL Server Database" />
<meta property="og:locale" content="en" />
<meta name="description" content="1. Deploy and connect to SQL Server Linux containers 1.1. Pull and run the SQL Server Linux container image 1.2. Connect to SQL Server 1.3. Create and query data 1.3.1. Create a new database 1.3.2. Insert data 1.3.3. Select data 2. Databases 2.1. Basic Information about Databases 2.1.1. Servers, Databases, Schemas and Tables 2.1.2. Files and FileGroups 2.1.3. Logins and Database Users 2.1.4. Roles and Permissions 2.2. Working with Databases 2.3. System Databases 2.3.1. master Database 2.4. Contained Databases 2.5. Database Files and Filegroups 2.5.1. Database Files 2.5.2. Logical and Physical File Names 3. Database Engine Permissions and Principals 3.1. Server-level roles 3.2. Database-level roles 3.3. Contained database users: Make your database portable by using contained databases 3.3.1. Traditional login and user model 3.3.2. Contained database user model 3.4. Security principals 3.4.1. Logins 3.4.2. Fixed server roles 3.4.3. User-defined server roles 3.4.4. Database users 3.4.5. Fixed database roles 3.4.6. User-defined database roles 3.4.7. Other principals 3.5. Assign permissions 3.6. Permission hierarchy 3.7. Monitor permissions 3.8. Principals (Database Engine) 3.8.1. SQL Server-level principals 3.8.2. Database-level principals 3.8.3. sa Login 3.8.4. dbo User and dbo Schema 3.8.5. public Server Role and Database Role 4. SQL and T-SQL 5. SQL Server Utilities Statements - GO 6. Collation and Unicode support 7. Database identifiers 8. Transact-SQL syntax conventions (Transact-SQL) 9. Tutorial: Write Transact-SQL statements 9.1. Lesson 1: Create and query database objects 9.1.1. Create a database 9.1.2. Create a Table 9.1.2.1. Switch the Query Editor connection to the TestData database 9.1.2.2. Create the table 9.1.3. Insert and update data in a table 9.1.3.1. Insert data into a table 9.1.3.2. Update the products table 9.1.4. Read data from a table 9.1.4.1. Read the data in a table 9.1.4.2. Useful functions in a SELECT statement 9.1.5. Create views and stored procedures 9.1.5.1. Create a view 9.1.5.2. Test the view 9.1.5.3. Create a stored procedure 9.1.5.4. Test the stored procedure 9.2. Lesson 2: Configure permissions on database objects 9.2.1. Create a login 9.2.1.1. Create a new Windows account 9.2.1.2. Create a SQL login using Windows Authentication with T-SQL 9.2.1.3. Create a login using SQL Server Authentication with T-SQL 9.2.2. Grant access to a database 9.2.2.1. Create a user in a database 9.2.2.2. Create views and stored procedures 9.2.2.3. About GRANT 9.3. Lesson 3: Delete database objects 9.3.1. Revoke stored procedure permissions 9.3.2. Drop permissions 9.3.3. Delete table 9.3.4. Remove database 10. References 1. Deploy and connect to SQL Server Linux containers In this quickstart, you&#8217;ll use Docker to pull and run the SQL Server 2022 (16.x) Linux container image, mssql-server-linux. Then you can connect with sqlcmd to create your first database and run queries. 1.1. Pull and run the SQL Server Linux container image Pull the SQL Server 2022 (16.x) Linux container image from the Microsoft Container Registry. sudo docker pull mcr.microsoft.com/mssql/server:2022-latest To run the Linux container image with Docker, you can use the following command from a bash shell or elevated PowerShell command prompt. The SA_PASSWORD environment variable is deprecated. Please use MSSQL_SA_PASSWORD instead. sudo docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;&quot; \ -p 1433:1433 --name sql1 --hostname sql1 \ -d \ mcr.microsoft.com/mssql/server:2022-latest Your password should follow the SQL Server default password policy, otherwise the container can&#8217;t set up SQL Server and will stop working. By default, the password must be at least eight characters long and contain characters from three of the following four sets: uppercase letters, lowercase letters, base-10 digits, and symbols. By default, this quickstart creates a container with the Developer edition of SQL Server. The process for running production editions in containers is slightly different. To view your Docker containers, use the docker ps command. docker ps You should see output similar to the following: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 274554ac9f0d mcr.microsoft.com/mssql/server:2022-latest &quot;/opt/mssql/bin/perm…&quot; 42 seconds ago Up 1 second 0.0.0.0:1433-&gt;1433/tcp, :::1433-&gt;1433/tcp sql1 If the STATUS column shows a status of Up, then SQL Server is running in the container and listening on the port specified in the PORTS column. If the STATUS column for your SQL Server container shows Exited, see the Troubleshooting section of the configuration guide. 1.2. Connect to SQL Server The following steps use the SQL Server command-line tool, sqlcmd, inside the container to connect to SQL Server. Use the docker exec -it command to start an interactive bash shell inside your running container. In the following example sql1 is name specified by the --name parameter when you created the container. sudo docker exec -it sql1 &quot;bash&quot; Once inside the container, connect locally with sqlcmd, using its full path. /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -P &quot;&lt;YourStrong@Passw0rd&gt;&quot; -No You can omit the password on the command-line to be prompted to enter it. Here&#8217;s an example: /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -No If successful, you should get to a sqlcmd command prompt: 1&gt;. 1&gt; :help :!! [&lt;command&gt;] - Executes a command in the command shell. :connect server[\instance] [-l timeout] [-U user [-P password]] - Connects to a SQL Server instance. :error &lt;dest&gt; - Redirects error output to a file, stderr, or stdout. :exit - Quits sqlcmd immediately. :exit() - Execute statement cache; quit with no return value. :exit(&lt;query&gt;) - Execute the specified query; returns numeric result. go [&lt;n&gt;] - Executes the statement cache (n times). :help - Shows this list of commands. :list - Prints the content of the statement cache. :listvar - Lists the set sqlcmd scripting variables. :on error [exit|ignore] - Action for batch or sqlcmd command errors. :out &lt;filename&gt;|stderr|stdout - Redirects query output to a file, stderr, or stdout. :perftrace &lt;filename&gt;|stderr|stdout - Redirects timing output to a file, stderr, or stdout. :quit - Quits sqlcmd immediately. :r &lt;filename&gt; - Append file contents to the statement cache. :reset - Discards the statement cache. :serverlist - Lists local and SQL Servers on the network. :setvar {variable} - Removes a sqlcmd scripting variable. :setvar &lt;variable&gt; &lt;value&gt; - Sets a sqlcmd scripting variable. $ /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -P &quot;&lt;YourStrong@Passw0rd&gt;&quot; -No -Q &quot;SELECT @@version&quot; ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ Microsoft SQL Server 2022 (RTM-CU16) (KB5048033) - 16.0.4165.4 (X64) Nov 6 2024 19:24:49 Copyright (C) 2022 Microsoft Corporation Developer Edition (64-bit) on Linux (Ubuntu 22.04.5 LTS) &lt;X64&gt; (1 rows affected) 1.3. Create and query data The following sections walk you through using sqlcmd and Transact-SQL to create a new database, add data, and run a query. 1.3.1. Create a new database The following steps create a new database named TestDB. From the sqlcmd command prompt, paste the following Transact-SQL command to create a test database: CREATE DATABASE TestDB; On the next line, write a query to return the name of all of the databases on your server: SELECT Name from sys.databases; The previous two commands weren&#8217;t run immediately. Type GO on a new line to run the previous commands: GO 1.3.2. Insert data Next create a new table, Inventory, and insert two new rows. From the sqlcmd command prompt, switch context to the new TestDB database: USE TestDB; Create new table named Inventory: CREATE TABLE Inventory (id INT, name NVARCHAR(50), quantity INT); Insert data into the new table: INSERT INTO Inventory VALUES (1, &#39;banana&#39;, 150); INSERT INTO Inventory VALUES (2, &#39;orange&#39;, 154); Type GO to run the previous commands: GO 1.3.3. Select data Now, run a query to return data from the Inventory table. From the sqlcmd command prompt, enter a query that returns rows from the Inventory table where the quantity is greater than 152: SELECT * FROM Inventory WHERE quantity &gt; 152; Run the command: GO Exit the sqlcmd command prompt To end your sqlcmd session, type QUIT: QUIT To exit the interactive command-prompt in your container, type exit. Your container continues to run after you exit the interactive bash shell. 2. Databases A database in SQL Server is made up of a collection of tables that stores a specific set of structured data. A table contains a collection of rows, also referred to as records or tuples, and columns, also referred to as attributes. Each column in the table is designed to store a certain type of information, for example, dates, names, dollar amounts, and numbers. 2.1. Basic Information about Databases 2.1.1. Servers, Databases, Schemas and Tables A computer can have one or more than one instance of SQL Server installed. Each instance of SQL Server can contain one or many databases. Within a database, there are one or many object ownership groups called schemas. Within each schema there are database objects such as tables, views, and stored procedures. Some objects such as certificates and asymmetric keys are contained within the database, but are not contained within a schema. For more information about creating tables, see Tables. Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views 2.1.2. Files and FileGroups SQL Server databases are stored in the file system in files. Files can be grouped into filegroups. For more information about files and filegroups, see Database Files and Filegroups. 2.1.3. Logins and Database Users When people gain access to an instance of SQL Server they are identified as a login. When people gain access to a database they are identified as a database user. A database user can be based on a login. If contained databases are enabled, a database user can be created that is not based on a login. For more information about users, see CREATE USER (Transact-SQL). Logins &lt;-&gt; Servers (instances) Database Users &lt;-&gt; Databases 2.1.4. Roles and Permissions A user that has access to a database can be given permission to access the objects in the database. Though permissions can be granted to individual users, we recommend creating database roles, adding the database users to the roles, and then grant access permission to the roles. Granting permissions to roles instead of users makes it easier to keep permissions consistent and understandable as the number of users grow and continually change. For more information about roles permissions, see CREATE ROLE (Transact-SQL) and Principals (Database Engine). 2.2. Working with Databases Most people who work with databases use the SQL Server Management Studio tool. The Management Studio tool has a graphical user interface for creating databases and the objects in the databases. Management Studio also has a query editor for interacting with databases by writing Transact-SQL statements. Management Studio can be installed from the SQL Server installation disk, or downloaded from MSDN. For more information about SQL Server Management Studio tool, see SQL Server Management Studio (SSMS). 2.3. System Databases SQL Server includes the following system databases. System database Description master Database Records all the system-level information for an instance of SQL Server. msdb Database Is used by SQL Server Agent for scheduling alerts and jobs. model Database Is used as the template for all databases created on the instance of SQL Server. Modifications made to the model database, such as database size, collation, recovery model, and other database options, are applied to any databases created afterward. Resource Database Is a read-only database that contains system objects that are included with SQL Server. System objects are physically persisted in the Resource database, but they logically appear in the sys schema of every database. tempdb Database Is a workspace for holding temporary objects or intermediate result sets. For Azure SQL Database single databases and elastic pools, only master Database and tempdb Database apply. 2.3.1. master Database The master database records all the system-level information for a SQL Server system. This includes instance-wide metadata such as logon accounts, endpoints, linked servers, and system configuration settings. In SQL Server, system objects are no longer stored in the master database; instead, they are stored in the Resource database. Also, master is the database that records the existence of all other databases and the location of those database files and records the initialization information for SQL Server. Therefore, SQL Server cannot start if the master database is unavailable. 2.4. Contained Databases A contained database is a database that is isolated from other databases and from the instance of SQL Server that hosts the database. SQL Server helps user to isolate their database from the instance in 4 ways. Much of the metadata that describes a database is maintained in the database. (In addition to, or instead of, maintaining metadata in the master database.) All metadata are defined using the same collation. User authentication can be performed by the database, reducing the databases dependency on the logins of the instance of SQL Server. The SQL Server environment (DMV&#8217;s, XEvents, etc.) reports and can act upon containment information. 2.5. Database Files and Filegroups At a minimum, every SQL Server database has two operating system files: a data file and a log file. Data files contain data and objects such as tables, indexes, stored procedures, and views. Log files contain the information that is required to recover all transactions in the database. Data files can be grouped together in filegroups for allocation and administration purposes. 2.5.1. Database Files SQL Server databases have three types of files, as shown in the following table. File Description Primary Contains startup information for the database and points to the other files in the database. Every database has one primary data file. The recommended file name extension for primary data files is .mdf. Secondary Optional user-defined data files. Data can be spread across multiple disks by putting each file on a different disk drive. The recommended file name extension for secondary data files is .ndf. Transaction Log The log holds information used to recover the database. There must be at least one log file for each database. The recommended file name extension for transaction logs is .ldf. For example, a simple database named Sales has one primary file that contains all data and objects and a log file that contains the transaction log information. A more complex database named Orders can be created that includes one primary file and five secondary files. The data and objects within the database spread across all six files, and the four log files contain the transaction log information. By default, the data and transaction logs are put on the same drive and path to handle single-disk systems. This choice may not be optimal for production environments. We recommend that you put data and log files on separate disks. $ ls /var/opt/mssql/data/ Entropy.bin Sales_log.ldf mastlog.ldf model_msdbdata.mdf model_replicatedmaster.ldf modellog.ldf msdblog.ldf tempdb2.ndf tempdb4.ndf Sales.mdf master.mdf model.mdf model_msdblog.ldf model_replicatedmaster.mdf msdbdata.mdf tempdb.mdf tempdb3.ndf templog.ldf 2.5.2. Logical and Physical File Names SQL Server files have two file name types: logical_file_name: The logical_file_name is the name used to refer to the physical file in all Transact-SQL statements. The logical file name must comply with the rules for SQL Server identifiers and must be unique among logical file names in the database. os_file_name: The os_file_name is the name of the physical file including the directory path. It must follow the rules for the operating system file names. When multiple instances of SQL Server are running on a single computer, each instance receives a different default directory to hold the files for the databases created in the instance. For more information, see File Locations for Default and Named Instances of SQL Server. 3. Database Engine Permissions and Principals Permissions in the Database Engine are managed at the server level through logins and server roles, and at the database level through database users and database roles. The model for SQL Database exposes the same system within each database, but the server level permissions aren&#8217;t available. 3.1. Server-level roles SQL Server provides server-level roles to help you manage the permissions on a server. These roles are security principals that group other principals. Server-level roles are server-wide in their permissions scope. 3.2. Database-level roles Database-level roles are database-wide in their permissions scope. There are two types of database-level roles: fixed-database roles that are predefined in the database and user-defined database roles that you can create. Fixed-database roles are defined at the database level and exist in each database. Members of the db_owner database role can manage fixed-database role membership. There are also some special-purpose database roles in the msdb database. You can add any database account and other SQL Server roles into database-level roles. 3.3. Contained database users: Make your database portable by using contained databases Use contained database users to authenticate SQL Server and Azure SQL Database connections at the database level. A contained database is a database that&#8217;s isolated from other databases and from the instance of SQL Server or SQL Database (and the master database) that hosts the database. 3.3.1. Traditional login and user model In the traditional connection model, Windows users or members of Windows groups connect to the Database Engine by providing user or group credentials authenticated by Windows. Or users can provide both a name and password and connect by using SQL Server authentication. In both cases, the master database must have a login that matches the connecting credentials. After the Database Engine confirms the Windows authentication credentials or authenticates the SQL Server authentication credentials, the connection typically attempts to connect to a user database. To connect to a user database, the login must be mapped to (that is, associated with) a database user in the user database. The connection string might also specify connecting to a specific database, which is optional in SQL Server but required in SQL Database. The important principle is that both the login (in the master database) and the user (in the user database) must exist and be related to each other. The connection to the user database has a dependency upon the login in the master database. This dependency limits the ability of the database to be moved to a different hosting SQL Server instance or Azure SQL Database server. If a connection to the master database is not available (for example, a failover is in progress), the overall connection time will increase, or the connection might time out. An unavailable connection might reduce connection scalability. 3.3.2. Contained database user model In the contained database user model, the login in the master database is not present. Instead, the authentication process occurs at the user database. The database user in the user database doesn&#8217;t have an associated login in the master database. The contained database user model supports both Windows authentication and SQL Server authentication. You can use it in both SQL Server and SQL Database. To connect as a contained database user, the connection string must always contain a parameter for the user database. The Database Engine uses this parameter to know which database is responsible for managing the authentication process. The activity of the contained database user is limited to the authenticating database. The database user account must be independently created in each database that the user needs. To change databases, SQL Database users must create a new connection. Contained database users in SQL Server can change databases if an identical user is present in another database. 3.4. Security principals Security principal is the official name of the identities that use SQL Server and that can be assigned permission to take actions. They are usually people or groups of people, but can be other entities that pretend to be people. The security principals can be created and managed using the Transact-SQL listed, or by using SQL Server Management Studio. 3.4.1. Logins Logins are individual user accounts for logging on to the SQL Server Database Engine. SQL Server and SQL Database support logins based on Windows authentication and logins based on SQL Server authentication. For information about the two types of logins, see Choose an Authentication Mode. 3.4.2. Fixed server roles In SQL Server, fixed server roles are a set of pre-configured roles that provide convenient group of server-level permissions. Logins can be added to the roles using the ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER SERVER ROLE (Transact-SQL). SQL Database doesn&#8217;t support the fixed server roles, but has two roles in the master database (dbmanager and loginmanager) that act like server roles. 3.4.3. User-defined server roles In SQL Server, you can create your own server roles and assign server-level permissions to them. Logins can be added to the server roles using the ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER SERVER ROLE (Transact-SQL). SQL Database doesn&#8217;t support the user-defined server roles. 3.4.4. Database users Logins are granted access to a database by creating a database user in a database and mapping that database user to sign in. Typically the database user name is the same as the login name, though it doesn&#8217;t have to be the same. Each database user maps to a single login. A login can be mapped to only one user in a database, but can be mapped as a database user in several different databases. Database users can also be created that don&#8217;t have a corresponding login. These users are called contained database users. Microsoft encourages the use of contained database users because it makes it easier to move your database to a different server. Like a login, a contained database user can use either Windows authentication or SQL Server authentication. For more information, see Contained Database Users - Making Your Database Portable. There are 12 types of users with slight differences in how they authenticate, and who they represent. To see a list of users, see CREATE USER (Transact-SQL). 3.4.5. Fixed database roles Fixed database roles are a set of pre-configured roles that provide convenient group of database-level permissions. Database users and user-defined database roles can be added to the fixed database roles using the ALTER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER ROLE (Transact-SQL). 3.4.6. User-defined database roles Users with the CREATE ROLE permission can create new user-defined database roles to represent groups of users with common permissions. Typically permissions are granted or denied to the entire role, simplifying permissions management and monitoring. Database users can be added to the database roles by using the ALTER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER ROLE (Transact-SQL). 3.4.7. Other principals Additional security principals not discussed here include application roles, and logins and users based on certificates or asymmetric keys. For a graphic showing the relationships between Windows users, Windows groups, logins, and database users, see Create a Database User. 3.5. Assign permissions Every SQL Server securable has associated permissions that can be granted to a principal. Permissions in the Database Engine are managed at the server level assigned to logins and server roles, and at the database level assigned to database users and database roles. The model for Azure SQL Database has the same system for the database permissions, but the server level permissions aren&#8217;t available. Most permission statements have the format: AUTHORIZATION PERMISSION ON SECURABLE::NAME TO PRINCIPAL; AUTHORIZATION must be GRANT, REVOKE or DENY. The PERMISSION establishes what action is allowed or prohibited. The exact number of permissions differs between SQL Server and SQL Database. The permissions are listed in the article Permissions (Database Engine) and in the chart referenced below. ON SECURABLE::NAME is the type of securable (server, server object, database, or database object) and its name. Some permissions don&#8217;t require ON SECURABLE::NAME because it is unambiguous or inappropriate in the context. For example, the CREATE TABLE permission doesn&#8217;t require the ON SECURABLE::NAME clause (GRANT CREATE TABLE TO Mary; allows Mary to create tables). PRINCIPAL is the security principal (login, user, or role) which receives or loses the permission. Grant permissions to roles whenever possible. The following example grant statement, grants the UPDATE permission on the Parts table or view that is contained in the Production schema to the role named PartsTeam: GRANT UPDATE ON OBJECT::Production.Parts TO PartsTeam; The following example grant statement grants the UPDATE permission on the Production schema, and by extension on any table or view contained within this schema to the role named ProductionTeam, which is a more effective and salable approach to assigning permissions than on individual object-level: GRANT UPDATE ON SCHEMA::Production TO ProductionTeam; Permissions are granted to security principals (logins, users, and roles) by using the GRANT statement. Permissions are explicitly denied by using the DENY command. A previously granted or denied permission is removed by using the REVOKE statement. Permissions are cumulative, with the user receiving all the permissions granted to the user, login, and any group memberships; however any permission denial overrides all grants. A common mistake is to attempt to remove a GRANT by using DENY instead of REVOKE. This can cause problems when a user receives permissions from multiple sources; which is quite common. The following example demonstrates the principal. The Sales group receives SELECT permissions on the OrderStatus table through the statement GRANT SELECT ON OBJECT::OrderStatus TO Sales;. User Jae is a member of the Sales role. Jae has also been granted SELECT permission to the OrderStatus table under their own user name through the statement GRANT SELECT ON OBJECT::OrderStatus TO Jae;. Presume the administer wishes to remove the GRANT to the Sales role. If the administrator correctly executes REVOKE SELECT ON OBJECT::OrderStatus TO Sales;, then Jae will retain SELECT access to the OrderStatus table through their individual GRANT statement. If the administrator incorrectly executes DENY SELECT ON OBJECT::OrderStatus TO Sales; then Jae, as a member of the Sales role, will be denied the SELECT permission because the DENY to Sales overrides their individual GRANT. Permissions can be configured using Management Studio. Find the securable in Object Explorer, right-click the securable, and then select Properties. Select the Permissions page. For help on using the permission page, see Permissions or Securables Page. 3.6. Permission hierarchy Permissions have a parent/child hierarchy. That is, if you grant SELECT permission on a database, that permission includes SELECT permission on all (child) schemas in the database. If you grant SELECT permission on a schema, it includes SELECT permission on all the (child) tables and views in the schema. The permissions are transitive; that is, if you grant SELECT permission on a database, it includes SELECT permission on all (child) schemas, and all (grandchild) tables and views. Permissions also have covering permissions. The CONTROL permission on an object, normally gives you all other permissions on the object. Because both the parent/child hierarchy and the covering hierarchy can act on the same permission, the permission system can get complicated. For example, let&#8217;s take a table (Region), in a schema (Customers), in a database (SalesDB). CONTROL permission on table Region includes all the other permissions on the table Region, including ALTER, SELECT, INSERT, UPDATE, DELETE, and some other permissions. SELECT on the Customers schema that owns the Region table includes the SELECT permission on the Region table. So SELECT permission on the Region table can be achieved through any of these six statements: GRANT SELECT ON OBJECT::Region TO Jae; GRANT CONTROL ON OBJECT::Region TO Jae; GRANT SELECT ON SCHEMA::Customers TO Jae; GRANT CONTROL ON SCHEMA::Customers TO Jae; GRANT SELECT ON DATABASE::SalesDB TO Jae; GRANT CONTROL ON DATABASE::SalesDB TO Jae; 3.7. Monitor permissions The following views return security information. The logins and user-defined server roles on a server can be examined by using the sys.server_principals view. This view isn&#8217;t available in SQL Database. The users and user-defined roles in a database can be examined by using the sys.database_principals view. The permissions granted to logins and user-defined fixed server roles can be examined by using the sys.server_permissions view. This view isn&#8217;t available in SQL Database. The permissions granted to users and user-defined fixed database roles can be examined by using the sys.database_permissions view. Database role membership can be examined by using the sys.database_role_members view. Server role membership can be examined by using the sys.server_role_members view. This view isn&#8217;t available in SQL Database. For additional security related views, see Security Catalog Views (Transact-SQL). 3.8. Principals (Database Engine) Principals are entities that can request SQL Server resources. Like other components of the SQL Server authorization model, principals can be arranged in a hierarchy. The scope of influence of a principal depends on the scope of the definition of the principal: Windows, server, database; and whether the principal is indivisible or a collection. A Windows Login is an example of an indivisible principal, and a Windows Group is an example of a principal that is a collection. Every principal has a security identifier (SID). 3.8.1. SQL Server-level principals SQL Server authentication Login Windows authentication login for a Windows user Windows authentication login for a Windows group Azure Active Directory authentication login for a AD user Azure Active Directory authentication login for a AD group Server Role 3.8.2. Database-level principals Database User (There are 12 types of users. For more information, see CREATE USER.) Database Role Application Role 3.8.3. sa Login The SQL Server sa login is a server-level principal. By default, it is created when an instance is installed. Beginning in SQL Server 2005 (9.x), the default database of sa is master. This is a change of behavior from earlier versions of SQL Server. The sa login is a member of the sysadmin fixed server-level role. The sa login has all permissions on the server and cannot be limited. The sa login cannot be dropped, but it can be disabled so that no one can use it. 3.8.4. dbo User and dbo Schema The dbo user is a special user principal in each database. All SQL Server administrators, members of the sysadmin fixed server role, sa login, and owners of the database, enter databases as the dbo user. The dbo user has all permissions in the database and cannot be limited or dropped. dbo stands for database owner, but the dbo user account is not the same as the db_owner fixed database role, and the db_owner fixed database role is not the same as the user account that is recorded as the owner of the database. The dbo user owns the dbo schema. The dbo schema is the default schema for all users, unless some other schema is specified. The dbo schema cannot be dropped. 3.8.5. public Server Role and Database Role Every login belongs to the public fixed server role, and every database user belongs to the public database role. When a login or user has not been granted or denied specific permissions on a securable, the login or user inherits the permissions granted to public on that securable. The public fixed server role and the public fixed database role cannot be dropped. However you can revoke permissions from the public roles. There are many permissions that are assigned to the public roles by default. Most of these permissions are needed for routine operations in the database; the type of things that everyone should be able to do. Be careful when revoking permissions from the public login or user, as it will affect all logins/users. Generally you should not deny permissions to public, because the deny statement overrides any grant statements you might make to individuals. 4. SQL and T-SQL SQL, From Wikipedia, the free encyclopedia, https://en.wikipedia.org/wiki/SQL Structured Query Language, abbreviated as SQL (/ˌɛsˌkjuːˈɛl/ ) S-Q-L, sometimes /ˈsiːkwəl/ &quot;sequel&quot; for historical reasons), is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It is particularly useful in handling structured data, i.e. data incorporating relations among entities and variables. Transact-SQL, From Wikipedia, the free encyclopedia, https://en.wikipedia.org/wiki/Transact-SQL Transact-SQL (T-SQL) is Microsoft&#8217;s and Sybase&#8217;s proprietary extension to the SQL (Structured Query Language) used to interact with relational databases. T-SQL expands on the SQL standard to include procedural programming, local variables, various support functions for string processing, date processing, mathematics, etc. and changes to the DELETE and UPDATE statements. Transact-SQL is central to using Microsoft SQL Server. All applications that communicate with an instance of SQL Server do so by sending Transact-SQL statements to the server, regardless of the user interface of the application. Stored procedures in SQL Server are executable server-side routines. The advantage of stored procedures is the ability to pass parameters. 5. SQL Server Utilities Statements - GO SQL Server provides commands that are not Transact-SQL statements, but are recognized by the sqlcmd and osql utilities and SQL Server Management Studio Code Editor. These commands can be used to facilitate the readability and execution of batches and scripts. GO signals the end of a batch of Transact-SQL statements to the SQL Server utilities. Syntax GO [count] Arguments count Is a positive integer. The batch preceding GO will execute the specified number of times. Remarks GO is not a Transact-SQL statement; it is a command recognized by the sqlcmd and osql utilities and SQL Server Management Studio Code editor. SQL Server utilities interpret GO as a signal that they should send the current batch of Transact-SQL statements to an instance of SQL Server. The current batch of statements is composed of all statements entered since the last GO, or since the start of the ad hoc session or script if this is the first GO. A Transact-SQL statement cannot occupy the same line as a GO command. However, the line can contain comments. Users must follow the rules for batches. For example, any execution of a stored procedure after the first statement in a batch must include the EXECUTE keyword. The scope of local (user-defined) variables is limited to a batch, and cannot be referenced after a GO command. USE AdventureWorks2012; GO DECLARE @MyMsg VARCHAR(50) SELECT @MyMsg = &#39;Hello, World.&#39; GO -- @MyMsg is not valid after this GO ends the batch. -- Yields an error because @MyMsg not declared in this batch. PRINT @MyMsg GO SELECT @@VERSION; -- Yields an error: Must be EXEC sp_who if not first statement in -- batch. sp_who GO SQL Server applications can send multiple Transact-SQL statements to an instance of SQL Server for execution as a batch. The statements in the batch are then compiled into a single execution plan. Programmers executing ad hoc statements in the SQL Server utilities, or building scripts of Transact-SQL statements to run through the SQL Server utilities, use GO to signal the end of a batch. Applications based on the ODBC or OLE DB APIs receive a syntax error if they try to execute a GO command. The SQL Server utilities never send a GO command to the server. Do not use a semicolon as a statement terminator after GO. -- Yields an error because ; is not permitted after GO SELECT @@VERSION; GO; The GO statement is not a SQL statement; rather, it is a command recognized by the SQL Server Management Studio (SSMS), sqlcmd, and other SQL Server utilities. In the context of these utilities, GO signals the end of a batch of statements and is used to separate batches of statements from each other. However, when you are performing database operations from ADO.NET (or any other context where you&#8217;re sending SQL statements directly to SQL Server), batch separation is not needed, and the GO statement is not recognized. If you try to include the GO statement in your SQL strings in ADO.NET, you&#8217;ll likely encounter a SQL Server error that &#39;GO&#39; is not a recognized built-in function name. Instead, just end each of your SQL statements with a semicolon (;). 6. Collation and Unicode support Collations in SQL Server provide sorting rules, case, and accent sensitivity properties for your data. Collations that are used with character data types, such as char and varchar, dictate the code page and corresponding characters that can be represented for that data type. Whether you&#8217;re installing a new instance of SQL Server, restoring a database backup, or connecting server to client databases, it&#8217;s important to understand the locale requirements, sorting order, and case and accent sensitivity of the data that you&#8217;re working with. To list the collations that are available on your instance of SQL Server, see sys.fn_helpcollations (Transact-SQL). When you select a collation for your server, database, column, or expression, you&#8217;re assigning certain characteristics to your data. These characteristics affect the results of many operations in the database. For example, when you construct a query by using ORDER BY, the sort order of your result set might depend on the collation that&#8217;s applied to the database or dictated in a COLLATE clause at the expression level of the query. Setting collations are supported at the following levels of an instance of SQL Server: Server-level collations The default server collation is determined during SQL Server setup, and it becomes the default collation of the system databases and all user databases. To query the server collation for an instance of SQL Server, use the SERVERPROPERTY function: SELECT CONVERT(nvarchar(128), SERVERPROPERTY(&#39;collation&#39;)); -- SQL_Latin1_General_CP1_CI_AS * SQL_Latin1_General_CP1_CI_AS is a collation setting in SQL Server. Here&#8217;s what each part of it means: SQL indicates that it is a SQL Server-defined collation. Latin1_General is the base language and alphabet, which in this case is the Latin 1 (Western European) alphabet. CP1 stands for Code Page 1, which implies that the collation is using code page 1252. This page includes all ASCII characters and additional characters used in English and several other Western European languages. CI stands for Case Insensitive. This means the collation doesn&#8217;t recognize case differences. When CI is specified, &#39;a&#39; is considered equal to &#39;A&#39;. AS stands for Accent Sensitive. This means the collation does recognize accent differences. When AS is specified, &#39;résumé&#39; is not equal to &#39;resume&#39;. * If you want to use unicode (UTF-8) character sets in SQL Server, you can use the newer collations introduced starting from SQL Server 2019 onward. The new collations are named as _SC or _SC_UTF8. The SC stands for Supplementary Characters, which supports UCS-2 or UTF-16 characters. If you want to particularly use UTF-8, you can use _utf8 postfix. So if you need to define columns that can store unicode (UTF-8) strings from any language, you can use something like Latin1_General_100_CI_AS_SC_UTF8. _100 here corresponds to newer set of collations in SQL Server 2019. Please note that UTF-8 collations are only available to char and varchar data types, not to text data type. And if you&#8217;re dealing with wider unicode character sets and more complex translations, it may be better to use nchar or nvarchar data types with either UTF-16 or supplementary character collations. * The Case Insensitive (CI) property in a SQL Server collation does not modify the actual data stored in a cell of a table. If a username is stored as &#39;JohnDoe&#39;, it will be stored as &#39;JohnDoe&#39; regardless of whether the collation is Case Sensitive (CS) or Case Insensitive (CI). The collation only affects how SQL Server compares and sorts that data during queries. In a Case Insensitive collation, SQL Server considers &#39;JohnDoe&#39; and &#39;johndoe&#39; to be equal. If the collation were Case Sensitive, &#39;JohnDoe&#39; and &#39;johndoe&#39; would be considered as two different values. So to put it diagrammatically: With Case Insensitive (CI) collation : SELECT * FROM Users WHERE user_name = &#39;johndoe&#39; will return &#39;JohnDoe&#39;, &#39;JOHNDOE&#39;, &#39;johndoe&#39;, etc. With Case Sensitive (CS) collation : SELECT * FROM Users WHERE user_name = &#39;johndoe&#39; will only return &#39;johndoe&#39; and not &#39;JohnDoe&#39; or &#39;JOHNDOE&#39;. This comparison and sorting behaviour applies both to operations you perform in queries (like WHERE, ORDER BY, JOIN, etc.), as well as to indexes that SQL Server uses to optimize query performance. To query the server for all available collations, use the following fn_helpcollations() built-in function: SELECT * FROM sys.fn_helpcollations(); Database-level collations When you create or modify a database, you can use the COLLATE clause of the CREATE DATABASE or ALTER DATABASE statement to specify the default database collation. If no collation is specified, the database is assigned the server collation. You can retrieve the current collation of a database by using a statement similar to the following code sample: SELECT CONVERT (nvarchar(128), DATABASEPROPERTYEX(&#39;database_name&#39;, &#39;collation&#39;)); Column-level collations When you create or alter a table, you can specify collations for each character-string column by using the COLLATE clause. If you don&#8217;t specify a collation, the column is assigned the default collation of the database. Expression-level collations Expression-level collations are set when a statement is run, and they affect the way a result set is returned. This enables ORDER BY sort results to be locale-specific. To implement expression-level collations, use a COLLATE clause such as the following code sample: SELECT name FROM customer ORDER BY name COLLATE Latin1_General_CS_AI; A locale is a set of information that&#8217;s associated with a location or a culture. The information can include the name and identifier of the spoken language, the script that&#8217;s used to write the language, and cultural conventions. Collations can be associated with one or more locales. For more information, see Locale IDs Assigned by Microsoft. A code page is an ordered set of characters of a given script in which a numeric index, or code point value, is associated with each character. A Windows code page is typically referred to as a character set or a charset. Code pages are used to provide support for the character sets and keyboard layouts that are used by different Windows system locales. Sort order specifies how data values are sorted. The order affects the results of data comparison. Data is sorted by using collations, and it can be optimized by using indexes. Unicode is a standard for mapping code points to characters. Because it&#8217;s designed to cover all the characters of all the languages of the world, you don&#8217;t need different code pages to handle different sets of characters. Storing data in multiple languages within one database is difficult to manage when you use only character data and code pages. It&#8217;s also difficult to find one code page for the database that can store all the required language-specific characters. Additionally, it&#8217;s difficult to guarantee the correct translation of special characters when they&#8217;re being read or updated by a variety of clients that are running various code pages. Databases that support international clients should always use Unicode data types instead of non-Unicode data types. The code pages that a client uses are determined by the operating system (OS) settings. To set client code pages on the Windows operating system, use Regional Settings in Control Panel. It would be difficult to select a code page for character data types that will support all the characters that are required by a worldwide audience. The easiest way to manage character data in international databases is to always use a data type that supports Unicode. If you store character data that reflects multiple languages in SQL Server (SQL Server 2005 (9.x) and later), use Unicode data types (nchar, nvarchar, and ntext) instead of non-Unicode data types (char, varchar, and text). Alternatively, starting with SQL Server 2019 (15.x), if a UTF-8 enabled collation (_UTF8) is used, previously non-Unicode data types (char and varchar) become Unicode data types using UTF-8 encoding. SQL Server 2019 (15.x) doesn&#8217;t change the behavior of previously existing Unicode data types (nchar, nvarchar, and ntext), which continue to use UCS-2 or UTF-16 encoding. For more information, see Storage differences between UTF-8 and UTF-16. 7. Database identifiers The database object name is referred to as its identifier. Everything in Microsoft SQL Server can have an identifier. Servers, databases, and database objects, such as tables, views, columns, indexes, triggers, procedures, constraints, and rules, can have identifiers. Identifiers are required for most objects, but are optional for some objects such as constraints. An object identifier is created when the object is defined. The identifier is then used to reference the object. For example, the following statement creates a table with the identifier TableX, and two columns with the identifiers KeyCol and Description: CREATE TABLE TableX (KeyCol INT PRIMARY KEY, Description nvarchar(80)); This table also has an unnamed constraint. The PRIMARY KEY constraint has no identifier. The collation of an identifier depends on the level at which it is defined. Identifiers of instance-level objects, such as logins and database names, are assigned the default collation of the instance. Identifiers of objects in a database, such as tables, views, and column names, are assigned the default collation of the database. For example, two tables with names that differ only in case can be created in a database that has case-sensitive collation, but cannot be created in a database that has case-insensitive collation. There are two classes of identifiers: Regular identifiers Comply with the rules for the format of identifiers. Regular identifiers are not delimited when they are used in Transact-SQL statements. USE AdventureWorks2022; GO SELECT * FROM HumanResources.Employee WHERE NationalIDNumber = 153479919 Delimited identifiers Are enclosed in double quotation marks (&quot;) or brackets ([ ]). Identifiers that comply with the rules for the format of identifiers might not be delimited. For example: USE AdventureWorks2022; GO SELECT * FROM [HumanResources].[Employee] --Delimiter is optional. WHERE [NationalIDNumber] = 153479919 --Delimiter is optional. Identifiers that do not comply with all the rules for identifiers must be delimited in a Transact-SQL statement. For example: SQL USE AdventureWorks2022; GO CREATE TABLE [SalesOrderDetail Table] --Identifier contains a space and uses a reserved keyword. ( [Order] [int] NOT NULL, [SalesOrderDetailID] [int] IDENTITY(1,1) NOT NULL, [OrderQty] [smallint] NOT NULL, [ProductID] [int] NOT NULL, [UnitPrice] [money] NOT NULL, [UnitPriceDiscount] [money] NOT NULL, [ModifiedDate] [datetime] NOT NULL, CONSTRAINT [PK_SalesOrderDetail_Order_SalesOrderDetailID] PRIMARY KEY CLUSTERED ([Order] ASC, [SalesOrderDetailID] ASC) ); GO SELECT * FROM [SalesOrderDetail Table] --Identifier contains a space and uses a reserved keyword. WHERE [Order] = 10; --Identifier is a reserved keyword. &gt; What&#8217;s the recommend naming convention in SQL Server? * Naming conventions in SQL Server are mostly a matter of personal preference or organizational standards. However, there are some commonly followed best practices that can increase the readability and manageability of your database. Here are a few recommended conventions: Meaningful and Descriptive Names: Names should clearly indicate what the object represents. For example, a table storing customer information should be named Customers or CustomerData, not Table1 or t1. Prefixes for Different Object Types: Using prefixes to denote the type of object can be useful. For example, stored procedures could be named with the sp_ prefix (like sp_GetCustomerDetails), views with vw_ prefix (like vw_CustomerOrders), and tables could be named without any prefix for clarity (like Orders). Avoid SQL Keywords: Avoid using SQL Server reserved words. This can cause confusion and sometimes lead to syntax errors. Be Consistent: Whichever convention you decide on, be consistent with it across all your SQL projects. PascalCase or snake_case: For multiple word names, use PascalCase (no spaces and each word capitalized like CustomerOrders) or snake_case (words separated by underscores like customer_orders). Avoid using spaces in object names. Singular or Plural Names: There&#8217;s much debate about whether to use singular or plural names for table names. Choose whichever makes the most logical sense in your context and be consistent. Avoid Special Characters and Spaces: With the exception of the underscore character, avoid using special characters, dots, hyphens, spaces etc. in names. Remember, the most important goal of any naming convention is to make the code and database structure easily understandable and manageable for the developers and administrators working on it. Note: In SQL Server, the sp_ prefix is reserved for system stored procedures. Some developers prefer not to use it for user-defined stored procedures to avoid potential naming conflicts and small performance penalties when the system searches the master database first for such procedures. They may use usp_ for user stored procedures instead. 8. Transact-SQL syntax conventions (Transact-SQL) The following table lists and describes conventions that are used in the syntax diagrams in the Transact-SQL reference. Convention Used for UPPERCASE Transact-SQL keywords. italic User-supplied parameters of Transact-SQL syntax. bold Type database names, table names, column names, index names, stored procedures, utilities, data type names, and text exactly as shown. | (vertical bar) Separates syntax items enclosed in brackets or braces. You can use only one of the items. [ ] (brackets) Optional syntax item. { } (braces) Required syntax items. Don&#8217;t type the braces. [ , &#8230;&#8203;n ] Indicates the preceding item can be repeated n number of times. The occurrences are separated by commas. [ &#8230;&#8203;n ] Indicates the preceding item can be repeated n number of times. The occurrences are separated by blanks. ; Transact-SQL statement terminator. Although the semicolon isn&#8217;t required for most statements in this version of SQL Server, it will be required in a future version. ::= The name for a block of syntax. Use this convention to group and label sections of lengthy syntax or a unit of syntax that you can use in more than one location within a statement. Each location in which the block of syntax could be used is indicated with the label enclosed in chevrons: &lt;label&gt;. A set is a collection of expressions, for example &lt;grouping set&gt;; and a list is a collection of sets, for example &lt;composite element list&gt;. Unless specified otherwise, all Transact-SQL references to the name of a database object can be a four-part name in the following form: server_name.[database_name].[schema_name].object_name | database_name.[schema_name].object_name | schema_name.object_name | object_name server_name Specifies a linked server name or remote server name. database_name Specifies the name of a SQL Server database when the object resides in a local instance of SQL Server. When the object is in a linked server, database_name specifies an OLE DB catalog. schema_name Specifies the name of the schema that contains the object if the object is in a SQL Server database. When the object is in a linked server, schema_name specifies an OLE DB schema name. object_name Refers to the name of the object. When referencing a specific object, you don&#8217;t always have to specify the server, database, and schema for the SQL Server Database Engine to identify the object. However, if the object can&#8217;t be found, an error is returned. To avoid name resolution errors, we recommend specifying the schema name whenever you specify a schema-scoped object. To omit intermediate nodes, use periods to indicate these positions. The following table shows the valid formats of object names. Object reference format Description server_name.database_name.schema_name.object_name Four-part name. server_name.database_name..object_name Schema name is omitted. server_name..schema_name.object_name Database name is omitted. server_name&#8230;&#8203;object_name Database and schema name are omitted. database_name.schema_name.object_name Server name is omitted. database_name..object_name Server and schema name are omitted. schema_name.object_name Server and database name are omitted. object_name Server, database, and schema name are omitted. SELECT @@SERVERNAME; -- 8a90e1fbcc1b SELECT name FROM [8a90e1fbcc1b].[master].[sys].[servers]; 9. Tutorial: Write Transact-SQL statements This tutorial is intended as a brief introduction to the Transact-SQL language and not as a replacement for a Transact-SQL class. The statements in this tutorial are intentionally simple, and aren&#8217;t meant to represent the complexity found in a typical production database. 9.1. Lesson 1: Create and query database objects Transact-SQL statements can be written and submitted to the Database Engine in the following ways: By using SQL Server Management Studio. By using the sqlcmd utility. By connecting from an application that you create. 9.1.1. Create a database Like many Transact-SQL statements, the CREATE DATABASE statement has a required parameter: the name of the database. CREATE DATABASE also has many optional parameters, such as the disk location where you want to put the database files. When you execute CREATE DATABASE without the optional parameters, SQL Server uses default values for many of these parameters. In a Query Editor window, type but don&#8217;t execute the following code: CREATE DATABASE TestData; GO Use the pointer to select the words CREATE DATABASE, and then press F1. In Query Editor, press F5 to execute the statement and create a database named TestData. When you create a database, SQL Server makes a copy of the model database, and renames the copy to the database name. This operation should only take several seconds, unless you specify a large initial size of the database as an optional parameter. The keyword GO separates statements when more than one statement is submitted in a single batch. GO is optional when the batch contains only one statement. 9.1.2. Create a Table To create a table, you must provide a name for the table, and the names and data types of each column in the table. It is also a good practice to indicate whether null values are allowed in each column. To create a table, you must have the CREATE TABLE permission, and the ALTER SCHEMA permission on the schema that will contain the table. The db_ddladmin fixed database role has these permissions. Most tables have a primary key, made up of one or more columns of the table. A primary key is always unique. The Database Engine will enforce the restriction that any primary key value can&#8217;t be repeated in the table. For a list of data types and links for a description of each, see Data Types (Transact-SQL). The Database Engine can be installed as case sensitive or non-case sensitive. If the Database Engine is installed as case sensitive, object names must always have the same case. For example, a table named OrderData is a different table from a table named ORDERDATA. If the Database Engine is installed as non-case sensitive, those two table names are considered to be the same table, and that name can only be used one time. 9.1.2.1. Switch the Query Editor connection to the TestData database In a Query Editor window, type and execute the following code to change your connection to the TestData database. USE TestData; GO 9.1.2.2. Create the table In a Query Editor window, type and execute the following code to create a table named Products. The columns in the table are named ProductID, ProductName, Price, and ProductDescription. The ProductID column is the primary key of the table. int, varchar(25), money, and varchar(max) are all data types. Only the Price and ProductionDescription columns can have no data when a row is inserted or changed. This statement contains an optional element (dbo.) called a schema. The schema is the database object that owns the table. If you are an administrator, dbo is the default schema. dbo stands for database owner. CREATE TABLE dbo.Products (ProductID int PRIMARY KEY NOT NULL, ProductName varchar(25) NOT NULL, Price money NULL, ProductDescription varchar(max) NULL); GO 9.1.3. Insert and update data in a table Now that you have created the Products table, you are ready to insert data into the table by using the INSERT statement. After the data is inserted, you will change the content of a row by using an UPDATE statement. You will use the WHERE clause of the UPDATE statement to restrict the update to a single row. The four statements will enter the following data. ProductID ProductName Price ProductDescription 1 Clamp 12.48 Workbench clamp 50 Screwdriver 3.17 Flat head 75 Tire Bar 30.00 Tool for changing tires. 3 mm Bracket 0.52 The basic syntax is: INSERT, table name, column list, VALUES, and then a list of the values to be inserted. The two hyphens in front of a line indicate that the line is a comment and the text will be ignored by the compiler. In this case, the comment describes a permissible variation of the syntax. 9.1.3.1. Insert data into a table Execute the following statement to insert a row into the Products table that was created in the previous task. -- Standard syntax INSERT dbo.Products (ProductID, ProductName, Price, ProductDescription) VALUES (1, &#39;Clamp&#39;, 12.48, &#39;Workbench clamp&#39;) GO If the insert succeeds, proceed to the next step. If the insert fails, it may be because the Product table already has a row with that product ID in it. To proceed, delete all the rows in the table and repeat the preceding step. TRUNCATE TABLE deletes all the rows in the table. Run the following command to delete all the rows in the table: TRUNCATE TABLE TestData.dbo.Products; GO After you truncate the table, repeat the INSERT command in this step. The following statement shows how you can change the order in which the parameters are provided by switching the placement of the ProductID and ProductName in both the field list (in parentheses) and in the values list. -- Changing the order of the columns INSERT dbo.Products (ProductName, ProductID, Price, ProductDescription) VALUES (&#39;Screwdriver&#39;, 50, 3.17, &#39;Flat head&#39;) GO The following statement demonstrates that the names of the columns are optional, as long as the values are listed in the correct order. This syntax is common but isn&#8217;t recommended because it might be harder for others to understand your code. NULL is specified for the Price column because the price for this product isn&#8217;t yet known. -- Skipping the column list, but keeping the values in order INSERT dbo.Products VALUES (75, &#39;Tire Bar&#39;, NULL, &#39;Tool for changing tires.&#39;) GO The schema name is optional as long as you are accessing and changing a table in your default schema. Because the ProductDescription column allows null values and no value is being provided, the ProductDescription column name and value can be dropped from the statement completely. SQL -- Dropping the optional dbo and dropping the ProductDescription column INSERT Products (ProductID, ProductName, Price) VALUES (3000, &#39;3 mm Bracket&#39;, 0.52) GO 9.1.3.2. Update the products table Type and execute the following UPDATE statement to change the ProductName of the second product from Screwdriver, to Flat Head Screwdriver. UPDATE dbo.Products SET ProductName = &#39;Flat Head Screwdriver&#39; WHERE ProductID = 50 GO 9.1.4. Read data from a table Use the SELECT statement to read the data in a table. The SELECT statement is one of the most important Transact-SQL statements, and there are many variations in the syntax. For this tutorial, you will work with five simple versions. 9.1.4.1. Read the data in a table Type and execute the following statements to read the data in the Products table. -- The basic syntax for reading data from a single table SELECT ProductID, ProductName, Price, ProductDescription FROM dbo.Products GO You can use an asterisk (*) to select all the columns in the table. The asterisk is for ad hoc queries. In permanent code, provide the column list so that the statement returns the predicted columns, even if a new column is added to the table later. -- Returns all columns in the table -- Does not use the optional schema, dbo SELECT * FROM Products GO You can omit columns that you don&#8217;t want to return. The columns will be returned in the order that they are listed. -- Returns only two of the columns from the table SELECT ProductName, Price FROM dbo.Products GO Use a WHERE clause to limit the rows that are returned to the user. -- Returns only two of the records in the table SELECT ProductID, ProductName, Price, ProductDescription FROM dbo.Products WHERE ProductID &lt; 60 GO You can work with the values in the columns as they are returned. The following example performs a mathematical operation on the Price column. Columns that have been changed in this way won&#8217;t have a name unless you provide one by using the AS keyword. -- Returns ProductName and the Price including a 7% tax -- Provides the name CustomerPays for the calculated column SELECT ProductName, Price * 1.07 AS CustomerPays FROM dbo.Products GO 9.1.4.2. Useful functions in a SELECT statement For information about some functions that you can use to work with data in SELECT statements, see the following articles: String Functions (Transact-SQL) Date and Time Data Types and Functions (Transact-SQL) Mathematical Functions (Transact-SQL) Text and Image Functions (Transact-SQL) 9.1.5. Create views and stored procedures A view is a stored SELECT statement, and a stored procedure is one or more Transact-SQL statements that execute as a batch. Views are queried like tables and don&#8217;t accept parameters. Stored procedures are more complex than views. Stored procedures can have both input and output parameters and can contain statements to control the flow of the code, such as IF and WHILE statements. It is good programming practice to use stored procedures for all repetitive actions in the database. For this example, you will use CREATE VIEW to create a view that selects only two of the columns in the Products table. Then, you will use CREATE PROCEDURE to create a stored procedure that accepts a price parameter and returns only those products that cost less than the specified parameter value. 9.1.5.1. Create a view Execute the following statement to create a view that executes a select statement, and returns the names and prices of our products to the user. CREATE VIEW vw_Names AS SELECT ProductName, Price FROM Products; GO 9.1.5.2. Test the view Views are treated just like tables. Use a SELECT statement to access a view. SELECT * FROM vw_Names; GO 9.1.5.3. Create a stored procedure The following statement creates a stored procedure name pr_Names, accepts an input parameter named @VarPrice of data type money. The stored procedure prints the statement Products less than concatenated with the input parameter that is changed from the money data type into a varchar(10) character data type. Then, the procedure executes a SELECT statement on the view, passing the input parameter as part of the WHERE clause. This returns all products that cost less than the input parameter value. CREATE PROCEDURE pr_Names @VarPrice money AS BEGIN -- The print statement returns text to the user PRINT &#39;Products less than &#39; + CAST(@VarPrice AS varchar(10)); -- A second statement starts here SELECT ProductName, Price FROM vw_Names WHERE Price &lt; @VarPrice; END GO 9.1.5.4. Test the stored procedure To test the stored procedure, type and execute the following statement. The procedure should return the names of the two products entered into the Products table in Lesson 1 with a price that is less than 10.00. EXECUTE pr_Names 10.00; GO 9.2. Lesson 2: Configure permissions on database objects Granting a user access to a database involves three steps. First, you create a login. The login lets the user connect to the SQL Server Database Engine. Then you configure the login as a user in the specified database. And finally, you grant that user permission to database objects. This lesson shows you these three steps, and shows you how to create a view and a stored procedure as the object. 9.2.1. Create a login To access the Database Engine, users require a login. The login can represent the user&#8217;s identity as a Windows account or as a member of a Windows group, or the login can be a SQL Server login that exists only in SQL Server. Whenever possible you should use Windows Authentication. 9.2.1.1. Create a new Windows account By default, administrators on your computer have full access to SQL Server. For this lesson, we want to have a less privileged user; therefore, you will create a new local Windows Authentication account on your computer. To do this, you must be an administrator on your computer. Then you will grant that new user access to SQL Server. Select Start, select Run, in the Open box, type %SystemRoot%\system32\compmgmt.msc /s and then select OK to open the Computer Management program. Under System Tools, expand Local Users and Groups, right-click Users, and then select New User. In the User name box type Mary. In the Password and Confirm password box, type a strong password, and then select Create to create a new local Windows user. 9.2.1.2. Create a SQL login using Windows Authentication with T-SQL In a Query Editor window of SQL Server Management Studio, type and execute the following code replacing computer_name with the name of your computer. FROM WINDOWS indicates that Windows will authenticate the user. The optional DEFAULT_DATABASE argument connects Mary to the TestData database, unless her connection string indicates another database. This statement introduces the semicolon as an optional termination for a Transact-SQL statement. CREATE LOGIN [computer_name\Mary] FROM WINDOWS WITH DEFAULT_DATABASE = [TestData]; GO This authorizes a user name Mary, authenticated by your computer, to access this instance of SQL Server. If there is more than one instance of SQL Server on the computer, you must create the login on each instance that Mary must access. Because Mary is not a domain account, this user name can only be authenticated on this computer. 9.2.1.3. Create a login using SQL Server Authentication with T-SQL -- Creates the user &quot;shcooper&quot; for SQL Server using the security credential &quot;RestrictedFaculty&quot; -- The user login starts with the password &quot;Baz1nga,&quot; but that password must be changed after the first login. CREATE LOGIN shcooper WITH PASSWORD = &#39;Baz1nga&#39; MUST_CHANGE, CREDENTIAL = RestrictedFaculty; GO 9.2.2. Grant access to a database Mary now has access to this instance of SQL Server, but doesn&#8217;t have permission to access the databases. She doesn&#8217;t even have access to her default database TestData until you authorize her as a database user. To grant Mary access, switch to the TestData database, and then use the CREATE USER statement to map her login to a user named Mary. 9.2.2.1. Create a user in a database Type and execute the following statements (replacing computer_name with the name of your computer) to grant Mary access to the TestData database. USE [TestData]; GO CREATE USER [Mary] FOR LOGIN [computer_name\Mary]; GO Now, Mary has access to both SQL Server and the TestData database. 9.2.2.2. Create views and stored procedures As an administrator, you can execute the SELECT from the Products table and the vw_Names view, and execute the pr_Names procedure; however, Mary can&#8217;t. To grant Mary the necessary permissions, use the GRANT statement. Grant permission to stored procedure Execute the following statement to give Mary the EXECUTE permission for the pr_Names stored procedure. GRANT EXECUTE ON pr_Names TO Mary; GO In this scenario, Mary can only access the Products table by using the stored procedure. If you want Mary to be able to execute a SELECT statement against the view, then you must also execute GRANT SELECT ON vw_Names TO Mary. To remove access to database objects, use the REVOKE statement. If the table, the view, and the stored procedure are not owned by the same schema, granting permissions becomes more complex. 9.2.2.3. About GRANT You must have EXECUTE permission to execute a stored procedure. You must have SELECT, INSERT, UPDATE, and DELETE permissions to access and change data. The GRANT statement is also used for other permissions, such as permission to create tables. 9.3. Lesson 3: Delete database objects This short lesson removes the objects that you created in Lesson 1 and Lesson 2, and then drops the database. Before you delete objects, make sure you are in the correct database: USE TestData; GO 9.3.1. Revoke stored procedure permissions Use the REVOKE statement to remove execute permission for Mary on the stored procedure: REVOKE EXECUTE ON pr_Names FROM Mary; GO 9.3.2. Drop permissions Use the DROP statement to remove permission for Mary to access the TestData database: DROP USER Mary; GO Use the DROP statement to remove permission for Mary to access this instance of SQL Server 2005 (9.x): DROP LOGIN [&lt;computer_name&gt;\Mary]; GO Use the DROP statement to remove the store procedure pr_Names: DROP PROC pr_Names; GO Use the DROP statement to remove the view vw_Names: DROP VIEW vw_Names; GO 9.3.3. Delete table Use the DELETE statement to remove all rows from the Products table: DELETE FROM Products; GO Use the DROP statement to remove the Products table: DROP TABLE Products; GO 9.3.4. Remove database You can&#8217;t remove the TestData database while you are in the database; therefore, first switch context to another database, and then use the DROP statement to remove the TestData database: USE MASTER; GO DROP DATABASE TestData; GO 10. References https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-deployment?view=sql-server-ver16&amp;pivots=cs1-bash https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver16&amp;preserve-view=true&amp;pivots=cs1-bash https://learn.microsoft.com/en-us/sql/relational-databases/databases/databases?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/databases/contained-databases?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/sql-server/install/file-locations-for-default-and-named-instances-of-sql-server?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/getting-started-with-database-engine-permissions?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/language-elements/sql-server-utilities-statements-go?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/language-elements/transact-sql-syntax-conventions-transact-sql?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/tutorial-writing-transact-sql-statements?view=sql-server-ver16 https://en.wikipedia.org/wiki/SQL" />
<meta property="og:description" content="1. Deploy and connect to SQL Server Linux containers 1.1. Pull and run the SQL Server Linux container image 1.2. Connect to SQL Server 1.3. Create and query data 1.3.1. Create a new database 1.3.2. Insert data 1.3.3. Select data 2. Databases 2.1. Basic Information about Databases 2.1.1. Servers, Databases, Schemas and Tables 2.1.2. Files and FileGroups 2.1.3. Logins and Database Users 2.1.4. Roles and Permissions 2.2. Working with Databases 2.3. System Databases 2.3.1. master Database 2.4. Contained Databases 2.5. Database Files and Filegroups 2.5.1. Database Files 2.5.2. Logical and Physical File Names 3. Database Engine Permissions and Principals 3.1. Server-level roles 3.2. Database-level roles 3.3. Contained database users: Make your database portable by using contained databases 3.3.1. Traditional login and user model 3.3.2. Contained database user model 3.4. Security principals 3.4.1. Logins 3.4.2. Fixed server roles 3.4.3. User-defined server roles 3.4.4. Database users 3.4.5. Fixed database roles 3.4.6. User-defined database roles 3.4.7. Other principals 3.5. Assign permissions 3.6. Permission hierarchy 3.7. Monitor permissions 3.8. Principals (Database Engine) 3.8.1. SQL Server-level principals 3.8.2. Database-level principals 3.8.3. sa Login 3.8.4. dbo User and dbo Schema 3.8.5. public Server Role and Database Role 4. SQL and T-SQL 5. SQL Server Utilities Statements - GO 6. Collation and Unicode support 7. Database identifiers 8. Transact-SQL syntax conventions (Transact-SQL) 9. Tutorial: Write Transact-SQL statements 9.1. Lesson 1: Create and query database objects 9.1.1. Create a database 9.1.2. Create a Table 9.1.2.1. Switch the Query Editor connection to the TestData database 9.1.2.2. Create the table 9.1.3. Insert and update data in a table 9.1.3.1. Insert data into a table 9.1.3.2. Update the products table 9.1.4. Read data from a table 9.1.4.1. Read the data in a table 9.1.4.2. Useful functions in a SELECT statement 9.1.5. Create views and stored procedures 9.1.5.1. Create a view 9.1.5.2. Test the view 9.1.5.3. Create a stored procedure 9.1.5.4. Test the stored procedure 9.2. Lesson 2: Configure permissions on database objects 9.2.1. Create a login 9.2.1.1. Create a new Windows account 9.2.1.2. Create a SQL login using Windows Authentication with T-SQL 9.2.1.3. Create a login using SQL Server Authentication with T-SQL 9.2.2. Grant access to a database 9.2.2.1. Create a user in a database 9.2.2.2. Create views and stored procedures 9.2.2.3. About GRANT 9.3. Lesson 3: Delete database objects 9.3.1. Revoke stored procedure permissions 9.3.2. Drop permissions 9.3.3. Delete table 9.3.4. Remove database 10. References 1. Deploy and connect to SQL Server Linux containers In this quickstart, you&#8217;ll use Docker to pull and run the SQL Server 2022 (16.x) Linux container image, mssql-server-linux. Then you can connect with sqlcmd to create your first database and run queries. 1.1. Pull and run the SQL Server Linux container image Pull the SQL Server 2022 (16.x) Linux container image from the Microsoft Container Registry. sudo docker pull mcr.microsoft.com/mssql/server:2022-latest To run the Linux container image with Docker, you can use the following command from a bash shell or elevated PowerShell command prompt. The SA_PASSWORD environment variable is deprecated. Please use MSSQL_SA_PASSWORD instead. sudo docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;&quot; \ -p 1433:1433 --name sql1 --hostname sql1 \ -d \ mcr.microsoft.com/mssql/server:2022-latest Your password should follow the SQL Server default password policy, otherwise the container can&#8217;t set up SQL Server and will stop working. By default, the password must be at least eight characters long and contain characters from three of the following four sets: uppercase letters, lowercase letters, base-10 digits, and symbols. By default, this quickstart creates a container with the Developer edition of SQL Server. The process for running production editions in containers is slightly different. To view your Docker containers, use the docker ps command. docker ps You should see output similar to the following: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 274554ac9f0d mcr.microsoft.com/mssql/server:2022-latest &quot;/opt/mssql/bin/perm…&quot; 42 seconds ago Up 1 second 0.0.0.0:1433-&gt;1433/tcp, :::1433-&gt;1433/tcp sql1 If the STATUS column shows a status of Up, then SQL Server is running in the container and listening on the port specified in the PORTS column. If the STATUS column for your SQL Server container shows Exited, see the Troubleshooting section of the configuration guide. 1.2. Connect to SQL Server The following steps use the SQL Server command-line tool, sqlcmd, inside the container to connect to SQL Server. Use the docker exec -it command to start an interactive bash shell inside your running container. In the following example sql1 is name specified by the --name parameter when you created the container. sudo docker exec -it sql1 &quot;bash&quot; Once inside the container, connect locally with sqlcmd, using its full path. /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -P &quot;&lt;YourStrong@Passw0rd&gt;&quot; -No You can omit the password on the command-line to be prompted to enter it. Here&#8217;s an example: /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -No If successful, you should get to a sqlcmd command prompt: 1&gt;. 1&gt; :help :!! [&lt;command&gt;] - Executes a command in the command shell. :connect server[\instance] [-l timeout] [-U user [-P password]] - Connects to a SQL Server instance. :error &lt;dest&gt; - Redirects error output to a file, stderr, or stdout. :exit - Quits sqlcmd immediately. :exit() - Execute statement cache; quit with no return value. :exit(&lt;query&gt;) - Execute the specified query; returns numeric result. go [&lt;n&gt;] - Executes the statement cache (n times). :help - Shows this list of commands. :list - Prints the content of the statement cache. :listvar - Lists the set sqlcmd scripting variables. :on error [exit|ignore] - Action for batch or sqlcmd command errors. :out &lt;filename&gt;|stderr|stdout - Redirects query output to a file, stderr, or stdout. :perftrace &lt;filename&gt;|stderr|stdout - Redirects timing output to a file, stderr, or stdout. :quit - Quits sqlcmd immediately. :r &lt;filename&gt; - Append file contents to the statement cache. :reset - Discards the statement cache. :serverlist - Lists local and SQL Servers on the network. :setvar {variable} - Removes a sqlcmd scripting variable. :setvar &lt;variable&gt; &lt;value&gt; - Sets a sqlcmd scripting variable. $ /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -P &quot;&lt;YourStrong@Passw0rd&gt;&quot; -No -Q &quot;SELECT @@version&quot; ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ Microsoft SQL Server 2022 (RTM-CU16) (KB5048033) - 16.0.4165.4 (X64) Nov 6 2024 19:24:49 Copyright (C) 2022 Microsoft Corporation Developer Edition (64-bit) on Linux (Ubuntu 22.04.5 LTS) &lt;X64&gt; (1 rows affected) 1.3. Create and query data The following sections walk you through using sqlcmd and Transact-SQL to create a new database, add data, and run a query. 1.3.1. Create a new database The following steps create a new database named TestDB. From the sqlcmd command prompt, paste the following Transact-SQL command to create a test database: CREATE DATABASE TestDB; On the next line, write a query to return the name of all of the databases on your server: SELECT Name from sys.databases; The previous two commands weren&#8217;t run immediately. Type GO on a new line to run the previous commands: GO 1.3.2. Insert data Next create a new table, Inventory, and insert two new rows. From the sqlcmd command prompt, switch context to the new TestDB database: USE TestDB; Create new table named Inventory: CREATE TABLE Inventory (id INT, name NVARCHAR(50), quantity INT); Insert data into the new table: INSERT INTO Inventory VALUES (1, &#39;banana&#39;, 150); INSERT INTO Inventory VALUES (2, &#39;orange&#39;, 154); Type GO to run the previous commands: GO 1.3.3. Select data Now, run a query to return data from the Inventory table. From the sqlcmd command prompt, enter a query that returns rows from the Inventory table where the quantity is greater than 152: SELECT * FROM Inventory WHERE quantity &gt; 152; Run the command: GO Exit the sqlcmd command prompt To end your sqlcmd session, type QUIT: QUIT To exit the interactive command-prompt in your container, type exit. Your container continues to run after you exit the interactive bash shell. 2. Databases A database in SQL Server is made up of a collection of tables that stores a specific set of structured data. A table contains a collection of rows, also referred to as records or tuples, and columns, also referred to as attributes. Each column in the table is designed to store a certain type of information, for example, dates, names, dollar amounts, and numbers. 2.1. Basic Information about Databases 2.1.1. Servers, Databases, Schemas and Tables A computer can have one or more than one instance of SQL Server installed. Each instance of SQL Server can contain one or many databases. Within a database, there are one or many object ownership groups called schemas. Within each schema there are database objects such as tables, views, and stored procedures. Some objects such as certificates and asymmetric keys are contained within the database, but are not contained within a schema. For more information about creating tables, see Tables. Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views 2.1.2. Files and FileGroups SQL Server databases are stored in the file system in files. Files can be grouped into filegroups. For more information about files and filegroups, see Database Files and Filegroups. 2.1.3. Logins and Database Users When people gain access to an instance of SQL Server they are identified as a login. When people gain access to a database they are identified as a database user. A database user can be based on a login. If contained databases are enabled, a database user can be created that is not based on a login. For more information about users, see CREATE USER (Transact-SQL). Logins &lt;-&gt; Servers (instances) Database Users &lt;-&gt; Databases 2.1.4. Roles and Permissions A user that has access to a database can be given permission to access the objects in the database. Though permissions can be granted to individual users, we recommend creating database roles, adding the database users to the roles, and then grant access permission to the roles. Granting permissions to roles instead of users makes it easier to keep permissions consistent and understandable as the number of users grow and continually change. For more information about roles permissions, see CREATE ROLE (Transact-SQL) and Principals (Database Engine). 2.2. Working with Databases Most people who work with databases use the SQL Server Management Studio tool. The Management Studio tool has a graphical user interface for creating databases and the objects in the databases. Management Studio also has a query editor for interacting with databases by writing Transact-SQL statements. Management Studio can be installed from the SQL Server installation disk, or downloaded from MSDN. For more information about SQL Server Management Studio tool, see SQL Server Management Studio (SSMS). 2.3. System Databases SQL Server includes the following system databases. System database Description master Database Records all the system-level information for an instance of SQL Server. msdb Database Is used by SQL Server Agent for scheduling alerts and jobs. model Database Is used as the template for all databases created on the instance of SQL Server. Modifications made to the model database, such as database size, collation, recovery model, and other database options, are applied to any databases created afterward. Resource Database Is a read-only database that contains system objects that are included with SQL Server. System objects are physically persisted in the Resource database, but they logically appear in the sys schema of every database. tempdb Database Is a workspace for holding temporary objects or intermediate result sets. For Azure SQL Database single databases and elastic pools, only master Database and tempdb Database apply. 2.3.1. master Database The master database records all the system-level information for a SQL Server system. This includes instance-wide metadata such as logon accounts, endpoints, linked servers, and system configuration settings. In SQL Server, system objects are no longer stored in the master database; instead, they are stored in the Resource database. Also, master is the database that records the existence of all other databases and the location of those database files and records the initialization information for SQL Server. Therefore, SQL Server cannot start if the master database is unavailable. 2.4. Contained Databases A contained database is a database that is isolated from other databases and from the instance of SQL Server that hosts the database. SQL Server helps user to isolate their database from the instance in 4 ways. Much of the metadata that describes a database is maintained in the database. (In addition to, or instead of, maintaining metadata in the master database.) All metadata are defined using the same collation. User authentication can be performed by the database, reducing the databases dependency on the logins of the instance of SQL Server. The SQL Server environment (DMV&#8217;s, XEvents, etc.) reports and can act upon containment information. 2.5. Database Files and Filegroups At a minimum, every SQL Server database has two operating system files: a data file and a log file. Data files contain data and objects such as tables, indexes, stored procedures, and views. Log files contain the information that is required to recover all transactions in the database. Data files can be grouped together in filegroups for allocation and administration purposes. 2.5.1. Database Files SQL Server databases have three types of files, as shown in the following table. File Description Primary Contains startup information for the database and points to the other files in the database. Every database has one primary data file. The recommended file name extension for primary data files is .mdf. Secondary Optional user-defined data files. Data can be spread across multiple disks by putting each file on a different disk drive. The recommended file name extension for secondary data files is .ndf. Transaction Log The log holds information used to recover the database. There must be at least one log file for each database. The recommended file name extension for transaction logs is .ldf. For example, a simple database named Sales has one primary file that contains all data and objects and a log file that contains the transaction log information. A more complex database named Orders can be created that includes one primary file and five secondary files. The data and objects within the database spread across all six files, and the four log files contain the transaction log information. By default, the data and transaction logs are put on the same drive and path to handle single-disk systems. This choice may not be optimal for production environments. We recommend that you put data and log files on separate disks. $ ls /var/opt/mssql/data/ Entropy.bin Sales_log.ldf mastlog.ldf model_msdbdata.mdf model_replicatedmaster.ldf modellog.ldf msdblog.ldf tempdb2.ndf tempdb4.ndf Sales.mdf master.mdf model.mdf model_msdblog.ldf model_replicatedmaster.mdf msdbdata.mdf tempdb.mdf tempdb3.ndf templog.ldf 2.5.2. Logical and Physical File Names SQL Server files have two file name types: logical_file_name: The logical_file_name is the name used to refer to the physical file in all Transact-SQL statements. The logical file name must comply with the rules for SQL Server identifiers and must be unique among logical file names in the database. os_file_name: The os_file_name is the name of the physical file including the directory path. It must follow the rules for the operating system file names. When multiple instances of SQL Server are running on a single computer, each instance receives a different default directory to hold the files for the databases created in the instance. For more information, see File Locations for Default and Named Instances of SQL Server. 3. Database Engine Permissions and Principals Permissions in the Database Engine are managed at the server level through logins and server roles, and at the database level through database users and database roles. The model for SQL Database exposes the same system within each database, but the server level permissions aren&#8217;t available. 3.1. Server-level roles SQL Server provides server-level roles to help you manage the permissions on a server. These roles are security principals that group other principals. Server-level roles are server-wide in their permissions scope. 3.2. Database-level roles Database-level roles are database-wide in their permissions scope. There are two types of database-level roles: fixed-database roles that are predefined in the database and user-defined database roles that you can create. Fixed-database roles are defined at the database level and exist in each database. Members of the db_owner database role can manage fixed-database role membership. There are also some special-purpose database roles in the msdb database. You can add any database account and other SQL Server roles into database-level roles. 3.3. Contained database users: Make your database portable by using contained databases Use contained database users to authenticate SQL Server and Azure SQL Database connections at the database level. A contained database is a database that&#8217;s isolated from other databases and from the instance of SQL Server or SQL Database (and the master database) that hosts the database. 3.3.1. Traditional login and user model In the traditional connection model, Windows users or members of Windows groups connect to the Database Engine by providing user or group credentials authenticated by Windows. Or users can provide both a name and password and connect by using SQL Server authentication. In both cases, the master database must have a login that matches the connecting credentials. After the Database Engine confirms the Windows authentication credentials or authenticates the SQL Server authentication credentials, the connection typically attempts to connect to a user database. To connect to a user database, the login must be mapped to (that is, associated with) a database user in the user database. The connection string might also specify connecting to a specific database, which is optional in SQL Server but required in SQL Database. The important principle is that both the login (in the master database) and the user (in the user database) must exist and be related to each other. The connection to the user database has a dependency upon the login in the master database. This dependency limits the ability of the database to be moved to a different hosting SQL Server instance or Azure SQL Database server. If a connection to the master database is not available (for example, a failover is in progress), the overall connection time will increase, or the connection might time out. An unavailable connection might reduce connection scalability. 3.3.2. Contained database user model In the contained database user model, the login in the master database is not present. Instead, the authentication process occurs at the user database. The database user in the user database doesn&#8217;t have an associated login in the master database. The contained database user model supports both Windows authentication and SQL Server authentication. You can use it in both SQL Server and SQL Database. To connect as a contained database user, the connection string must always contain a parameter for the user database. The Database Engine uses this parameter to know which database is responsible for managing the authentication process. The activity of the contained database user is limited to the authenticating database. The database user account must be independently created in each database that the user needs. To change databases, SQL Database users must create a new connection. Contained database users in SQL Server can change databases if an identical user is present in another database. 3.4. Security principals Security principal is the official name of the identities that use SQL Server and that can be assigned permission to take actions. They are usually people or groups of people, but can be other entities that pretend to be people. The security principals can be created and managed using the Transact-SQL listed, or by using SQL Server Management Studio. 3.4.1. Logins Logins are individual user accounts for logging on to the SQL Server Database Engine. SQL Server and SQL Database support logins based on Windows authentication and logins based on SQL Server authentication. For information about the two types of logins, see Choose an Authentication Mode. 3.4.2. Fixed server roles In SQL Server, fixed server roles are a set of pre-configured roles that provide convenient group of server-level permissions. Logins can be added to the roles using the ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER SERVER ROLE (Transact-SQL). SQL Database doesn&#8217;t support the fixed server roles, but has two roles in the master database (dbmanager and loginmanager) that act like server roles. 3.4.3. User-defined server roles In SQL Server, you can create your own server roles and assign server-level permissions to them. Logins can be added to the server roles using the ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER SERVER ROLE (Transact-SQL). SQL Database doesn&#8217;t support the user-defined server roles. 3.4.4. Database users Logins are granted access to a database by creating a database user in a database and mapping that database user to sign in. Typically the database user name is the same as the login name, though it doesn&#8217;t have to be the same. Each database user maps to a single login. A login can be mapped to only one user in a database, but can be mapped as a database user in several different databases. Database users can also be created that don&#8217;t have a corresponding login. These users are called contained database users. Microsoft encourages the use of contained database users because it makes it easier to move your database to a different server. Like a login, a contained database user can use either Windows authentication or SQL Server authentication. For more information, see Contained Database Users - Making Your Database Portable. There are 12 types of users with slight differences in how they authenticate, and who they represent. To see a list of users, see CREATE USER (Transact-SQL). 3.4.5. Fixed database roles Fixed database roles are a set of pre-configured roles that provide convenient group of database-level permissions. Database users and user-defined database roles can be added to the fixed database roles using the ALTER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER ROLE (Transact-SQL). 3.4.6. User-defined database roles Users with the CREATE ROLE permission can create new user-defined database roles to represent groups of users with common permissions. Typically permissions are granted or denied to the entire role, simplifying permissions management and monitoring. Database users can be added to the database roles by using the ALTER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER ROLE (Transact-SQL). 3.4.7. Other principals Additional security principals not discussed here include application roles, and logins and users based on certificates or asymmetric keys. For a graphic showing the relationships between Windows users, Windows groups, logins, and database users, see Create a Database User. 3.5. Assign permissions Every SQL Server securable has associated permissions that can be granted to a principal. Permissions in the Database Engine are managed at the server level assigned to logins and server roles, and at the database level assigned to database users and database roles. The model for Azure SQL Database has the same system for the database permissions, but the server level permissions aren&#8217;t available. Most permission statements have the format: AUTHORIZATION PERMISSION ON SECURABLE::NAME TO PRINCIPAL; AUTHORIZATION must be GRANT, REVOKE or DENY. The PERMISSION establishes what action is allowed or prohibited. The exact number of permissions differs between SQL Server and SQL Database. The permissions are listed in the article Permissions (Database Engine) and in the chart referenced below. ON SECURABLE::NAME is the type of securable (server, server object, database, or database object) and its name. Some permissions don&#8217;t require ON SECURABLE::NAME because it is unambiguous or inappropriate in the context. For example, the CREATE TABLE permission doesn&#8217;t require the ON SECURABLE::NAME clause (GRANT CREATE TABLE TO Mary; allows Mary to create tables). PRINCIPAL is the security principal (login, user, or role) which receives or loses the permission. Grant permissions to roles whenever possible. The following example grant statement, grants the UPDATE permission on the Parts table or view that is contained in the Production schema to the role named PartsTeam: GRANT UPDATE ON OBJECT::Production.Parts TO PartsTeam; The following example grant statement grants the UPDATE permission on the Production schema, and by extension on any table or view contained within this schema to the role named ProductionTeam, which is a more effective and salable approach to assigning permissions than on individual object-level: GRANT UPDATE ON SCHEMA::Production TO ProductionTeam; Permissions are granted to security principals (logins, users, and roles) by using the GRANT statement. Permissions are explicitly denied by using the DENY command. A previously granted or denied permission is removed by using the REVOKE statement. Permissions are cumulative, with the user receiving all the permissions granted to the user, login, and any group memberships; however any permission denial overrides all grants. A common mistake is to attempt to remove a GRANT by using DENY instead of REVOKE. This can cause problems when a user receives permissions from multiple sources; which is quite common. The following example demonstrates the principal. The Sales group receives SELECT permissions on the OrderStatus table through the statement GRANT SELECT ON OBJECT::OrderStatus TO Sales;. User Jae is a member of the Sales role. Jae has also been granted SELECT permission to the OrderStatus table under their own user name through the statement GRANT SELECT ON OBJECT::OrderStatus TO Jae;. Presume the administer wishes to remove the GRANT to the Sales role. If the administrator correctly executes REVOKE SELECT ON OBJECT::OrderStatus TO Sales;, then Jae will retain SELECT access to the OrderStatus table through their individual GRANT statement. If the administrator incorrectly executes DENY SELECT ON OBJECT::OrderStatus TO Sales; then Jae, as a member of the Sales role, will be denied the SELECT permission because the DENY to Sales overrides their individual GRANT. Permissions can be configured using Management Studio. Find the securable in Object Explorer, right-click the securable, and then select Properties. Select the Permissions page. For help on using the permission page, see Permissions or Securables Page. 3.6. Permission hierarchy Permissions have a parent/child hierarchy. That is, if you grant SELECT permission on a database, that permission includes SELECT permission on all (child) schemas in the database. If you grant SELECT permission on a schema, it includes SELECT permission on all the (child) tables and views in the schema. The permissions are transitive; that is, if you grant SELECT permission on a database, it includes SELECT permission on all (child) schemas, and all (grandchild) tables and views. Permissions also have covering permissions. The CONTROL permission on an object, normally gives you all other permissions on the object. Because both the parent/child hierarchy and the covering hierarchy can act on the same permission, the permission system can get complicated. For example, let&#8217;s take a table (Region), in a schema (Customers), in a database (SalesDB). CONTROL permission on table Region includes all the other permissions on the table Region, including ALTER, SELECT, INSERT, UPDATE, DELETE, and some other permissions. SELECT on the Customers schema that owns the Region table includes the SELECT permission on the Region table. So SELECT permission on the Region table can be achieved through any of these six statements: GRANT SELECT ON OBJECT::Region TO Jae; GRANT CONTROL ON OBJECT::Region TO Jae; GRANT SELECT ON SCHEMA::Customers TO Jae; GRANT CONTROL ON SCHEMA::Customers TO Jae; GRANT SELECT ON DATABASE::SalesDB TO Jae; GRANT CONTROL ON DATABASE::SalesDB TO Jae; 3.7. Monitor permissions The following views return security information. The logins and user-defined server roles on a server can be examined by using the sys.server_principals view. This view isn&#8217;t available in SQL Database. The users and user-defined roles in a database can be examined by using the sys.database_principals view. The permissions granted to logins and user-defined fixed server roles can be examined by using the sys.server_permissions view. This view isn&#8217;t available in SQL Database. The permissions granted to users and user-defined fixed database roles can be examined by using the sys.database_permissions view. Database role membership can be examined by using the sys.database_role_members view. Server role membership can be examined by using the sys.server_role_members view. This view isn&#8217;t available in SQL Database. For additional security related views, see Security Catalog Views (Transact-SQL). 3.8. Principals (Database Engine) Principals are entities that can request SQL Server resources. Like other components of the SQL Server authorization model, principals can be arranged in a hierarchy. The scope of influence of a principal depends on the scope of the definition of the principal: Windows, server, database; and whether the principal is indivisible or a collection. A Windows Login is an example of an indivisible principal, and a Windows Group is an example of a principal that is a collection. Every principal has a security identifier (SID). 3.8.1. SQL Server-level principals SQL Server authentication Login Windows authentication login for a Windows user Windows authentication login for a Windows group Azure Active Directory authentication login for a AD user Azure Active Directory authentication login for a AD group Server Role 3.8.2. Database-level principals Database User (There are 12 types of users. For more information, see CREATE USER.) Database Role Application Role 3.8.3. sa Login The SQL Server sa login is a server-level principal. By default, it is created when an instance is installed. Beginning in SQL Server 2005 (9.x), the default database of sa is master. This is a change of behavior from earlier versions of SQL Server. The sa login is a member of the sysadmin fixed server-level role. The sa login has all permissions on the server and cannot be limited. The sa login cannot be dropped, but it can be disabled so that no one can use it. 3.8.4. dbo User and dbo Schema The dbo user is a special user principal in each database. All SQL Server administrators, members of the sysadmin fixed server role, sa login, and owners of the database, enter databases as the dbo user. The dbo user has all permissions in the database and cannot be limited or dropped. dbo stands for database owner, but the dbo user account is not the same as the db_owner fixed database role, and the db_owner fixed database role is not the same as the user account that is recorded as the owner of the database. The dbo user owns the dbo schema. The dbo schema is the default schema for all users, unless some other schema is specified. The dbo schema cannot be dropped. 3.8.5. public Server Role and Database Role Every login belongs to the public fixed server role, and every database user belongs to the public database role. When a login or user has not been granted or denied specific permissions on a securable, the login or user inherits the permissions granted to public on that securable. The public fixed server role and the public fixed database role cannot be dropped. However you can revoke permissions from the public roles. There are many permissions that are assigned to the public roles by default. Most of these permissions are needed for routine operations in the database; the type of things that everyone should be able to do. Be careful when revoking permissions from the public login or user, as it will affect all logins/users. Generally you should not deny permissions to public, because the deny statement overrides any grant statements you might make to individuals. 4. SQL and T-SQL SQL, From Wikipedia, the free encyclopedia, https://en.wikipedia.org/wiki/SQL Structured Query Language, abbreviated as SQL (/ˌɛsˌkjuːˈɛl/ ) S-Q-L, sometimes /ˈsiːkwəl/ &quot;sequel&quot; for historical reasons), is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It is particularly useful in handling structured data, i.e. data incorporating relations among entities and variables. Transact-SQL, From Wikipedia, the free encyclopedia, https://en.wikipedia.org/wiki/Transact-SQL Transact-SQL (T-SQL) is Microsoft&#8217;s and Sybase&#8217;s proprietary extension to the SQL (Structured Query Language) used to interact with relational databases. T-SQL expands on the SQL standard to include procedural programming, local variables, various support functions for string processing, date processing, mathematics, etc. and changes to the DELETE and UPDATE statements. Transact-SQL is central to using Microsoft SQL Server. All applications that communicate with an instance of SQL Server do so by sending Transact-SQL statements to the server, regardless of the user interface of the application. Stored procedures in SQL Server are executable server-side routines. The advantage of stored procedures is the ability to pass parameters. 5. SQL Server Utilities Statements - GO SQL Server provides commands that are not Transact-SQL statements, but are recognized by the sqlcmd and osql utilities and SQL Server Management Studio Code Editor. These commands can be used to facilitate the readability and execution of batches and scripts. GO signals the end of a batch of Transact-SQL statements to the SQL Server utilities. Syntax GO [count] Arguments count Is a positive integer. The batch preceding GO will execute the specified number of times. Remarks GO is not a Transact-SQL statement; it is a command recognized by the sqlcmd and osql utilities and SQL Server Management Studio Code editor. SQL Server utilities interpret GO as a signal that they should send the current batch of Transact-SQL statements to an instance of SQL Server. The current batch of statements is composed of all statements entered since the last GO, or since the start of the ad hoc session or script if this is the first GO. A Transact-SQL statement cannot occupy the same line as a GO command. However, the line can contain comments. Users must follow the rules for batches. For example, any execution of a stored procedure after the first statement in a batch must include the EXECUTE keyword. The scope of local (user-defined) variables is limited to a batch, and cannot be referenced after a GO command. USE AdventureWorks2012; GO DECLARE @MyMsg VARCHAR(50) SELECT @MyMsg = &#39;Hello, World.&#39; GO -- @MyMsg is not valid after this GO ends the batch. -- Yields an error because @MyMsg not declared in this batch. PRINT @MyMsg GO SELECT @@VERSION; -- Yields an error: Must be EXEC sp_who if not first statement in -- batch. sp_who GO SQL Server applications can send multiple Transact-SQL statements to an instance of SQL Server for execution as a batch. The statements in the batch are then compiled into a single execution plan. Programmers executing ad hoc statements in the SQL Server utilities, or building scripts of Transact-SQL statements to run through the SQL Server utilities, use GO to signal the end of a batch. Applications based on the ODBC or OLE DB APIs receive a syntax error if they try to execute a GO command. The SQL Server utilities never send a GO command to the server. Do not use a semicolon as a statement terminator after GO. -- Yields an error because ; is not permitted after GO SELECT @@VERSION; GO; The GO statement is not a SQL statement; rather, it is a command recognized by the SQL Server Management Studio (SSMS), sqlcmd, and other SQL Server utilities. In the context of these utilities, GO signals the end of a batch of statements and is used to separate batches of statements from each other. However, when you are performing database operations from ADO.NET (or any other context where you&#8217;re sending SQL statements directly to SQL Server), batch separation is not needed, and the GO statement is not recognized. If you try to include the GO statement in your SQL strings in ADO.NET, you&#8217;ll likely encounter a SQL Server error that &#39;GO&#39; is not a recognized built-in function name. Instead, just end each of your SQL statements with a semicolon (;). 6. Collation and Unicode support Collations in SQL Server provide sorting rules, case, and accent sensitivity properties for your data. Collations that are used with character data types, such as char and varchar, dictate the code page and corresponding characters that can be represented for that data type. Whether you&#8217;re installing a new instance of SQL Server, restoring a database backup, or connecting server to client databases, it&#8217;s important to understand the locale requirements, sorting order, and case and accent sensitivity of the data that you&#8217;re working with. To list the collations that are available on your instance of SQL Server, see sys.fn_helpcollations (Transact-SQL). When you select a collation for your server, database, column, or expression, you&#8217;re assigning certain characteristics to your data. These characteristics affect the results of many operations in the database. For example, when you construct a query by using ORDER BY, the sort order of your result set might depend on the collation that&#8217;s applied to the database or dictated in a COLLATE clause at the expression level of the query. Setting collations are supported at the following levels of an instance of SQL Server: Server-level collations The default server collation is determined during SQL Server setup, and it becomes the default collation of the system databases and all user databases. To query the server collation for an instance of SQL Server, use the SERVERPROPERTY function: SELECT CONVERT(nvarchar(128), SERVERPROPERTY(&#39;collation&#39;)); -- SQL_Latin1_General_CP1_CI_AS * SQL_Latin1_General_CP1_CI_AS is a collation setting in SQL Server. Here&#8217;s what each part of it means: SQL indicates that it is a SQL Server-defined collation. Latin1_General is the base language and alphabet, which in this case is the Latin 1 (Western European) alphabet. CP1 stands for Code Page 1, which implies that the collation is using code page 1252. This page includes all ASCII characters and additional characters used in English and several other Western European languages. CI stands for Case Insensitive. This means the collation doesn&#8217;t recognize case differences. When CI is specified, &#39;a&#39; is considered equal to &#39;A&#39;. AS stands for Accent Sensitive. This means the collation does recognize accent differences. When AS is specified, &#39;résumé&#39; is not equal to &#39;resume&#39;. * If you want to use unicode (UTF-8) character sets in SQL Server, you can use the newer collations introduced starting from SQL Server 2019 onward. The new collations are named as _SC or _SC_UTF8. The SC stands for Supplementary Characters, which supports UCS-2 or UTF-16 characters. If you want to particularly use UTF-8, you can use _utf8 postfix. So if you need to define columns that can store unicode (UTF-8) strings from any language, you can use something like Latin1_General_100_CI_AS_SC_UTF8. _100 here corresponds to newer set of collations in SQL Server 2019. Please note that UTF-8 collations are only available to char and varchar data types, not to text data type. And if you&#8217;re dealing with wider unicode character sets and more complex translations, it may be better to use nchar or nvarchar data types with either UTF-16 or supplementary character collations. * The Case Insensitive (CI) property in a SQL Server collation does not modify the actual data stored in a cell of a table. If a username is stored as &#39;JohnDoe&#39;, it will be stored as &#39;JohnDoe&#39; regardless of whether the collation is Case Sensitive (CS) or Case Insensitive (CI). The collation only affects how SQL Server compares and sorts that data during queries. In a Case Insensitive collation, SQL Server considers &#39;JohnDoe&#39; and &#39;johndoe&#39; to be equal. If the collation were Case Sensitive, &#39;JohnDoe&#39; and &#39;johndoe&#39; would be considered as two different values. So to put it diagrammatically: With Case Insensitive (CI) collation : SELECT * FROM Users WHERE user_name = &#39;johndoe&#39; will return &#39;JohnDoe&#39;, &#39;JOHNDOE&#39;, &#39;johndoe&#39;, etc. With Case Sensitive (CS) collation : SELECT * FROM Users WHERE user_name = &#39;johndoe&#39; will only return &#39;johndoe&#39; and not &#39;JohnDoe&#39; or &#39;JOHNDOE&#39;. This comparison and sorting behaviour applies both to operations you perform in queries (like WHERE, ORDER BY, JOIN, etc.), as well as to indexes that SQL Server uses to optimize query performance. To query the server for all available collations, use the following fn_helpcollations() built-in function: SELECT * FROM sys.fn_helpcollations(); Database-level collations When you create or modify a database, you can use the COLLATE clause of the CREATE DATABASE or ALTER DATABASE statement to specify the default database collation. If no collation is specified, the database is assigned the server collation. You can retrieve the current collation of a database by using a statement similar to the following code sample: SELECT CONVERT (nvarchar(128), DATABASEPROPERTYEX(&#39;database_name&#39;, &#39;collation&#39;)); Column-level collations When you create or alter a table, you can specify collations for each character-string column by using the COLLATE clause. If you don&#8217;t specify a collation, the column is assigned the default collation of the database. Expression-level collations Expression-level collations are set when a statement is run, and they affect the way a result set is returned. This enables ORDER BY sort results to be locale-specific. To implement expression-level collations, use a COLLATE clause such as the following code sample: SELECT name FROM customer ORDER BY name COLLATE Latin1_General_CS_AI; A locale is a set of information that&#8217;s associated with a location or a culture. The information can include the name and identifier of the spoken language, the script that&#8217;s used to write the language, and cultural conventions. Collations can be associated with one or more locales. For more information, see Locale IDs Assigned by Microsoft. A code page is an ordered set of characters of a given script in which a numeric index, or code point value, is associated with each character. A Windows code page is typically referred to as a character set or a charset. Code pages are used to provide support for the character sets and keyboard layouts that are used by different Windows system locales. Sort order specifies how data values are sorted. The order affects the results of data comparison. Data is sorted by using collations, and it can be optimized by using indexes. Unicode is a standard for mapping code points to characters. Because it&#8217;s designed to cover all the characters of all the languages of the world, you don&#8217;t need different code pages to handle different sets of characters. Storing data in multiple languages within one database is difficult to manage when you use only character data and code pages. It&#8217;s also difficult to find one code page for the database that can store all the required language-specific characters. Additionally, it&#8217;s difficult to guarantee the correct translation of special characters when they&#8217;re being read or updated by a variety of clients that are running various code pages. Databases that support international clients should always use Unicode data types instead of non-Unicode data types. The code pages that a client uses are determined by the operating system (OS) settings. To set client code pages on the Windows operating system, use Regional Settings in Control Panel. It would be difficult to select a code page for character data types that will support all the characters that are required by a worldwide audience. The easiest way to manage character data in international databases is to always use a data type that supports Unicode. If you store character data that reflects multiple languages in SQL Server (SQL Server 2005 (9.x) and later), use Unicode data types (nchar, nvarchar, and ntext) instead of non-Unicode data types (char, varchar, and text). Alternatively, starting with SQL Server 2019 (15.x), if a UTF-8 enabled collation (_UTF8) is used, previously non-Unicode data types (char and varchar) become Unicode data types using UTF-8 encoding. SQL Server 2019 (15.x) doesn&#8217;t change the behavior of previously existing Unicode data types (nchar, nvarchar, and ntext), which continue to use UCS-2 or UTF-16 encoding. For more information, see Storage differences between UTF-8 and UTF-16. 7. Database identifiers The database object name is referred to as its identifier. Everything in Microsoft SQL Server can have an identifier. Servers, databases, and database objects, such as tables, views, columns, indexes, triggers, procedures, constraints, and rules, can have identifiers. Identifiers are required for most objects, but are optional for some objects such as constraints. An object identifier is created when the object is defined. The identifier is then used to reference the object. For example, the following statement creates a table with the identifier TableX, and two columns with the identifiers KeyCol and Description: CREATE TABLE TableX (KeyCol INT PRIMARY KEY, Description nvarchar(80)); This table also has an unnamed constraint. The PRIMARY KEY constraint has no identifier. The collation of an identifier depends on the level at which it is defined. Identifiers of instance-level objects, such as logins and database names, are assigned the default collation of the instance. Identifiers of objects in a database, such as tables, views, and column names, are assigned the default collation of the database. For example, two tables with names that differ only in case can be created in a database that has case-sensitive collation, but cannot be created in a database that has case-insensitive collation. There are two classes of identifiers: Regular identifiers Comply with the rules for the format of identifiers. Regular identifiers are not delimited when they are used in Transact-SQL statements. USE AdventureWorks2022; GO SELECT * FROM HumanResources.Employee WHERE NationalIDNumber = 153479919 Delimited identifiers Are enclosed in double quotation marks (&quot;) or brackets ([ ]). Identifiers that comply with the rules for the format of identifiers might not be delimited. For example: USE AdventureWorks2022; GO SELECT * FROM [HumanResources].[Employee] --Delimiter is optional. WHERE [NationalIDNumber] = 153479919 --Delimiter is optional. Identifiers that do not comply with all the rules for identifiers must be delimited in a Transact-SQL statement. For example: SQL USE AdventureWorks2022; GO CREATE TABLE [SalesOrderDetail Table] --Identifier contains a space and uses a reserved keyword. ( [Order] [int] NOT NULL, [SalesOrderDetailID] [int] IDENTITY(1,1) NOT NULL, [OrderQty] [smallint] NOT NULL, [ProductID] [int] NOT NULL, [UnitPrice] [money] NOT NULL, [UnitPriceDiscount] [money] NOT NULL, [ModifiedDate] [datetime] NOT NULL, CONSTRAINT [PK_SalesOrderDetail_Order_SalesOrderDetailID] PRIMARY KEY CLUSTERED ([Order] ASC, [SalesOrderDetailID] ASC) ); GO SELECT * FROM [SalesOrderDetail Table] --Identifier contains a space and uses a reserved keyword. WHERE [Order] = 10; --Identifier is a reserved keyword. &gt; What&#8217;s the recommend naming convention in SQL Server? * Naming conventions in SQL Server are mostly a matter of personal preference or organizational standards. However, there are some commonly followed best practices that can increase the readability and manageability of your database. Here are a few recommended conventions: Meaningful and Descriptive Names: Names should clearly indicate what the object represents. For example, a table storing customer information should be named Customers or CustomerData, not Table1 or t1. Prefixes for Different Object Types: Using prefixes to denote the type of object can be useful. For example, stored procedures could be named with the sp_ prefix (like sp_GetCustomerDetails), views with vw_ prefix (like vw_CustomerOrders), and tables could be named without any prefix for clarity (like Orders). Avoid SQL Keywords: Avoid using SQL Server reserved words. This can cause confusion and sometimes lead to syntax errors. Be Consistent: Whichever convention you decide on, be consistent with it across all your SQL projects. PascalCase or snake_case: For multiple word names, use PascalCase (no spaces and each word capitalized like CustomerOrders) or snake_case (words separated by underscores like customer_orders). Avoid using spaces in object names. Singular or Plural Names: There&#8217;s much debate about whether to use singular or plural names for table names. Choose whichever makes the most logical sense in your context and be consistent. Avoid Special Characters and Spaces: With the exception of the underscore character, avoid using special characters, dots, hyphens, spaces etc. in names. Remember, the most important goal of any naming convention is to make the code and database structure easily understandable and manageable for the developers and administrators working on it. Note: In SQL Server, the sp_ prefix is reserved for system stored procedures. Some developers prefer not to use it for user-defined stored procedures to avoid potential naming conflicts and small performance penalties when the system searches the master database first for such procedures. They may use usp_ for user stored procedures instead. 8. Transact-SQL syntax conventions (Transact-SQL) The following table lists and describes conventions that are used in the syntax diagrams in the Transact-SQL reference. Convention Used for UPPERCASE Transact-SQL keywords. italic User-supplied parameters of Transact-SQL syntax. bold Type database names, table names, column names, index names, stored procedures, utilities, data type names, and text exactly as shown. | (vertical bar) Separates syntax items enclosed in brackets or braces. You can use only one of the items. [ ] (brackets) Optional syntax item. { } (braces) Required syntax items. Don&#8217;t type the braces. [ , &#8230;&#8203;n ] Indicates the preceding item can be repeated n number of times. The occurrences are separated by commas. [ &#8230;&#8203;n ] Indicates the preceding item can be repeated n number of times. The occurrences are separated by blanks. ; Transact-SQL statement terminator. Although the semicolon isn&#8217;t required for most statements in this version of SQL Server, it will be required in a future version. ::= The name for a block of syntax. Use this convention to group and label sections of lengthy syntax or a unit of syntax that you can use in more than one location within a statement. Each location in which the block of syntax could be used is indicated with the label enclosed in chevrons: &lt;label&gt;. A set is a collection of expressions, for example &lt;grouping set&gt;; and a list is a collection of sets, for example &lt;composite element list&gt;. Unless specified otherwise, all Transact-SQL references to the name of a database object can be a four-part name in the following form: server_name.[database_name].[schema_name].object_name | database_name.[schema_name].object_name | schema_name.object_name | object_name server_name Specifies a linked server name or remote server name. database_name Specifies the name of a SQL Server database when the object resides in a local instance of SQL Server. When the object is in a linked server, database_name specifies an OLE DB catalog. schema_name Specifies the name of the schema that contains the object if the object is in a SQL Server database. When the object is in a linked server, schema_name specifies an OLE DB schema name. object_name Refers to the name of the object. When referencing a specific object, you don&#8217;t always have to specify the server, database, and schema for the SQL Server Database Engine to identify the object. However, if the object can&#8217;t be found, an error is returned. To avoid name resolution errors, we recommend specifying the schema name whenever you specify a schema-scoped object. To omit intermediate nodes, use periods to indicate these positions. The following table shows the valid formats of object names. Object reference format Description server_name.database_name.schema_name.object_name Four-part name. server_name.database_name..object_name Schema name is omitted. server_name..schema_name.object_name Database name is omitted. server_name&#8230;&#8203;object_name Database and schema name are omitted. database_name.schema_name.object_name Server name is omitted. database_name..object_name Server and schema name are omitted. schema_name.object_name Server and database name are omitted. object_name Server, database, and schema name are omitted. SELECT @@SERVERNAME; -- 8a90e1fbcc1b SELECT name FROM [8a90e1fbcc1b].[master].[sys].[servers]; 9. Tutorial: Write Transact-SQL statements This tutorial is intended as a brief introduction to the Transact-SQL language and not as a replacement for a Transact-SQL class. The statements in this tutorial are intentionally simple, and aren&#8217;t meant to represent the complexity found in a typical production database. 9.1. Lesson 1: Create and query database objects Transact-SQL statements can be written and submitted to the Database Engine in the following ways: By using SQL Server Management Studio. By using the sqlcmd utility. By connecting from an application that you create. 9.1.1. Create a database Like many Transact-SQL statements, the CREATE DATABASE statement has a required parameter: the name of the database. CREATE DATABASE also has many optional parameters, such as the disk location where you want to put the database files. When you execute CREATE DATABASE without the optional parameters, SQL Server uses default values for many of these parameters. In a Query Editor window, type but don&#8217;t execute the following code: CREATE DATABASE TestData; GO Use the pointer to select the words CREATE DATABASE, and then press F1. In Query Editor, press F5 to execute the statement and create a database named TestData. When you create a database, SQL Server makes a copy of the model database, and renames the copy to the database name. This operation should only take several seconds, unless you specify a large initial size of the database as an optional parameter. The keyword GO separates statements when more than one statement is submitted in a single batch. GO is optional when the batch contains only one statement. 9.1.2. Create a Table To create a table, you must provide a name for the table, and the names and data types of each column in the table. It is also a good practice to indicate whether null values are allowed in each column. To create a table, you must have the CREATE TABLE permission, and the ALTER SCHEMA permission on the schema that will contain the table. The db_ddladmin fixed database role has these permissions. Most tables have a primary key, made up of one or more columns of the table. A primary key is always unique. The Database Engine will enforce the restriction that any primary key value can&#8217;t be repeated in the table. For a list of data types and links for a description of each, see Data Types (Transact-SQL). The Database Engine can be installed as case sensitive or non-case sensitive. If the Database Engine is installed as case sensitive, object names must always have the same case. For example, a table named OrderData is a different table from a table named ORDERDATA. If the Database Engine is installed as non-case sensitive, those two table names are considered to be the same table, and that name can only be used one time. 9.1.2.1. Switch the Query Editor connection to the TestData database In a Query Editor window, type and execute the following code to change your connection to the TestData database. USE TestData; GO 9.1.2.2. Create the table In a Query Editor window, type and execute the following code to create a table named Products. The columns in the table are named ProductID, ProductName, Price, and ProductDescription. The ProductID column is the primary key of the table. int, varchar(25), money, and varchar(max) are all data types. Only the Price and ProductionDescription columns can have no data when a row is inserted or changed. This statement contains an optional element (dbo.) called a schema. The schema is the database object that owns the table. If you are an administrator, dbo is the default schema. dbo stands for database owner. CREATE TABLE dbo.Products (ProductID int PRIMARY KEY NOT NULL, ProductName varchar(25) NOT NULL, Price money NULL, ProductDescription varchar(max) NULL); GO 9.1.3. Insert and update data in a table Now that you have created the Products table, you are ready to insert data into the table by using the INSERT statement. After the data is inserted, you will change the content of a row by using an UPDATE statement. You will use the WHERE clause of the UPDATE statement to restrict the update to a single row. The four statements will enter the following data. ProductID ProductName Price ProductDescription 1 Clamp 12.48 Workbench clamp 50 Screwdriver 3.17 Flat head 75 Tire Bar 30.00 Tool for changing tires. 3 mm Bracket 0.52 The basic syntax is: INSERT, table name, column list, VALUES, and then a list of the values to be inserted. The two hyphens in front of a line indicate that the line is a comment and the text will be ignored by the compiler. In this case, the comment describes a permissible variation of the syntax. 9.1.3.1. Insert data into a table Execute the following statement to insert a row into the Products table that was created in the previous task. -- Standard syntax INSERT dbo.Products (ProductID, ProductName, Price, ProductDescription) VALUES (1, &#39;Clamp&#39;, 12.48, &#39;Workbench clamp&#39;) GO If the insert succeeds, proceed to the next step. If the insert fails, it may be because the Product table already has a row with that product ID in it. To proceed, delete all the rows in the table and repeat the preceding step. TRUNCATE TABLE deletes all the rows in the table. Run the following command to delete all the rows in the table: TRUNCATE TABLE TestData.dbo.Products; GO After you truncate the table, repeat the INSERT command in this step. The following statement shows how you can change the order in which the parameters are provided by switching the placement of the ProductID and ProductName in both the field list (in parentheses) and in the values list. -- Changing the order of the columns INSERT dbo.Products (ProductName, ProductID, Price, ProductDescription) VALUES (&#39;Screwdriver&#39;, 50, 3.17, &#39;Flat head&#39;) GO The following statement demonstrates that the names of the columns are optional, as long as the values are listed in the correct order. This syntax is common but isn&#8217;t recommended because it might be harder for others to understand your code. NULL is specified for the Price column because the price for this product isn&#8217;t yet known. -- Skipping the column list, but keeping the values in order INSERT dbo.Products VALUES (75, &#39;Tire Bar&#39;, NULL, &#39;Tool for changing tires.&#39;) GO The schema name is optional as long as you are accessing and changing a table in your default schema. Because the ProductDescription column allows null values and no value is being provided, the ProductDescription column name and value can be dropped from the statement completely. SQL -- Dropping the optional dbo and dropping the ProductDescription column INSERT Products (ProductID, ProductName, Price) VALUES (3000, &#39;3 mm Bracket&#39;, 0.52) GO 9.1.3.2. Update the products table Type and execute the following UPDATE statement to change the ProductName of the second product from Screwdriver, to Flat Head Screwdriver. UPDATE dbo.Products SET ProductName = &#39;Flat Head Screwdriver&#39; WHERE ProductID = 50 GO 9.1.4. Read data from a table Use the SELECT statement to read the data in a table. The SELECT statement is one of the most important Transact-SQL statements, and there are many variations in the syntax. For this tutorial, you will work with five simple versions. 9.1.4.1. Read the data in a table Type and execute the following statements to read the data in the Products table. -- The basic syntax for reading data from a single table SELECT ProductID, ProductName, Price, ProductDescription FROM dbo.Products GO You can use an asterisk (*) to select all the columns in the table. The asterisk is for ad hoc queries. In permanent code, provide the column list so that the statement returns the predicted columns, even if a new column is added to the table later. -- Returns all columns in the table -- Does not use the optional schema, dbo SELECT * FROM Products GO You can omit columns that you don&#8217;t want to return. The columns will be returned in the order that they are listed. -- Returns only two of the columns from the table SELECT ProductName, Price FROM dbo.Products GO Use a WHERE clause to limit the rows that are returned to the user. -- Returns only two of the records in the table SELECT ProductID, ProductName, Price, ProductDescription FROM dbo.Products WHERE ProductID &lt; 60 GO You can work with the values in the columns as they are returned. The following example performs a mathematical operation on the Price column. Columns that have been changed in this way won&#8217;t have a name unless you provide one by using the AS keyword. -- Returns ProductName and the Price including a 7% tax -- Provides the name CustomerPays for the calculated column SELECT ProductName, Price * 1.07 AS CustomerPays FROM dbo.Products GO 9.1.4.2. Useful functions in a SELECT statement For information about some functions that you can use to work with data in SELECT statements, see the following articles: String Functions (Transact-SQL) Date and Time Data Types and Functions (Transact-SQL) Mathematical Functions (Transact-SQL) Text and Image Functions (Transact-SQL) 9.1.5. Create views and stored procedures A view is a stored SELECT statement, and a stored procedure is one or more Transact-SQL statements that execute as a batch. Views are queried like tables and don&#8217;t accept parameters. Stored procedures are more complex than views. Stored procedures can have both input and output parameters and can contain statements to control the flow of the code, such as IF and WHILE statements. It is good programming practice to use stored procedures for all repetitive actions in the database. For this example, you will use CREATE VIEW to create a view that selects only two of the columns in the Products table. Then, you will use CREATE PROCEDURE to create a stored procedure that accepts a price parameter and returns only those products that cost less than the specified parameter value. 9.1.5.1. Create a view Execute the following statement to create a view that executes a select statement, and returns the names and prices of our products to the user. CREATE VIEW vw_Names AS SELECT ProductName, Price FROM Products; GO 9.1.5.2. Test the view Views are treated just like tables. Use a SELECT statement to access a view. SELECT * FROM vw_Names; GO 9.1.5.3. Create a stored procedure The following statement creates a stored procedure name pr_Names, accepts an input parameter named @VarPrice of data type money. The stored procedure prints the statement Products less than concatenated with the input parameter that is changed from the money data type into a varchar(10) character data type. Then, the procedure executes a SELECT statement on the view, passing the input parameter as part of the WHERE clause. This returns all products that cost less than the input parameter value. CREATE PROCEDURE pr_Names @VarPrice money AS BEGIN -- The print statement returns text to the user PRINT &#39;Products less than &#39; + CAST(@VarPrice AS varchar(10)); -- A second statement starts here SELECT ProductName, Price FROM vw_Names WHERE Price &lt; @VarPrice; END GO 9.1.5.4. Test the stored procedure To test the stored procedure, type and execute the following statement. The procedure should return the names of the two products entered into the Products table in Lesson 1 with a price that is less than 10.00. EXECUTE pr_Names 10.00; GO 9.2. Lesson 2: Configure permissions on database objects Granting a user access to a database involves three steps. First, you create a login. The login lets the user connect to the SQL Server Database Engine. Then you configure the login as a user in the specified database. And finally, you grant that user permission to database objects. This lesson shows you these three steps, and shows you how to create a view and a stored procedure as the object. 9.2.1. Create a login To access the Database Engine, users require a login. The login can represent the user&#8217;s identity as a Windows account or as a member of a Windows group, or the login can be a SQL Server login that exists only in SQL Server. Whenever possible you should use Windows Authentication. 9.2.1.1. Create a new Windows account By default, administrators on your computer have full access to SQL Server. For this lesson, we want to have a less privileged user; therefore, you will create a new local Windows Authentication account on your computer. To do this, you must be an administrator on your computer. Then you will grant that new user access to SQL Server. Select Start, select Run, in the Open box, type %SystemRoot%\system32\compmgmt.msc /s and then select OK to open the Computer Management program. Under System Tools, expand Local Users and Groups, right-click Users, and then select New User. In the User name box type Mary. In the Password and Confirm password box, type a strong password, and then select Create to create a new local Windows user. 9.2.1.2. Create a SQL login using Windows Authentication with T-SQL In a Query Editor window of SQL Server Management Studio, type and execute the following code replacing computer_name with the name of your computer. FROM WINDOWS indicates that Windows will authenticate the user. The optional DEFAULT_DATABASE argument connects Mary to the TestData database, unless her connection string indicates another database. This statement introduces the semicolon as an optional termination for a Transact-SQL statement. CREATE LOGIN [computer_name\Mary] FROM WINDOWS WITH DEFAULT_DATABASE = [TestData]; GO This authorizes a user name Mary, authenticated by your computer, to access this instance of SQL Server. If there is more than one instance of SQL Server on the computer, you must create the login on each instance that Mary must access. Because Mary is not a domain account, this user name can only be authenticated on this computer. 9.2.1.3. Create a login using SQL Server Authentication with T-SQL -- Creates the user &quot;shcooper&quot; for SQL Server using the security credential &quot;RestrictedFaculty&quot; -- The user login starts with the password &quot;Baz1nga,&quot; but that password must be changed after the first login. CREATE LOGIN shcooper WITH PASSWORD = &#39;Baz1nga&#39; MUST_CHANGE, CREDENTIAL = RestrictedFaculty; GO 9.2.2. Grant access to a database Mary now has access to this instance of SQL Server, but doesn&#8217;t have permission to access the databases. She doesn&#8217;t even have access to her default database TestData until you authorize her as a database user. To grant Mary access, switch to the TestData database, and then use the CREATE USER statement to map her login to a user named Mary. 9.2.2.1. Create a user in a database Type and execute the following statements (replacing computer_name with the name of your computer) to grant Mary access to the TestData database. USE [TestData]; GO CREATE USER [Mary] FOR LOGIN [computer_name\Mary]; GO Now, Mary has access to both SQL Server and the TestData database. 9.2.2.2. Create views and stored procedures As an administrator, you can execute the SELECT from the Products table and the vw_Names view, and execute the pr_Names procedure; however, Mary can&#8217;t. To grant Mary the necessary permissions, use the GRANT statement. Grant permission to stored procedure Execute the following statement to give Mary the EXECUTE permission for the pr_Names stored procedure. GRANT EXECUTE ON pr_Names TO Mary; GO In this scenario, Mary can only access the Products table by using the stored procedure. If you want Mary to be able to execute a SELECT statement against the view, then you must also execute GRANT SELECT ON vw_Names TO Mary. To remove access to database objects, use the REVOKE statement. If the table, the view, and the stored procedure are not owned by the same schema, granting permissions becomes more complex. 9.2.2.3. About GRANT You must have EXECUTE permission to execute a stored procedure. You must have SELECT, INSERT, UPDATE, and DELETE permissions to access and change data. The GRANT statement is also used for other permissions, such as permission to create tables. 9.3. Lesson 3: Delete database objects This short lesson removes the objects that you created in Lesson 1 and Lesson 2, and then drops the database. Before you delete objects, make sure you are in the correct database: USE TestData; GO 9.3.1. Revoke stored procedure permissions Use the REVOKE statement to remove execute permission for Mary on the stored procedure: REVOKE EXECUTE ON pr_Names FROM Mary; GO 9.3.2. Drop permissions Use the DROP statement to remove permission for Mary to access the TestData database: DROP USER Mary; GO Use the DROP statement to remove permission for Mary to access this instance of SQL Server 2005 (9.x): DROP LOGIN [&lt;computer_name&gt;\Mary]; GO Use the DROP statement to remove the store procedure pr_Names: DROP PROC pr_Names; GO Use the DROP statement to remove the view vw_Names: DROP VIEW vw_Names; GO 9.3.3. Delete table Use the DELETE statement to remove all rows from the Products table: DELETE FROM Products; GO Use the DROP statement to remove the Products table: DROP TABLE Products; GO 9.3.4. Remove database You can&#8217;t remove the TestData database while you are in the database; therefore, first switch context to another database, and then use the DROP statement to remove the TestData database: USE MASTER; GO DROP DATABASE TestData; GO 10. References https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-deployment?view=sql-server-ver16&amp;pivots=cs1-bash https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver16&amp;preserve-view=true&amp;pivots=cs1-bash https://learn.microsoft.com/en-us/sql/relational-databases/databases/databases?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/databases/contained-databases?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/sql-server/install/file-locations-for-default-and-named-instances-of-sql-server?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/getting-started-with-database-engine-permissions?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/language-elements/sql-server-utilities-statements-go?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/language-elements/transact-sql-syntax-conventions-transact-sql?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/tutorial-writing-transact-sql-statements?view=sql-server-ver16 https://en.wikipedia.org/wiki/SQL" />
<link rel="canonical" href="https://blog.codefarm.me/2023/04/06/sql-server-database/" />
<meta property="og:url" content="https://blog.codefarm.me/2023/04/06/sql-server-database/" />
<meta property="og:site_name" content="CODE FARM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-06T10:14:18+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Intro to SQL Server Database" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-06T10:14:18+08:00","datePublished":"2023-04-06T10:14:18+08:00","description":"1. Deploy and connect to SQL Server Linux containers 1.1. Pull and run the SQL Server Linux container image 1.2. Connect to SQL Server 1.3. Create and query data 1.3.1. Create a new database 1.3.2. Insert data 1.3.3. Select data 2. Databases 2.1. Basic Information about Databases 2.1.1. Servers, Databases, Schemas and Tables 2.1.2. Files and FileGroups 2.1.3. Logins and Database Users 2.1.4. Roles and Permissions 2.2. Working with Databases 2.3. System Databases 2.3.1. master Database 2.4. Contained Databases 2.5. Database Files and Filegroups 2.5.1. Database Files 2.5.2. Logical and Physical File Names 3. Database Engine Permissions and Principals 3.1. Server-level roles 3.2. Database-level roles 3.3. Contained database users: Make your database portable by using contained databases 3.3.1. Traditional login and user model 3.3.2. Contained database user model 3.4. Security principals 3.4.1. Logins 3.4.2. Fixed server roles 3.4.3. User-defined server roles 3.4.4. Database users 3.4.5. Fixed database roles 3.4.6. User-defined database roles 3.4.7. Other principals 3.5. Assign permissions 3.6. Permission hierarchy 3.7. Monitor permissions 3.8. Principals (Database Engine) 3.8.1. SQL Server-level principals 3.8.2. Database-level principals 3.8.3. sa Login 3.8.4. dbo User and dbo Schema 3.8.5. public Server Role and Database Role 4. SQL and T-SQL 5. SQL Server Utilities Statements - GO 6. Collation and Unicode support 7. Database identifiers 8. Transact-SQL syntax conventions (Transact-SQL) 9. Tutorial: Write Transact-SQL statements 9.1. Lesson 1: Create and query database objects 9.1.1. Create a database 9.1.2. Create a Table 9.1.2.1. Switch the Query Editor connection to the TestData database 9.1.2.2. Create the table 9.1.3. Insert and update data in a table 9.1.3.1. Insert data into a table 9.1.3.2. Update the products table 9.1.4. Read data from a table 9.1.4.1. Read the data in a table 9.1.4.2. Useful functions in a SELECT statement 9.1.5. Create views and stored procedures 9.1.5.1. Create a view 9.1.5.2. Test the view 9.1.5.3. Create a stored procedure 9.1.5.4. Test the stored procedure 9.2. Lesson 2: Configure permissions on database objects 9.2.1. Create a login 9.2.1.1. Create a new Windows account 9.2.1.2. Create a SQL login using Windows Authentication with T-SQL 9.2.1.3. Create a login using SQL Server Authentication with T-SQL 9.2.2. Grant access to a database 9.2.2.1. Create a user in a database 9.2.2.2. Create views and stored procedures 9.2.2.3. About GRANT 9.3. Lesson 3: Delete database objects 9.3.1. Revoke stored procedure permissions 9.3.2. Drop permissions 9.3.3. Delete table 9.3.4. Remove database 10. References 1. Deploy and connect to SQL Server Linux containers In this quickstart, you&#8217;ll use Docker to pull and run the SQL Server 2022 (16.x) Linux container image, mssql-server-linux. Then you can connect with sqlcmd to create your first database and run queries. 1.1. Pull and run the SQL Server Linux container image Pull the SQL Server 2022 (16.x) Linux container image from the Microsoft Container Registry. sudo docker pull mcr.microsoft.com/mssql/server:2022-latest To run the Linux container image with Docker, you can use the following command from a bash shell or elevated PowerShell command prompt. The SA_PASSWORD environment variable is deprecated. Please use MSSQL_SA_PASSWORD instead. sudo docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;&quot; \\ -p 1433:1433 --name sql1 --hostname sql1 \\ -d \\ mcr.microsoft.com/mssql/server:2022-latest Your password should follow the SQL Server default password policy, otherwise the container can&#8217;t set up SQL Server and will stop working. By default, the password must be at least eight characters long and contain characters from three of the following four sets: uppercase letters, lowercase letters, base-10 digits, and symbols. By default, this quickstart creates a container with the Developer edition of SQL Server. The process for running production editions in containers is slightly different. To view your Docker containers, use the docker ps command. docker ps You should see output similar to the following: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 274554ac9f0d mcr.microsoft.com/mssql/server:2022-latest &quot;/opt/mssql/bin/perm…&quot; 42 seconds ago Up 1 second 0.0.0.0:1433-&gt;1433/tcp, :::1433-&gt;1433/tcp sql1 If the STATUS column shows a status of Up, then SQL Server is running in the container and listening on the port specified in the PORTS column. If the STATUS column for your SQL Server container shows Exited, see the Troubleshooting section of the configuration guide. 1.2. Connect to SQL Server The following steps use the SQL Server command-line tool, sqlcmd, inside the container to connect to SQL Server. Use the docker exec -it command to start an interactive bash shell inside your running container. In the following example sql1 is name specified by the --name parameter when you created the container. sudo docker exec -it sql1 &quot;bash&quot; Once inside the container, connect locally with sqlcmd, using its full path. /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -P &quot;&lt;YourStrong@Passw0rd&gt;&quot; -No You can omit the password on the command-line to be prompted to enter it. Here&#8217;s an example: /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -No If successful, you should get to a sqlcmd command prompt: 1&gt;. 1&gt; :help :!! [&lt;command&gt;] - Executes a command in the command shell. :connect server[\\instance] [-l timeout] [-U user [-P password]] - Connects to a SQL Server instance. :error &lt;dest&gt; - Redirects error output to a file, stderr, or stdout. :exit - Quits sqlcmd immediately. :exit() - Execute statement cache; quit with no return value. :exit(&lt;query&gt;) - Execute the specified query; returns numeric result. go [&lt;n&gt;] - Executes the statement cache (n times). :help - Shows this list of commands. :list - Prints the content of the statement cache. :listvar - Lists the set sqlcmd scripting variables. :on error [exit|ignore] - Action for batch or sqlcmd command errors. :out &lt;filename&gt;|stderr|stdout - Redirects query output to a file, stderr, or stdout. :perftrace &lt;filename&gt;|stderr|stdout - Redirects timing output to a file, stderr, or stdout. :quit - Quits sqlcmd immediately. :r &lt;filename&gt; - Append file contents to the statement cache. :reset - Discards the statement cache. :serverlist - Lists local and SQL Servers on the network. :setvar {variable} - Removes a sqlcmd scripting variable. :setvar &lt;variable&gt; &lt;value&gt; - Sets a sqlcmd scripting variable. $ /opt/mssql-tools18/bin/sqlcmd -S localhost -U SA -P &quot;&lt;YourStrong@Passw0rd&gt;&quot; -No -Q &quot;SELECT @@version&quot; ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ Microsoft SQL Server 2022 (RTM-CU16) (KB5048033) - 16.0.4165.4 (X64) Nov 6 2024 19:24:49 Copyright (C) 2022 Microsoft Corporation Developer Edition (64-bit) on Linux (Ubuntu 22.04.5 LTS) &lt;X64&gt; (1 rows affected) 1.3. Create and query data The following sections walk you through using sqlcmd and Transact-SQL to create a new database, add data, and run a query. 1.3.1. Create a new database The following steps create a new database named TestDB. From the sqlcmd command prompt, paste the following Transact-SQL command to create a test database: CREATE DATABASE TestDB; On the next line, write a query to return the name of all of the databases on your server: SELECT Name from sys.databases; The previous two commands weren&#8217;t run immediately. Type GO on a new line to run the previous commands: GO 1.3.2. Insert data Next create a new table, Inventory, and insert two new rows. From the sqlcmd command prompt, switch context to the new TestDB database: USE TestDB; Create new table named Inventory: CREATE TABLE Inventory (id INT, name NVARCHAR(50), quantity INT); Insert data into the new table: INSERT INTO Inventory VALUES (1, &#39;banana&#39;, 150); INSERT INTO Inventory VALUES (2, &#39;orange&#39;, 154); Type GO to run the previous commands: GO 1.3.3. Select data Now, run a query to return data from the Inventory table. From the sqlcmd command prompt, enter a query that returns rows from the Inventory table where the quantity is greater than 152: SELECT * FROM Inventory WHERE quantity &gt; 152; Run the command: GO Exit the sqlcmd command prompt To end your sqlcmd session, type QUIT: QUIT To exit the interactive command-prompt in your container, type exit. Your container continues to run after you exit the interactive bash shell. 2. Databases A database in SQL Server is made up of a collection of tables that stores a specific set of structured data. A table contains a collection of rows, also referred to as records or tuples, and columns, also referred to as attributes. Each column in the table is designed to store a certain type of information, for example, dates, names, dollar amounts, and numbers. 2.1. Basic Information about Databases 2.1.1. Servers, Databases, Schemas and Tables A computer can have one or more than one instance of SQL Server installed. Each instance of SQL Server can contain one or many databases. Within a database, there are one or many object ownership groups called schemas. Within each schema there are database objects such as tables, views, and stored procedures. Some objects such as certificates and asymmetric keys are contained within the database, but are not contained within a schema. For more information about creating tables, see Tables. Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views 2.1.2. Files and FileGroups SQL Server databases are stored in the file system in files. Files can be grouped into filegroups. For more information about files and filegroups, see Database Files and Filegroups. 2.1.3. Logins and Database Users When people gain access to an instance of SQL Server they are identified as a login. When people gain access to a database they are identified as a database user. A database user can be based on a login. If contained databases are enabled, a database user can be created that is not based on a login. For more information about users, see CREATE USER (Transact-SQL). Logins &lt;-&gt; Servers (instances) Database Users &lt;-&gt; Databases 2.1.4. Roles and Permissions A user that has access to a database can be given permission to access the objects in the database. Though permissions can be granted to individual users, we recommend creating database roles, adding the database users to the roles, and then grant access permission to the roles. Granting permissions to roles instead of users makes it easier to keep permissions consistent and understandable as the number of users grow and continually change. For more information about roles permissions, see CREATE ROLE (Transact-SQL) and Principals (Database Engine). 2.2. Working with Databases Most people who work with databases use the SQL Server Management Studio tool. The Management Studio tool has a graphical user interface for creating databases and the objects in the databases. Management Studio also has a query editor for interacting with databases by writing Transact-SQL statements. Management Studio can be installed from the SQL Server installation disk, or downloaded from MSDN. For more information about SQL Server Management Studio tool, see SQL Server Management Studio (SSMS). 2.3. System Databases SQL Server includes the following system databases. System database Description master Database Records all the system-level information for an instance of SQL Server. msdb Database Is used by SQL Server Agent for scheduling alerts and jobs. model Database Is used as the template for all databases created on the instance of SQL Server. Modifications made to the model database, such as database size, collation, recovery model, and other database options, are applied to any databases created afterward. Resource Database Is a read-only database that contains system objects that are included with SQL Server. System objects are physically persisted in the Resource database, but they logically appear in the sys schema of every database. tempdb Database Is a workspace for holding temporary objects or intermediate result sets. For Azure SQL Database single databases and elastic pools, only master Database and tempdb Database apply. 2.3.1. master Database The master database records all the system-level information for a SQL Server system. This includes instance-wide metadata such as logon accounts, endpoints, linked servers, and system configuration settings. In SQL Server, system objects are no longer stored in the master database; instead, they are stored in the Resource database. Also, master is the database that records the existence of all other databases and the location of those database files and records the initialization information for SQL Server. Therefore, SQL Server cannot start if the master database is unavailable. 2.4. Contained Databases A contained database is a database that is isolated from other databases and from the instance of SQL Server that hosts the database. SQL Server helps user to isolate their database from the instance in 4 ways. Much of the metadata that describes a database is maintained in the database. (In addition to, or instead of, maintaining metadata in the master database.) All metadata are defined using the same collation. User authentication can be performed by the database, reducing the databases dependency on the logins of the instance of SQL Server. The SQL Server environment (DMV&#8217;s, XEvents, etc.) reports and can act upon containment information. 2.5. Database Files and Filegroups At a minimum, every SQL Server database has two operating system files: a data file and a log file. Data files contain data and objects such as tables, indexes, stored procedures, and views. Log files contain the information that is required to recover all transactions in the database. Data files can be grouped together in filegroups for allocation and administration purposes. 2.5.1. Database Files SQL Server databases have three types of files, as shown in the following table. File Description Primary Contains startup information for the database and points to the other files in the database. Every database has one primary data file. The recommended file name extension for primary data files is .mdf. Secondary Optional user-defined data files. Data can be spread across multiple disks by putting each file on a different disk drive. The recommended file name extension for secondary data files is .ndf. Transaction Log The log holds information used to recover the database. There must be at least one log file for each database. The recommended file name extension for transaction logs is .ldf. For example, a simple database named Sales has one primary file that contains all data and objects and a log file that contains the transaction log information. A more complex database named Orders can be created that includes one primary file and five secondary files. The data and objects within the database spread across all six files, and the four log files contain the transaction log information. By default, the data and transaction logs are put on the same drive and path to handle single-disk systems. This choice may not be optimal for production environments. We recommend that you put data and log files on separate disks. $ ls /var/opt/mssql/data/ Entropy.bin Sales_log.ldf mastlog.ldf model_msdbdata.mdf model_replicatedmaster.ldf modellog.ldf msdblog.ldf tempdb2.ndf tempdb4.ndf Sales.mdf master.mdf model.mdf model_msdblog.ldf model_replicatedmaster.mdf msdbdata.mdf tempdb.mdf tempdb3.ndf templog.ldf 2.5.2. Logical and Physical File Names SQL Server files have two file name types: logical_file_name: The logical_file_name is the name used to refer to the physical file in all Transact-SQL statements. The logical file name must comply with the rules for SQL Server identifiers and must be unique among logical file names in the database. os_file_name: The os_file_name is the name of the physical file including the directory path. It must follow the rules for the operating system file names. When multiple instances of SQL Server are running on a single computer, each instance receives a different default directory to hold the files for the databases created in the instance. For more information, see File Locations for Default and Named Instances of SQL Server. 3. Database Engine Permissions and Principals Permissions in the Database Engine are managed at the server level through logins and server roles, and at the database level through database users and database roles. The model for SQL Database exposes the same system within each database, but the server level permissions aren&#8217;t available. 3.1. Server-level roles SQL Server provides server-level roles to help you manage the permissions on a server. These roles are security principals that group other principals. Server-level roles are server-wide in their permissions scope. 3.2. Database-level roles Database-level roles are database-wide in their permissions scope. There are two types of database-level roles: fixed-database roles that are predefined in the database and user-defined database roles that you can create. Fixed-database roles are defined at the database level and exist in each database. Members of the db_owner database role can manage fixed-database role membership. There are also some special-purpose database roles in the msdb database. You can add any database account and other SQL Server roles into database-level roles. 3.3. Contained database users: Make your database portable by using contained databases Use contained database users to authenticate SQL Server and Azure SQL Database connections at the database level. A contained database is a database that&#8217;s isolated from other databases and from the instance of SQL Server or SQL Database (and the master database) that hosts the database. 3.3.1. Traditional login and user model In the traditional connection model, Windows users or members of Windows groups connect to the Database Engine by providing user or group credentials authenticated by Windows. Or users can provide both a name and password and connect by using SQL Server authentication. In both cases, the master database must have a login that matches the connecting credentials. After the Database Engine confirms the Windows authentication credentials or authenticates the SQL Server authentication credentials, the connection typically attempts to connect to a user database. To connect to a user database, the login must be mapped to (that is, associated with) a database user in the user database. The connection string might also specify connecting to a specific database, which is optional in SQL Server but required in SQL Database. The important principle is that both the login (in the master database) and the user (in the user database) must exist and be related to each other. The connection to the user database has a dependency upon the login in the master database. This dependency limits the ability of the database to be moved to a different hosting SQL Server instance or Azure SQL Database server. If a connection to the master database is not available (for example, a failover is in progress), the overall connection time will increase, or the connection might time out. An unavailable connection might reduce connection scalability. 3.3.2. Contained database user model In the contained database user model, the login in the master database is not present. Instead, the authentication process occurs at the user database. The database user in the user database doesn&#8217;t have an associated login in the master database. The contained database user model supports both Windows authentication and SQL Server authentication. You can use it in both SQL Server and SQL Database. To connect as a contained database user, the connection string must always contain a parameter for the user database. The Database Engine uses this parameter to know which database is responsible for managing the authentication process. The activity of the contained database user is limited to the authenticating database. The database user account must be independently created in each database that the user needs. To change databases, SQL Database users must create a new connection. Contained database users in SQL Server can change databases if an identical user is present in another database. 3.4. Security principals Security principal is the official name of the identities that use SQL Server and that can be assigned permission to take actions. They are usually people or groups of people, but can be other entities that pretend to be people. The security principals can be created and managed using the Transact-SQL listed, or by using SQL Server Management Studio. 3.4.1. Logins Logins are individual user accounts for logging on to the SQL Server Database Engine. SQL Server and SQL Database support logins based on Windows authentication and logins based on SQL Server authentication. For information about the two types of logins, see Choose an Authentication Mode. 3.4.2. Fixed server roles In SQL Server, fixed server roles are a set of pre-configured roles that provide convenient group of server-level permissions. Logins can be added to the roles using the ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER SERVER ROLE (Transact-SQL). SQL Database doesn&#8217;t support the fixed server roles, but has two roles in the master database (dbmanager and loginmanager) that act like server roles. 3.4.3. User-defined server roles In SQL Server, you can create your own server roles and assign server-level permissions to them. Logins can be added to the server roles using the ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER SERVER ROLE (Transact-SQL). SQL Database doesn&#8217;t support the user-defined server roles. 3.4.4. Database users Logins are granted access to a database by creating a database user in a database and mapping that database user to sign in. Typically the database user name is the same as the login name, though it doesn&#8217;t have to be the same. Each database user maps to a single login. A login can be mapped to only one user in a database, but can be mapped as a database user in several different databases. Database users can also be created that don&#8217;t have a corresponding login. These users are called contained database users. Microsoft encourages the use of contained database users because it makes it easier to move your database to a different server. Like a login, a contained database user can use either Windows authentication or SQL Server authentication. For more information, see Contained Database Users - Making Your Database Portable. There are 12 types of users with slight differences in how they authenticate, and who they represent. To see a list of users, see CREATE USER (Transact-SQL). 3.4.5. Fixed database roles Fixed database roles are a set of pre-configured roles that provide convenient group of database-level permissions. Database users and user-defined database roles can be added to the fixed database roles using the ALTER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER ROLE (Transact-SQL). 3.4.6. User-defined database roles Users with the CREATE ROLE permission can create new user-defined database roles to represent groups of users with common permissions. Typically permissions are granted or denied to the entire role, simplifying permissions management and monitoring. Database users can be added to the database roles by using the ALTER ROLE &#8230;&#8203; ADD MEMBER statement. For more information, see ALTER ROLE (Transact-SQL). 3.4.7. Other principals Additional security principals not discussed here include application roles, and logins and users based on certificates or asymmetric keys. For a graphic showing the relationships between Windows users, Windows groups, logins, and database users, see Create a Database User. 3.5. Assign permissions Every SQL Server securable has associated permissions that can be granted to a principal. Permissions in the Database Engine are managed at the server level assigned to logins and server roles, and at the database level assigned to database users and database roles. The model for Azure SQL Database has the same system for the database permissions, but the server level permissions aren&#8217;t available. Most permission statements have the format: AUTHORIZATION PERMISSION ON SECURABLE::NAME TO PRINCIPAL; AUTHORIZATION must be GRANT, REVOKE or DENY. The PERMISSION establishes what action is allowed or prohibited. The exact number of permissions differs between SQL Server and SQL Database. The permissions are listed in the article Permissions (Database Engine) and in the chart referenced below. ON SECURABLE::NAME is the type of securable (server, server object, database, or database object) and its name. Some permissions don&#8217;t require ON SECURABLE::NAME because it is unambiguous or inappropriate in the context. For example, the CREATE TABLE permission doesn&#8217;t require the ON SECURABLE::NAME clause (GRANT CREATE TABLE TO Mary; allows Mary to create tables). PRINCIPAL is the security principal (login, user, or role) which receives or loses the permission. Grant permissions to roles whenever possible. The following example grant statement, grants the UPDATE permission on the Parts table or view that is contained in the Production schema to the role named PartsTeam: GRANT UPDATE ON OBJECT::Production.Parts TO PartsTeam; The following example grant statement grants the UPDATE permission on the Production schema, and by extension on any table or view contained within this schema to the role named ProductionTeam, which is a more effective and salable approach to assigning permissions than on individual object-level: GRANT UPDATE ON SCHEMA::Production TO ProductionTeam; Permissions are granted to security principals (logins, users, and roles) by using the GRANT statement. Permissions are explicitly denied by using the DENY command. A previously granted or denied permission is removed by using the REVOKE statement. Permissions are cumulative, with the user receiving all the permissions granted to the user, login, and any group memberships; however any permission denial overrides all grants. A common mistake is to attempt to remove a GRANT by using DENY instead of REVOKE. This can cause problems when a user receives permissions from multiple sources; which is quite common. The following example demonstrates the principal. The Sales group receives SELECT permissions on the OrderStatus table through the statement GRANT SELECT ON OBJECT::OrderStatus TO Sales;. User Jae is a member of the Sales role. Jae has also been granted SELECT permission to the OrderStatus table under their own user name through the statement GRANT SELECT ON OBJECT::OrderStatus TO Jae;. Presume the administer wishes to remove the GRANT to the Sales role. If the administrator correctly executes REVOKE SELECT ON OBJECT::OrderStatus TO Sales;, then Jae will retain SELECT access to the OrderStatus table through their individual GRANT statement. If the administrator incorrectly executes DENY SELECT ON OBJECT::OrderStatus TO Sales; then Jae, as a member of the Sales role, will be denied the SELECT permission because the DENY to Sales overrides their individual GRANT. Permissions can be configured using Management Studio. Find the securable in Object Explorer, right-click the securable, and then select Properties. Select the Permissions page. For help on using the permission page, see Permissions or Securables Page. 3.6. Permission hierarchy Permissions have a parent/child hierarchy. That is, if you grant SELECT permission on a database, that permission includes SELECT permission on all (child) schemas in the database. If you grant SELECT permission on a schema, it includes SELECT permission on all the (child) tables and views in the schema. The permissions are transitive; that is, if you grant SELECT permission on a database, it includes SELECT permission on all (child) schemas, and all (grandchild) tables and views. Permissions also have covering permissions. The CONTROL permission on an object, normally gives you all other permissions on the object. Because both the parent/child hierarchy and the covering hierarchy can act on the same permission, the permission system can get complicated. For example, let&#8217;s take a table (Region), in a schema (Customers), in a database (SalesDB). CONTROL permission on table Region includes all the other permissions on the table Region, including ALTER, SELECT, INSERT, UPDATE, DELETE, and some other permissions. SELECT on the Customers schema that owns the Region table includes the SELECT permission on the Region table. So SELECT permission on the Region table can be achieved through any of these six statements: GRANT SELECT ON OBJECT::Region TO Jae; GRANT CONTROL ON OBJECT::Region TO Jae; GRANT SELECT ON SCHEMA::Customers TO Jae; GRANT CONTROL ON SCHEMA::Customers TO Jae; GRANT SELECT ON DATABASE::SalesDB TO Jae; GRANT CONTROL ON DATABASE::SalesDB TO Jae; 3.7. Monitor permissions The following views return security information. The logins and user-defined server roles on a server can be examined by using the sys.server_principals view. This view isn&#8217;t available in SQL Database. The users and user-defined roles in a database can be examined by using the sys.database_principals view. The permissions granted to logins and user-defined fixed server roles can be examined by using the sys.server_permissions view. This view isn&#8217;t available in SQL Database. The permissions granted to users and user-defined fixed database roles can be examined by using the sys.database_permissions view. Database role membership can be examined by using the sys.database_role_members view. Server role membership can be examined by using the sys.server_role_members view. This view isn&#8217;t available in SQL Database. For additional security related views, see Security Catalog Views (Transact-SQL). 3.8. Principals (Database Engine) Principals are entities that can request SQL Server resources. Like other components of the SQL Server authorization model, principals can be arranged in a hierarchy. The scope of influence of a principal depends on the scope of the definition of the principal: Windows, server, database; and whether the principal is indivisible or a collection. A Windows Login is an example of an indivisible principal, and a Windows Group is an example of a principal that is a collection. Every principal has a security identifier (SID). 3.8.1. SQL Server-level principals SQL Server authentication Login Windows authentication login for a Windows user Windows authentication login for a Windows group Azure Active Directory authentication login for a AD user Azure Active Directory authentication login for a AD group Server Role 3.8.2. Database-level principals Database User (There are 12 types of users. For more information, see CREATE USER.) Database Role Application Role 3.8.3. sa Login The SQL Server sa login is a server-level principal. By default, it is created when an instance is installed. Beginning in SQL Server 2005 (9.x), the default database of sa is master. This is a change of behavior from earlier versions of SQL Server. The sa login is a member of the sysadmin fixed server-level role. The sa login has all permissions on the server and cannot be limited. The sa login cannot be dropped, but it can be disabled so that no one can use it. 3.8.4. dbo User and dbo Schema The dbo user is a special user principal in each database. All SQL Server administrators, members of the sysadmin fixed server role, sa login, and owners of the database, enter databases as the dbo user. The dbo user has all permissions in the database and cannot be limited or dropped. dbo stands for database owner, but the dbo user account is not the same as the db_owner fixed database role, and the db_owner fixed database role is not the same as the user account that is recorded as the owner of the database. The dbo user owns the dbo schema. The dbo schema is the default schema for all users, unless some other schema is specified. The dbo schema cannot be dropped. 3.8.5. public Server Role and Database Role Every login belongs to the public fixed server role, and every database user belongs to the public database role. When a login or user has not been granted or denied specific permissions on a securable, the login or user inherits the permissions granted to public on that securable. The public fixed server role and the public fixed database role cannot be dropped. However you can revoke permissions from the public roles. There are many permissions that are assigned to the public roles by default. Most of these permissions are needed for routine operations in the database; the type of things that everyone should be able to do. Be careful when revoking permissions from the public login or user, as it will affect all logins/users. Generally you should not deny permissions to public, because the deny statement overrides any grant statements you might make to individuals. 4. SQL and T-SQL SQL, From Wikipedia, the free encyclopedia, https://en.wikipedia.org/wiki/SQL Structured Query Language, abbreviated as SQL (/ˌɛsˌkjuːˈɛl/ ) S-Q-L, sometimes /ˈsiːkwəl/ &quot;sequel&quot; for historical reasons), is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It is particularly useful in handling structured data, i.e. data incorporating relations among entities and variables. Transact-SQL, From Wikipedia, the free encyclopedia, https://en.wikipedia.org/wiki/Transact-SQL Transact-SQL (T-SQL) is Microsoft&#8217;s and Sybase&#8217;s proprietary extension to the SQL (Structured Query Language) used to interact with relational databases. T-SQL expands on the SQL standard to include procedural programming, local variables, various support functions for string processing, date processing, mathematics, etc. and changes to the DELETE and UPDATE statements. Transact-SQL is central to using Microsoft SQL Server. All applications that communicate with an instance of SQL Server do so by sending Transact-SQL statements to the server, regardless of the user interface of the application. Stored procedures in SQL Server are executable server-side routines. The advantage of stored procedures is the ability to pass parameters. 5. SQL Server Utilities Statements - GO SQL Server provides commands that are not Transact-SQL statements, but are recognized by the sqlcmd and osql utilities and SQL Server Management Studio Code Editor. These commands can be used to facilitate the readability and execution of batches and scripts. GO signals the end of a batch of Transact-SQL statements to the SQL Server utilities. Syntax GO [count] Arguments count Is a positive integer. The batch preceding GO will execute the specified number of times. Remarks GO is not a Transact-SQL statement; it is a command recognized by the sqlcmd and osql utilities and SQL Server Management Studio Code editor. SQL Server utilities interpret GO as a signal that they should send the current batch of Transact-SQL statements to an instance of SQL Server. The current batch of statements is composed of all statements entered since the last GO, or since the start of the ad hoc session or script if this is the first GO. A Transact-SQL statement cannot occupy the same line as a GO command. However, the line can contain comments. Users must follow the rules for batches. For example, any execution of a stored procedure after the first statement in a batch must include the EXECUTE keyword. The scope of local (user-defined) variables is limited to a batch, and cannot be referenced after a GO command. USE AdventureWorks2012; GO DECLARE @MyMsg VARCHAR(50) SELECT @MyMsg = &#39;Hello, World.&#39; GO -- @MyMsg is not valid after this GO ends the batch. -- Yields an error because @MyMsg not declared in this batch. PRINT @MyMsg GO SELECT @@VERSION; -- Yields an error: Must be EXEC sp_who if not first statement in -- batch. sp_who GO SQL Server applications can send multiple Transact-SQL statements to an instance of SQL Server for execution as a batch. The statements in the batch are then compiled into a single execution plan. Programmers executing ad hoc statements in the SQL Server utilities, or building scripts of Transact-SQL statements to run through the SQL Server utilities, use GO to signal the end of a batch. Applications based on the ODBC or OLE DB APIs receive a syntax error if they try to execute a GO command. The SQL Server utilities never send a GO command to the server. Do not use a semicolon as a statement terminator after GO. -- Yields an error because ; is not permitted after GO SELECT @@VERSION; GO; The GO statement is not a SQL statement; rather, it is a command recognized by the SQL Server Management Studio (SSMS), sqlcmd, and other SQL Server utilities. In the context of these utilities, GO signals the end of a batch of statements and is used to separate batches of statements from each other. However, when you are performing database operations from ADO.NET (or any other context where you&#8217;re sending SQL statements directly to SQL Server), batch separation is not needed, and the GO statement is not recognized. If you try to include the GO statement in your SQL strings in ADO.NET, you&#8217;ll likely encounter a SQL Server error that &#39;GO&#39; is not a recognized built-in function name. Instead, just end each of your SQL statements with a semicolon (;). 6. Collation and Unicode support Collations in SQL Server provide sorting rules, case, and accent sensitivity properties for your data. Collations that are used with character data types, such as char and varchar, dictate the code page and corresponding characters that can be represented for that data type. Whether you&#8217;re installing a new instance of SQL Server, restoring a database backup, or connecting server to client databases, it&#8217;s important to understand the locale requirements, sorting order, and case and accent sensitivity of the data that you&#8217;re working with. To list the collations that are available on your instance of SQL Server, see sys.fn_helpcollations (Transact-SQL). When you select a collation for your server, database, column, or expression, you&#8217;re assigning certain characteristics to your data. These characteristics affect the results of many operations in the database. For example, when you construct a query by using ORDER BY, the sort order of your result set might depend on the collation that&#8217;s applied to the database or dictated in a COLLATE clause at the expression level of the query. Setting collations are supported at the following levels of an instance of SQL Server: Server-level collations The default server collation is determined during SQL Server setup, and it becomes the default collation of the system databases and all user databases. To query the server collation for an instance of SQL Server, use the SERVERPROPERTY function: SELECT CONVERT(nvarchar(128), SERVERPROPERTY(&#39;collation&#39;)); -- SQL_Latin1_General_CP1_CI_AS * SQL_Latin1_General_CP1_CI_AS is a collation setting in SQL Server. Here&#8217;s what each part of it means: SQL indicates that it is a SQL Server-defined collation. Latin1_General is the base language and alphabet, which in this case is the Latin 1 (Western European) alphabet. CP1 stands for Code Page 1, which implies that the collation is using code page 1252. This page includes all ASCII characters and additional characters used in English and several other Western European languages. CI stands for Case Insensitive. This means the collation doesn&#8217;t recognize case differences. When CI is specified, &#39;a&#39; is considered equal to &#39;A&#39;. AS stands for Accent Sensitive. This means the collation does recognize accent differences. When AS is specified, &#39;résumé&#39; is not equal to &#39;resume&#39;. * If you want to use unicode (UTF-8) character sets in SQL Server, you can use the newer collations introduced starting from SQL Server 2019 onward. The new collations are named as _SC or _SC_UTF8. The SC stands for Supplementary Characters, which supports UCS-2 or UTF-16 characters. If you want to particularly use UTF-8, you can use _utf8 postfix. So if you need to define columns that can store unicode (UTF-8) strings from any language, you can use something like Latin1_General_100_CI_AS_SC_UTF8. _100 here corresponds to newer set of collations in SQL Server 2019. Please note that UTF-8 collations are only available to char and varchar data types, not to text data type. And if you&#8217;re dealing with wider unicode character sets and more complex translations, it may be better to use nchar or nvarchar data types with either UTF-16 or supplementary character collations. * The Case Insensitive (CI) property in a SQL Server collation does not modify the actual data stored in a cell of a table. If a username is stored as &#39;JohnDoe&#39;, it will be stored as &#39;JohnDoe&#39; regardless of whether the collation is Case Sensitive (CS) or Case Insensitive (CI). The collation only affects how SQL Server compares and sorts that data during queries. In a Case Insensitive collation, SQL Server considers &#39;JohnDoe&#39; and &#39;johndoe&#39; to be equal. If the collation were Case Sensitive, &#39;JohnDoe&#39; and &#39;johndoe&#39; would be considered as two different values. So to put it diagrammatically: With Case Insensitive (CI) collation : SELECT * FROM Users WHERE user_name = &#39;johndoe&#39; will return &#39;JohnDoe&#39;, &#39;JOHNDOE&#39;, &#39;johndoe&#39;, etc. With Case Sensitive (CS) collation : SELECT * FROM Users WHERE user_name = &#39;johndoe&#39; will only return &#39;johndoe&#39; and not &#39;JohnDoe&#39; or &#39;JOHNDOE&#39;. This comparison and sorting behaviour applies both to operations you perform in queries (like WHERE, ORDER BY, JOIN, etc.), as well as to indexes that SQL Server uses to optimize query performance. To query the server for all available collations, use the following fn_helpcollations() built-in function: SELECT * FROM sys.fn_helpcollations(); Database-level collations When you create or modify a database, you can use the COLLATE clause of the CREATE DATABASE or ALTER DATABASE statement to specify the default database collation. If no collation is specified, the database is assigned the server collation. You can retrieve the current collation of a database by using a statement similar to the following code sample: SELECT CONVERT (nvarchar(128), DATABASEPROPERTYEX(&#39;database_name&#39;, &#39;collation&#39;)); Column-level collations When you create or alter a table, you can specify collations for each character-string column by using the COLLATE clause. If you don&#8217;t specify a collation, the column is assigned the default collation of the database. Expression-level collations Expression-level collations are set when a statement is run, and they affect the way a result set is returned. This enables ORDER BY sort results to be locale-specific. To implement expression-level collations, use a COLLATE clause such as the following code sample: SELECT name FROM customer ORDER BY name COLLATE Latin1_General_CS_AI; A locale is a set of information that&#8217;s associated with a location or a culture. The information can include the name and identifier of the spoken language, the script that&#8217;s used to write the language, and cultural conventions. Collations can be associated with one or more locales. For more information, see Locale IDs Assigned by Microsoft. A code page is an ordered set of characters of a given script in which a numeric index, or code point value, is associated with each character. A Windows code page is typically referred to as a character set or a charset. Code pages are used to provide support for the character sets and keyboard layouts that are used by different Windows system locales. Sort order specifies how data values are sorted. The order affects the results of data comparison. Data is sorted by using collations, and it can be optimized by using indexes. Unicode is a standard for mapping code points to characters. Because it&#8217;s designed to cover all the characters of all the languages of the world, you don&#8217;t need different code pages to handle different sets of characters. Storing data in multiple languages within one database is difficult to manage when you use only character data and code pages. It&#8217;s also difficult to find one code page for the database that can store all the required language-specific characters. Additionally, it&#8217;s difficult to guarantee the correct translation of special characters when they&#8217;re being read or updated by a variety of clients that are running various code pages. Databases that support international clients should always use Unicode data types instead of non-Unicode data types. The code pages that a client uses are determined by the operating system (OS) settings. To set client code pages on the Windows operating system, use Regional Settings in Control Panel. It would be difficult to select a code page for character data types that will support all the characters that are required by a worldwide audience. The easiest way to manage character data in international databases is to always use a data type that supports Unicode. If you store character data that reflects multiple languages in SQL Server (SQL Server 2005 (9.x) and later), use Unicode data types (nchar, nvarchar, and ntext) instead of non-Unicode data types (char, varchar, and text). Alternatively, starting with SQL Server 2019 (15.x), if a UTF-8 enabled collation (_UTF8) is used, previously non-Unicode data types (char and varchar) become Unicode data types using UTF-8 encoding. SQL Server 2019 (15.x) doesn&#8217;t change the behavior of previously existing Unicode data types (nchar, nvarchar, and ntext), which continue to use UCS-2 or UTF-16 encoding. For more information, see Storage differences between UTF-8 and UTF-16. 7. Database identifiers The database object name is referred to as its identifier. Everything in Microsoft SQL Server can have an identifier. Servers, databases, and database objects, such as tables, views, columns, indexes, triggers, procedures, constraints, and rules, can have identifiers. Identifiers are required for most objects, but are optional for some objects such as constraints. An object identifier is created when the object is defined. The identifier is then used to reference the object. For example, the following statement creates a table with the identifier TableX, and two columns with the identifiers KeyCol and Description: CREATE TABLE TableX (KeyCol INT PRIMARY KEY, Description nvarchar(80)); This table also has an unnamed constraint. The PRIMARY KEY constraint has no identifier. The collation of an identifier depends on the level at which it is defined. Identifiers of instance-level objects, such as logins and database names, are assigned the default collation of the instance. Identifiers of objects in a database, such as tables, views, and column names, are assigned the default collation of the database. For example, two tables with names that differ only in case can be created in a database that has case-sensitive collation, but cannot be created in a database that has case-insensitive collation. There are two classes of identifiers: Regular identifiers Comply with the rules for the format of identifiers. Regular identifiers are not delimited when they are used in Transact-SQL statements. USE AdventureWorks2022; GO SELECT * FROM HumanResources.Employee WHERE NationalIDNumber = 153479919 Delimited identifiers Are enclosed in double quotation marks (&quot;) or brackets ([ ]). Identifiers that comply with the rules for the format of identifiers might not be delimited. For example: USE AdventureWorks2022; GO SELECT * FROM [HumanResources].[Employee] --Delimiter is optional. WHERE [NationalIDNumber] = 153479919 --Delimiter is optional. Identifiers that do not comply with all the rules for identifiers must be delimited in a Transact-SQL statement. For example: SQL USE AdventureWorks2022; GO CREATE TABLE [SalesOrderDetail Table] --Identifier contains a space and uses a reserved keyword. ( [Order] [int] NOT NULL, [SalesOrderDetailID] [int] IDENTITY(1,1) NOT NULL, [OrderQty] [smallint] NOT NULL, [ProductID] [int] NOT NULL, [UnitPrice] [money] NOT NULL, [UnitPriceDiscount] [money] NOT NULL, [ModifiedDate] [datetime] NOT NULL, CONSTRAINT [PK_SalesOrderDetail_Order_SalesOrderDetailID] PRIMARY KEY CLUSTERED ([Order] ASC, [SalesOrderDetailID] ASC) ); GO SELECT * FROM [SalesOrderDetail Table] --Identifier contains a space and uses a reserved keyword. WHERE [Order] = 10; --Identifier is a reserved keyword. &gt; What&#8217;s the recommend naming convention in SQL Server? * Naming conventions in SQL Server are mostly a matter of personal preference or organizational standards. However, there are some commonly followed best practices that can increase the readability and manageability of your database. Here are a few recommended conventions: Meaningful and Descriptive Names: Names should clearly indicate what the object represents. For example, a table storing customer information should be named Customers or CustomerData, not Table1 or t1. Prefixes for Different Object Types: Using prefixes to denote the type of object can be useful. For example, stored procedures could be named with the sp_ prefix (like sp_GetCustomerDetails), views with vw_ prefix (like vw_CustomerOrders), and tables could be named without any prefix for clarity (like Orders). Avoid SQL Keywords: Avoid using SQL Server reserved words. This can cause confusion and sometimes lead to syntax errors. Be Consistent: Whichever convention you decide on, be consistent with it across all your SQL projects. PascalCase or snake_case: For multiple word names, use PascalCase (no spaces and each word capitalized like CustomerOrders) or snake_case (words separated by underscores like customer_orders). Avoid using spaces in object names. Singular or Plural Names: There&#8217;s much debate about whether to use singular or plural names for table names. Choose whichever makes the most logical sense in your context and be consistent. Avoid Special Characters and Spaces: With the exception of the underscore character, avoid using special characters, dots, hyphens, spaces etc. in names. Remember, the most important goal of any naming convention is to make the code and database structure easily understandable and manageable for the developers and administrators working on it. Note: In SQL Server, the sp_ prefix is reserved for system stored procedures. Some developers prefer not to use it for user-defined stored procedures to avoid potential naming conflicts and small performance penalties when the system searches the master database first for such procedures. They may use usp_ for user stored procedures instead. 8. Transact-SQL syntax conventions (Transact-SQL) The following table lists and describes conventions that are used in the syntax diagrams in the Transact-SQL reference. Convention Used for UPPERCASE Transact-SQL keywords. italic User-supplied parameters of Transact-SQL syntax. bold Type database names, table names, column names, index names, stored procedures, utilities, data type names, and text exactly as shown. | (vertical bar) Separates syntax items enclosed in brackets or braces. You can use only one of the items. [ ] (brackets) Optional syntax item. { } (braces) Required syntax items. Don&#8217;t type the braces. [ , &#8230;&#8203;n ] Indicates the preceding item can be repeated n number of times. The occurrences are separated by commas. [ &#8230;&#8203;n ] Indicates the preceding item can be repeated n number of times. The occurrences are separated by blanks. ; Transact-SQL statement terminator. Although the semicolon isn&#8217;t required for most statements in this version of SQL Server, it will be required in a future version. ::= The name for a block of syntax. Use this convention to group and label sections of lengthy syntax or a unit of syntax that you can use in more than one location within a statement. Each location in which the block of syntax could be used is indicated with the label enclosed in chevrons: &lt;label&gt;. A set is a collection of expressions, for example &lt;grouping set&gt;; and a list is a collection of sets, for example &lt;composite element list&gt;. Unless specified otherwise, all Transact-SQL references to the name of a database object can be a four-part name in the following form: server_name.[database_name].[schema_name].object_name | database_name.[schema_name].object_name | schema_name.object_name | object_name server_name Specifies a linked server name or remote server name. database_name Specifies the name of a SQL Server database when the object resides in a local instance of SQL Server. When the object is in a linked server, database_name specifies an OLE DB catalog. schema_name Specifies the name of the schema that contains the object if the object is in a SQL Server database. When the object is in a linked server, schema_name specifies an OLE DB schema name. object_name Refers to the name of the object. When referencing a specific object, you don&#8217;t always have to specify the server, database, and schema for the SQL Server Database Engine to identify the object. However, if the object can&#8217;t be found, an error is returned. To avoid name resolution errors, we recommend specifying the schema name whenever you specify a schema-scoped object. To omit intermediate nodes, use periods to indicate these positions. The following table shows the valid formats of object names. Object reference format Description server_name.database_name.schema_name.object_name Four-part name. server_name.database_name..object_name Schema name is omitted. server_name..schema_name.object_name Database name is omitted. server_name&#8230;&#8203;object_name Database and schema name are omitted. database_name.schema_name.object_name Server name is omitted. database_name..object_name Server and schema name are omitted. schema_name.object_name Server and database name are omitted. object_name Server, database, and schema name are omitted. SELECT @@SERVERNAME; -- 8a90e1fbcc1b SELECT name FROM [8a90e1fbcc1b].[master].[sys].[servers]; 9. Tutorial: Write Transact-SQL statements This tutorial is intended as a brief introduction to the Transact-SQL language and not as a replacement for a Transact-SQL class. The statements in this tutorial are intentionally simple, and aren&#8217;t meant to represent the complexity found in a typical production database. 9.1. Lesson 1: Create and query database objects Transact-SQL statements can be written and submitted to the Database Engine in the following ways: By using SQL Server Management Studio. By using the sqlcmd utility. By connecting from an application that you create. 9.1.1. Create a database Like many Transact-SQL statements, the CREATE DATABASE statement has a required parameter: the name of the database. CREATE DATABASE also has many optional parameters, such as the disk location where you want to put the database files. When you execute CREATE DATABASE without the optional parameters, SQL Server uses default values for many of these parameters. In a Query Editor window, type but don&#8217;t execute the following code: CREATE DATABASE TestData; GO Use the pointer to select the words CREATE DATABASE, and then press F1. In Query Editor, press F5 to execute the statement and create a database named TestData. When you create a database, SQL Server makes a copy of the model database, and renames the copy to the database name. This operation should only take several seconds, unless you specify a large initial size of the database as an optional parameter. The keyword GO separates statements when more than one statement is submitted in a single batch. GO is optional when the batch contains only one statement. 9.1.2. Create a Table To create a table, you must provide a name for the table, and the names and data types of each column in the table. It is also a good practice to indicate whether null values are allowed in each column. To create a table, you must have the CREATE TABLE permission, and the ALTER SCHEMA permission on the schema that will contain the table. The db_ddladmin fixed database role has these permissions. Most tables have a primary key, made up of one or more columns of the table. A primary key is always unique. The Database Engine will enforce the restriction that any primary key value can&#8217;t be repeated in the table. For a list of data types and links for a description of each, see Data Types (Transact-SQL). The Database Engine can be installed as case sensitive or non-case sensitive. If the Database Engine is installed as case sensitive, object names must always have the same case. For example, a table named OrderData is a different table from a table named ORDERDATA. If the Database Engine is installed as non-case sensitive, those two table names are considered to be the same table, and that name can only be used one time. 9.1.2.1. Switch the Query Editor connection to the TestData database In a Query Editor window, type and execute the following code to change your connection to the TestData database. USE TestData; GO 9.1.2.2. Create the table In a Query Editor window, type and execute the following code to create a table named Products. The columns in the table are named ProductID, ProductName, Price, and ProductDescription. The ProductID column is the primary key of the table. int, varchar(25), money, and varchar(max) are all data types. Only the Price and ProductionDescription columns can have no data when a row is inserted or changed. This statement contains an optional element (dbo.) called a schema. The schema is the database object that owns the table. If you are an administrator, dbo is the default schema. dbo stands for database owner. CREATE TABLE dbo.Products (ProductID int PRIMARY KEY NOT NULL, ProductName varchar(25) NOT NULL, Price money NULL, ProductDescription varchar(max) NULL); GO 9.1.3. Insert and update data in a table Now that you have created the Products table, you are ready to insert data into the table by using the INSERT statement. After the data is inserted, you will change the content of a row by using an UPDATE statement. You will use the WHERE clause of the UPDATE statement to restrict the update to a single row. The four statements will enter the following data. ProductID ProductName Price ProductDescription 1 Clamp 12.48 Workbench clamp 50 Screwdriver 3.17 Flat head 75 Tire Bar 30.00 Tool for changing tires. 3 mm Bracket 0.52 The basic syntax is: INSERT, table name, column list, VALUES, and then a list of the values to be inserted. The two hyphens in front of a line indicate that the line is a comment and the text will be ignored by the compiler. In this case, the comment describes a permissible variation of the syntax. 9.1.3.1. Insert data into a table Execute the following statement to insert a row into the Products table that was created in the previous task. -- Standard syntax INSERT dbo.Products (ProductID, ProductName, Price, ProductDescription) VALUES (1, &#39;Clamp&#39;, 12.48, &#39;Workbench clamp&#39;) GO If the insert succeeds, proceed to the next step. If the insert fails, it may be because the Product table already has a row with that product ID in it. To proceed, delete all the rows in the table and repeat the preceding step. TRUNCATE TABLE deletes all the rows in the table. Run the following command to delete all the rows in the table: TRUNCATE TABLE TestData.dbo.Products; GO After you truncate the table, repeat the INSERT command in this step. The following statement shows how you can change the order in which the parameters are provided by switching the placement of the ProductID and ProductName in both the field list (in parentheses) and in the values list. -- Changing the order of the columns INSERT dbo.Products (ProductName, ProductID, Price, ProductDescription) VALUES (&#39;Screwdriver&#39;, 50, 3.17, &#39;Flat head&#39;) GO The following statement demonstrates that the names of the columns are optional, as long as the values are listed in the correct order. This syntax is common but isn&#8217;t recommended because it might be harder for others to understand your code. NULL is specified for the Price column because the price for this product isn&#8217;t yet known. -- Skipping the column list, but keeping the values in order INSERT dbo.Products VALUES (75, &#39;Tire Bar&#39;, NULL, &#39;Tool for changing tires.&#39;) GO The schema name is optional as long as you are accessing and changing a table in your default schema. Because the ProductDescription column allows null values and no value is being provided, the ProductDescription column name and value can be dropped from the statement completely. SQL -- Dropping the optional dbo and dropping the ProductDescription column INSERT Products (ProductID, ProductName, Price) VALUES (3000, &#39;3 mm Bracket&#39;, 0.52) GO 9.1.3.2. Update the products table Type and execute the following UPDATE statement to change the ProductName of the second product from Screwdriver, to Flat Head Screwdriver. UPDATE dbo.Products SET ProductName = &#39;Flat Head Screwdriver&#39; WHERE ProductID = 50 GO 9.1.4. Read data from a table Use the SELECT statement to read the data in a table. The SELECT statement is one of the most important Transact-SQL statements, and there are many variations in the syntax. For this tutorial, you will work with five simple versions. 9.1.4.1. Read the data in a table Type and execute the following statements to read the data in the Products table. -- The basic syntax for reading data from a single table SELECT ProductID, ProductName, Price, ProductDescription FROM dbo.Products GO You can use an asterisk (*) to select all the columns in the table. The asterisk is for ad hoc queries. In permanent code, provide the column list so that the statement returns the predicted columns, even if a new column is added to the table later. -- Returns all columns in the table -- Does not use the optional schema, dbo SELECT * FROM Products GO You can omit columns that you don&#8217;t want to return. The columns will be returned in the order that they are listed. -- Returns only two of the columns from the table SELECT ProductName, Price FROM dbo.Products GO Use a WHERE clause to limit the rows that are returned to the user. -- Returns only two of the records in the table SELECT ProductID, ProductName, Price, ProductDescription FROM dbo.Products WHERE ProductID &lt; 60 GO You can work with the values in the columns as they are returned. The following example performs a mathematical operation on the Price column. Columns that have been changed in this way won&#8217;t have a name unless you provide one by using the AS keyword. -- Returns ProductName and the Price including a 7% tax -- Provides the name CustomerPays for the calculated column SELECT ProductName, Price * 1.07 AS CustomerPays FROM dbo.Products GO 9.1.4.2. Useful functions in a SELECT statement For information about some functions that you can use to work with data in SELECT statements, see the following articles: String Functions (Transact-SQL) Date and Time Data Types and Functions (Transact-SQL) Mathematical Functions (Transact-SQL) Text and Image Functions (Transact-SQL) 9.1.5. Create views and stored procedures A view is a stored SELECT statement, and a stored procedure is one or more Transact-SQL statements that execute as a batch. Views are queried like tables and don&#8217;t accept parameters. Stored procedures are more complex than views. Stored procedures can have both input and output parameters and can contain statements to control the flow of the code, such as IF and WHILE statements. It is good programming practice to use stored procedures for all repetitive actions in the database. For this example, you will use CREATE VIEW to create a view that selects only two of the columns in the Products table. Then, you will use CREATE PROCEDURE to create a stored procedure that accepts a price parameter and returns only those products that cost less than the specified parameter value. 9.1.5.1. Create a view Execute the following statement to create a view that executes a select statement, and returns the names and prices of our products to the user. CREATE VIEW vw_Names AS SELECT ProductName, Price FROM Products; GO 9.1.5.2. Test the view Views are treated just like tables. Use a SELECT statement to access a view. SELECT * FROM vw_Names; GO 9.1.5.3. Create a stored procedure The following statement creates a stored procedure name pr_Names, accepts an input parameter named @VarPrice of data type money. The stored procedure prints the statement Products less than concatenated with the input parameter that is changed from the money data type into a varchar(10) character data type. Then, the procedure executes a SELECT statement on the view, passing the input parameter as part of the WHERE clause. This returns all products that cost less than the input parameter value. CREATE PROCEDURE pr_Names @VarPrice money AS BEGIN -- The print statement returns text to the user PRINT &#39;Products less than &#39; + CAST(@VarPrice AS varchar(10)); -- A second statement starts here SELECT ProductName, Price FROM vw_Names WHERE Price &lt; @VarPrice; END GO 9.1.5.4. Test the stored procedure To test the stored procedure, type and execute the following statement. The procedure should return the names of the two products entered into the Products table in Lesson 1 with a price that is less than 10.00. EXECUTE pr_Names 10.00; GO 9.2. Lesson 2: Configure permissions on database objects Granting a user access to a database involves three steps. First, you create a login. The login lets the user connect to the SQL Server Database Engine. Then you configure the login as a user in the specified database. And finally, you grant that user permission to database objects. This lesson shows you these three steps, and shows you how to create a view and a stored procedure as the object. 9.2.1. Create a login To access the Database Engine, users require a login. The login can represent the user&#8217;s identity as a Windows account or as a member of a Windows group, or the login can be a SQL Server login that exists only in SQL Server. Whenever possible you should use Windows Authentication. 9.2.1.1. Create a new Windows account By default, administrators on your computer have full access to SQL Server. For this lesson, we want to have a less privileged user; therefore, you will create a new local Windows Authentication account on your computer. To do this, you must be an administrator on your computer. Then you will grant that new user access to SQL Server. Select Start, select Run, in the Open box, type %SystemRoot%\\system32\\compmgmt.msc /s and then select OK to open the Computer Management program. Under System Tools, expand Local Users and Groups, right-click Users, and then select New User. In the User name box type Mary. In the Password and Confirm password box, type a strong password, and then select Create to create a new local Windows user. 9.2.1.2. Create a SQL login using Windows Authentication with T-SQL In a Query Editor window of SQL Server Management Studio, type and execute the following code replacing computer_name with the name of your computer. FROM WINDOWS indicates that Windows will authenticate the user. The optional DEFAULT_DATABASE argument connects Mary to the TestData database, unless her connection string indicates another database. This statement introduces the semicolon as an optional termination for a Transact-SQL statement. CREATE LOGIN [computer_name\\Mary] FROM WINDOWS WITH DEFAULT_DATABASE = [TestData]; GO This authorizes a user name Mary, authenticated by your computer, to access this instance of SQL Server. If there is more than one instance of SQL Server on the computer, you must create the login on each instance that Mary must access. Because Mary is not a domain account, this user name can only be authenticated on this computer. 9.2.1.3. Create a login using SQL Server Authentication with T-SQL -- Creates the user &quot;shcooper&quot; for SQL Server using the security credential &quot;RestrictedFaculty&quot; -- The user login starts with the password &quot;Baz1nga,&quot; but that password must be changed after the first login. CREATE LOGIN shcooper WITH PASSWORD = &#39;Baz1nga&#39; MUST_CHANGE, CREDENTIAL = RestrictedFaculty; GO 9.2.2. Grant access to a database Mary now has access to this instance of SQL Server, but doesn&#8217;t have permission to access the databases. She doesn&#8217;t even have access to her default database TestData until you authorize her as a database user. To grant Mary access, switch to the TestData database, and then use the CREATE USER statement to map her login to a user named Mary. 9.2.2.1. Create a user in a database Type and execute the following statements (replacing computer_name with the name of your computer) to grant Mary access to the TestData database. USE [TestData]; GO CREATE USER [Mary] FOR LOGIN [computer_name\\Mary]; GO Now, Mary has access to both SQL Server and the TestData database. 9.2.2.2. Create views and stored procedures As an administrator, you can execute the SELECT from the Products table and the vw_Names view, and execute the pr_Names procedure; however, Mary can&#8217;t. To grant Mary the necessary permissions, use the GRANT statement. Grant permission to stored procedure Execute the following statement to give Mary the EXECUTE permission for the pr_Names stored procedure. GRANT EXECUTE ON pr_Names TO Mary; GO In this scenario, Mary can only access the Products table by using the stored procedure. If you want Mary to be able to execute a SELECT statement against the view, then you must also execute GRANT SELECT ON vw_Names TO Mary. To remove access to database objects, use the REVOKE statement. If the table, the view, and the stored procedure are not owned by the same schema, granting permissions becomes more complex. 9.2.2.3. About GRANT You must have EXECUTE permission to execute a stored procedure. You must have SELECT, INSERT, UPDATE, and DELETE permissions to access and change data. The GRANT statement is also used for other permissions, such as permission to create tables. 9.3. Lesson 3: Delete database objects This short lesson removes the objects that you created in Lesson 1 and Lesson 2, and then drops the database. Before you delete objects, make sure you are in the correct database: USE TestData; GO 9.3.1. Revoke stored procedure permissions Use the REVOKE statement to remove execute permission for Mary on the stored procedure: REVOKE EXECUTE ON pr_Names FROM Mary; GO 9.3.2. Drop permissions Use the DROP statement to remove permission for Mary to access the TestData database: DROP USER Mary; GO Use the DROP statement to remove permission for Mary to access this instance of SQL Server 2005 (9.x): DROP LOGIN [&lt;computer_name&gt;\\Mary]; GO Use the DROP statement to remove the store procedure pr_Names: DROP PROC pr_Names; GO Use the DROP statement to remove the view vw_Names: DROP VIEW vw_Names; GO 9.3.3. Delete table Use the DELETE statement to remove all rows from the Products table: DELETE FROM Products; GO Use the DROP statement to remove the Products table: DROP TABLE Products; GO 9.3.4. Remove database You can&#8217;t remove the TestData database while you are in the database; therefore, first switch context to another database, and then use the DROP statement to remove the TestData database: USE MASTER; GO DROP DATABASE TestData; GO 10. References https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-deployment?view=sql-server-ver16&amp;pivots=cs1-bash https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver16&amp;preserve-view=true&amp;pivots=cs1-bash https://learn.microsoft.com/en-us/sql/relational-databases/databases/databases?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/databases/contained-databases?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/sql-server/install/file-locations-for-default-and-named-instances-of-sql-server?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/getting-started-with-database-engine-permissions?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/language-elements/sql-server-utilities-statements-go?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/language-elements/transact-sql-syntax-conventions-transact-sql?view=sql-server-ver16 https://learn.microsoft.com/en-us/sql/t-sql/tutorial-writing-transact-sql-statements?view=sql-server-ver16 https://en.wikipedia.org/wiki/SQL","headline":"Intro to SQL Server Database","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.codefarm.me/2023/04/06/sql-server-database/"},"url":"https://blog.codefarm.me/2023/04/06/sql-server-database/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/style.css"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-SN88FJ18E5');
    </script></head>
  <body>
    <header class="c-header">
  <div class="o-container">
    <a class="c-header-title" href="/">CODE FARM</a>
    <button class="c-header-nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
      <span class="c-header-nav-toggle-icon"></span>
    </button>
    <div class="c-header-nav-wrapper" id="nav-wrapper">
      <nav class="c-header-nav">
        <a href="/">Home</a>
        <a href="/categories/">Category</a>
        <a href="/tags/">Tag</a>
        <a href="/archives/">Archive</a>
        <a href="/about/">About</a>
        <a href="https://resume.github.io/?looogos" target="_blank">R&eacute;sum&eacute;</a>
      </nav>
    </div>
  </div>
  



<div class="o-container">
  <div class="c-banner">
    <img src="/assets/images/galaxy.svg" alt="Galaxy background" class="c-banner-bg">
    <div class="c-banner-quote">
      <p>"The Renaissance was a time when art, science, and philosophy flourished."</p>
      <cite>- Michelangelo</cite>
    </div>
  </div>
</div>
</header>

    <main class="o-container">
      <article class="c-post">
  <header class="c-post-header">
    <h1 class="c-post-title">Intro to SQL Server Database</h1><p class="c-post-meta">29 Nov 2024</p>
  </header>

  <div class="c-post-content">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#deploy-and-connect-to-sql-server-linux-containers">1. Deploy and connect to SQL Server Linux containers</a>
<ul class="sectlevel2">
<li><a href="#pull-and-run-the-sql-server-linux-container-image">1.1. Pull and run the SQL Server Linux container image</a></li>
<li><a href="#connect-to-sql-server">1.2. Connect to SQL Server</a></li>
<li><a href="#create-and-query-data">1.3. Create and query data</a>
<ul class="sectlevel3">
<li><a href="#create-a-new-database">1.3.1. Create a new database</a></li>
<li><a href="#insert-data">1.3.2. Insert data</a></li>
<li><a href="#select-data">1.3.3. Select data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#databases">2. Databases</a>
<ul class="sectlevel2">
<li><a href="#basic-information-about-databases">2.1. Basic Information about Databases</a>
<ul class="sectlevel3">
<li><a href="#servers-databases-schemas-and-tables">2.1.1. Servers, Databases, Schemas and Tables</a></li>
<li><a href="#files-and-filegroups">2.1.2. Files and FileGroups</a></li>
<li><a href="#logins-and-database-users">2.1.3. Logins and Database Users</a></li>
<li><a href="#roles-and-permissions">2.1.4. Roles and Permissions</a></li>
</ul>
</li>
<li><a href="#working-with-databases">2.2. Working with Databases</a></li>
<li><a href="#system-databases">2.3. System Databases</a>
<ul class="sectlevel3">
<li><a href="#master-database">2.3.1. master Database</a></li>
</ul>
</li>
<li><a href="#contained-databases">2.4. Contained Databases</a></li>
<li><a href="#database-files-and-filegroups">2.5. Database Files and Filegroups</a>
<ul class="sectlevel3">
<li><a href="#database-files">2.5.1. Database Files</a></li>
<li><a href="#logical-and-physical-file-names">2.5.2. Logical and Physical File Names</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#database-engine-permissions-and-principals">3. Database Engine Permissions and Principals</a>
<ul class="sectlevel2">
<li><a href="#server-level-roles">3.1. Server-level roles</a></li>
<li><a href="#database-level-roles">3.2. Database-level roles</a></li>
<li><a href="#contained-database-users-make-your-database-portable-by-using-contained-databases">3.3. Contained database users: Make your database portable by using contained databases</a>
<ul class="sectlevel3">
<li><a href="#traditional-login-and-user-model">3.3.1. Traditional login and user model</a></li>
<li><a href="#contained-database-user-model">3.3.2. Contained database user model</a></li>
</ul>
</li>
<li><a href="#security-principals">3.4. Security principals</a>
<ul class="sectlevel3">
<li><a href="#logins">3.4.1. Logins</a></li>
<li><a href="#fixed-server-roles">3.4.2. Fixed server roles</a></li>
<li><a href="#user-defined-server-roles">3.4.3. User-defined server roles</a></li>
<li><a href="#database-users">3.4.4. Database users</a></li>
<li><a href="#fixed-database-roles">3.4.5. Fixed database roles</a></li>
<li><a href="#user-defined-database-roles">3.4.6. User-defined database roles</a></li>
<li><a href="#other-principals">3.4.7. Other principals</a></li>
</ul>
</li>
<li><a href="#assign-permissions">3.5. Assign permissions</a></li>
<li><a href="#permission-hierarchy">3.6. Permission hierarchy</a></li>
<li><a href="#monitor-permissions">3.7. Monitor permissions</a></li>
<li><a href="#principals-database-engine">3.8. Principals (Database Engine)</a>
<ul class="sectlevel3">
<li><a href="#sql-server-level-principals">3.8.1. SQL Server-level principals</a></li>
<li><a href="#database-level-principals">3.8.2. Database-level principals</a></li>
<li><a href="#sa-login">3.8.3. sa Login</a></li>
<li><a href="#dbo-user-and-dbo-schema">3.8.4. dbo User and dbo Schema</a></li>
<li><a href="#public-server-role-and-database-role">3.8.5. public Server Role and Database Role</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sql-and-t-sql">4. SQL and T-SQL</a></li>
<li><a href="#sql-server-utilities-statements-go">5. SQL Server Utilities Statements - GO</a></li>
<li><a href="#collation-and-unicode-support">6. Collation and Unicode support</a></li>
<li><a href="#database-identifiers">7. Database identifiers</a></li>
<li><a href="#transact-sql-syntax-conventions-transact-sql">8. Transact-SQL syntax conventions (Transact-SQL)</a></li>
<li><a href="#tutorial-write-transact-sql-statements">9. Tutorial: Write Transact-SQL statements</a>
<ul class="sectlevel2">
<li><a href="#lesson-1-create-and-query-database-objects">9.1. Lesson 1: Create and query database objects</a>
<ul class="sectlevel3">
<li><a href="#create-a-database">9.1.1. Create a database</a></li>
<li><a href="#create-a-table">9.1.2. Create a Table</a>
<ul class="sectlevel4">
<li><a href="#switch-the-query-editor-connection-to-the-testdata-database">9.1.2.1. Switch the Query Editor connection to the TestData database</a></li>
<li><a href="#create-the-table">9.1.2.2. Create the table</a></li>
</ul>
</li>
<li><a href="#insert-and-update-data-in-a-table">9.1.3. Insert and update data in a table</a>
<ul class="sectlevel4">
<li><a href="#insert-data-into-a-table">9.1.3.1. Insert data into a table</a></li>
<li><a href="#update-the-products-table">9.1.3.2. Update the products table</a></li>
</ul>
</li>
<li><a href="#read-data-from-a-table">9.1.4. Read data from a table</a>
<ul class="sectlevel4">
<li><a href="#read-the-data-in-a-table">9.1.4.1. Read the data in a table</a></li>
<li><a href="#useful-functions-in-a-select-statement">9.1.4.2. Useful functions in a SELECT statement</a></li>
</ul>
</li>
<li><a href="#create-views-and-stored-procedures">9.1.5. Create views and stored procedures</a>
<ul class="sectlevel4">
<li><a href="#create-a-view">9.1.5.1. Create a view</a></li>
<li><a href="#test-the-view">9.1.5.2. Test the view</a></li>
<li><a href="#create-a-stored-procedure">9.1.5.3. Create a stored procedure</a></li>
<li><a href="#test-the-stored-procedure">9.1.5.4. Test the stored procedure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lesson-2-configure-permissions-on-database-objects">9.2. Lesson 2: Configure permissions on database objects</a>
<ul class="sectlevel3">
<li><a href="#create-a-login">9.2.1. Create a login</a>
<ul class="sectlevel4">
<li><a href="#create-a-new-windows-account">9.2.1.1. Create a new Windows account</a></li>
<li><a href="#create-a-sql-login-using-windows-authentication-with-t-sql">9.2.1.2. Create a SQL login  using Windows Authentication with T-SQL</a></li>
<li><a href="#create-a-login-using-sql-server-authentication-with-t-sql">9.2.1.3. Create a login using SQL Server Authentication with T-SQL</a></li>
</ul>
</li>
<li><a href="#grant-access-to-a-database">9.2.2. Grant access to a database</a>
<ul class="sectlevel4">
<li><a href="#create-a-user-in-a-database">9.2.2.1. Create a user in a database</a></li>
<li><a href="#create-views-and-stored-procedures-2">9.2.2.2. Create views and stored procedures</a></li>
<li><a href="#about-grant">9.2.2.3. About GRANT</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lesson-3-delete-database-objects">9.3. Lesson 3: Delete database objects</a>
<ul class="sectlevel3">
<li><a href="#revoke-stored-procedure-permissions">9.3.1. Revoke stored procedure permissions</a></li>
<li><a href="#drop-permissions">9.3.2. Drop permissions</a></li>
<li><a href="#delete-table">9.3.3. Delete table</a></li>
<li><a href="#remove-database">9.3.4. Remove database</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#references">10. References</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="deploy-and-connect-to-sql-server-linux-containers">1. Deploy and connect to SQL Server Linux containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this quickstart, you&#8217;ll use Docker to pull and run the SQL Server 2022 (16.x) Linux container image, <a href="https://hub.docker.com/_/microsoft-mssql-server">mssql-server-linux</a>. Then you can connect with <a href="https://learn.microsoft.com/en-us/sql/tools/sqlcmd/sqlcmd-utility"><strong>sqlcmd</strong></a> to create your first database and run queries.</p>
</div>
<div class="sect2">
<h3 id="pull-and-run-the-sql-server-linux-container-image">1.1. Pull and run the SQL Server Linux container image</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Pull the SQL Server 2022 (16.x) Linux container image from the Microsoft Container Registry.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="nb">sudo </span>docker pull mcr.microsoft.com/mssql/server:2022-latest</code></pre>
</div>
</div>
</li>
<li>
<p>To run the Linux container image with Docker, you can use the following command from a bash shell or elevated PowerShell command prompt.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>SA_PASSWORD</code> environment variable is deprecated. Please use <code>MSSQL_SA_PASSWORD</code> instead.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="nb">sudo </span>docker run <span class="nt">-e</span> <span class="s2">"ACCEPT_EULA=Y"</span> <span class="nt">-e</span> <span class="s2">"MSSQL_SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;"</span> <span class="se">\</span>
   <span class="nt">-p</span> 1433:1433 <span class="nt">--name</span> sql1 <span class="nt">--hostname</span> sql1 <span class="se">\</span>
   <span class="nt">-d</span> <span class="se">\</span>
   mcr.microsoft.com/mssql/server:2022-latest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your password should follow the SQL Server default password policy, otherwise the container can&#8217;t set up SQL Server and will stop working. By default, the password must be at least eight characters long and contain characters from three of the following four sets: uppercase letters, lowercase letters, base-10 digits, and symbols.</p>
</div>
<div class="paragraph">
<p>By default, this quickstart creates a container with the Developer edition of SQL Server. The process for running production editions in containers is slightly different.</p>
</div>
</li>
<li>
<p>To view your Docker containers, use the <code>docker ps</code> command.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">docker ps</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see output similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">CONTAINER ID   IMAGE                                        COMMAND                  CREATED          STATUS        PORTS                                       NAMES
</span><span class="gp">274554ac9f0d   mcr.microsoft.com/mssql/server:2022-latest   "/opt/mssql/bin/perm…"   42 seconds ago   Up 1 second   0.0.0.0:1433-&gt;</span>1433/tcp, :::1433-&gt;1433/tcp   sql1</code></pre>
</div>
</div>
</li>
<li>
<p>If the <code>STATUS</code> column shows a status of <code>Up</code>, then SQL Server is running in the container and listening on the port specified in the <code>PORTS</code> column. If the <code>STATUS</code> column for your SQL Server container shows <code>Exited</code>, see the <a href="https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-troubleshooting?view=sql-server-ver16">Troubleshooting section of the configuration guide</a>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="connect-to-sql-server">1.2. Connect to SQL Server</h3>
<div class="paragraph">
<p>The following steps use the SQL Server command-line tool, sqlcmd, inside the container to connect to SQL Server.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the <code>docker exec -it</code> command to start an interactive bash shell inside your running container. In the following example <code>sql1</code> is name specified by the <code>--name</code> parameter when you created the container.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="nb">sudo </span>docker <span class="nb">exec</span> <span class="nt">-it</span> sql1 <span class="s2">"bash"</span></code></pre>
</div>
</div>
</li>
<li>
<p>Once inside the container, connect locally with <strong>sqlcmd</strong>, using its full path.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">/opt/mssql-tools18/bin/sqlcmd <span class="nt">-S</span> localhost <span class="nt">-U</span> SA <span class="nt">-P</span> <span class="s2">"&lt;YourStrong@Passw0rd&gt;"</span> <span class="nt">-No</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can omit the password on the command-line to be prompted to enter it. Here&#8217;s an example:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">/opt/mssql-tools18/bin/sqlcmd <span class="nt">-S</span> localhost <span class="nt">-U</span> SA <span class="nt">-No</span></code></pre>
</div>
</div>
</li>
<li>
<p>If successful, you should get to a <strong>sqlcmd</strong> command prompt: <code>1&gt;</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">1&gt; :help
:!! [&lt;command&gt;]
  - Executes a command in the command shell.
:connect server[\instance] [-l timeout] [-U user [-P password]]
  - Connects to a SQL Server instance.
:error &lt;dest&gt;
  - Redirects error output to a file, stderr, or stdout.
:exit
  - Quits sqlcmd immediately.
:exit()
  - Execute statement cache; quit with no return value.
:exit(&lt;query&gt;)
  - Execute the specified query; returns numeric result.
go [&lt;n&gt;]
  - Executes the statement cache (n times).
:help
  - Shows this list of commands.
:list
  - Prints the content of the statement cache.
:listvar
  - Lists the set sqlcmd scripting variables.
:on error [exit|ignore]
  - Action for batch or sqlcmd command errors.
:out &lt;filename&gt;|stderr|stdout
  - Redirects query output to a file, stderr, or stdout.
:perftrace &lt;filename&gt;|stderr|stdout
  - Redirects timing output to a file, stderr, or stdout.
:quit
  - Quits sqlcmd immediately.
:r &lt;filename&gt;
  - Append file contents to the statement cache.
:reset
  - Discards the statement cache.
:serverlist
  - Lists local and SQL Servers on the network.
:setvar {variable}
  - Removes a sqlcmd scripting variable.
:setvar &lt;variable&gt; &lt;value&gt;
  - Sets a sqlcmd scripting variable.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>/opt/mssql-tools18/bin/sqlcmd <span class="nt">-S</span> localhost <span class="nt">-U</span> SA <span class="nt">-P</span> <span class="s2">"&lt;YourStrong@Passw0rd&gt;"</span> <span class="nt">-No</span> <span class="nt">-Q</span> <span class="s2">"SELECT @@version"</span>
<span class="go">
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Microsoft SQL Server 2022 (RTM-CU16) (KB5048033) - 16.0.4165.4 (X64)
	Nov  6 2024 19:24:49
	Copyright (C) 2022 Microsoft Corporation
</span><span class="gp">	Developer Edition (64-bit) on Linux (Ubuntu 22.04.5 LTS) &lt;X64&gt;</span><span class="w">
</span><span class="go">
(1 rows affected)</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="create-and-query-data">1.3. Create and query data</h3>
<div class="paragraph">
<p>The following sections walk you through using <strong>sqlcmd</strong> and Transact-SQL to create a new database, add data, and run a query.</p>
</div>
<div class="sect3">
<h4 id="create-a-new-database">1.3.1. Create a new database</h4>
<div class="paragraph">
<p>The following steps create a new database named <code>TestDB</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From the sqlcmd command prompt, paste the following Transact-SQL command to create a test database:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">TestDB</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>On the next line, write a query to return the name of all of the databases on your server:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">Name</span> <span class="k">from</span> <span class="n">sys</span><span class="p">.</span><span class="n">databases</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>The previous two commands weren&#8217;t run immediately. Type <code>GO</code> on a new line to run the previous commands:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GO</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="insert-data">1.3.2. Insert data</h4>
<div class="paragraph">
<p>Next create a new table, Inventory, and insert two new rows.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From the <em>sqlcmd</em> command prompt, switch context to the new <em>TestDB</em> database:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">TestDB</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Create new table named <code>Inventory</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Inventory</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">name</span> <span class="n">NVARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">quantity</span> <span class="nb">INT</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Insert data into the new table:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Inventory</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'banana'</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Inventory</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'orange'</span><span class="p">,</span> <span class="mi">154</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Type <code>GO</code> to run the previous commands:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GO</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="select-data">1.3.3. Select data</h4>
<div class="paragraph">
<p>Now, run a query to return data from the <code>Inventory</code> table.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From the <em>sqlcmd</em> command prompt, enter a query that returns rows from the <code>Inventory</code> table where the quantity is greater than 152:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Inventory</span> <span class="k">WHERE</span> <span class="n">quantity</span> <span class="o">&gt;</span> <span class="mi">152</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Run the command:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>Exit the sqlcmd command prompt</p>
<div class="paragraph">
<p>To end your sqlcmd session, type <code>QUIT</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">QUIT</span></code></pre>
</div>
</div>
</li>
<li>
<p>To exit the interactive command-prompt in your container, type <code>exit</code>. Your container continues to run after you exit the interactive bash shell.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="databases">2. Databases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>database</em> in <em>SQL Server</em> is made up of a collection of <em>tables</em> that stores a specific set of structured data. A table contains a collection of <em>rows</em>, also referred to as <em>records</em> or <em>tuples</em>, and <em>columns</em>, also referred to as <em>attributes</em>. Each column in the table is designed to store a certain type of information, for example, dates, names, dollar amounts, and numbers.</p>
</div>
<div class="sect2">
<h3 id="basic-information-about-databases">2.1. Basic Information about Databases</h3>
<div class="sect3">
<h4 id="servers-databases-schemas-and-tables">2.1.1. Servers, Databases, Schemas and Tables</h4>
<div class="paragraph">
<p>A computer can have one or more than one instance of <em>SQL Server</em> installed. Each instance of SQL Server can contain one or many <em>databases</em>. Within a database, there are one or many object ownership groups called <em>schemas</em>. Within each schema there are database objects such as <em>tables</em>, <em>views</em>, and <em>stored procedures</em>. Some objects such as certificates and asymmetric keys are contained within the database, but are not contained within a schema. For more information about creating tables, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/tables/tables?view=sql-server-ver16">Tables</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Machine -&gt; * Servers (instances) -&gt; * Databases -&gt; * Schemas -&gt; * Tables, * Views</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="files-and-filegroups">2.1.2. Files and FileGroups</h4>
<div class="paragraph">
<p>SQL Server databases are stored in the file system in <em>files</em>. Files can be grouped into <em>filegroups</em>. For more information about files and filegroups, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-files-and-filegroups?view=sql-server-ver16">Database Files and Filegroups</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="logins-and-database-users">2.1.3. Logins and Database Users</h4>
<div class="paragraph">
<p>When people gain access to an instance of SQL Server they are identified as a <em>login</em>. When people gain access to a database they are identified as a <em>database user</em>. A database user can be based on a login. If <em>contained databases</em> are enabled, a database user can be created that is not based on a login. For more information about users, see <code>CREATE USER</code> (<a href="https://learn.microsoft.com/en-us/sql/t-sql/language-reference?view=sql-server-ver16">Transact-SQL</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Logins &lt;-&gt; Servers (instances)
Database Users &lt;-&gt; Databases</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="roles-and-permissions">2.1.4. Roles and Permissions</h4>
<div class="paragraph">
<p>A user that has access to a database can be given <em>permission</em> to access the objects in the database. Though permissions can be granted to <em>individual users</em>, we recommend creating <em>database roles</em>, adding the database users to the roles, and then grant access permission to the roles. Granting permissions to roles instead of users makes it easier to keep permissions consistent and understandable as the number of users grow and continually change. For more information about roles permissions, see <code>CREATE ROLE</code> (<a href="https://learn.microsoft.com/en-us/sql/t-sql/language-reference?view=sql-server-ver16">Transact-SQL</a>) and <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine?view=sql-server-ver16">Principals (Database Engine)</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="working-with-databases">2.2. Working with Databases</h3>
<div class="paragraph">
<p>Most people who work with databases use the <em>SQL Server Management Studio</em> tool. The Management Studio tool has a graphical user interface for creating databases and the objects in the databases. Management Studio also has a query editor for interacting with databases by writing Transact-SQL statements. Management Studio can be installed from the SQL Server installation disk, or downloaded from MSDN. For more information about SQL Server Management Studio tool, see <a href="https://learn.microsoft.com/en-us/sql/ssms/sql-server-management-studio-ssms?view=sql-server-ver16">SQL Server Management Studio (SSMS)</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="system-databases">2.3. System Databases</h3>
<div class="paragraph">
<p>SQL Server includes the following system databases.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">System database</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/master-database?view=sql-server-ver16">master Database</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Records all the system-level information for an instance of SQL Server.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/msdb-database?view=sql-server-ver16">msdb Database</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is used by SQL Server Agent for scheduling alerts and jobs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/model-database?view=sql-server-ver16">model Database</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is used as the template for all databases created on the instance of SQL Server. Modifications made to the model database, such as database size, collation, recovery model, and other database options, are applied to any databases created afterward.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/resource-database?view=sql-server-ver16">Resource Database</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is a read-only database that contains system objects that are included with SQL Server. System objects are physically persisted in the Resource database, but they logically appear in the sys schema of every database.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/tempdb-database?view=sql-server-ver16">tempdb Database</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is a workspace for holding temporary objects or intermediate result sets.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For Azure SQL Database single databases and elastic pools, only <em>master</em> Database and <em>tempdb</em> Database apply.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="master-database">2.3.1. master Database</h4>
<div class="paragraph">
<p>The <em>master database</em> records all the system-level information for a SQL Server system. This includes instance-wide metadata such as logon accounts, endpoints, linked servers, and system configuration settings.</p>
</div>
<div class="paragraph">
<p>In SQL Server, system objects are no longer stored in the <em>master</em> database; instead, they are stored in the <em>Resource database</em>.</p>
</div>
<div class="paragraph">
<p>Also, <em>master</em> is the database that records the existence of all other databases and the location of those database files and records the initialization information for SQL Server. Therefore, SQL Server cannot start if the master database is unavailable.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contained-databases">2.4. Contained Databases</h3>
<div class="paragraph">
<p>A <em>contained database</em> is a database that is isolated from other databases and from the instance of SQL Server that hosts the database. SQL Server helps user to isolate their database from the instance in 4 ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Much of the metadata that describes a database is maintained in the database. (In addition to, or instead of, maintaining metadata in the master database.)</p>
</li>
<li>
<p>All metadata are defined using the same collation.</p>
</li>
<li>
<p>User authentication can be performed by the database, reducing the databases dependency on the logins of the instance of SQL Server.</p>
</li>
<li>
<p>The SQL Server environment (DMV&#8217;s, XEvents, etc.) reports and can act upon containment information.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="database-files-and-filegroups">2.5. Database Files and Filegroups</h3>
<div class="paragraph">
<p>At a minimum, every SQL Server database has two operating system files: a <em>data file</em> and a <em>log file</em>. Data files contain data and objects such as tables, indexes, stored procedures, and views. Log files contain the information that is required to recover all transactions in the database. Data files can be grouped together in filegroups for allocation and administration purposes.</p>
</div>
<div class="sect3">
<h4 id="database-files">2.5.1. Database Files</h4>
<div class="paragraph">
<p>SQL Server databases have three types of files, as shown in the following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">File</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contains startup information for the database and points to the other files in the database. Every database has one primary data file. The recommended file name extension for primary data files is <em>.mdf</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional user-defined data files. Data can be spread across multiple disks by putting each file on a different disk drive. The recommended file name extension for secondary data files is <em>.ndf</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction Log</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The log holds information used to recover the database. There must be at least one log file for each database. The recommended file name extension for transaction logs is <em>.ldf</em>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For example, a simple database named <strong>Sales</strong> has one primary file that contains all data and objects and a log file that contains the transaction log information. A more complex database named <strong>Orders</strong> can be created that includes one primary file and five secondary files. The data and objects within the database spread across all six files, and the four log files contain the transaction log information.</p>
</div>
<div class="paragraph">
<p>By default, the data and transaction logs are put on the same drive and path to handle single-disk systems. This choice may not be optimal for production environments. We recommend that you <em>put data and log files on separate disks</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">ls</span> /var/opt/mssql/data/
<span class="go">Entropy.bin  Sales_log.ldf  mastlog.ldf  model_msdbdata.mdf  model_replicatedmaster.ldf  modellog.ldf  msdblog.ldf  tempdb2.ndf  tempdb4.ndf
Sales.mdf    master.mdf     model.mdf	 model_msdblog.ldf   model_replicatedmaster.mdf  msdbdata.mdf  tempdb.mdf   tempdb3.ndf  templog.ldf</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="logical-and-physical-file-names">2.5.2. Logical and Physical File Names</h4>
<div class="paragraph">
<p>SQL Server files have two file name types:</p>
</div>
<div class="paragraph">
<p><strong>logical_file_name</strong>: The <em>logical_file_name</em> is the name used to refer to the physical file in all Transact-SQL statements. The logical file name must comply with the rules for SQL Server identifiers and must be unique among logical file names in the database.</p>
</div>
<div class="paragraph">
<p><strong>os_file_name</strong>: The <em>os_file_name</em> is the name of the physical file including the directory path. It must follow the rules for the operating system file names.</p>
</div>
<div class="paragraph">
<p>When multiple instances of SQL Server are running on a single computer, each instance receives a different default directory to hold the files for the databases created in the instance. For more information, see <a href="https://learn.microsoft.com/en-us/sql/sql-server/install/file-locations-for-default-and-named-instances-of-sql-server?view=sql-server-ver16">File Locations for Default and Named Instances of SQL Server</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="database-engine-permissions-and-principals">3. Database Engine Permissions and Principals</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Permissions</em> in the Database Engine are managed at the <em>server level</em> through <em>logins</em> and <em>server roles</em>, and at the <em>database level</em> through <em>database users</em> and <em>database roles</em>. The model for SQL Database exposes the same system within each database, but the server level permissions aren&#8217;t available.</p>
</div>
<div class="sect2">
<h3 id="server-level-roles">3.1. Server-level roles</h3>
<div class="paragraph">
<p>SQL Server provides <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16">server-level roles</a> to help you manage the permissions on a server. These roles are security principals that group other principals. Server-level roles are server-wide in their permissions scope.</p>
</div>
</div>
<div class="sect2">
<h3 id="database-level-roles">3.2. Database-level roles</h3>
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/database-level-roles?view=sql-server-ver16">Database-level roles</a> are database-wide in their permissions scope.</p>
</div>
<div class="paragraph">
<p>There are two types of database-level roles: fixed-database roles that are predefined in the database and user-defined database roles that you can create.</p>
</div>
<div class="paragraph">
<p>Fixed-database roles are defined at the database level and exist in each database. Members of the <code>db_owner</code> database role can manage fixed-database role membership. There are also some special-purpose database roles in the <code>msdb</code> database.</p>
</div>
<div class="paragraph">
<p>You can add any database account and other SQL Server roles into database-level roles.</p>
</div>
</div>
<div class="sect2">
<h3 id="contained-database-users-make-your-database-portable-by-using-contained-databases">3.3. Contained database users: Make your database portable by using contained databases</h3>
<div class="paragraph">
<p>Use <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/contained-database-users-making-your-database-portable?view=sql-server-ver16">contained database users</a> to authenticate SQL Server and Azure SQL Database connections at the database level. A contained database is a database that&#8217;s isolated from other databases and from the instance of SQL Server or SQL Database (and the master database) that hosts the database.</p>
</div>
<div class="sect3">
<h4 id="traditional-login-and-user-model">3.3.1. Traditional login and user model</h4>
<div class="paragraph">
<p>In the traditional connection model, Windows users or members of Windows groups connect to the Database Engine by providing user or group credentials authenticated by Windows. Or users can provide both a name and password and connect by using SQL Server authentication. In both cases, the master database must have a login that matches the connecting credentials.</p>
</div>
<div class="paragraph">
<p>After the Database Engine confirms the Windows authentication credentials or authenticates the SQL Server authentication credentials, the connection typically attempts to connect to a user database. To connect to a user database, the login must be mapped to (that is, associated with) a database user in the user database. The connection string might also specify connecting to a specific database, which is optional in SQL Server but required in SQL Database.</p>
</div>
<div class="paragraph">
<p>The important principle is that both the <em>login</em> (in the <code>master</code> database) and the <em>user</em> (in the user database) must exist and be related to each other. The connection to the user database has a dependency upon the login in the <code>master</code> database. This dependency limits the ability of the database to be moved to a different hosting SQL Server instance or Azure SQL Database server.</p>
</div>
<div class="paragraph">
<p>If a connection to the <code>master</code> database is not available (for example, a failover is in progress), the overall connection time will increase, or the connection might time out. An unavailable connection might reduce connection scalability.</p>
</div>
</div>
<div class="sect3">
<h4 id="contained-database-user-model">3.3.2. Contained database user model</h4>
<div class="paragraph">
<p>In the contained database user model, the login in the <code>master</code> database is not present. Instead, the authentication process occurs at the user database. The database user in the user database doesn&#8217;t have an associated login in the master database.</p>
</div>
<div class="paragraph">
<p>The contained database user model supports both Windows authentication and SQL Server authentication. You can use it in both SQL Server and SQL Database.</p>
</div>
<div class="paragraph">
<p>To connect as a contained database user, the connection string must always contain a parameter for the user database. The Database Engine uses this parameter to know which database is responsible for managing the authentication process.</p>
</div>
<div class="paragraph">
<p>The activity of the contained database user is limited to the authenticating database. The database user account must be independently created in each database that the user needs. To change databases, SQL Database users must create a new connection. Contained database users in SQL Server can change databases if an identical user is present in another database.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-principals">3.4. Security principals</h3>
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine?view=sql-server-ver16"><em>Security principal</em></a> is the official name of the identities that use SQL Server and that can be assigned permission to take actions. They are usually people or groups of people, but can be other entities that pretend to be people.</p>
</div>
<div class="paragraph">
<p>The security principals can be created and managed using the Transact-SQL listed, or by using SQL Server Management Studio.</p>
</div>
<div class="sect3">
<h4 id="logins">3.4.1. Logins</h4>
<div class="paragraph">
<p><em>Logins</em> are individual user accounts for logging on to the SQL Server Database Engine. SQL Server and SQL Database support logins based on <em>Windows authentication</em> and logins based on <em>SQL Server authentication</em>.</p>
</div>
<div class="paragraph">
<p>For information about the two types of logins, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/choose-an-authentication-mode?view=sql-server-ver16">Choose an Authentication Mode</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="fixed-server-roles">3.4.2. Fixed server roles</h4>
<div class="paragraph">
<p>In SQL Server, <em>fixed server roles</em> are a set of pre-configured roles that provide convenient group of server-level permissions. Logins can be added to the roles using the <code>ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER</code> statement.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-server-role-transact-sql?view=sql-server-ver16">ALTER SERVER ROLE (Transact-SQL)</a>.</p>
</div>
<div class="paragraph">
<p>SQL Database doesn&#8217;t support the fixed server roles, but has two roles in the <code>master</code> database (<code>dbmanager</code> and <code>loginmanager</code>) that act like server roles.</p>
</div>
</div>
<div class="sect3">
<h4 id="user-defined-server-roles">3.4.3. User-defined server roles</h4>
<div class="paragraph">
<p>In SQL Server, you can create your own server roles and assign server-level permissions to them. Logins can be added to the server roles using the <code>ALTER SERVER ROLE &#8230;&#8203; ADD MEMBER</code> statement.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-server-role-transact-sql?view=sql-server-ver16">ALTER SERVER ROLE (Transact-SQL)</a>.</p>
</div>
<div class="paragraph">
<p>SQL Database doesn&#8217;t support the user-defined server roles.</p>
</div>
</div>
<div class="sect3">
<h4 id="database-users">3.4.4. Database users</h4>
<div class="paragraph">
<p>Logins are granted access to a database by creating a <em>database user</em> in a database and mapping that database user to sign in. Typically the database user name is the same as the login name, though it doesn&#8217;t have to be the same.</p>
</div>
<div class="paragraph">
<p>Each database user maps to a single login. A login can be mapped to only one user in a database, but can be mapped as a database user in several different databases.</p>
</div>
<div class="paragraph">
<p>Database users can also be created that don&#8217;t have a corresponding login. These users are called <em>contained database users</em>. Microsoft encourages the use of contained database users because it makes it easier to move your database to a different server. Like a login, a contained database user can use either Windows authentication or SQL Server authentication. For more information, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/contained-database-users-making-your-database-portable?view=sql-server-ver16">Contained Database Users - Making Your Database Portable</a>.</p>
</div>
<div class="paragraph">
<p>There are 12 types of users with slight differences in how they authenticate, and who they represent. To see a list of users, see <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/create-user-transact-sql?view=sql-server-ver16">CREATE USER (Transact-SQL)</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="fixed-database-roles">3.4.5. Fixed database roles</h4>
<div class="paragraph">
<p><em>Fixed database roles</em> are a set of pre-configured roles that provide convenient group of database-level permissions. Database users and user-defined database roles can be added to the fixed database roles using the <code>ALTER ROLE &#8230;&#8203; ADD MEMBER</code> statement.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-role-transact-sql?view=sql-server-ver16">ALTER ROLE (Transact-SQL)</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="user-defined-database-roles">3.4.6. User-defined database roles</h4>
<div class="paragraph">
<p>Users with the <code>CREATE ROLE</code> permission can create new <em>user-defined database roles</em> to represent groups of users with common permissions. Typically permissions are granted or denied to the entire role, simplifying permissions management and monitoring. Database users can be added to the database roles by using the <code>ALTER ROLE &#8230;&#8203; ADD MEMBER</code> statement.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-role-transact-sql?view=sql-server-ver16">ALTER ROLE (Transact-SQL)</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="other-principals">3.4.7. Other principals</h4>
<div class="paragraph">
<p>Additional security principals not discussed here include application roles, and logins and users based on certificates or asymmetric keys.</p>
</div>
<div class="paragraph">
<p>For a graphic showing the relationships between Windows users, Windows groups, logins, and database users, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/create-a-database-user?view=sql-server-ver16">Create a Database User</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="assign-permissions">3.5. Assign permissions</h3>
<div class="paragraph">
<p>Every SQL Server securable has associated <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/permissions-database-engine?view=sql-server-ver16">permissions</a> that can be granted to a principal. Permissions in the Database Engine are managed at the server level assigned to logins and server roles, and at the database level assigned to database users and database roles. The model for Azure SQL Database has the same system for the database permissions, but the server level permissions aren&#8217;t available.</p>
</div>
<div class="paragraph">
<p>Most permission statements have the format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">AUTHORIZATION</span> <span class="n">PERMISSION</span> <span class="k">ON</span> <span class="n">SECURABLE</span><span class="p">::</span><span class="n">NAME</span> <span class="k">TO</span> <span class="n">PRINCIPAL</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AUTHORIZATION</code> must be <code>GRANT</code>, <code>REVOKE</code> or <code>DENY</code>.</p>
</li>
<li>
<p>The <code>PERMISSION</code> establishes what action is allowed or prohibited. The exact number of permissions differs between SQL Server and SQL Database. The permissions are listed in the article <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/permissions-database-engine?view=sql-server-ver16">Permissions (Database Engine)</a> and in the chart referenced below.</p>
</li>
<li>
<p><code>ON SECURABLE::NAME</code> is the type of securable (server, server object, database, or database object) and its name.</p>
<div class="paragraph">
<p>Some permissions don&#8217;t require <code>ON SECURABLE::NAME</code> because it is unambiguous or inappropriate in the context. For example, the <code>CREATE TABLE</code> permission doesn&#8217;t require the <code>ON SECURABLE::NAME</code> clause (<code>GRANT CREATE TABLE TO Mary</code>; allows Mary to create tables).</p>
</div>
</li>
<li>
<p><code>PRINCIPAL</code> is the security principal (login, user, or role) which receives or loses the permission. Grant permissions to roles whenever possible.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example grant statement, grants the <code>UPDATE</code> permission on the <code>Parts</code> table or view that is contained in the <code>Production</code> schema to the role named <code>PartsTeam</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GRANT</span> <span class="k">UPDATE</span> <span class="k">ON</span> <span class="k">OBJECT</span><span class="p">::</span><span class="n">Production</span><span class="p">.</span><span class="n">Parts</span> <span class="k">TO</span> <span class="n">PartsTeam</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example grant statement grants the <code>UPDATE</code> permission on the <code>Production</code> schema, and by extension on any table or view contained within this schema to the role named <code>ProductionTeam</code>, which is a more effective and salable approach to assigning permissions than on individual object-level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GRANT</span> <span class="k">UPDATE</span> <span class="k">ON</span> <span class="k">SCHEMA</span><span class="p">::</span><span class="n">Production</span> <span class="k">TO</span> <span class="n">ProductionTeam</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Permissions are granted to security principals (logins, users, and roles) by using the <code>GRANT</code> statement. Permissions are explicitly denied by using the <code>DENY</code> command. A previously granted or denied permission is removed by using the <code>REVOKE</code> statement. Permissions are cumulative, with the user receiving all the permissions granted to the user, login, and any group memberships; however any permission denial overrides all grants.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A common mistake is to attempt to remove a <code>GRANT</code> by using <code>DENY</code> instead of <code>REVOKE</code>. This can cause problems when a user receives permissions from multiple sources; which is quite common. The following example demonstrates the principal.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Sales group receives <code>SELECT</code> permissions on the OrderStatus table through the statement <code>GRANT SELECT ON OBJECT::OrderStatus TO Sales;</code>. User Jae is a member of the Sales role. Jae has also been granted <code>SELECT</code> permission to the <code>OrderStatus</code> table under their own user name through the statement <code>GRANT SELECT ON OBJECT::OrderStatus TO Jae</code>;. Presume the administer wishes to remove the <code>GRANT</code> to the Sales role.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the administrator correctly executes <code>REVOKE SELECT ON OBJECT::OrderStatus TO Sales</code>;, then Jae will retain <code>SELECT</code> access to the OrderStatus table through their individual <code>GRANT</code> statement.</p>
</li>
<li>
<p>If the administrator incorrectly executes <code>DENY SELECT ON OBJECT::OrderStatus TO Sales;</code> then Jae, as a member of the Sales role, will be denied the <code>SELECT</code> permission because the <code>DENY</code> to Sales overrides their individual <code>GRANT</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Permissions can be configured using Management Studio. Find the securable in Object Explorer, right-click the securable, and then select <strong>Properties</strong>. Select the <strong>Permissions</strong> page.</p>
</div>
<div class="paragraph">
<p>For help on using the permission page, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/permissions-or-securables-page?view=sql-server-ver16">Permissions or Securables Page</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="permission-hierarchy">3.6. Permission hierarchy</h3>
<div class="paragraph">
<p>Permissions have a parent/child hierarchy. That is, if you grant <em>SELECT</em> permission on a database, that permission includes <em>SELECT</em> permission on all (child) schemas in the database. If you grant <em>SELECT</em> permission on a schema, it includes <em>SELECT</em> permission on all the (child) tables and views in the schema. The permissions are transitive; that is, if you grant <em>SELECT</em> permission on a database, it includes <em>SELECT</em> permission on all (child) schemas, and all (grandchild) tables and views.</p>
</div>
<div class="paragraph">
<p>Permissions also have covering permissions. The <em>CONTROL</em> permission on an object, normally gives you all other permissions on the object.</p>
</div>
<div class="paragraph">
<p>Because both the parent/child hierarchy and the covering hierarchy can act on the same permission, the permission system can get complicated. For example, let&#8217;s take a table (Region), in a schema (Customers), in a database (SalesDB).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CONTROL</code> permission on table Region includes all the other permissions on the table Region, including <code>ALTER</code>, <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and some other permissions.</p>
</li>
<li>
<p><code>SELECT</code> on the Customers schema that owns the Region table includes the <code>SELECT</code> permission on the Region table.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So <code>SELECT</code> permission on the Region table can be achieved through any of these six statements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GRANT</span> <span class="k">SELECT</span> <span class="k">ON</span> <span class="k">OBJECT</span><span class="p">::</span><span class="n">Region</span> <span class="k">TO</span> <span class="n">Jae</span><span class="p">;</span>

<span class="k">GRANT</span> <span class="n">CONTROL</span> <span class="k">ON</span> <span class="k">OBJECT</span><span class="p">::</span><span class="n">Region</span> <span class="k">TO</span> <span class="n">Jae</span><span class="p">;</span>

<span class="k">GRANT</span> <span class="k">SELECT</span> <span class="k">ON</span> <span class="k">SCHEMA</span><span class="p">::</span><span class="n">Customers</span> <span class="k">TO</span> <span class="n">Jae</span><span class="p">;</span>

<span class="k">GRANT</span> <span class="n">CONTROL</span> <span class="k">ON</span> <span class="k">SCHEMA</span><span class="p">::</span><span class="n">Customers</span> <span class="k">TO</span> <span class="n">Jae</span><span class="p">;</span>

<span class="k">GRANT</span> <span class="k">SELECT</span> <span class="k">ON</span> <span class="k">DATABASE</span><span class="p">::</span><span class="n">SalesDB</span> <span class="k">TO</span> <span class="n">Jae</span><span class="p">;</span>

<span class="k">GRANT</span> <span class="n">CONTROL</span> <span class="k">ON</span> <span class="k">DATABASE</span><span class="p">::</span><span class="n">SalesDB</span> <span class="k">TO</span> <span class="n">Jae</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="monitor-permissions">3.7. Monitor permissions</h3>
<div class="paragraph">
<p>The following views return security information.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The logins and user-defined server roles on a server can be examined by using the <code>sys.server_principals</code> view. This view isn&#8217;t available in SQL Database.</p>
</li>
<li>
<p>The users and user-defined roles in a database can be examined by using the <code>sys.database_principals</code> view.</p>
</li>
<li>
<p>The permissions granted to logins and user-defined fixed server roles can be examined by using the <code>sys.server_permissions</code> view. This view isn&#8217;t available in SQL Database.</p>
</li>
<li>
<p>The permissions granted to users and user-defined fixed database roles can be examined by using the <code>sys.database_permissions</code> view.</p>
</li>
<li>
<p>Database role membership can be examined by using the <code>sys.database_role_members</code> view.</p>
</li>
<li>
<p>Server role membership can be examined by using the <code>sys.server_role_members</code> view. This view isn&#8217;t available in SQL Database.</p>
</li>
<li>
<p>For additional security related views, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/system-catalog-views/security-catalog-views-transact-sql?view=sql-server-ver16">Security Catalog Views (Transact-SQL)</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="principals-database-engine">3.8. Principals (Database Engine)</h3>
<div class="paragraph">
<p><em>Principals</em> are entities that can request SQL Server resources. Like other components of the SQL Server authorization model, principals can be arranged in a hierarchy. The scope of influence of a principal depends on the scope of the definition of the principal: Windows, server, database; and whether the principal is indivisible or a collection. A <em>Windows Login</em> is an example of an indivisible principal, and a <em>Windows Group</em> is an example of a principal that is a collection. Every principal has a <em>security identifier (SID)</em>.</p>
</div>
<div class="sect3">
<h4 id="sql-server-level-principals">3.8.1. SQL Server-level principals</h4>
<div class="ulist">
<ul>
<li>
<p>SQL Server authentication Login</p>
</li>
<li>
<p>Windows authentication login for a Windows user</p>
</li>
<li>
<p>Windows authentication login for a Windows group</p>
</li>
<li>
<p>Azure Active Directory authentication login for a AD user</p>
</li>
<li>
<p>Azure Active Directory authentication login for a AD group</p>
</li>
<li>
<p>Server Role</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="database-level-principals">3.8.2. Database-level principals</h4>
<div class="ulist">
<ul>
<li>
<p>Database User (There are 12 types of users. For more information, see <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/create-user-transact-sql?view=sql-server-ver16">CREATE USER</a>.)</p>
</li>
<li>
<p>Database Role</p>
</li>
<li>
<p>Application Role</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sa-login">3.8.3. sa Login</h4>
<div class="paragraph">
<p>The SQL Server <code>sa</code> login is a server-level principal. By default, it is created when an instance is installed.</p>
</div>
<div class="paragraph">
<p>Beginning in SQL Server 2005 (9.x), the default database of sa is master. This is a change of behavior from earlier versions of SQL Server.</p>
</div>
<div class="paragraph">
<p>The <code>sa</code> login is a member of the <code>sysadmin</code> fixed server-level role.</p>
</div>
<div class="paragraph">
<p>The <code>sa</code> login has all permissions on the server and cannot be limited.</p>
</div>
<div class="paragraph">
<p>The <code>sa</code> login cannot be dropped, but it can be disabled so that no one can use it.</p>
</div>
</div>
<div class="sect3">
<h4 id="dbo-user-and-dbo-schema">3.8.4. dbo User and dbo Schema</h4>
<div class="paragraph">
<p>The <code>dbo</code> user is a special user principal in each database.</p>
</div>
<div class="paragraph">
<p>All SQL Server administrators, members of the <code>sysadmin</code> fixed server role, <code>sa</code> login, and owners of the database, enter databases as the <code>dbo</code> user.</p>
</div>
<div class="paragraph">
<p>The <code>dbo</code> user has all permissions in the database and cannot be limited or dropped.</p>
</div>
<div class="paragraph">
<p><code>dbo</code> stands for database owner, but the <code>dbo</code> user account is not the same as the <code>db_owner</code> fixed database role, and the <code>db_owner</code> fixed database role is not the same as the user account that is recorded as the owner of the database.</p>
</div>
<div class="paragraph">
<p>The <code>dbo</code> user owns the <code>dbo</code> schema. The <code>dbo</code> schema is the default schema for all users, unless some other schema is specified. The <code>dbo</code> schema cannot be dropped.</p>
</div>
</div>
<div class="sect3">
<h4 id="public-server-role-and-database-role">3.8.5. public Server Role and Database Role</h4>
<div class="paragraph">
<p>Every login belongs to the <code>public</code> fixed server role, and every database user belongs to the <code>public</code> database role.</p>
</div>
<div class="paragraph">
<p>When a login or user has not been granted or denied specific permissions on a securable, the login or user inherits the permissions granted to public on that securable.</p>
</div>
<div class="paragraph">
<p>The <code>public</code> fixed server role and the <code>public</code> fixed database role cannot be dropped. However you can revoke permissions from the <code>public</code> roles.</p>
</div>
<div class="paragraph">
<p>There are many permissions that are assigned to the <code>public</code> roles by default. Most of these permissions are needed for routine operations in the database; the type of things that everyone should be able to do.</p>
</div>
<div class="paragraph">
<p>Be careful when revoking permissions from the public login or user, as it will affect all logins/users. Generally you should not deny permissions to public, because the deny statement overrides any grant statements you might make to individuals.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sql-and-t-sql">4. SQL and T-SQL</h2>
<div class="sectionbody">
<div class="quoteblock">
<div class="title">SQL, From Wikipedia, the free encyclopedia, <a href="https://en.wikipedia.org/wiki/SQL" class="bare">https://en.wikipedia.org/wiki/SQL</a></div>
<blockquote>
<div class="paragraph">
<p><strong>Structured Query Language</strong>, abbreviated as <strong>SQL</strong> (/ˌɛsˌkjuːˈɛl/ ) <em>S-Q-L</em>, sometimes /ˈsiːkwəl/ "sequel" for historical reasons), is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It is particularly useful in handling structured data, i.e. data incorporating relations among entities and variables.</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<div class="title">Transact-SQL, From Wikipedia, the free encyclopedia, <a href="https://en.wikipedia.org/wiki/Transact-SQL" class="bare">https://en.wikipedia.org/wiki/Transact-SQL</a></div>
<blockquote>
<div class="paragraph">
<p>Transact-SQL (T-SQL) is Microsoft&#8217;s and Sybase&#8217;s proprietary extension to the SQL (Structured Query Language) used to interact with relational databases. T-SQL expands on the SQL standard to include procedural programming, local variables, various support functions for string processing, date processing, mathematics, etc. and changes to the DELETE and UPDATE statements.</p>
</div>
<div class="paragraph">
<p>Transact-SQL is central to using Microsoft SQL Server. All applications that communicate with an instance of SQL Server do so by sending Transact-SQL statements to the server, regardless of the user interface of the application.</p>
</div>
<div class="paragraph">
<p>Stored procedures in SQL Server are executable server-side routines. The advantage of stored procedures is the ability to pass parameters.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sql-server-utilities-statements-go">5. SQL Server Utilities Statements - GO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SQL Server provides commands that are not Transact-SQL statements, but are recognized by the <strong>sqlcmd</strong> and <strong>osql</strong> utilities and SQL Server Management Studio Code Editor. These commands can be used to facilitate the readability and execution of batches and scripts.</p>
</div>
<div class="paragraph">
<p><code>GO</code> signals the end of a batch of Transact-SQL statements to the SQL Server utilities.</p>
</div>
<div class="paragraph">
<p><strong>Syntax</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GO</span> <span class="p">[</span><span class="k">count</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Arguments</strong></p>
</div>
<div class="paragraph">
<p><em>count</em></p>
</div>
<div class="paragraph">
<p>Is a positive integer. The batch preceding GO will execute the specified number of times.</p>
</div>
<div class="paragraph">
<p><strong>Remarks</strong></p>
</div>
<div class="paragraph">
<p><code>GO</code> is not a Transact-SQL statement; it is a command recognized by the <strong>sqlcmd</strong> and <strong>osql</strong> utilities and SQL Server Management Studio Code editor.</p>
</div>
<div class="paragraph">
<p>SQL Server utilities interpret <code>GO</code> as a signal that they should send the current batch of Transact-SQL statements to an instance of SQL Server. The current batch of statements is composed of all statements entered since the last <code>GO</code>, or since the start of the ad hoc session or script if this is the first <code>GO</code>.</p>
</div>
<div class="paragraph">
<p>A Transact-SQL statement cannot occupy the same line as a <code>GO</code> command. However, the line can contain comments.</p>
</div>
<div class="paragraph">
<p>Users must follow the rules for batches. For example, any execution of a stored procedure after the first statement in a batch must include the <code>EXECUTE</code> keyword. The scope of local (user-defined) variables is limited to a batch, and cannot be referenced after a <code>GO</code> command.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">AdventureWorks2012</span><span class="p">;</span>
<span class="k">GO</span>
<span class="k">DECLARE</span> <span class="o">@</span><span class="n">MyMsg</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="o">@</span><span class="n">MyMsg</span> <span class="o">=</span> <span class="s1">'Hello, World.'</span>
<span class="k">GO</span> <span class="c1">-- @MyMsg is not valid after this GO ends the batch.</span>

<span class="c1">-- Yields an error because @MyMsg not declared in this batch.</span>
<span class="n">PRINT</span> <span class="o">@</span><span class="n">MyMsg</span>
<span class="k">GO</span>

<span class="k">SELECT</span> <span class="o">@@</span><span class="k">VERSION</span><span class="p">;</span>
<span class="c1">-- Yields an error: Must be EXEC sp_who if not first statement in</span>
<span class="c1">-- batch.</span>
<span class="n">sp_who</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>SQL Server applications can send multiple Transact-SQL statements to an instance of SQL Server for execution as a batch. The statements in the batch are then compiled into a single <em>execution plan</em>. Programmers executing ad hoc statements in the SQL Server utilities, or building scripts of Transact-SQL statements to run through the SQL Server utilities, use <code>GO</code> to signal the end of a batch.</p>
</div>
<div class="paragraph">
<p>Applications based on the ODBC or OLE DB APIs receive a syntax error if they try to execute a <code>GO</code> command. The SQL Server utilities never send a <code>GO</code> command to the server.</p>
</div>
<div class="paragraph">
<p>Do not use a semicolon as a statement terminator after <code>GO</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Yields an error because ; is not permitted after GO</span>
<span class="k">SELECT</span> <span class="o">@@</span><span class="k">VERSION</span><span class="p">;</span>
<span class="k">GO</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>GO</code> statement is not a SQL statement; rather, it is a command recognized by the SQL Server Management Studio (SSMS), sqlcmd, and other SQL Server utilities.</p>
</div>
<div class="paragraph">
<p>In the context of these utilities, <code>GO</code> signals the end of a batch of statements and is used to separate batches of statements from each other. However, when you are performing database operations from ADO.NET (or any other context where you&#8217;re sending SQL statements directly to SQL Server), batch separation is not needed, and the <code>GO</code> statement is not recognized.</p>
</div>
<div class="paragraph">
<p>If you try to include the <code>GO</code> statement in your SQL strings in ADO.NET, you&#8217;ll likely encounter a SQL Server error that 'GO' is not a recognized built-in function name. Instead, just end each of your SQL statements with a semicolon (<code>;</code>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="collation-and-unicode-support">6. Collation and Unicode support</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-ver16">Collations</a> in SQL Server provide sorting rules, case, and accent sensitivity properties for your data. Collations that are used with character data types, such as char and varchar, dictate the code page and corresponding characters that can be represented for that data type.</p>
</div>
<div class="paragraph">
<p>Whether you&#8217;re installing a new instance of SQL Server, restoring a database backup, or connecting server to client databases, it&#8217;s important to understand the locale requirements, sorting order, and case and accent sensitivity of the data that you&#8217;re working with. To list the collations that are available on your instance of SQL Server, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/system-functions/sys-fn-helpcollations-transact-sql?view=sql-server-ver16">sys.fn_helpcollations (Transact-SQL)</a>.</p>
</div>
<div class="paragraph">
<p>When you select a collation for your server, database, column, or expression, you&#8217;re assigning certain characteristics to your data. These characteristics affect the results of many operations in the database. For example, when you construct a query by using <code>ORDER BY</code>, the sort order of your result set might depend on the collation that&#8217;s applied to the database or dictated in a <code>COLLATE</code> clause at the expression level of the query.</p>
</div>
<div class="paragraph">
<p>Setting collations are supported at the following levels of an instance of SQL Server:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Server-level collations</p>
<div class="paragraph">
<p>The default server collation is determined during SQL Server setup, and it becomes the default collation of the system databases and all user databases.</p>
</div>
<div class="paragraph">
<p>To query the server collation for an instance of SQL Server, use the SERVERPROPERTY function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">CONVERT</span><span class="p">(</span><span class="n">nvarchar</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">SERVERPROPERTY</span><span class="p">(</span><span class="s1">'collation'</span><span class="p">));</span>
<span class="c1">-- SQL_Latin1_General_CP1_CI_AS</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>* <code>SQL_Latin1_General_CP1_CI_AS</code> is a collation setting in SQL Server. Here&#8217;s what each part of it means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SQL</code> indicates that it is a SQL Server-defined collation.</p>
</li>
<li>
<p><code>Latin1_General</code> is the base language and alphabet, which in this case is the Latin 1 (Western European) alphabet.</p>
</li>
<li>
<p><code>CP1</code> stands for Code Page 1, which implies that the collation is using code page 1252. This page includes all ASCII characters and additional characters used in English and several other Western European languages.</p>
</li>
<li>
<p><code>CI</code> stands for Case Insensitive. This means the collation doesn&#8217;t recognize case differences. When CI is specified, 'a' is considered equal to 'A'.</p>
</li>
<li>
<p><code>AS</code> stands for Accent Sensitive. This means the collation does recognize accent differences. When AS is specified, 'résumé' is not equal to 'resume'.</p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p>* If you want to use unicode (UTF-8) character sets in SQL Server, you can use the newer collations introduced starting from SQL Server 2019 onward. The new collations are named as <code>_SC</code> or <code>_SC_UTF8</code>.</p>
</div>
<div class="paragraph">
<p>The <code>SC</code> stands for Supplementary Characters, which supports UCS-2 or UTF-16 characters. If you want to particularly use UTF-8, you can use <code>_utf8</code> postfix.</p>
</div>
<div class="paragraph">
<p>So if you need to define columns that can store unicode (UTF-8) strings from any language, you can use something like <code>Latin1_General_100_CI_AS_SC_UTF8</code>. <code>_100</code> here corresponds to newer set of collations in SQL Server 2019.</p>
</div>
<div class="paragraph">
<p>Please note that UTF-8 collations are only available to <code>char</code> and <code>varchar</code> data types, not to <code>text</code> data type. And if you&#8217;re dealing with wider unicode character sets and more complex translations, it may be better to use <code>nchar</code> or <code>nvarchar</code> data types with either UTF-16 or supplementary character collations.</p>
</div>
<hr>
<div class="paragraph">
<p>* The Case Insensitive (CI) property in a SQL Server collation does not modify the actual data stored in a cell of a table. If a username is stored as 'JohnDoe', it will be stored as 'JohnDoe' regardless of whether the collation is Case Sensitive (CS) or Case Insensitive (CI).</p>
</div>
<div class="paragraph">
<p>The collation only affects how SQL Server compares and sorts that data during queries. In a Case Insensitive collation, SQL Server considers 'JohnDoe' and 'johndoe' to be equal. If the collation were Case Sensitive, 'JohnDoe' and 'johndoe' would be considered as two different values.</p>
</div>
<div class="paragraph">
<p>So to put it diagrammatically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With Case Insensitive (CI) collation :</p>
<div class="paragraph">
<p><code>SELECT * FROM Users WHERE user_name = 'johndoe'</code> will return 'JohnDoe', 'JOHNDOE', 'johndoe', etc.</p>
</div>
</li>
<li>
<p>With Case Sensitive (CS) collation :</p>
<div class="paragraph">
<p><code>SELECT * FROM Users WHERE user_name = 'johndoe'</code> will only return 'johndoe' and not 'JohnDoe' or 'JOHNDOE'.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>This comparison and sorting behaviour applies both to operations you perform in queries (like WHERE, ORDER BY, JOIN, etc.), as well as to indexes that SQL Server uses to optimize query performance.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To query the server for all available collations, use the following fn_helpcollations() built-in function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">fn_helpcollations</span><span class="p">();</span></code></pre>
</div>
</div>
</li>
<li>
<p>Database-level collations</p>
<div class="paragraph">
<p>When you create or modify a database, you can use the <code>COLLATE</code> clause of the <code>CREATE DATABASE</code> or <code>ALTER DATABASE</code> statement to specify the default database collation. If no collation is specified, the database is assigned the server collation.</p>
</div>
<div class="paragraph">
<p>You can retrieve the current collation of a database by using a statement similar to the following code sample:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="k">CONVERT</span> <span class="p">(</span><span class="n">nvarchar</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">DATABASEPROPERTYEX</span><span class="p">(</span><span class="s1">'database_name'</span><span class="p">,</span> <span class="s1">'collation'</span><span class="p">));</span></code></pre>
</div>
</div>
</li>
<li>
<p>Column-level collations</p>
<div class="paragraph">
<p>When you create or alter a table, you can specify collations for each character-string column by using the <code>COLLATE</code> clause. If you don&#8217;t specify a collation, the column is assigned the default collation of the database.</p>
</div>
</li>
<li>
<p>Expression-level collations</p>
<div class="paragraph">
<p>Expression-level collations are set when a statement is run, and they affect the way a result set is returned. This enables <code>ORDER BY</code> sort results to be locale-specific. To implement expression-level collations, use a <code>COLLATE</code> clause such as the following code sample:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">customer</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">name</span> <span class="k">COLLATE</span> <span class="n">Latin1_General_CS_AI</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <strong>locale</strong> is a set of information that&#8217;s associated with a location or a culture. The information can include the name and identifier of the spoken language, the script that&#8217;s used to write the language, and cultural conventions. Collations can be associated with one or more locales. For more information, see Locale IDs Assigned by Microsoft.</p>
</div>
<div class="paragraph">
<p>A <strong>code page</strong> is an ordered set of characters of a given script in which a numeric index, or code point value, is associated with each character. A Windows code page is typically referred to as a character set or a charset. Code pages are used to provide support for the character sets and keyboard layouts that are used by different Windows system locales.</p>
</div>
<div class="paragraph">
<p><strong>Sort order</strong> specifies how data values are sorted. The order affects the results of data comparison. Data is sorted by using collations, and it can be optimized by using indexes.</p>
</div>
<div class="paragraph">
<p><strong>Unicode</strong> is a standard for mapping code points to characters. Because it&#8217;s designed to cover all the characters of all the languages of the world, you don&#8217;t need different code pages to handle different sets of characters.</p>
</div>
<div class="paragraph">
<p>Storing data in multiple languages within one database is difficult to manage when you use only character data and code pages. It&#8217;s also difficult to find one code page for the database that can store all the required language-specific characters. Additionally, it&#8217;s difficult to guarantee the correct translation of special characters when they&#8217;re being read or updated by a variety of clients that are running various code pages. Databases that support international clients should always use Unicode data types instead of non-Unicode data types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The code pages that a client uses are determined by the operating system (OS) settings. To set client code pages on the Windows operating system, use Regional Settings in Control Panel.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It would be difficult to select a code page for character data types that will support all the characters that are required by a worldwide audience. The easiest way to manage character data in international databases is to always use a data type that supports Unicode.</p>
</div>
<div class="paragraph">
<p>If you store character data that reflects multiple languages in SQL Server (SQL Server 2005 (9.x) and later), use Unicode data types (<code>nchar</code>, <code>nvarchar</code>, and <code>ntext</code>) instead of non-Unicode data types (<code>char</code>, <code>varchar</code>, and <code>text</code>).</p>
</div>
<div class="paragraph">
<p>Alternatively, starting with SQL Server 2019 (15.x), if a UTF-8 enabled collation (<code>_UTF8</code>) is used, previously non-Unicode data types (<code>char</code> and <code>varchar</code>) become Unicode data types using UTF-8 encoding. SQL Server 2019 (15.x) doesn&#8217;t change the behavior of previously existing Unicode data types (<code>nchar</code>, <code>nvarchar</code>, and <code>ntext</code>), which continue to use UCS-2 or UTF-16 encoding. For more information, see <a href="https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-ver16#storage_differences">Storage differences between UTF-8 and UTF-16</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="database-identifiers">7. Database identifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The database object name is referred to as its <a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-identifiers?view=sql-server-ver16">identifier</a>. Everything in Microsoft SQL Server can have an identifier. Servers, databases, and database objects, such as tables, views, columns, indexes, triggers, procedures, constraints, and rules, can have identifiers. Identifiers are required for most objects, but are optional for some objects such as constraints.</p>
</div>
<div class="paragraph">
<p>An object identifier is created when the object is defined. The identifier is then used to reference the object. For example, the following statement creates a table with the identifier <code>TableX</code>, and two columns with the identifiers <code>KeyCol</code> and <code>Description</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">TableX</span>
<span class="p">(</span><span class="n">KeyCol</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">Description</span> <span class="n">nvarchar</span><span class="p">(</span><span class="mi">80</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This table also has an unnamed constraint. The <code>PRIMARY KEY</code> constraint has no identifier.</p>
</div>
<div class="paragraph">
<p>The collation of an identifier depends on the level at which it is defined.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identifiers of instance-level objects, such as logins and database names, are assigned the default collation of the instance.</p>
</li>
<li>
<p>Identifiers of objects in a database, such as tables, views, and column names, are assigned the default collation of the database.</p>
<div class="paragraph">
<p>For example, two tables with names that differ only in case can be created in a database that has case-sensitive collation, but cannot be created in a database that has case-insensitive collation.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are two classes of identifiers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Regular identifiers</p>
<div class="paragraph">
<p>Comply with the rules for the format of identifiers. Regular identifiers are not delimited when they are used in Transact-SQL statements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">AdventureWorks2022</span><span class="p">;</span>
<span class="k">GO</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">HumanResources</span><span class="p">.</span><span class="n">Employee</span>
<span class="k">WHERE</span> <span class="n">NationalIDNumber</span> <span class="o">=</span> <span class="mi">153479919</span></code></pre>
</div>
</div>
</li>
<li>
<p>Delimited identifiers</p>
<div class="paragraph">
<p>Are enclosed in double quotation marks (<code>"</code>) or brackets (<code>[ ]</code>). Identifiers that comply with the rules for the format of identifiers might not be delimited. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">AdventureWorks2022</span><span class="p">;</span>
<span class="k">GO</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="p">[</span><span class="n">HumanResources</span><span class="p">].[</span><span class="n">Employee</span><span class="p">]</span> <span class="c1">--Delimiter is optional.</span>
<span class="k">WHERE</span> <span class="p">[</span><span class="n">NationalIDNumber</span><span class="p">]</span> <span class="o">=</span> <span class="mi">153479919</span> <span class="c1">--Delimiter is optional.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Identifiers that do not comply with all the rules for identifiers must be delimited in a Transact-SQL statement. For example:
SQL</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">AdventureWorks2022</span><span class="p">;</span>
<span class="k">GO</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">[</span><span class="n">SalesOrderDetail</span> <span class="k">Table</span><span class="p">]</span> <span class="c1">--Identifier contains a space and uses a reserved keyword.</span>
<span class="p">(</span>
    <span class="p">[</span><span class="k">Order</span><span class="p">]</span> <span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SalesOrderDetailID</span><span class="p">]</span> <span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="k">IDENTITY</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="p">[</span><span class="n">OrderQty</span><span class="p">]</span> <span class="p">[</span><span class="nb">smallint</span><span class="p">]</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="p">[</span><span class="n">ProductID</span><span class="p">]</span> <span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="p">[</span><span class="n">UnitPrice</span><span class="p">]</span> <span class="p">[</span><span class="n">money</span><span class="p">]</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="p">[</span><span class="n">UnitPriceDiscount</span><span class="p">]</span> <span class="p">[</span><span class="n">money</span><span class="p">]</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="p">[</span><span class="n">ModifiedDate</span><span class="p">]</span> <span class="p">[</span><span class="nb">datetime</span><span class="p">]</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">PK_SalesOrderDetail_Order_SalesOrderDetailID</span><span class="p">]</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="n">CLUSTERED</span>
  <span class="p">([</span><span class="k">Order</span><span class="p">]</span> <span class="k">ASC</span><span class="p">,</span> <span class="p">[</span><span class="n">SalesOrderDetailID</span><span class="p">]</span> <span class="k">ASC</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">GO</span>

<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="p">[</span><span class="n">SalesOrderDetail</span> <span class="k">Table</span><span class="p">]</span>  <span class="c1">--Identifier contains a space and uses a reserved keyword.</span>
<span class="k">WHERE</span> <span class="p">[</span><span class="k">Order</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>            <span class="c1">--Identifier is a reserved keyword.</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s the recommend naming convention in SQL Server?</p>
</div>
<div class="paragraph">
<p>* Naming conventions in SQL Server are mostly a matter of personal preference or organizational standards. However, there are some commonly followed best practices that can increase the readability and manageability of your database. Here are a few recommended conventions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Meaningful and Descriptive Names</strong>: Names should clearly indicate what the object represents. For example, a table storing customer information should be named <code>Customers</code> or <code>CustomerData</code>, not <code>Table1</code> or <code>t1</code>.</p>
</li>
<li>
<p><strong>Prefixes for Different Object Types</strong>: Using prefixes to denote the type of object can be useful. For example, stored procedures could be named with the <code>sp_</code> prefix (like <code>sp_GetCustomerDetails</code>), views with <code>vw_</code> prefix (like <code>vw_CustomerOrders</code>), and tables could be named without any prefix for clarity (like <code>Orders</code>).</p>
</li>
<li>
<p><strong>Avoid SQL Keywords</strong>: Avoid using SQL Server reserved words. This can cause confusion and sometimes lead to syntax errors.</p>
</li>
<li>
<p><strong>Be Consistent</strong>: Whichever convention you decide on, be consistent with it across all your SQL projects.</p>
</li>
<li>
<p><strong>PascalCase or snake_case</strong>: For multiple word names, use <code>PascalCase</code> (no spaces and each word capitalized like <code>CustomerOrders</code>) or <code>snake_case</code> (words separated by underscores like <code>customer_orders</code>). Avoid using spaces in object names.</p>
</li>
<li>
<p><strong>Singular or Plural Names</strong>: There&#8217;s much debate about whether to use singular or plural names for table names. Choose whichever makes the most logical sense in your context and be consistent.</p>
</li>
<li>
<p><strong>Avoid Special Characters and Spaces</strong>: With the exception of the underscore character, avoid using special characters, dots, hyphens, spaces etc. in names.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Remember, the most important goal of any naming convention is to make the code and database structure easily understandable and manageable for the developers and administrators working on it.</p>
</div>
<div class="paragraph">
<p>Note: In SQL Server, the <code>sp_</code> prefix is reserved for system stored procedures. Some developers prefer not to use it for user-defined stored procedures to avoid potential naming conflicts and small performance penalties when the system searches the master database first for such procedures. They may use <code>usp_</code> for user stored procedures instead.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transact-sql-syntax-conventions-transact-sql">8. Transact-SQL syntax conventions (Transact-SQL)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following table lists and describes conventions that are used in the syntax diagrams in the Transact-SQL reference.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Convention</th>
<th class="tableblock halign-left valign-top">Used for</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UPPERCASE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transact-SQL keywords.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>italic</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User-supplied parameters of Transact-SQL syntax.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bold</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type database names, table names, column names, index names, stored procedures, utilities, data type names, and text exactly as shown.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">| (vertical bar)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separates syntax items enclosed in brackets or braces. You can use only one of the items.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[ ] (brackets)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional syntax item.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ } (braces)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required syntax items. Don&#8217;t type the braces.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[ , &#8230;&#8203;n ]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the preceding item can be repeated n number of times. The occurrences are separated by commas.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[ &#8230;&#8203;n ]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the preceding item can be repeated n number of times. The occurrences are separated by blanks.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transact-SQL statement terminator. Although the semicolon isn&#8217;t required for most statements in this version of SQL Server, it will be required in a future version.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">::=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name for a block of syntax. Use this convention to group and label sections of lengthy syntax or a unit of syntax that you can use in more than one location within a statement. Each location in which the block of syntax could be used is indicated with the label enclosed in chevrons: &lt;label&gt;.</p>
<p class="tableblock">A set is a collection of expressions, for example &lt;grouping set&gt;; and a list is a collection of sets, for example &lt;composite element list&gt;.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Unless specified otherwise, all Transact-SQL references to the name of a database object can be a four-part name in the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre><em>server_name.[database_name].[schema_name].object_name</em>

<em>| database_name.[schema_name].object_name</em>

<em>| schema_name.object_name</em>

<em>| object_name</em></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>server_name</p>
<div class="paragraph">
<p>Specifies a linked server name or remote server name.</p>
</div>
</li>
<li>
<p>database_name</p>
<div class="paragraph">
<p>Specifies the name of a SQL Server database when the object resides in a local instance of SQL Server. When the object is in a linked server, database_name specifies an OLE DB catalog.</p>
</div>
</li>
<li>
<p>schema_name</p>
<div class="paragraph">
<p>Specifies the name of the schema that contains the object if the object is in a SQL Server database. When the object is in a linked server, schema_name specifies an OLE DB schema name.</p>
</div>
</li>
<li>
<p>object_name</p>
<div class="paragraph">
<p>Refers to the name of the object.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When referencing a specific object, you don&#8217;t always have to specify the server, database, and schema for the SQL Server Database Engine to identify the object. However, if the object can&#8217;t be found, an error is returned.</p>
</div>
<div class="paragraph">
<p>To avoid name resolution errors, we recommend specifying the schema name whenever you specify a schema-scoped object.</p>
</div>
<div class="paragraph">
<p>To omit intermediate nodes, use periods to indicate these positions. The following table shows the valid formats of object names.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Object reference format</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>server_name.database_name.schema_name.object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Four-part name.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>server_name.database_name..object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Schema name is omitted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>server_name..schema_name.object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Database name is omitted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>server_name&#8230;&#8203;object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Database and schema name are omitted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>database_name.schema_name.object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server name is omitted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>database_name..object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server and schema name are omitted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>schema_name.object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server and database name are omitted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>object_name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server, database, and schema name are omitted.</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">@@</span><span class="n">SERVERNAME</span><span class="p">;</span> <span class="c1">-- 8a90e1fbcc1b</span>
<span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="p">[</span><span class="mi">8</span><span class="n">a90e1fbcc1b</span><span class="p">].[</span><span class="n">master</span><span class="p">].[</span><span class="n">sys</span><span class="p">].[</span><span class="n">servers</span><span class="p">];</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial-write-transact-sql-statements">9. Tutorial: Write Transact-SQL statements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial is intended as a brief introduction to the Transact-SQL language and not as a replacement for a Transact-SQL class. The statements in this tutorial are intentionally simple, and aren&#8217;t meant to represent the complexity found in a typical production database.</p>
</div>
<div class="sect2">
<h3 id="lesson-1-create-and-query-database-objects">9.1. Lesson 1: Create and query database objects</h3>
<div class="paragraph">
<p>Transact-SQL statements can be written and submitted to the Database Engine in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By using SQL Server Management Studio.</p>
</li>
<li>
<p>By using the <strong>sqlcmd</strong> utility.</p>
</li>
<li>
<p>By connecting from an application that you create.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="create-a-database">9.1.1. Create a database</h4>
<div class="paragraph">
<p>Like many Transact-SQL statements, the <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/create-database-transact-sql?view=sql-server-ver16">CREATE DATABASE</a> statement has a required parameter: the name of the database.</p>
</div>
<div class="paragraph">
<p><code>CREATE DATABASE</code> also has many optional parameters, such as the disk location where you want to put the database files.</p>
</div>
<div class="paragraph">
<p>When you execute <code>CREATE DATABASE</code> without the optional parameters, SQL Server uses default values for many of these parameters.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In a Query Editor window, type but don&#8217;t execute the following code:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">TestData</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use the pointer to select the words <code>CREATE DATABASE</code>, and then press <strong>F1</strong>.</p>
</li>
<li>
<p>In Query Editor, press <strong>F5</strong> to execute the statement and create a database named TestData.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When you create a database, SQL Server makes a copy of the <code>model</code> database, and renames the copy to the database name. This operation should only take several seconds, unless you specify a large initial size of the database as an optional parameter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The keyword <code>GO</code> separates statements when more than one statement is submitted in a single batch. <code>GO</code> is optional when the batch contains only one statement.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="create-a-table">9.1.2. Create a Table</h4>
<div class="paragraph">
<p>To create a table, you must provide a name for the table, and the names and data types of each column in the table.</p>
</div>
<div class="paragraph">
<p>It is also a good practice to indicate whether null values are allowed in each column.</p>
</div>
<div class="paragraph">
<p>To create a table, you must have the <code>CREATE TABLE</code> permission, and the <code>ALTER SCHEMA</code> permission on the schema that will contain the table. The <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/database-level-roles?view=sql-server-ver16">db_ddladmin</a> fixed database role has these permissions.</p>
</div>
<div class="paragraph">
<p>Most tables have a primary key, made up of one or more columns of the table. A primary key is always unique. The Database Engine will enforce the restriction that any primary key value can&#8217;t be repeated in the table.</p>
</div>
<div class="paragraph">
<p>For a list of data types and links for a description of each, see <a href="https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16">Data Types (Transact-SQL)</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Database Engine can be installed as case sensitive or non-case sensitive. If the Database Engine is installed as case sensitive, object names must always have the same case. For example, a table named OrderData is a different table from a table named ORDERDATA. If the Database Engine is installed as non-case sensitive, those two table names are considered to be the same table, and that name can only be used one time.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="switch-the-query-editor-connection-to-the-testdata-database">9.1.2.1. Switch the Query Editor connection to the TestData database</h5>
<div class="paragraph">
<p>In a Query Editor window, type and execute the following code to change your connection to the TestData database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">TestData</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="create-the-table">9.1.2.2. Create the table</h5>
<div class="paragraph">
<p>In a Query Editor window, type and execute the following code to create a table named <code>Products</code>.</p>
</div>
<div class="paragraph">
<p>The columns in the table are named <code>ProductID</code>, <code>ProductName</code>, <code>Price</code>, and <code>ProductDescription</code>. The <code>ProductID</code> column is the primary key of the table. <code>int</code>, <code>varchar(25)</code>, <code>money</code>, and <code>varchar(max)</code> are all data types. Only the <code>Price</code> and <code>ProductionDescription</code> columns can have no data when a row is inserted or changed.
This statement contains an optional element (<code>dbo.</code>) called a schema. The schema is the database object that owns the table. If you are an administrator, <code>dbo</code> is the default schema. <code>dbo</code> stands for database owner.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
    <span class="p">(</span><span class="n">ProductID</span> <span class="nb">int</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">ProductName</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">Price</span> <span class="n">money</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">ProductDescription</span> <span class="nb">varchar</span><span class="p">(</span><span class="k">max</span><span class="p">)</span> <span class="k">NULL</span><span class="p">);</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="insert-and-update-data-in-a-table">9.1.3. Insert and update data in a table</h4>
<div class="paragraph">
<p>Now that you have created the <code>Products</code> table, you are ready to insert data into the table by using the INSERT statement. After the data is inserted, you will change the content of a row by using an UPDATE statement. You will use the WHERE clause of the UPDATE statement to restrict the update to a single row. The four statements will enter the following data.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ProductID</th>
<th class="tableblock halign-left valign-top">ProductName</th>
<th class="tableblock halign-left valign-top">Price</th>
<th class="tableblock halign-left valign-top">ProductDescription</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clamp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12.48</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Workbench clamp</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Screwdriver</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flat head</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">75</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tire Bar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30.00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tool for changing tires.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bracket</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.52</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The basic syntax is: INSERT, table name, column list, VALUES, and then a list of the values to be inserted. The two hyphens in front of a line indicate that the line is a comment and the text will be ignored by the compiler. In this case, the comment describes a permissible variation of the syntax.</p>
</div>
<div class="sect4">
<h5 id="insert-data-into-a-table">9.1.3.1. Insert data into a table</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Execute the following statement to insert a row into the <code>Products</code> table that was created in the previous task.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Standard syntax</span>
<span class="k">INSERT</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span> <span class="p">(</span><span class="n">ProductID</span><span class="p">,</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span><span class="p">,</span> <span class="n">ProductDescription</span><span class="p">)</span>
    <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Clamp'</span><span class="p">,</span> <span class="mi">12</span><span class="p">.</span><span class="mi">48</span><span class="p">,</span> <span class="s1">'Workbench clamp'</span><span class="p">)</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the insert succeeds, proceed to the next step.</p>
</div>
<div class="paragraph">
<p>If the insert fails, it may be because the <code>Product</code> table already has a row with that product ID in it. To proceed, delete all the rows in the table and repeat the preceding step. <a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/truncate-table-transact-sql?view=sql-server-ver16">TRUNCATE TABLE</a> deletes all the rows in the table.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Run the following command to delete all the rows in the table:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">TestData</span><span class="p">.</span><span class="n">dbo</span><span class="p">.</span><span class="n">Products</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After you truncate the table, repeat the INSERT command in this step.</p>
</div>
</li>
<li>
<p>The following statement shows how you can change the order in which the parameters are provided by switching the placement of the <code>ProductID</code> and <code>ProductName</code> in both the field list (in parentheses) and in the values list.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Changing the order of the columns</span>
<span class="k">INSERT</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span> <span class="p">(</span><span class="n">ProductName</span><span class="p">,</span> <span class="n">ProductID</span><span class="p">,</span> <span class="n">Price</span><span class="p">,</span> <span class="n">ProductDescription</span><span class="p">)</span>
    <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Screwdriver'</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">17</span><span class="p">,</span> <span class="s1">'Flat head'</span><span class="p">)</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>The following statement demonstrates that the names of the columns are optional, as long as the values are listed in the correct order. This syntax is common but isn&#8217;t recommended because it might be harder for others to understand your code. <code>NULL</code> is specified for the <code>Price</code> column because the price for this product isn&#8217;t yet known.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Skipping the column list, but keeping the values in order</span>
<span class="k">INSERT</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
    <span class="k">VALUES</span> <span class="p">(</span><span class="mi">75</span><span class="p">,</span> <span class="s1">'Tire Bar'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="s1">'Tool for changing tires.'</span><span class="p">)</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>The schema name is optional as long as you are accessing and changing a table in your default schema. Because the <code>ProductDescription</code> column allows null values and no value is being provided, the ProductDescription column name and value can be dropped from the statement completely.
SQL</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Dropping the optional dbo and dropping the ProductDescription column</span>
<span class="k">INSERT</span> <span class="n">Products</span> <span class="p">(</span><span class="n">ProductID</span><span class="p">,</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span><span class="p">)</span>
    <span class="k">VALUES</span> <span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="s1">'3 mm Bracket'</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">52</span><span class="p">)</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="update-the-products-table">9.1.3.2. Update the products table</h5>
<div class="paragraph">
<p>Type and execute the following UPDATE statement to change the <code>ProductName</code> of the second product from <code>Screwdriver</code>, to <code>Flat Head Screwdriver</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">UPDATE</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
    <span class="k">SET</span> <span class="n">ProductName</span> <span class="o">=</span> <span class="s1">'Flat Head Screwdriver'</span>
    <span class="k">WHERE</span> <span class="n">ProductID</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="read-data-from-a-table">9.1.4. Read data from a table</h4>
<div class="paragraph">
<p>Use the SELECT statement to read the data in a table. The SELECT statement is one of the most important Transact-SQL statements, and there are many variations in the syntax. For this tutorial, you will work with five simple versions.</p>
</div>
<div class="sect4">
<h5 id="read-the-data-in-a-table">9.1.4.1. Read the data in a table</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Type and execute the following statements to read the data in the <code>Products</code> table.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- The basic syntax for reading data from a single table</span>
<span class="k">SELECT</span> <span class="n">ProductID</span><span class="p">,</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span><span class="p">,</span> <span class="n">ProductDescription</span>
    <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>You can use an asterisk (<code>*</code>) to select all the columns in the table. The asterisk is for ad hoc queries. In permanent code, provide the column list so that the statement returns the predicted columns, even if a new column is added to the table later.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Returns all columns in the table</span>
<span class="c1">-- Does not use the optional schema, dbo</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Products</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>You can omit columns that you don&#8217;t want to return. The columns will be returned in the order that they are listed.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Returns only two of the columns from the table</span>
<span class="k">SELECT</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span>
    <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use a <code>WHERE</code> clause to limit the rows that are returned to the user.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Returns only two of the records in the table</span>
<span class="k">SELECT</span> <span class="n">ProductID</span><span class="p">,</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span><span class="p">,</span> <span class="n">ProductDescription</span>
    <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
    <span class="k">WHERE</span> <span class="n">ProductID</span> <span class="o">&lt;</span> <span class="mi">60</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>You can work with the values in the columns as they are returned. The following example performs a mathematical operation on the <code>Price</code> column. Columns that have been changed in this way won&#8217;t have a name unless you provide one by using the <code>AS</code> keyword.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Returns ProductName and the Price including a 7% tax</span>
<span class="c1">-- Provides the name CustomerPays for the calculated column</span>
<span class="k">SELECT</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span> <span class="o">*</span> <span class="mi">1</span><span class="p">.</span><span class="mi">07</span> <span class="k">AS</span> <span class="n">CustomerPays</span>
    <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">Products</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="useful-functions-in-a-select-statement">9.1.4.2. Useful functions in a SELECT statement</h5>
<div class="paragraph">
<p>For information about some functions that you can use to work with data in SELECT statements, see the following articles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/string-functions-transact-sql?view=sql-server-ver16">String Functions (Transact-SQL)</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/date-and-time-data-types-and-functions-transact-sql?view=sql-server-ver16">Date and Time Data Types and Functions (Transact-SQL)</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver16">Mathematical Functions (Transact-SQL)</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/functions/text-and-image-functions-textptr-transact-sql?view=sql-server-ver16">Text and Image Functions (Transact-SQL)</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="create-views-and-stored-procedures">9.1.5. Create views and stored procedures</h4>
<div class="paragraph">
<p>A view is a stored SELECT statement, and a stored procedure is one or more Transact-SQL statements that execute as a batch.</p>
</div>
<div class="paragraph">
<p>Views are queried like tables and don&#8217;t accept parameters. Stored procedures are more complex than views. Stored procedures can have both input and output parameters and can contain statements to control the flow of the code, such as IF and WHILE statements. It is good programming practice to use stored procedures for all repetitive actions in the database.</p>
</div>
<div class="paragraph">
<p>For this example, you will use CREATE VIEW to create a view that selects only two of the columns in the <code>Products</code> table. Then, you will use CREATE PROCEDURE to create a stored procedure that accepts a price parameter and returns only those products that cost less than the specified parameter value.</p>
</div>
<div class="sect4">
<h5 id="create-a-view">9.1.5.1. Create a view</h5>
<div class="paragraph">
<p>Execute the following statement to create a view that executes a select statement, and returns the names and prices of our products to the user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">vw_Names</span>
   <span class="k">AS</span>
   <span class="k">SELECT</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span> <span class="k">FROM</span> <span class="n">Products</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="test-the-view">9.1.5.2. Test the view</h5>
<div class="paragraph">
<p>Views are treated just like tables. Use a <code>SELECT</code> statement to access a view.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">vw_Names</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="create-a-stored-procedure">9.1.5.3. Create a stored procedure</h5>
<div class="paragraph">
<p>The following statement creates a stored procedure name <code>pr_Names</code>, accepts an input parameter named <code>@VarPrice</code> of data type <code>money</code>. The stored procedure prints the statement <code>Products less than</code> concatenated with the input parameter that is changed from the <code>money</code> data type into a <code>varchar(10)</code> character data type. Then, the procedure executes a <code>SELECT</code> statement on the view, passing the input parameter as part of the <code>WHERE</code> clause. This returns all products that cost less than the input parameter value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="k">PROCEDURE</span> <span class="n">pr_Names</span> <span class="o">@</span><span class="n">VarPrice</span> <span class="n">money</span>
   <span class="k">AS</span>
   <span class="k">BEGIN</span>
      <span class="c1">-- The print statement returns text to the user</span>
      <span class="n">PRINT</span> <span class="s1">'Products less than '</span> <span class="o">+</span> <span class="k">CAST</span><span class="p">(</span><span class="o">@</span><span class="n">VarPrice</span> <span class="k">AS</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
      <span class="c1">-- A second statement starts here</span>
      <span class="k">SELECT</span> <span class="n">ProductName</span><span class="p">,</span> <span class="n">Price</span> <span class="k">FROM</span> <span class="n">vw_Names</span>
            <span class="k">WHERE</span> <span class="n">Price</span> <span class="o">&lt;</span> <span class="o">@</span><span class="n">VarPrice</span><span class="p">;</span>
   <span class="k">END</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="test-the-stored-procedure">9.1.5.4. Test the stored procedure</h5>
<div class="paragraph">
<p>To test the stored procedure, type and execute the following statement. The procedure should return the names of the two products entered into the <code>Products</code> table in Lesson 1 with a price that is less than <code>10.00</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">EXECUTE</span> <span class="n">pr_Names</span> <span class="mi">10</span><span class="p">.</span><span class="mi">00</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lesson-2-configure-permissions-on-database-objects">9.2. Lesson 2: Configure permissions on database objects</h3>
<div class="paragraph">
<p>Granting a user access to a database involves three steps.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, you create a login. The login lets the user connect to the SQL Server Database Engine.</p>
</li>
<li>
<p>Then you configure the login as a user in the specified database.</p>
</li>
<li>
<p>And finally, you grant that user permission to database objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This lesson shows you these three steps, and shows you how to create a view and a stored procedure as the object.</p>
</div>
<div class="sect3">
<h4 id="create-a-login">9.2.1. Create a login</h4>
<div class="paragraph">
<p>To access the Database Engine, users require a login. The login can represent the user&#8217;s identity as a Windows account or as a member of a Windows group, or the login can be a SQL Server login that exists only in SQL Server. Whenever possible you should use Windows Authentication.</p>
</div>
<div class="sect4">
<h5 id="create-a-new-windows-account">9.2.1.1. Create a new Windows account</h5>
<div class="paragraph">
<p>By default, administrators on your computer have full access to SQL Server. For this lesson, we want to have a less privileged user; therefore, you will create a new local Windows Authentication account on your computer.</p>
</div>
<div class="paragraph">
<p>To do this, you must be an administrator on your computer. Then you will grant that new user access to SQL Server.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Start</strong>, select <strong>Run</strong>, in the <strong>Open</strong> box, type <code>%SystemRoot%\system32\compmgmt.msc /s</code> and then select <strong>OK</strong> to open the Computer Management program.</p>
</li>
<li>
<p>Under <strong>System Tools</strong>, expand <strong>Local Users and Groups</strong>, right-click <strong>Users</strong>, and then select <strong>New User</strong>.</p>
</li>
<li>
<p>In the <strong>User</strong> name box type <strong>Mary</strong>.</p>
</li>
<li>
<p>In the <strong>Password</strong> and <strong>Confirm password</strong> box, type a strong password, and then select <strong>Create</strong> to create a new local Windows user.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="create-a-sql-login-using-windows-authentication-with-t-sql">9.2.1.2. Create a SQL login  using Windows Authentication with T-SQL</h5>
<div class="paragraph">
<p>In a Query Editor window of SQL Server Management Studio, type and execute the following code replacing <code>computer_name</code> with the name of your computer. <code>FROM WINDOWS</code> indicates that Windows will authenticate the user. The optional <code>DEFAULT_DATABASE</code> argument connects <code>Mary</code> to the <code>TestData</code> database, unless her connection string indicates another database. This statement introduces the semicolon as an optional termination for a Transact-SQL statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">CREATE</span> <span class="n">LOGIN</span> <span class="p">[</span><span class="n">computer_name</span><span class="err">\</span><span class="n">Mary</span><span class="p">]</span>
    <span class="k">FROM</span> <span class="n">WINDOWS</span>
    <span class="k">WITH</span> <span class="n">DEFAULT_DATABASE</span> <span class="o">=</span> <span class="p">[</span><span class="n">TestData</span><span class="p">];</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This authorizes a user name <code>Mary</code>, authenticated by your computer, to access this instance of SQL Server. If there is more than one instance of SQL Server on the computer, you must create the login on each instance that Mary must access.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because <code>Mary</code> is not a domain account, this user name can only be authenticated on this computer.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="create-a-login-using-sql-server-authentication-with-t-sql">9.2.1.3. Create a login using SQL Server Authentication with T-SQL</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Creates the user "shcooper" for SQL Server using the security credential "RestrictedFaculty"</span>
<span class="c1">-- The user login starts with the password "Baz1nga," but that password must be changed after the first login.</span>

<span class="k">CREATE</span> <span class="n">LOGIN</span> <span class="n">shcooper</span>
   <span class="k">WITH</span> <span class="n">PASSWORD</span> <span class="o">=</span> <span class="s1">'Baz1nga'</span> <span class="n">MUST_CHANGE</span><span class="p">,</span>
   <span class="n">CREDENTIAL</span> <span class="o">=</span> <span class="n">RestrictedFaculty</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="grant-access-to-a-database">9.2.2. Grant access to a database</h4>
<div class="paragraph">
<p>Mary now has access to this instance of SQL Server, but doesn&#8217;t have permission to access the databases. She doesn&#8217;t even have access to her default database <code>TestData</code> until you authorize her as a database user.</p>
</div>
<div class="paragraph">
<p>To grant Mary access, switch to the <code>TestData</code> database, and then use the <code>CREATE USER</code> statement to map her login to a user named <code>Mary</code>.</p>
</div>
<div class="sect4">
<h5 id="create-a-user-in-a-database">9.2.2.1. Create a user in a database</h5>
<div class="paragraph">
<p>Type and execute the following statements (replacing <code>computer_name</code> with the name of your computer) to grant <code>Mary</code> access to the <code>TestData</code> database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="p">[</span><span class="n">TestData</span><span class="p">];</span>
<span class="k">GO</span>

<span class="k">CREATE</span> <span class="k">USER</span> <span class="p">[</span><span class="n">Mary</span><span class="p">]</span> <span class="k">FOR</span> <span class="n">LOGIN</span> <span class="p">[</span><span class="n">computer_name</span><span class="err">\</span><span class="n">Mary</span><span class="p">];</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, Mary has access to both SQL Server and the <code>TestData</code> database.</p>
</div>
</div>
<div class="sect4">
<h5 id="create-views-and-stored-procedures-2">9.2.2.2. Create views and stored procedures</h5>
<div class="paragraph">
<p>As an administrator, you can execute the SELECT from the <code>Products</code> table and the <code>vw_Names</code> view, and execute the <code>pr_Names</code> procedure; however, Mary can&#8217;t. To grant Mary the necessary permissions, use the <code>GRANT</code> statement.</p>
</div>
<div class="paragraph">
<p><strong>Grant permission to stored procedure</strong></p>
</div>
<div class="paragraph">
<p>Execute the following statement to give Mary the EXECUTE permission for the pr_Names stored procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">GRANT</span> <span class="k">EXECUTE</span> <span class="k">ON</span> <span class="n">pr_Names</span> <span class="k">TO</span> <span class="n">Mary</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this scenario, Mary can only access the <code>Products</code> table by using the stored procedure. If you want Mary to be able to execute a SELECT statement against the view, then you must also execute <code>GRANT SELECT ON vw_Names TO Mary</code>. To remove access to database objects, use the REVOKE statement.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the table, the view, and the stored procedure are not owned by the same schema, granting permissions becomes more complex.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="about-grant">9.2.2.3. About GRANT</h5>
<div class="paragraph">
<p>You must have EXECUTE permission to execute a stored procedure. You must have SELECT, INSERT, UPDATE, and DELETE permissions to access and change data. The GRANT statement is also used for other permissions, such as permission to create tables.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lesson-3-delete-database-objects">9.3. Lesson 3: Delete database objects</h3>
<div class="paragraph">
<p>This short lesson removes the objects that you created in Lesson 1 and Lesson 2, and then drops the database.</p>
</div>
<div class="paragraph">
<p>Before you delete objects, make sure you are in the correct database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">TestData</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="revoke-stored-procedure-permissions">9.3.1. Revoke stored procedure permissions</h4>
<div class="paragraph">
<p>Use the <code>REVOKE</code> statement to remove execute permission for <code>Mary</code> on the stored procedure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">REVOKE</span> <span class="k">EXECUTE</span> <span class="k">ON</span> <span class="n">pr_Names</span> <span class="k">FROM</span> <span class="n">Mary</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="drop-permissions">9.3.2. Drop permissions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the <code>DROP</code> statement to remove permission for <code>Mary</code> to access the <code>TestData</code> database:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">USER</span> <span class="n">Mary</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use the <code>DROP</code> statement to remove permission for <code>Mary</code> to access this instance of SQL Server 2005 (9.x):</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="n">LOGIN</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">computer_name</span><span class="o">&gt;</span><span class="err">\</span><span class="n">Mary</span><span class="p">];</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use the <code>DROP</code> statement to remove the store procedure <code>pr_Names</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="n">PROC</span> <span class="n">pr_Names</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use the <code>DROP</code> statement to remove the view <code>vw_Names</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">VIEW</span> <span class="n">vw_Names</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="delete-table">9.3.3. Delete table</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the <code>DELETE</code> statement to remove all rows from the <code>Products</code> table:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">Products</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use the <code>DROP</code> statement to remove the <code>Products</code> table:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">Products</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="remove-database">9.3.4. Remove database</h4>
<div class="paragraph">
<p>You can&#8217;t remove the <code>TestData</code> database while you are in the database; therefore, first switch context to another database, and then use the <code>DROP</code> statement to remove the <code>TestData</code> database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">USE</span> <span class="n">MASTER</span><span class="p">;</span>
<span class="k">GO</span>
<span class="k">DROP</span> <span class="k">DATABASE</span> <span class="n">TestData</span><span class="p">;</span>
<span class="k">GO</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">10. References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-deployment?view=sql-server-ver16&amp;pivots=cs1-bash" class="bare">https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-deployment?view=sql-server-ver16&amp;pivots=cs1-bash</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver16&amp;preserve-view=true&amp;pivots=cs1-bash" class="bare">https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver16&amp;preserve-view=true&amp;pivots=cs1-bash</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/databases?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/relational-databases/databases/databases?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/relational-databases/databases/contained-databases?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/relational-databases/databases/contained-databases?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/sql-server/install/file-locations-for-default-and-named-instances-of-sql-server?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/sql-server/install/file-locations-for-default-and-named-instances-of-sql-server?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/getting-started-with-database-engine-permissions?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/getting-started-with-database-engine-permissions?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/language-elements/sql-server-utilities-statements-go?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/t-sql/language-elements/sql-server-utilities-statements-go?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/language-elements/transact-sql-syntax-conventions-transact-sql?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/t-sql/language-elements/transact-sql-syntax-conventions-transact-sql?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/tutorial-writing-transact-sql-statements?view=sql-server-ver16" class="bare">https://learn.microsoft.com/en-us/sql/t-sql/tutorial-writing-transact-sql-statements?view=sql-server-ver16</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/SQL" class="bare">https://en.wikipedia.org/wiki/SQL</a></p>
</li>
</ul>
</div>
</div>
</div>
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="looogos/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</article>
    </main>
    <footer class="c-footer">
  <div class="c-footer-license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details class="c-footer-extralinks" open>
    <summary class="c-footer-extralinks-summary">Extral Links</summary>
    <div class="c-footer-extralinks-content">
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/liquid/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>

    <script src="/assets/js/nav.js" defer></script>
    <script src="/assets/js/heading-anchors.js" defer></script>
    <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->    
    <script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>
  </body>
</html>
